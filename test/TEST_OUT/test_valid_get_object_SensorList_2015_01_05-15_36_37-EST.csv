cache_row_id,category,creation_time,delimiter,description,exclude_from_parse_flag,hash,hidden_flag,id,ignore_case_flag,last_modified_by,max_age_seconds,metadata_item_0_admin_flag,metadata_item_0_name,metadata_item_0_value,modification_time,name,parameter_definition,parameters_parameter_0_key,parameters_parameter_0_value,parameters_parameter_1_key,parameters_parameter_1_value,parameters_parameter_2_key,parameters_parameter_2_value,parameters_parameter_3_key,queries_query_0_platform,queries_query_0_script,queries_query_0_script_type,queries_query_1_platform,queries_query_1_script,queries_query_1_script_type,queries_query_2_platform,queries_query_2_script,queries_query_2_script_type,source_id,string_count,subcolumns_subcolumn_0_hidden_flag,subcolumns_subcolumn_0_ignore_case_flag,subcolumns_subcolumn_0_index,subcolumns_subcolumn_0_name,subcolumns_subcolumn_0_value_type,subcolumns_subcolumn_10_hidden_flag,subcolumns_subcolumn_10_ignore_case_flag,subcolumns_subcolumn_10_index,subcolumns_subcolumn_10_name,subcolumns_subcolumn_10_value_type,subcolumns_subcolumn_11_hidden_flag,subcolumns_subcolumn_11_ignore_case_flag,subcolumns_subcolumn_11_index,subcolumns_subcolumn_11_name,subcolumns_subcolumn_11_value_type,subcolumns_subcolumn_12_hidden_flag,subcolumns_subcolumn_12_ignore_case_flag,subcolumns_subcolumn_12_index,subcolumns_subcolumn_12_name,subcolumns_subcolumn_12_value_type,subcolumns_subcolumn_13_hidden_flag,subcolumns_subcolumn_13_ignore_case_flag,subcolumns_subcolumn_13_index,subcolumns_subcolumn_13_name,subcolumns_subcolumn_13_value_type,subcolumns_subcolumn_14_hidden_flag,subcolumns_subcolumn_14_ignore_case_flag,subcolumns_subcolumn_14_index,subcolumns_subcolumn_14_name,subcolumns_subcolumn_14_value_type,subcolumns_subcolumn_1_hidden_flag,subcolumns_subcolumn_1_ignore_case_flag,subcolumns_subcolumn_1_index,subcolumns_subcolumn_1_name,subcolumns_subcolumn_1_value_type,subcolumns_subcolumn_2_hidden_flag,subcolumns_subcolumn_2_ignore_case_flag,subcolumns_subcolumn_2_index,subcolumns_subcolumn_2_name,subcolumns_subcolumn_2_value_type,subcolumns_subcolumn_3_hidden_flag,subcolumns_subcolumn_3_ignore_case_flag,subcolumns_subcolumn_3_index,subcolumns_subcolumn_3_name,subcolumns_subcolumn_3_value_type,subcolumns_subcolumn_4_hidden_flag,subcolumns_subcolumn_4_ignore_case_flag,subcolumns_subcolumn_4_index,subcolumns_subcolumn_4_name,subcolumns_subcolumn_4_value_type,subcolumns_subcolumn_5_hidden_flag,subcolumns_subcolumn_5_ignore_case_flag,subcolumns_subcolumn_5_index,subcolumns_subcolumn_5_name,subcolumns_subcolumn_5_value_type,subcolumns_subcolumn_6_hidden_flag,subcolumns_subcolumn_6_ignore_case_flag,subcolumns_subcolumn_6_index,subcolumns_subcolumn_6_name,subcolumns_subcolumn_6_value_type,subcolumns_subcolumn_7_hidden_flag,subcolumns_subcolumn_7_ignore_case_flag,subcolumns_subcolumn_7_index,subcolumns_subcolumn_7_name,subcolumns_subcolumn_7_value_type,subcolumns_subcolumn_8_hidden_flag,subcolumns_subcolumn_8_ignore_case_flag,subcolumns_subcolumn_8_index,subcolumns_subcolumn_8_name,subcolumns_subcolumn_8_value_type,subcolumns_subcolumn_9_hidden_flag,subcolumns_subcolumn_9_ignore_case_flag,subcolumns_subcolumn_9_index,subcolumns_subcolumn_9_name,subcolumns_subcolumn_9_value_type,value_type
0,Reserved,,,"The recorded state of each action a client has taken recently in the form of id:status.
Example: 1:Completed",1,1792443391,0,1,1,,3600,,,,,Action Statuses,,,,,,,,,Windows,Reserved,WMIQuery,,,,,,,0,3726,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
1,Reserved,,,"A unique identifier of each computer for internal use.
Example: 4202979704",1,3556221173,0,2,1,,300,,,,,Computer ID,,,,,,,,,Windows,Reserved,WMIQuery,,,,,,,0,87,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
2,Reserved,,,"The assigned name of the client machine.
Example: workstation-1.company.com",0,3409330187,0,3,1,,86400,,,,,Computer Name,,,,,,,,,Windows,select CSName from win32_operatingsystem,WMIQuery,,,,,,,0,7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
3,Reserved,,,"The recorded state of each download a client has made recently in the form of hash:completion percentage.
Example: 05839407baccdfccfd8e2c1ffc0ff27541cc053d15b52cfd4ed904510e59b428:100",0,322086833,0,4,1,,900,,,,,Download Statuses,,,,,,,,,Windows,Reserved,WMIQuery,,,,,,,0,331,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
4,Reserved,,,"A list of manual group ids for internal use.
Example: 72",1,487883112,0,5,1,,300,,,,,Manual Group Membership,,,,,,,,,Windows,Reserved,WMIQuery,,,,,,,0,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
5,Tanium,2015-01-05T20:22:01,",","Version number of the Tanium Client on the client machine.
Example: 4.1.314.7020",1,435957060,0,7,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Tanium Client Version,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Version
&#039;========================================

Option Explicit


Dim fso, filePath, objFile

Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

If GetTaniumDir(&quot;&quot;) = False Then 
	WScript.Echo &quot;Not installed&quot;
	WScript.Quit
End If 

filePath = GetTaniumDir(&quot;&quot;) &amp; &quot;taniumclient.exe&quot;

If fso.FileExists(filePath) Then
	Set objFile = fso.GetFile(filePath)
	WScript.Echo fso.GetFileVersion(objFile)
Else
	WScript.Echo &quot;Not installed&quot;
End If

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/bash
for ini in *Client.ini; do
  TINI=&quot;$ini&quot;
done
TVER=&quot;`grep -i &quot;Version&quot; &quot;$TINI&quot; | awk -F &#039;=&#039; &#039;{ print $2 }&#039;`&quot;
if [ &quot;X$TVER&quot; = &quot;X&quot; ]; then
  echo &quot;Version not specified in $TINI&quot;
else
  echo &quot;$TVER&quot;
fi
",UnixShell,Mac,"#!/bin/bash
for ini in *Client.ini; do
  TINI=&quot;$ini&quot;
done
TVER=&quot;`grep -i &quot;Version&quot; &quot;$TINI&quot; | awk -F &#039;=&#039; &#039;{ print $2 }&#039;`&quot;
if [ &quot;X$TVER&quot; = &quot;X&quot; ]; then
  echo &quot;Version not specified in $TINI&quot;
else
  echo &quot;$TVER&quot;
fi
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
6,Tanium Diagnostics,2015-01-05T20:22:01,",","Determines whether the Tanium Client is able to execute the default content set successfully.  Returns any error conditions.
Example: Error: Windows Script Host version must be at least 5.6",1,824239263,0,9,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Tanium Client Core Health,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Core Health
&#039;========================================

Option Explicit

On Error Resume Next

&#039; Hold whether to report a final error state
Dim bGlobalError : bGlobalError = False

&#039; Global objects the functions may as well use
Dim objFSO,objReg

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)

&#039; First try the very basic access (FSO and registry access)

If Not TestFSO Then
	WScript.Echo &quot;Error: Cannot properly access filesystem&quot;
	WScript.Quit
End If

If Not TestRegistry Then
	WScript.Echo &quot;Error: Cannot properly access registry via WMI&quot;
	WScript.Quit
End If


TestWSHVersionTooLow bGlobalError
TestWMI bGlobalError

If bGlobalError Then
	&#039; Do not report &quot;Yes&quot;
Else
	WScript.Echo &quot;Healthy&quot;
End If

Function TestWMI(ByRef bGlobalError)
&#039; Tests basic WMI
	Dim locale,objWMIService,colItems,objItem
	locale = &quot;&quot;
	On Error Resume Next
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_OperatingSystem&quot;,,48)

	For Each objItem in colItems
		locale = objItem.Locale
	Next
	On Error Goto 0
	If MyIsNumeric(locale) Then
		&#039; None
	Else
		WScript.Echo &quot;Error: WMI cannot retrieve a basic property&quot;
		bGlobalError = True
	End If
End Function &#039;TestWMI

Function TestWSHVersionTooLow(ByRef bGlobalError)
&#039; this function ensures wsh version 5.6
	Dim WSHVersion
	WSHVersion = &quot;&quot;
	WSHVersion = WScript.Version
	If Not MyIsNumeric(WSHVersion) Then
		WScript.Echo &quot;Error: Unknown Windows Script Host version&quot;
		bGlobalError = True
	Else
		WSHVersion = CDbl(WSHVersion)
		If WSHVersion &lt; 5.6 Then
			WScript.Echo &quot;Error: Windows Script Host version must be at least 5.6&quot;
			bGlobalError = True
		End If
	End If
End Function &#039;TestWSHVersionTooLow

Function TestRegistry
&#039; this function will return true if a registry access test via WMI succeeds

	Const HKLM = &amp;h80000002
	
	Dim aValueNames, aValueTypes
	On Error Resume Next
	If objReg.EnumValues(HKLM, &quot;SYSTEM&quot;, aValueNames, aValueTypes) = 0 Then
		TestRegistry = True
	Else
		TestRegistry = False
	End If
	On Error Goto 0

End Function &#039;TestRegistry

Function TestFSO
&#039; this function will return true if an FSO call succeeds

	Dim strWinDir
	&#039;Every machine has a windir
	On Error Resume Next
	strWinDir = objFSO.GetSpecialFolder(0)
	
	If Not objFSO.FolderExists(strWinDir) Then
		TestFSO = False
	Else
		TestFSO = True
	End If
	On Error Goto 0

End Function &#039;TestFSO

Function MyIsNumeric(strTemp)
	Dim i,d
	If IsNull(strTemp) Then
		MyIsNumeric = False
		Exit Function
	End If
	If strTemp = &quot;&quot; Then
		MyIsNumeric = False
		Exit Function
	End If
	
    MyIsNumeric = True
    For i = 1 to Len(strTemp) 
        d = Mid(strTemp, i, 1) 
        If Asc(d) &lt; 48 OR Asc(d) &gt; 57 Then 
            isReallyNumeric = False 
            Exit For 
        End If 
    Next 
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
7,Miscellaneous,2015-01-05T20:22:01,",","Returns, in all cases, the word True.  This sensor is used in many ways, including to find a common target for machines which may have responded to a question with a 'where' clause - get ""online from machines where IP address starts with 192.168.10."" will allow you to target the respondents with an action or count responses.
Example:True",1,131549066,0,11,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Online,,,,,,,,,Windows,"&#039;========================================
&#039; Online
&#039;========================================

Wscript.echo &quot;True&quot;",VBScript,Linux,"#!/bin/bash

echo &quot;True&quot;
",UnixShell,Mac,"#!/bin/bash

echo &quot;True&quot;
",UnixShell,0,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
8,Operating System,2015-01-05T20:22:01,",","Returns the name of the Operating System from all machines.  This name may be localized.
Example: Windows Server 2008 R2 Enterprise",0,45421433,0,13,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:01,Operating System,,,,,,,,,Windows,"&#039;========================================
&#039; Operating System
&#039;========================================

Set oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    
Set oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    
Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)    
Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    
For Each objItem In colItems       
strStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   
&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   
if Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   
strOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   
Else   
strOS = strStrip1
End IF   
wscript.echo Trim(strOS)
Next",VBScript,Linux,"#!/bin/sh
# Detects which OS and if it is Linux then it will detect which Linux
# Distribution.

OS=`uname -s`

GetVersionFromFile()
{
    VERSION=`cat $1 | tr &quot;\n&quot; &#039; &#039; | sed s/.*VERSION.*=\ // `
}

if [ &quot;${OS}&quot; = &quot;Darwin&quot; ] ; then
    # Opps, ran on Mac instead of Linux
    OS=Mac
    OSSTR=&quot;${OS} incorrect script&quot;
elif [ &quot;${OS}&quot; = &quot;Linux&quot; ] ; then
    KERNEL=`uname -r`
    if [ -f /etc/redhat-release ] ; then
        DIST=&#039;RedHat&#039;
        PSUEDONAME=`cat /etc/redhat-release`
        REV=`cat /etc/redhat-release | sed s/.*release\ // | sed s/\ .*//`
        # just cat of redhat-release, to keep compatibility with old version
        # of sensor, but could do something different here
        OSSTR=&quot;${PSUEDONAME}&quot;
    elif [ -f /etc/SuSE-release ] ; then
        DIST=`cat /etc/SuSE-release | tr &quot;\n&quot; &#039; &#039;| sed s/VERSION.*//`
        REV=`cat /etc/SuSE-release | tr &quot;\n&quot; &#039; &#039; | sed s/.*=\ //`
        OSSTR=&quot;${DIST}&quot;
    elif [ -f /etc/lsb-release ] ; then
        # Ubuntu will use the lsb-release, but Debian should be caught by the next
        # if -- note that Ubuntu also has a /etc/debian_version
        # some other less popular distros may be caught by this too
        DIST=`awk -F= &#039;/^DISTRIB_DESCRIPTION/ {print $2}&#039; /etc/lsb-release| tr -d &#039;&quot;&#039;`
        OSSTR=&quot;${DIST}&quot;
    elif [ -f /etc/debian_version ] ; then
        DIST=&quot;Debian `cat /etc/debian_version`&quot;
        OSSTR=&quot;${DIST}&quot;
    else 
        # Fall through, some Linux distributions we don&#039;t know or that does not 
        # use lsb style names
        REV=`uname -r`
        OSSTR=&quot;Linux $REV&quot;
    fi
else
   # in case this is run on something else -- like Solaris or BSD ir AIX or HP-UX
   OSSTR=&quot;${OS}&quot;
fi

echo ${OSSTR}
",UnixShell,Mac,"#!/bin/bash
name=$(sw_vers | awk -F&#039;:\t&#039; &#039; /ProductName/ { print $2 }&#039;)
version=$(sw_vers | awk -F&#039;:\t&#039; &#039; /ProductVersion/ { print $2 }&#039;)
echo $name \($version\)
",UnixShell,0,8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
9,Tanium Diagnostics,2015-01-05T20:22:01,",","Logging level setting between 1 and 100 of the Tanium Client on the client machine.
Example: 41",1,4086596771,0,15,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:01,Tanium Client Logging Level,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Logging Level
&#039;========================================

Option Explicit

WScript.Echo GetLogLevel


&#039;----------End Main Line-----------&#039;

Function GetLogLevel()
&#039; This function sets maintenance window values passed to it

	Const HKLM = &amp;h80000002
	
	Dim strTaniumRegistryKey, strComputer, intLogLevel
	Dim objReg, bLogLevelResult
	
	&#039; Set up access to registry via WMI
	strComputer = &quot;.&quot;
	
	Set objReg = _
		GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
		&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

	strTaniumRegistryKey = GetTaniumRegistryPath()

	objReg.GetDWORDValue HKLM, strTaniumRegistryKey, &quot;LogVerbosityLevel&quot;, intLogLevel
	
	If Not IsNull(intLogLevel) Then
		GetLogLevel = intLogLevel
	Else
		GetLogLevel = &quot;Not Set&quot;
	End If

	&#039; Cleanup
	Set objReg = Nothing
End Function &#039;GetLogLevel

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists",VBScript,Linux,"#!/bin/bash
logLevel=$(grep -w &quot;^LogVerbosityLevel&quot; TaniumClient.ini | cut -d= -f2)

if [[ $logLevel == &quot;&quot; ]]
then
logLevel=&quot;Not set&quot;
fi

echo $logLevel
",UnixShell,Mac,"#!/bin/bash
logLevel=$(grep -w &quot;^LogVerbosityLevel&quot; TaniumClient.ini | cut -d= -f2)

if [[ $logLevel == &quot;&quot; ]]
then
logLevel=&quot;Not set&quot;
fi

echo $logLevel
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
10,Tanium Diagnostics,2015-01-05T20:22:01,",","Returns the combined size of all Action_XXXX subdirectories in the Tanium Client\Downloads directory.
Example: 351 MB",1,2290387752,0,17,1,Jim Olsen,900,,,,2015-01-05T20:22:01,Tanium Client Action Folder Sizes,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Action Folder Sizes
&#039;========================================

Option Explicit

SetLocale(GetTaniumLocale)

Const HKLM = &amp;H80000002
Dim objRegistry,strTaniumClientKey
Dim objFSO,objFolder,strTaniumClientPath,strDownloadsDir
Dim lngSize,intCount,folder
Dim strSize,strSep

strSep = &quot;|&quot;

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

Set objRegistry=GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)

strTaniumClientKey = GetTaniumRegistryPath()
If Not strTaniumClientKey = &quot;&quot; Then
	objRegistry.GetStringValue HKLM,strTaniumClientKey,&quot;Path&quot;,strTaniumClientPath
End If

If ( IsNull(strTaniumClientPath) Or strTaniumClientPath = &quot;&quot;) Or ( Not objFSO.FolderExists(strTaniumClientPath)) Then
	WScript.Echo &quot;Tanium Client Directory Not Found&quot;
Else
	On Error Resume Next
	strDownloadsDir = strTaniumClientPath&amp;&quot;\Downloads&quot;
	lngSize = 0
	intCount = 0
	If objFso.FolderExists(strDownloadsDir) Then
		Set objFolder = objFso.GetFolder(strDownloadsDir)

		For Each folder In objFolder.SubFolders
			If Left(folder.Name, 7) = &quot;Action_&quot; Then
				lngSize = lngSize + GetAccessibleFolderSize(folder.Path)
				intCount = intCount + 1
			End If
		Next
		On Error Goto 0
		If intCount &gt; 0 Then
			WScript.Echo GetPrettyFileSize(CStr(lngSize))
		Else
			WScript.Echo &quot;No Action Folders Found in Downloads dir&quot;
		End If
	
	Else
		WScript.Echo &quot;Tanium Client Downloads Directory Not Found&quot;
	End If


End If

&#039; --- end main --- &#039;

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function GetPrettyFileSize(strSize)
Dim dblSize
	dblSize = CDbl(strSize)

	If dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB
		strSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;	
	ElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB
		strSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;
	ElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB
		strSize = CStr(Round(dblSize / 1024)) &amp; &quot; KB&quot;
	Else
		strSize = CStr(dblSize) &amp; &quot; B&quot;	
	End If	
	GetPrettyFileSize = strSize
End Function &#039;GetPrettyFileSize


Function GetAccessibleFolderSize(strFolderPath)
&#039; Gets the folder sizes that it is able to
&#039; and skips those it has no rights to see
    On Error Resume Next &#039; Permissions Errors potentially

	Dim objFSO
    Dim objFolder,objSubfolder,intSize,bHasSubfolders	
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	    
    bHasSubfolders = False

    Set objFolder = objFSO.GetFolder(strFolderPath)
    Err.Clear
    intSize = objFolder.Size
    If Err.Number &lt;&gt; 0 Then
        For Each objSubfolder in objFolder.SubFolders
            intSize = intSize + GetAccessibleFolderSize(objSubfolder.Path)
            bHasSubfolders = True
        Next

        If Not bHasSubfolders Then
            intSize = objFolder.Size
        End If
    End If

    GetAccessibleFolderSize = intSize
    
    On Error Goto 0

End Function &#039;GetAccessibleFolderSize

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
11,Applications,2015-01-05T20:22:01,",","Provides an indication of whether the Managed Applications definitions file is up to date or out of date.
Example: Up to Date",1,2660023085,0,19,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:01,Managed Applications Status,,,,,,,,,Windows,"&#039;========================================
&#039; Managed Applications Status
&#039;========================================

Option Explicit
Dim hoursThreshold
hoursThreshold = 23

&#039; This sensor uses date math which is locale specific
SetLocale(GetTaniumLocale) &#039;us/english by default


Const HKLM = &amp;H80000002
Dim strSep
strSep = &quot;|&quot;
Dim objFso, strXml, objFile
Const ForReading = 1
Set objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

Dim strMAPath
strMAPath = GetTaniumDir(&quot;Tools\Managed Applications&quot;)

Dim strDatPath, strScanPath, strCurrentDir, oShell

strDatPath = strMAPath &amp; &quot;tanium.dat&quot;
strScanPath = strMAPath &amp; &quot;run-managed-applications-scan.vbs&quot;

Dim isDebug
isDebug = False 
If isDebug Then
	Set oShell = CreateObject(&quot;WScript.Shell&quot;)
	strCurrentDir = objFso.GetParentFolderName(Wscript.ScriptFullName)
	strDatPath = strCurrentDir &amp; &quot;\tanium.dat&quot;
	WScript.Echo strDatPath
End If 

&#039;Check if the scanner vbs exists
If Not objFso.FileExists(strScanPath) Then
	WScript.Echo &quot;Cannot find scanner&quot;
	WScript.Quit
End If

&#039;Check if the DAT file exists
If Not objFso.FileExists(strDatPath) Then
	WScript.Echo &quot;Cannot find DAT file&quot;
	WScript.Quit
End If

Dim strAge
strAge = GetHoursOld(strDatPath)
&#039;WScript.Echo &quot;Age in hours: &quot; &amp; strAge
If strAge &gt; hoursThreshold Then
	WScript.Echo &quot;Out of Date&quot;
Else
	WScript.Echo &quot;Up to Date&quot;
End If	
WScript.Quit


Function GetHoursOld(strDatPath)
	Dim objDatFile
	Set objDatFile = objFso.GetFile(strDatPath)	
	GetHoursOld = DateDiff(&quot;h&quot;, objDatFile.DateLastModified, Now())
End Function

Function RegKey32Exists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function


Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
12,Patch,2015-01-05T20:22:01,",","A sensor to return error conditions that would prevent the timely scan and delivery of patches.
Example: ""Error: WUA Version is less than supported version 6.1.0022.4""",1,293035193,0,21,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Patch Tools Errors,,,,,,,,,Windows,"&#039;========================================
&#039; Patch Tools Errors
&#039;========================================

&#039; this sensor will return error conditions
&#039; that would prevent the timely scan and delivery of patches

Option Explicit

On Error Resume Next
SetLocale(1033) &#039; this sensor uses date math, setting to us/english

&#039; Hold whether to report a final error state
Dim bGlobalError : bGlobalError = False

&#039; Global objects the functions may as well use
Dim objFSO,objReg

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)

&#039; First try the very basic access (FSO and registry access)

If Not TestFSO Then
	WScript.Echo &quot;Error: Cannot properly access filesystem&quot;
	WScript.Quit
End If

If Not TestRegistry Then
	WScript.Echo &quot;Error: Cannot properly access registry&quot;
	WScript.Quit
End If

&#039; Pass the global error flag down each of the functions
&#039; which will flip it and report their own errors

&#039; do not use parentheses or will not pass ByRef.
&#039; could use parentheses and use the Call keyword, however

PatchCabOutOfDateOrNotFound bGlobalError
PatchResultsErrors bGlobalError
PatchResultsOutOfDate bGlobalError
WUAVersionTooLow bGlobalError
WSHVersionTooLow bGlobalError

If bGlobalError Then
	&#039; Do not report &quot;Yes&quot;
Else
	WScript.Echo &quot;Healthy&quot;
End If

&#039; --- Health Check Functions --- &#039;

Function WUAVersionTooLow(ByRef bHasError)
	Dim strOutput, strSysDir, strWuaDll, i
	Dim strNeededVersion, arrNeededVersion
	Dim strVersion, arrVersion, intVersionPiece, bOldVersion
	
	&#039;adjust as required version changes
	strNeededVersion = &quot;6.1.0022.4&quot;
	arrNeededVersion = Split(strNeededVersion,&quot;.&quot;)
	
	strSysDir = GetSystemDir		
	strWuaDll = strSysDir &amp; &quot;\wuaueng.dll&quot;
	If objFSO.FileExists(strWuaDll) Then
		strVersion = objFSO.GetFileVersion(strWuaDll)
		If strVersion &lt;&gt; strNeededVersion Then
		arrVersion = Split(strVersion, &quot;.&quot;)
		&#039; We assume there will be 4 fields, if not throw error
			If UBound(arrVersion) &lt;&gt; 3 Then
				bHasError = True
				strOutput = &quot;Error: Cannot determine Windows Update Agent version, does not look like X.X.X.X&quot;
			Else
				bOldVersion = False &#039;assume version is good
				&#039; loop through each part
				&#039; if any individual part is less than its corresponding required part
				For i = 0 To UBound(arrVersion)
					If CInt(arrVersion(i)) &lt; CInt(arrNeededVersion(i)) Then
						bOldVersion = True
						Exit For &#039; No further checking necessary, it&#039;s out of date
					End If
				Next
				If bOldVersion Then 
					strOutput = &quot;Error: WUA Version is less than supported version &quot; &amp; strNeededVersion
					bHasError = True
				End If
			End If
		Else
			&#039; versions are the same
		End If
	Else 
		strOutput = &quot;Error: WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;
		bHasError = True
	End If
	
	WScript.Echo strOutput

End Function &#039;WUAVersionTooLow

Function WSHVersionTooLow(ByRef bGlobalError)
&#039; this function ensures wsh version 5.6
	Dim WSHVersion
	WSHVersion = &quot;&quot;
	WSHVersion = WScript.Version
	If Not MyIsNumeric(WSHVersion) Then
		WScript.Echo &quot;Error: Unknown Windows Script Host version&quot;
		bGlobalError = True
	Else
		WSHVersion = CDbl(WSHVersion)
		If WSHVersion &lt; 5.6 Then
			WScript.Echo &quot;Error: Windows Script Host version must be at least 5.6&quot;
			bGlobalError = True
		End If
	End If
End Function &#039;WSHVersionTooLow

Function MyIsNumeric(strTemp)
	Dim i,d
	If IsNull(strTemp) Then
		MyIsNumeric = False
		Exit Function
	End If
	If strTemp = &quot;&quot; Then
		MyIsNumeric = False
		Exit Function
	End If
	
    MyIsNumeric = True
    For i = 1 to Len(strTemp) 
        d = Mid(strTemp, i, 1) 
        If Asc(d) &lt; 48 OR Asc(d) &gt; 57 Then 
            isReallyNumeric = False 
            Exit For 
        End If 
    Next 
End Function




Function PatchCabOutOfDateOrNotFound(ByRef bHasError)
&#039; This function will return an error message if the patch cab is
&#039; out of date
	Dim objCabFile
	Dim ageThreshold,strToolsDir,strPatchCabPath
	Dim words,minutesOld
	
	ageThreshold = 60*48       &#039;2 days in minutes
	
	strToolsDir = GetTaniumDir(&quot;Tools&quot;)
	strPatchCabPath = strToolsDir &amp; &quot;\wsusscn2.cab&quot;

	If objFSO.FileExists(strPatchCabPath) Then
		Set objCabFile = objFSO.GetFile(strPatchCabPath)
		words = Split(objCabFile.DateLastModified, &quot; &quot;)
		
		minutesOld = GetMinutesOld(objCabFile.DateLastModified)
		if cint(minutesOld) &gt;= ageThreshold Then
		  Wscript.echo  &quot;Error: Patch definition Cab file hasn&#039;t been modified in over 2 days&quot;
		  bHasError = True
		End If
	Else
		  Wscript.echo  &quot;Error: Patch Cab not found&quot;
		  bHasError = True
	End If
	
	&#039;Cleanup
	Set objCabFile = Nothing

End Function &#039;PatchCabOutOfDateOrNotFound

Function PatchResultsErrors(ByRef bHasError)

	Dim fn, objReadFile, contents, path, strSep
	strSep = &quot;|&quot;
	
	&#039; results should look like:
	&#039;title|severity|bulletins|creation date|urls|filenames|etc ..
	
	&#039; first check 
	path = GetTaniumDir(&quot;Tools\Scans&quot;)

	fn = path &amp; &quot;\patchresultsreadable.txt&quot;

	If objFSO.FileExists(fn) Then
		&#039; If file exists but there&#039;s an issue opening it
		On Error Resume Next
		Set objReadFile = objFSO.OpenTextFile(fn, 1, False)
		If Err.Number &lt;&gt; 0 Then
			WScript.Echo &quot;Error: Patch results file exists but cannot open&quot;
			bHasError = True
			Exit Function
		End If
	
		On Error Goto 0
		&#039; Check on all patch results lines
		&#039; If we locate any that do not have the separator value in them, throw an
		&#039; invalid line entry and exit the function
		Dim strLine, words
		Do While Not objReadFile.AtEndOfStream
			strLine = objReadFile.ReadLine
	
			&#039;CHECK FOR MULTI-URL PATCHES
			If Not InStr(strLine,strSep) &gt; 0 Then &#039; must be an invalid line
				WScript.Echo &quot;Error: Invalid patch results line says - &quot; &amp; strLine
				bHasError = True
			End If
		Loop
	
		objReadFile.close
	Else
	   Wscript.echo &quot;Error: Patch results output not found&quot;
	   bHasError = True
	End If
End Function &#039;PatchResultsErrors

Function PatchResultsOutOfDate(ByRef bHasError)
	Dim objFile
	Dim strScansDir, strResultsPath, daysOld, words
	
	&#039; This sensor uses date math which is locale specific
	SetLocale(1033) &#039;us/english
		
	strScansDir = GetTaniumDir(&quot;Tools\Scans&quot;)
	strResultsPath = strScansDir &amp; &quot;\patchresultsreadable.txt&quot;
		
	If objFso.FileExists(strResultsPath) Then
		Set objFile = objFso.GetFile(strResultsPath)
		words = Split(objFile.DateLastModified, &quot; &quot;)
		
		daysOld = GetDaysOld(words(0))
		if cint(daysOld) &gt;= 4 Then
		  Wscript.echo  &quot;Error: Microsoft patches not scanned in at least 4 days&quot;
		  bHasError = True
		End If
	
	Else
		&#039; Results not found, but would be checked with other function
	End If
	
	&#039;Cleanup
	Set objFile = Nothing

End Function &#039;PatchResultsOutOfDate


&#039; ---- Support Functions ---- &#039;
Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function GetMinutesOld(strDate)
&#039;date format is MM/DD/YYYY 
	SetLocale(1033)
	Dim patternDate, today
	patternDate = CDate( strDate )
	today = CDate( now )
	GetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)
End Function &#039;GetMinutesOld

Function GetDaysOld(strDate)
&#039;date format is MM/DD/YYYY 
	SetLocale(1033)
	Dim patternDate, today
	patternDate = CDate( strDate )
	today = CDate( now )
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function &#039;GetDaysOld


Function GetSystemDir 
	Dim strWinDir,strSysDir
	
	&#039;Check for 64-bit sysnative directory to avoid win redirect
	strWinDir = objFSO.GetSpecialFolder(0)
	strSysDir = strWinDir &amp; &quot;\sysnative&quot;
	
	If Not objFSO.FolderExists(strSysDir) Then
		strSysDir = objFSO.GetSpecialFolder(1)
	End If
	GetSystemDir = strSysDir
End Function &#039; GetSystemDir

Function TestRegistry
&#039; this function will return true if a registry access test via WMI succeeds

	Const HKLM = &amp;h80000002
	
	Dim aValueNames, aValueTypes
	On Error Resume Next
	If objReg.EnumValues(HKLM, &quot;SYSTEM&quot;, aValueNames, aValueTypes) = 0 Then
		TestRegistry = True
	Else
		TestRegistry = False
	End If
	On Error Goto 0

End Function &#039;TestRegistry

Function TestFSO
&#039; this function will return true if an FSO call succeeds

	Dim strWinDir
	&#039;Every machine has a windir
	On Error Resume Next
	strWinDir = objFSO.GetSpecialFolder(0)
	
	If Not objFSO.FolderExists(strWinDir) Then
		TestFSO = False
	Else
		TestFSO = True
	End If
	On Error Goto 0

End Function &#039;TestFSO",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
13,Tanium,2015-01-05T20:22:01,",","Returns whether the client is in a 'locked' state. Use the package ""Tanium Client Action Unlock"" to unlock the Client and allow actions.
Example: Action Lock On",1,2671758800,0,23,1,Jim Olsen,120,0,defined,Tanium,2015-01-05T20:22:01,Action Lock Status,,,,,,,,,Windows,"&#039;========================================
&#039; Action Lock Status
&#039;========================================

Option Explicit

If ActionLockOn Then
	WScript.Echo &quot;Action Lock On&quot;
Else
	WScript.Echo &quot;Action Lock Off&quot;
End If

Function ActionLockOn
&#039; returns true or false
	Dim objShell,strRegistryPath,intLockStatus
	
	strRegistryPath = GetTaniumRegistryPath
	
	Set objShell = WScript.CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLockStatus = objShell.RegRead(&quot;HKLM\&quot;&amp;strRegistryPath&amp;&quot;\ActionLockFlag&quot;)
	
	If Err.Number &lt;&gt; 0 Then
		intLockStatus = 0
	End If
	On Error Goto 0
	
	If intLockStatus = 1 Then
		ActionLockOn = True
	Else
		ActionLockOn = False
	End If

End Function &#039;ActionLockOn

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		GetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		GetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;GetTaniumRegistryPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
14,Tanium,2015-01-05T20:22:01,",",Retrieves the PowerShell Execution Policy as the Tanium Client sees it,1,1805210070,0,25,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Tanium PowerShell Execution Policy,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium PowerShell Execution Policy
&#039;========================================

&#039; this sensor will retrieve the PowerShell Execution Policy
&#039; of the 32-bit environment

Option Explicit

Dim objShell : Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Dim objShellExec
Dim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

Dim strPSPath,strLine
strPSPath = objFSO.GetSpecialFolder(1)&amp;&quot;\WindowsPowerShell\v1.0\powershell.exe&quot;
If objFSO.FileExists(strPSPath) Then
	Set objShellExec = objShell.Exec(Chr(34)&amp;strPSPath&amp;Chr(34)&amp;&quot; -Command Get-ExecutionPolicy;Exit&quot;)
	Do Until objShellExec.StdOut.AtEndOfStream
		strLine = objShellExec.StdOut.ReadLine
		If Not strLine = &quot;&quot; Then
			WScript.Echo strLine
			Exit Do
		End If
	Loop
Else
	WScript.Echo &quot;Cannot locate PowerShell executable&quot;
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
15,Tanium,2015-01-05T20:22:01,",","Version number of  Tanium Server installed. 
Example: 6.2.314.3218",1,711837192,0,27,1,Jim Olsen,900,,,,2015-01-05T20:22:01,Tanium Server Version,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Server Version
&#039;========================================

Option Explicit


Dim fso, filePath, objFile

Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

If GetTaniumDir(&quot;&quot;) = False Then 
	WScript.Echo &quot;Not installed&quot;
	WScript.Quit
End If 

filePath = GetTaniumDir(&quot;&quot;) &amp; &quot;TaniumReceiver.exe&quot;

If fso.FileExists(filePath) Then
	Set objFile = fso.GetFile(filePath)
	WScript.Echo fso.GetFileVersion(objFile)
Else
	WScript.Echo &quot;Not installed&quot;
End If

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Server&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Server&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
16,Tanium,2015-01-05T20:22:01,",","Version number of  Tanium Zone Server installed. 
Example: 6.2.314.3218",1,333178608,0,29,1,Jim Olsen,900,,,,2015-01-05T20:22:01,Tanium Zone Server Version,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Zone Server Version
&#039;========================================

Option Explicit

Const HKEY_LOCAL_MACHINE  = &amp;H80000002

Const keyNativePath = &quot;Software\Tanium\Tanium ZoneServer&quot;
Const keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium ZoneServer&quot;

Dim fso, dirPath, filePath, objFile, objReg

&#039; Zone Server has to be treated differently than client and server
&#039; The latest Zone Server will write the 
Set objReg = Getx64RegistryProvider()

Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

Set objReg = Getx64RegistryProvider()

dirPath = Null

If RegKeyExists(objReg, HKEY_LOCAL_MACHINE, keyNativePath) Then 
	objReg.GetStringValue HKEY_LOCAL_MACHINE, keyNativePath, &quot;Path&quot;, dirPath
End If

If IsNull(dirPath) Then 
	If RegKeyExists(objReg, HKEY_LOCAL_MACHINE, keyWowPath) Then 
		objReg.GetStringValue HKEY_LOCAL_MACHINE, keyWowPath, &quot;Path&quot;, dirPath
	End If
End If

filePath = dirPath &amp; &quot;\TaniumZoneServer.exe&quot;

If fso.FileExists(filePath) Then
	Set objFile = fso.GetFile(filePath)
	WScript.Echo fso.GetFileVersion(objFile)
Else
	WScript.Echo &quot;Not installed&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
17,Tanium,2015-01-05T20:22:01,",","Returns the value of a supplied Tanium Client Setting fom the Tanium Clients registry key.  Supply only the client setting name, for instance: ServerName and the output will appear as follows:
Example: berkeley.tanium.com",1,3760050184,0,31,1,Jim Olsen,900,,,,2015-01-05T20:22:01,Tanium Client Explicit Setting,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)"",""value"":"""",""promptText"":""Enter the Client Setting Name"",""defaultValue"":"""",""label"":""Client Setting Name"",""maxChars"":64,""key"":""setting"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Registry Value Data
&#039;========================================

&#039;Columns:
&#039; User | Data | Type | Architecture | KeyPath | Value

&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)

strKey = &quot;HKLM\&quot;&amp;GetTaniumRegistryPath()
strValue = unescape(&quot;||setting||&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client&quot;
&#039;strValue = &quot;Version&quot;

&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;
&#039;strValue = &quot;Emailname&quot;
strSep = &quot;~~&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If


If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive
		hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True
	End If
End If

If Not (hasAnyResult) Then
	WScript.Echo &quot;Key/Value not found&quot;
End If

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames
	arrTypes = Outparams.Types

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			
			&#039;if strValue is found, echo
			If LCase(strValueName) = LCase(strValue) Then
				EchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit
				CheckValues = True
				Exit Function
			End If
		Next
	End If
	CheckValues = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit)
	If intBit = 64 Then
		strArch = &quot;64-bit&quot;
	Else
		strArch = &quot;32-bit&quot;
	End If
			
	GetDisplayString = strValue
End Function

Function EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)
	&#039; Note the key that was being searched, will be a hidden column
	strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
	
	Dim objInParams, objOutParams
	Select Case constType
		Case REG_SZ  
			Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_EXPAND_SZ
			Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_BINARY
			Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)

			strBytes = &quot;&quot;
			For Each uByte in objOutParams.uValue
				strTemp = Hex(uByte)
				If Len(strTemp) &lt; 2 Then
					strTemp = &quot;0&quot; &amp; strTemp
				End If	
				strBytes = strBytes &amp; strTemp &amp; &quot; &quot;
			Next
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)
		Case REG_DWORD
		    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_QWORD
		    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_MULTI_SZ
		    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)
		
			arrValues = objOutParams.sValue
			strResponse = &quot;&quot;

			For Each strTemp In arrValues
				If strResponse = &quot;&quot; Then
					strResponse = strTemp
				Else
					strResponse = strResponse &amp; vbCrLf &amp; strTemp
				End If
			Next
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)
	End Select
End Function


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||setting||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||setting||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
18,Hardware,2015-01-05T20:22:01,",","Returns Yes or No to indicate whether the hardware is virtual.
Echo: Yes",1,1022769818,0,33,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Is Virtual,,,,,,,,,Windows,"&#039;========================================
&#039; Is Virtual
&#039;========================================

&#039; This sensor will determine if a machine is a virtual machine or not
&#039; Comparing values for certain properties against known values.
&#039; It will need to be updated for some current tech and 
&#039; as new technologies come to market.


Option Explicit

If IsVM Then 
    WScript.Echo &quot;Yes&quot;
Else
    WScript.Echo &quot;No&quot;
End If


Function IsVM
	Dim sVMPlatform, sMake, sModel, sBIOSVersion,bIsVM

    &#039; Check the WMI information against known values

    bIsVM = false
    sVMPlatform = &quot;&quot;

    sMake = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Manufacturer&quot;)
    sModel = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Model&quot;)
    sBIOSVersion = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_BIOS&quot;, &quot;Version&quot;)

    &#039;WScript.Echo &quot;Manufacturer=&quot; &amp; sMake
    &#039;WScript.Echo &quot;Model=&quot; &amp; sModel
    &#039;WScript.Echo &quot;BIOSVersion=&quot; &amp; sBIOSVersion

    If sModel = &quot;Virtual Machine&quot; Then

        &#039; Microsoft virtualization technology detected, assign defaults

        sVMPlatform = &quot;Hyper-V&quot;
        bIsVM = true

        &#039; Try to determine more specific values

        Select Case sBIOSVersion
        Case &quot;VRTUAL - 1000831&quot;
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 Beta or RC0&quot;
        Case &quot;VRTUAL - 5000805&quot;, &quot;BIOS Date: 05/05/08 20:35:56  Ver: 08.00.02&quot;
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 RTM&quot;
        Case &quot;VRTUAL - 3000919&quot; 
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 R2&quot;
        Case &quot;A M I  - 2000622&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005R2SP1 or VPC2007&quot;
        Case &quot;A M I  - 9000520&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005R2&quot;
        Case &quot;A M I  - 9000816&quot;, &quot;A M I  - 6000901&quot;
            bIsVM = true
            sVMPlatform = &quot;Windows Virtual PC&quot;
        Case &quot;A M I  - 8000314&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005 or VPC2004&quot;
        Case &quot;Xen - 0s&quot;
        	bIsVM = True
        	sVMPlatform = &quot;Xen&quot;
        Case &quot;Xen - 0&quot;
        	bIsVM = True
        	sVMPlatform = &quot;Xen&quot;
        End Select

    ElseIf sMake = &quot;Xen&quot; Then
    
        &#039; Xen detected

        sVMPlatform = &quot;Xen&quot;
        bIsVM = true
    
    ElseIf sModel = &quot;VMware Virtual Platform&quot; then

        &#039; VMware detected

        sVMPlatform = &quot;VMware&quot;
        bIsVM = true

    ElseIf sModel  = &quot;VirtualBox&quot; then

        &#039; VirtualBox detected

        bIsVM = true
        sVMPlatform = &quot;VirtualBox&quot;
    
    ElseIf sModel  = &quot;HVM domU&quot; then

        &#039; Xen detected

        bIsVM = true
        sVMPlatform = &quot;Xen&quot;
        
    Else 
        &#039; This computer does not appear to be a virtual machine.
    End if

    &#039; Set the return value

    If bIsVM Then
    	&#039; Let&#039;s not actually do anything here 
        &#039;WScript.Echo &quot;IsVirtualMachine=True&quot;
        &#039;WScript.Echo &quot;VirtualMachinePlatform=&quot; &amp; sVMPlatform
    Else
        &#039;WScript.Echo &quot;IsVirtualMachine=False&quot;
    End If

    IsVM = bIsVM

End Function

Function GetWmiPropertyValue(strNameSpace, strClassName, strPropertyName)
	Dim strPropertyValue, oWMIClass, oWMIProperties, objWMIService, colItems
	Dim objItem, objProperty
	Dim sLine
	
    On Error Resume Next

    strPropertyValue = &quot;&quot;
    set oWmiClass = getobject(&quot;winmgmts:&quot; &amp; strNameSpace).get(strClassName,&amp;h20000) &#039;amended
    set oWmiProperties = oWmiClass.Properties_

    Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; &quot;.&quot; &amp; &quot;\&quot; &amp; strNameSpace)
    Set colItems = objWMIService.ExecQuery(&quot;Select * from &quot; &amp; strClassName,,48)

    For Each objItem in colItems
        For Each objProperty in oWmiProperties
            sLine = &quot;&quot;
            &#039;WScript.Echo &quot;- &quot; &amp; objProperty.name &amp; &quot;: &quot; &amp; strPropertyName

            If objProperty.Name = strPropertyName Then
                If objProperty.IsArray = True Then
                    sLine = &quot;str&quot; &amp; objProperty.Name &amp; &quot; = Join(objItem.&quot; &amp; objProperty.Name &amp; &quot;, &quot; &amp; Chr(34) &amp; &quot;,&quot; &amp; Chr(34) &amp; &quot;)&quot; &amp; vbCrLf
                    sLine = sLine &amp; &quot;strPropertyValue =  str&quot; &amp; objProperty.Name
                &#039;ElseIf objProperty.CIMTYPE = 101 Then
                &#039;    bHasDates = True
                &#039;    sLine =  &quot;strPropertyValue =  WMIDateStringToDate(objItem.&quot; &amp; objProperty.Name &amp; &quot;)&quot;
                Else
                    sLine =  &quot;strPropertyValue =  objItem.&quot; &amp; objProperty.Name
                End If

                &#039;WScript.Echo sLine
                Execute sLine
            End If

        Next
    Next

    GetWmiPropertyValue = strPropertyValue
    
    &#039;Cleanup!
    set oWmiClass = Nothing
    set oWmiProperties = Nothing

    Set objWMIService = Nothing
    Set colItems = Nothing

End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
19,Operating System,2015-01-05T20:22:01,",","Returns whether the machine runs Windows.  True if so, False if not.
Example: True",0,2721439124,0,35,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:01,Is Windows,,,,,,,,,Windows,"&#039;========================================
&#039; Is Windows
&#039;========================================

Wscript.echo &quot;True&quot;",VBScript,Linux,"#!/bin/bash
echo False
",UnixShell,Mac,"#!/bin/bash
echo False
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
20,Operating System,2015-01-05T20:22:01,|,"Returns a group name and a member of that group on each line. For each member in any group, two columns of output will appear.
Example: Administrators|user.name",0,443412787,0,37,1,Jim Olsen,300,,,,2015-01-05T20:22:01,Local Groups With Members,,,,,,,,,Windows,"&#039;========================================
&#039; Local Groups With Members
&#039;========================================

&#039; output all local groups
&#039; for each member of a group, output the group in the first column
&#039; and the member in the second column.

&#039; Contains hidden columns, full output is:
&#039; Group Name|Member Name|ADSPath|PerfectMatchMember|PerfectMatchGroup
&#039; Final three are hidden. ADSPath is for feeding actions. PerfectMatch columns
&#039; allow for exact beginning to end matches in a column using contains.


Option Explicit

Dim strGroup, dictBlacklist,dictGroups,bShouldWrite
Set dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; Add one line for each user or group that you do not want listed in the sensor output.  
&#039;dictBlacklist.Add (&quot;IgnoreMe&quot;), True &#039;Case insensitive

&#039; Do not run on a Domain Controller, would list all domain groups
If IsDC Then WScript.Quit

Set dictGroups = GetLocalGroupsAndMembers
For Each strGroup In dictGroups.Keys
	bShouldWrite = True
	Dim strItem,strMember
	For Each strMember In Split(dictGroups.Item(strGroup),&quot;,&quot;)
		For Each strItem In dictBlacklist.Keys
			If ( InStr(1,strGroup, strItem, vbTextCompare) &gt; 0 _ 
				Or InStr(1,strMember,strItem,vbTextCompare) &gt; 0) Then
				bShouldWrite = False
			End If
		Next
		If bShouldWrite Then WScript.Echo strGroup &amp;&quot;|&quot;&amp; strMember	
	Next
Next

Function GetLocalGroupsAndMembers

	Dim colGroups,objGroup,dictGroups,strMembers,objMember,i
	Dim objReg,objCTX,strMember,strDomain,strADSPath,strShortDomain
	Dim strPostADS,arrDomainSplit,objWshNet,strComputer
	Dim strPerfectMatchMemberName,strPerfectMatchGroupName
	
	Set objCtx = GetObjCtx(32)
	Set objReg = GetObjReg(objCtx)	
		
	Set colGroups = GetObject(&quot;WinNT://.&quot;)
	colGroups.Filter = Array(&quot;group&quot;)
	Set dictGroups = CreateObject(&quot;Scripting.Dictionary&quot;)
	Set objWshNet = CreateObject(&quot;WScript.Network&quot;)

	strComputer = objWshNet.ComputerName
		
	For Each objGroup In colGroups
		&#039; encapsulate group string in something we can compare against in questions. Hidden column at end
		strPerfectMatchGroupName = &quot;:G:&quot;&amp;objGroup.Name&amp;&quot;:&quot;
		i = 0
		strMembers = &quot;&quot;
    	If Not dictGroups.Exists(objGroup.Name) Then
    		For Each objMember in objGroup.Members
    			If objMember.Name = &quot;&quot; Then
    				strMember = &quot;::Blank/Error::&quot;
    			Else
    				strMember = objMember.Name
    			End If
    			
    			If InStr(strMember,&quot;S-&quot;) &gt; 0 Then
					&#039; Possible SID entry, try to resolve
					strMember = GetUserForSIDLocal(objReg,strMember)&amp;&quot; (unresolvable)&quot;
				End If	
				strADSPath = objMember.ADSPath
				strPostADS = Replace(strADSPath,&quot;WinNT://&quot;,&quot;&quot;)
				
				If InStr(strPostADS,&quot;/&quot;) &gt; 0 Then
					&#039;domain user
					arrDomainSplit = Split(strPostADS,&quot;/&quot;)
					If UBound(arrDomainSplit) &gt; 0 Then
						strDomain = arrDomainSplit(0)
						strMember = arrDomainSplit(1)
		    			If InStr(strMember,&quot;S-&quot;) &gt; 0 Then
							&#039; Possible SID entry, try to resolve
							strMember = GetUserForSIDLocal(objReg,strMember)&amp;&quot; (unresolvable / cached)&quot;
						End If				
					Else
						strDomain = &quot;Unknown&quot;
						strMember = &quot;Unknown&quot;
					End If
				End If

				If InStr(1,objMember.ADSPath,strComputer) &gt; 0 Then &#039;local entry		
					strADSPath = Replace(objMember.ADSPath,strComputer,&quot;::ComputerName::&quot;,1,1,vbTextCompare)
					&#039; output a perfect match name like &quot;::GroupName::&quot; so you cna do contains &quot;::GroupName::&quot;
					&#039; and know you&#039;re matching the group name, beginning to end and no other entries
					strPerfectMatchMemberName=&quot;:M:&quot;&amp;strMember&amp;&quot;:&quot;
					strMembers = strMembers&amp;&quot;,&quot;&amp;strMember&amp;&quot;|&quot;&amp;strADSPath&amp;&quot;|&quot; _
						&amp;strPerfectMatchMemberName&amp;&quot;|&quot;&amp;strPerfectMatchGroupName
				Else
					strADSPath = objMember.ADSPath
					strPerfectMatchMemberName=&quot;:M:&quot;&amp;strDomain&amp;&quot;\&quot;&amp;strMember&amp;&quot;:&quot;
					strMembers = strMembers&amp;&quot;,&quot;&amp;strDomain&amp;&quot;\&quot;&amp;strMember&amp;&quot;|&quot;&amp;strADSPath&amp;&quot;|&quot; _
						&amp;strPerfectMatchMemberName&amp;&quot;|&quot;&amp;strPerfectMatchGroupName
				End If
    			i = i + 1
    		Next
    		If i &gt; 0 Then
				&#039; Remove preceeding delimiter
				strMembers = Right(strMembers,Len(strMembers) - 1)
			Else
				strMembers = &quot;::Empty Group::&quot;
	    	End If
	    	dictGroups.Add objGroup.Name,strMembers	    	
    	End If	
    Next
	Set GetLocalGroupsAndMembers = dictGroups
End Function &#039;GetLocalGroups


Function IsDC
&#039; This function will return True if the machine is on a domain
&#039; and False if not or if it&#039;s a domain controller
	
	Dim objWMIService, colItems, objItem
	Dim bDomainMember, intDomainRole
	
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;,,48)

	For Each objItem in colItems
		bDomainMember = objItem.PartOfDomain
		intDomainRole = objItem.DomainRole
	Next
	
	If bDomainMember = &quot;True&quot; And (intDomainRole = 4 Or intDomainRole = 5) Then
		&#039; Skip if on domain and is domain controller	
		IsDC = True
	Else
		IsDC = False
	End If

End Function &#039;IsDC


Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = strSID
		End If
	Else
		GetUserForSIDLocal = strSID
	End If
End Function &#039;GetUserForSIDLocal

Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function


Function SplitDomain(strEntry)
	&#039; examines entry, returns array:
	&#039; Domain|Member
	
	Dim arrOut,strDomain,strMember,arrSplit,objWshNet,strComputer
	Dim arrADSSplit,strRest
	
	Set objWshNet = CreateObject(&quot;WScript.Network&quot;)
	strComputer = objWshNet.ComputerName
	
	&#039;&#039; right here we need to return a domain|Member split from the adspath
	&#039;&#039; if the domain is the computer name, don&#039;t output that
	
	If InStr(strEntry,&quot;@&quot;) &gt; 0 Then
		arrSplit = Split(strEntry,&quot;@&quot;)
		If UBound(arrSplit) &gt; 0 Then
			strMember = arrSplit(0)
			strDomain = arrSplit(1)
		End If
	ElseIf InStr(strEntry,&quot;\&quot;) &gt; 0 Then
		arrSplit = Split(strEntry,&quot;\&quot;)
		If UBound(arrSplit) &gt; 0 Then
			strDomain = arrSplit(0)
			strMember = arrSplit(1)
		End If
	ElseIf InStr(strEntry,&quot;//&quot;) &gt; 0 Then
		&#039; is ADSPath
		arrADSSplit = Split(strEntry,&quot;//&quot;)
		strDomain = Split(arrADSSplit(1),&quot;/&quot;)(0)
		strMember = Split(arrADSSplit(1),&quot;/&quot;)(1)	
	Else
		strDomain = &quot;&quot;
		strMember = strEntry
	End If
	
	arrOut = Array(strDomain,strMember)
	
	SplitDomain = arrOut
	
End Function &#039;SplitDomain",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,25,0,1,0,Group Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Member Name,String,1,1,2,ADSPath,String,1,1,3,PerfectMatch Member Name,String,1,1,4,PerfectMatch Group Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,String
21,Operating System,2015-01-05T20:22:01,",","Returns the names of Local Groups on Windows machines.
Example:Administrators",0,28471576,0,39,1,Jim Olsen,300,,,,2015-01-05T20:22:01,Local Groups,,,,,,,,,Windows,"&#039;========================================
&#039; Local Groups
&#039;========================================

&#039; output all local groups

Option Explicit

Dim strGroup, dictBlacklist,dictGroups
Set dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; Add one line for each user or group that you do not want listed in the sensor output.  
&#039;dictBlacklist.Add LCase(&quot;IgnoreMe&quot;), True

&#039; Do not run on a Domain Controller, would list all domain groups
If IsDC Then WScript.Quit

Set dictGroups = GetLocalGroups
For Each strGroup In dictGroups.Keys
	Dim bShouldList,strItem
	bShouldList = True

	For Each strItem In dictBlacklist.Keys
		If InStr(LCase(strGroup), strItem) &gt; 0 Then 
			bShouldList = False
		End If
	Next

	If bShouldList Then 
		WScript.Echo strGroup
	End If 
Next

Function GetLocalGroups

	Dim colGroups,objGroup,dictGroups
	Set colGroups = GetObject(&quot;WinNT://.&quot;)
	colGroups.Filter = Array(&quot;group&quot;)
	Set dictGroups = CreateObject(&quot;Scripting.Dictionary&quot;)
	
	For Each objGroup In colGroups
    	If Not dictGroups.Exists(objGroup.Name) Then
	    	dictGroups.Add objGroup.Name, 1
    	End If	
    Next
	Set GetLocalGroups = dictGroups
End Function &#039;GetLocalGroups


Function IsDC
&#039; This function will return True if the machine is on a domain
&#039; and is a domain controller
	
	Dim objWMIService, colItems, objItem
	Dim bDomainMember, intDomainRole
	
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;,,48)

	For Each objItem in colItems
		bDomainMember = objItem.PartOfDomain
		intDomainRole = objItem.DomainRole
	Next
	
	If bDomainMember = &quot;True&quot; And (intDomainRole = 4 Or intDomainRole = 5) Then
		&#039; on domain and is domain controller	
		IsDC = True
	Else
		IsDC = False
	End If

End Function &#039;IsDC",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,20,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
22,Applications,2015-01-05T20:22:01,|,"List of the applications and versions of those applications installed on the client machine.
Example: Mozilla Firefox | 16.0.1",1,1511329504,0,41,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:01,Installed Applications,,,,,,,,,Windows,"&#039;========================================
&#039; Installed Applications
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039; This sensor will return information in the uninstall areas of the registry.
&#039; There are two hidden columns which can be filtered on despite the fact that
&#039; they&#039;re hidden, and can also feed actions.
&#039; if the uninstallstring is msi based, it is altered to show the
&#039; silent uninstall options and marked as &quot;Is Uninstallable&quot;
&#039; finally, if it&#039;s a user installed application, it will note that
&#039; The columns look like:
&#039; Name|Version|Silent Uninstall String|Uninstallable

SensorRandomize()

Set objRegistry = Getx64RegistryProvider()

keyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall&quot;
key64Path = &quot;SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall&quot;

Const HKLM = &amp;H80000002
Const HKEY_USERS = &amp;H80000003

&#039; list out 32-bit applications on a 64-bit system
If RegKeyExists(HKLM, key64Path) Then
	objRegistry.EnumKey HKLM, key64Path, arrSubKeys
	GetApplications HKLM,key64path,arrSubKeys
End If

&#039; list out 32-bit applications on a 32-bit system, or 64-bit applications
&#039; on a 64-bit system.
If RegKeyExists(HKLM, keyPath) Then
	objRegistry.EnumKey HKLM, keypath, arrSubKeys
	GetApplications HKLM,keypath,arrSubKeys
End If

&#039; Also list out applications installed to HKEY_Users areas
&#039; which will be appended to the arrSubKeys
objRegistry.EnumKey HKEY_USERS, &quot;&quot;, arrUserKeys
For Each strSIDkey In arrUserKeys
	If RegKeyExists(HKEY_USERS, strSIDKEY&amp;&quot;\&quot;&amp;keyPath) Then
		objRegistry.EnumKey HKEY_USERS, strSIDkey&amp;&quot;\&quot;&amp;keyPath, arrSubKeys
		GetApplications HKEY_USERS,strSIDKey&amp;&quot;\&quot;&amp;keyPath,arrSubKeys
	End If
Next


Function GetApplications(HIVE, keypath,arrSubKeys)
	Set applications = CreateObject(&quot;Scripting.Dictionary&quot;)
	On Error Resume Next
	For Each key in arrSubKeys
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;DisplayName&quot;, displayName
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;DisplayVersion&quot;, version
		objRegistry.GetDWORDValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;SystemComponent&quot;, systemComponent	
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;UninstallString&quot;, uninstallString	
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;ParentKeyName&quot;, parentKey	
		&#039; on error goto 0
		&#039; assume it&#039;s not uninstallable
		bUninstallable = &quot;Not Uninstallable&quot;
				
		If displayName &lt;&gt; &quot;&quot; _
			And Not IsNull(uninstallString) _ 
			And IsNull(parentKey) _
			And InStr(displayName, &quot;Hotfix&quot;) = 0 _
			And InStr(displayName, &quot;Update for&quot;) = 0 _
	 		And InStr(displayName, &quot;Security Update for&quot;) = 0 _
	 	Then 
	 		If InStr(LCase(uninstallString), &quot;msiexec&quot;) Then
	 			&#039; replace any /I with /X and add silent flags
	 			uninstallString = Replace(uninstallString,&quot;/I&quot;,&quot;/X&quot;) &amp; &quot; /qn /noreboot&quot; 
	  			bUninstallable = &quot;Is Uninstallable&quot;
	  		End If
	 		If IsNull(systemComponent) Or systemComponent = 0 Then
				If IsNull(version) Then
					version = GetVersionInString(displayName)
				End If
				&#039; This is a multi-column sensor.  Last two columns are hidden.

				displayString = displayName &amp; &quot;|&quot; &amp; version &amp; &quot;|&quot; &amp; uninstallString &amp; &quot;|&quot; &amp; bUninstallable

				&#039; treat displayString as the unique value - cannot be listed twice.
				If Not applications.Exists(displayString) Then
					applications.Add displayString, &quot;&quot;
				End If 	
			End If 	
		End If 
	Next
	On Error Goto 0
	
	SortDictionary applications, 1 &#039; This calls a sorting function specific to dictionaries
	arrApplicationsKeys = applications.Keys
	For Each application In arrApplicationsKeys
		&#039; final output of the sensor
		WScript.Echo CleanCharacters(application)
	Next
End Function &#039;GetApplications

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function SortDictionary(objDict, intSort)
 &#039;   objDict - the dictionary to sort
 &#039;   intSort - the field to sort (1=key, 2=item)
 
   &#039; declare constants
   Const dictKey  = 1
   Const dictItem = 2
 
   &#039; declare our variables
   Dim strDict()
   Dim objKey
   Dim strKey,strItem
   Dim X,Y,Z
 
   &#039; get the dictionary count
   Z = objDict.Count
 
   &#039; we need more than one item to warrant sorting
   If Z &gt; 1 Then
     &#039; create an array to store dictionary information
     ReDim strDict(Z,2)
     X = 0
     &#039; populate the string array
     For Each objKey In objDict
         strDict(X,dictKey)  = CStr(objKey)
         strDict(X,dictItem) = CStr(objDict(objKey))
         X = X + 1
     Next
 
     &#039; perform a a shell sort of the string array
     For X = 0 To (Z - 2)
       For Y = X To (Z - 1)
         If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) &gt; 0 Then
             strKey  = strDict(X,dictKey)
             strItem = strDict(X,dictItem)
             strDict(X,dictKey)  = strDict(Y,dictKey)
             strDict(X,dictItem) = strDict(Y,dictItem)
             strDict(Y,dictKey)  = strKey
             strDict(Y,dictItem) = strItem
         End If
       Next
     Next
 
     &#039; erase the contents of the dictionary object
     objDict.RemoveAll
 
     &#039; repopulate the dictionary with the sorted information
     For X = 0 To (Z - 1)
       objDict.Add strDict(X,dictKey), strDict(X,dictItem)
     Next
 
   End If
 End Function &#039;SortDictionary

Function GetVersionInString(ByVal strTemp)
&#039; examines a string and returns a version string at the end of it
	Dim strOut
	strOut = &quot;&quot;
	If Not IsNull(strTemp) Then
		strTemp = StrReverse(strTemp)
		Dim strLookAtChar,intCurPos
		Dim bNumbersStartMarked : bNumbersStartMarked = False

		For intCurPos = 1 To Len(strTemp)		
			strLookAtChar = Mid(strTemp,intCurPos,1)
			If IsNumeric(strLookAtChar) Or strLookAtChar = &quot;.&quot; Or strLookAtChar = &quot;-&quot; Then
				bNumbersStartMarked = True
				strOut = strOut &amp; strLookAtChar
			End If
		If bNumbersStartMarked And ( (Not IsNumeric(strLookAtChar) And strLookAtChar &lt;&gt; &quot;.&quot; And strLookAtChar &lt;&gt; &quot;-&quot;) ) Then
			Exit For
		End If	
		Next
		strOut = StrReverse(strOut)
	Else
		strOut = &quot;&quot;
	End If
	
	If Len(strOut) = 0 Then strOut = &quot;N/A&quot;
	
	GetVersionInString = strOut
	
End Function &#039;GetVersionInString

Function CleanCharacters(strTest)
&#039; String returned will not have characters in the output which
&#039; are not friendly to the console app
	strPattern = &quot;[^\x20-\x7E]&quot;
	strReplace = &quot;&quot;
	Set objRegExp = New RegExp
	objRegExp.Global = True
	objRegExp.IgnoreCase = True
	objRegExp.Pattern = strPattern
	objRegExp.Global = True
	CleanCharacters = objRegExp.Replace(strTest, strReplace)
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/sh
# Detects which OS and if it is Linux then it will detect which Linux
# Distribution.

# Can be used as a starting point for shell scripts that need to work differently on
# Mac, and various flavors of Linux

OS=`uname -s`

GetVersionFromFile()
{
    VERSION=`cat $1 | tr &quot;\n&quot; &#039; &#039; | sed s/.*VERSION.*=\ // `
}

if [ &quot;${OS}&quot; = &quot;Linux&quot; ] ; then
    KERNEL=`uname -r`
    if [ -f /etc/redhat-release ] ; then
        # Redhat based system
        rpm -qa --queryformat &quot;%{NAME}|%{VERSION}|nothing|Not Uninstallable\n&quot;
    elif [ -f /etc/SuSE-release ] ; then
        # SuSE / OpenSuSE based system
        rpm -qa --queryformat &quot;%{NAME}|%{VERSION}|nothing|Not Uninstallable\n&quot;
    elif [ -f /etc/lsb-release ] ; then
        # Usually Ubuntu -- this is a Linux Standard Based system, which
        # Ubuntu is by far the biggest.  But general LSB commands should work
        dpkg -l | awk &#039;{print $2&quot;|&quot;$3&quot;|nothing|Not Uninstallable&quot;}&#039;
    elif [ -f /etc/debian_version ] ; then
        # Debian -- note that Ubuntu is Debian based, but Debian does not have a
        # lsb-release file
        dpkg -l | awk &#039;{print $2&quot;|&quot;$3&quot;|nothing|Not Uninstallable&quot;}&#039;
        #else
	# a less common distribution.  Most all really popular distributions will
        # be caught by the tree above.
    fi
#else
   # not Linux -- could be anything, BSD / Solaris / AIX / etc
fi

echo ${OSSTR}
",UnixShell,Mac,"#!/bin/bash

notcontains() {
    string=&quot;$1&quot;
    substring=&quot;$2&quot;
    if test &quot;${string#*$substring}&quot; != &quot;$string&quot;
    then
        return 1    # $substring is not in $string
    else
        return 0    # $substring is in $string
    fi
}

ftemp=$(mktemp -t &#039;apps.xml&#039;)
system_profiler -xml SPApplicationsDataType &gt; &quot;$ftemp&quot;

count=1

while true
do
        app=`/usr/libexec/PlistBuddy -c &quot;Print :0:_items:$count:_name&quot; $ftemp 2&gt;/dev/null`
        version=`/usr/libexec/PlistBuddy -c &quot;Print :0:_items:$count:version&quot; $ftemp 2&gt;/dev/null`
        if [ -z &quot;$app&quot; ]; then
                break
        fi
        test=&quot;VMware&quot;
        if notcontains &quot;$version&quot; &quot;$test&quot;; then
                echo $app&quot;|&quot;$version&quot;|nothing|Not Uninstallable&quot;
        fi
        let count=count+1
done
rm -rf &quot;$ftemp&quot;
",UnixShell,0,3229,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Version,Version,1,1,2,Silent Uninstall String,String,1,1,3,Uninstallable,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
23,Kaspersky,2015-01-05T20:22:01,",","Returns the version of the Kaspersky Antivirus Scanner.
Example:5.6",1,2527517741,0,43,1,Jim Olsen,1800,0,defined,Tanium,2015-01-05T20:22:01,Kaspersky Client Version,,,,,,,,,Windows,"&#039;========================================
&#039; Kaspersky Client Version
&#039;========================================

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

Const HKLM = &amp;H80000002 

keyPath = &quot;Software\KasperskyLab&quot;
key64Path = &quot;Software\WOW6432Node\KasperskyLab&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

&#039;Check for AVP11
If RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP11\environment&quot;) Then
	WScript.Echo GetVersion(keyPath &amp; &quot;\protected\AVP11\environment&quot;)

&#039;Check for AVP10
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP10\environment&quot;) Then
	WScript.Echo GetVersion(keyPath &amp; &quot;\protected\AVP10\environment&quot;)

&#039;Check for AVP9
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP9\environment&quot;) Then
	WScript.Echo GetVersion(keyPath &amp; &quot;\protected\AVP9\environment&quot;)

&#039;Check for AVP8
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP8\environment&quot;) Then
	WScript.Echo GetVersion(keyPath &amp; &quot;\protected\AVP8\environment&quot;)

Else
	WScript.Echo &quot;Version not found&quot;
End If


Function GetVersion(fullKeyPath)
	objRegistry.GetStringValue HKLM,fullKeyPath ,&quot;ProductVersion&quot;, strVersion
	If Not IsNull(strVersion) Then
		GetVersion = strVersion
		Exit Function
	End If	

	GetVersion = &quot;Version not found&quot;
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
24,Kaspersky,2015-01-05T20:22:01,",","Returns the age, in days, of the the Kaspersky Antivirus DAT file.
Example: 5",1,1220267691,0,45,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Kaspersky DAT Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Kaspersky DAT Days Old
&#039;========================================

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

Const HKLM = &amp;H80000002 

&#039;Uses date math - set locale

SetLocale(1033)

keyPath = &quot;Software\KasperskyLab&quot;
key64Path = &quot;Software\WOW6432Node\KasperskyLab&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

&#039;Check for AVP11
If RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP11\environment&quot;) Then
	WScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\protected\AVP11\environment&quot;))

&#039;Check for AVP10
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP10\environment&quot;) Then
	WScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\protected\AVP10\environment&quot;))

&#039;Check for AVP9
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP9\environment&quot;) Then
	WScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\protected\AVP9\environment&quot;))

&#039;Check for AVP8
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP8\environment&quot;) Then
	WScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\protected\AVP8\environment&quot;))

Else
	WScript.Echo &quot;DAT version not found&quot;
End If


Function GetDatVersion(fullKeyPath)
	objRegistry.GetStringValue HKLM,fullKeyPath ,&quot;DataRoot&quot;, dataRoot
	objRegistry.GetStringValue HKLM,fullKeyPath ,&quot;UpdateRoot&quot;, updateRoot
	words = Split(updateRoot, &quot;/&quot;)
	updateFile = words(UBound(words))
	strFile = dataRoot &amp; &quot;\data\&quot; &amp; updateFile
	
	Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	If fso.FileExists(strFile) Then
		Set objFile = fso.OpenTextFile(strFile, 1)
		Do Until objFile.AtEndOfStream
		    strLine = objFile.ReadLine
		    If InStr(strLine, &quot;UpdateDate=&quot;) Then
		    	words = Split(strLine, &quot;&quot;&quot;&quot;)
		    	dats = Split(words(UBound(words)-1))
		    	GetDatVersion = dats(0)
		    	Exit Function
		    End If
		Loop
	End If
	GetDatVersion = &quot;DAT version not found&quot;
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function GetDatDaysOld(strValue)
	datDate = CDate( Mid(strValue, 3, 2) &amp; &quot;/&quot; &amp; Left(strValue, 2) &amp; &quot;/&quot; &amp; Right(strValue, 4) )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDatDaysOld = DateDiff(&quot;d&quot;, datDate, today)
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
25,Kaspersky,2015-01-05T20:22:01,",","Returns the version of the Kaspersky Antivirus DAT file.
Example: 5.0.0.3",1,1391517255,0,47,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,Kaspersky DAT Version,,,,,,,,,Windows,"&#039;========================================
&#039; Kaspersky DAT Version
&#039;========================================

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

Const HKLM = &amp;H80000002 

keyPath = &quot;Software\KasperskyLab&quot;
key64Path = &quot;Software\WOW6432Node\KasperskyLab&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

&#039;Check for AVP11
If RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP11\environment&quot;) Then
	WScript.Echo GetDatVersion(keyPath &amp; &quot;\protected\AVP11\environment&quot;)

&#039;Check for AVP10
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP10\environment&quot;) Then
	WScript.Echo GetDatVersion(keyPath &amp; &quot;\protected\AVP10\environment&quot;)

&#039;Check for AVP9
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP9\environment&quot;) Then
	WScript.Echo GetDatVersion(keyPath &amp; &quot;\protected\AVP9\environment&quot;)

&#039;Check for AVP8
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\protected\AVP8\environment&quot;) Then
	WScript.Echo GetDatVersion(keyPath &amp; &quot;\protected\AVP8\environment&quot;)

Else
	WScript.Echo &quot;DAT version not found&quot;
End If


Function GetDatVersion(fullKeyPath)
	objRegistry.GetStringValue HKLM,fullKeyPath ,&quot;DataRoot&quot;, dataRoot
	objRegistry.GetStringValue HKLM,fullKeyPath ,&quot;UpdateRoot&quot;, updateRoot
	words = Split(updateRoot, &quot;/&quot;)
	updateFile = words(UBound(words))
	strFile = dataRoot &amp; &quot;\data\&quot; &amp; updateFile
	
	Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	If fso.FileExists(strFile) Then
		Set objFile = fso.OpenTextFile(strFile, 1)
		Do Until objFile.AtEndOfStream
		    strLine = objFile.ReadLine
		    If InStr(strLine, &quot;UpdateDate=&quot;) Then
		    	words = Split(strLine, &quot;&quot;&quot;&quot;)
		    	dats = Split(words(UBound(words)-1))
		    	GetDatVersion = dats(0)
		    	Exit Function
		    End If
		Loop
	End If 	
	GetDatVersion = &quot;DAT version not found&quot;
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
26,Applications,2015-01-05T20:22:01,",","Provides a list of currently running services on the client machine.
Example: DHCP Client",1,1497251383,0,49,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:01,Running Service,,,,,,,,,Windows,select Caption from win32_Service where State=&#039;Running&#039;,WMIQuery,Linux,"#!/bin/sh
# Detects which OS and if it is Linux then it will detect which Linux
# Distribution.

# Can be used as a starting point for shell scripts that need to work differently on
# Mac, and various flavors of Linux

OS=`uname -s`

GetVersionFromFile()
{
    VERSION=`cat $1 | tr &quot;\n&quot; &#039; &#039; | sed s/.*VERSION.*=\ // `
}

if [ &quot;${OS}&quot; = &quot;Linux&quot; ] ; then
    KERNEL=`uname -r`
    if [ -f /etc/redhat-release ] ; then
        # Redhat based system
        chkconfig --list | grep 3:on | awk &#039;{print $1}&#039;
    elif [ -f /etc/SuSE-release ] ; then
        # SuSE / OpenSuSE based system
        ps aux | awk &#039;{print $11}&#039;
    elif [ -f /etc/lsb-release ] ; then
        # Usually Ubuntu -- this is a Linux Standard Based system, which
        # Ubuntu is by far the biggest.  But general LSB commands should work
        ps aux | awk &#039;{print $11}&#039;
    elif [ -f /etc/debian_version ] ; then
        # Debian -- note that Ubuntu is Debian based, but Debian does not have a
        # lsb-release file
        ps aux | awk &#039;{print $11}&#039;
        #else
	# a less common distribution.  Most all really popular distributions will
        # be caught by the tree above.
    fi
#else
   # not Linux -- could be anything, BSD / Solaris / AIX / etc
fi

echo ${OSSTR}
",UnixShell,Mac,"#!/bin/bash
first=true
launchctl list | while read line
do
    set -- $line
if ( $first ); 
then
	first=false
else
	if [ &quot;$2&quot; == &quot;-&quot; ]; 
	then
		echo $3
	fi
fi
done
",UnixShell,0,59,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
27,McAfee,2015-01-05T20:22:01,",","Returns whether on-access scanning is enabled on the machine.
Example: Enabled",1,1053039240,0,51,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,VirusScan Enterprise On-Access Scan State,,,,,,,,,Windows,"&#039;========================================
&#039; VirusScan Enterprise On-Access Scan State
&#039;========================================

Option Explicit

Dim strServiceState
&#039; First get the state of the service
strServiceState = ServiceState(&quot;McShield&quot;)
If strServiceState = &quot;Not Installed&quot; Then
    &#039;No further tests are necessary
    WScript.Echo &quot;VirusScan Enterprise Not Installed&quot;
    WScript.Quit
End If

Const HKLM = &amp;h80000002
Dim objReg

Set objReg = Getx64RegistryProvider()

WScript.Echo GetOASStatus

Function GetOASStatus

    Dim intOnAccessScanEnabled
    Dim strRegPath, strReport

    strRegPath = GetMcAfeeProductRegRootKey(&quot;DesktopProtection&quot;)

    If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
        objReg.GetDWORDValue HKLM,strRegPath,&quot;OASState&quot;,intOnAccessScanEnabled
        Select Case intOnAccessScanEnabled
            Case 2
                strReport = &quot;Disabled&quot;
            Case 3
                strReport = &quot;Enabled&quot;
        End Select
    Else
        WScript.Echo &quot;Error: Cannot determine On-Access Scan Status&quot;
    End If

    GetOASStatus = strReport

End Function &#039;GetOASStatus

Function GetMcAfeeProductRegRootKey(strProductString)
&#039; Retrieves McAfee key for a product
&#039; products are passed in and defined in the function

    Dim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey
    Dim strProductKeyPath

    &#039; select on input
    strProductString = UCase(strProductString)
    Select Case strProductString
        Case &quot;AGENT&quot;
            strProductSubKey = &quot;McAfee\Agent&quot;
        Case &quot;AVENGINE&quot;
            strProductSubKey = &quot;McAfee\AVEngine&quot;
        Case &quot;DESKTOPPROTECTION&quot;
            strProductSubKey = &quot;McAfee\DesktopProtection&quot;
        Case &quot;EPO&quot;
            strProductSubKey = &quot;McAfee\ePolicy Orchestrator&quot;
        Case &quot;HIPS&quot;
            strProductSubKey = &quot;McAfee\HIP&quot;
        Case &quot;HIPSCORE&quot;
            strProductSubKey = &quot;McAfee\HIPSCore&quot;
        Case &quot;MCTRAY&quot;
            strProductSubKey = &quot;McAfee\McTray&quot;
        Case &quot;SITEADVISOR&quot;
            strProductSubKey = &quot;McAfee\SiteAdvisor Enterprise Plus&quot;
        Case &quot;SYSTEMCORE&quot;
            strProductSubKey = &quot;McAfee\SystemCore&quot;
        Case &quot;VSCORE&quot;
            strProductSubKey = &quot;McAfee\VSCore&quot;
        Case &quot;NAIEPO&quot;
            strProductSubKey = &quot;Network Associates\ePolicy Orchestrator&quot;
        Case &quot;NAITVD&quot;
            strProductSubKey = &quot;Network Associates\TVD&quot;
        Case Else
            strProductSubKey = False
    End Select

    Const HKLM = &amp;h80000002

    strRootSoftwareKeyNative = &quot;Software&quot;
    strRootSoftwareKeyWow64 = &quot;Software\Wow6432Node&quot;
    If Not strProductSubKey = False Then
        &#039; Assume not in both places on a 64-bit machine
        If RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey) Then
            strProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey
        ElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey) Then
            strProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey
        End If
    Else
        strProductKeyPath = False
    End If

    GetMcAfeeProductRegRootKey = strProductKeyPath

End Function &#039;GetMcAfeeProductRegRootKey

Function RegKeyExists(sHive, sRegKey)
    Dim aValueNames, aValueTypes
    If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
        RegKeyExists = True
    Else
        RegKeyExists = False
    End If
End Function &#039;RegKeyExists

Function ServiceState(strServiceName)
&#039; This function determines if a service is in a bad state and returns
&#039; values indicating the state.  Examples:
&#039; &quot;Stopped&quot;
&#039; &quot;Stopped Manual&quot;
&#039; &quot;Running Disabled&quot;
&#039; &quot;Not Installed&quot;

    Dim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState

    strWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;

    strState = &quot;&quot;
    strStartMode = &quot;&quot;
    Set objWMIService = GetObject(&quot;winmgmts:&quot; _
        &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
    Set colItems = objWMIService.ExecQuery(strWMIQuery)

    If colItems.Count = 0 Then
        ServiceState = &quot;Not Installed&quot;
    Else
        For Each objItem In colItems
            If objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then
                strState = objItem.State
            End If
            If objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then
                strStartMode = objItem.StartMode
            End If
            ServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)
        Next
    End If

End Function &#039;ServiceState

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next

    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)

    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
28,Anti-Virus,2015-01-05T20:22:01,",","Returns the version number of the McAfee AntiVirus client running on the machine.
Example: 8.8.0.975",1,2481801758,0,53,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,VirusScan Enterprise Version,,,,,,,,,Windows,"&#039;========================================
&#039; VirusScan Enterprise Version
&#039;========================================
Const HKLM = &amp;H80000002

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

&#039;Check for VirusScan key
keyPath = &quot;Software\Network Associates\TVD\VirusScan&quot;
key64Path = &quot;Software\WOW6432Node\Network Associates\TVD\VirusScan&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path
End If

If RegKeyExists(HKLM, keyPath) Then
	objRegistry.GetStringValue HKLM,keyPath ,&quot;szCurrentVersionNumber&quot;, strVersion
	If Not IsNull(strVersion) Then
		WScript.Echo strVersion
		WScript.Quit
	End If
End If

&#039;Check for VirusScan Enterprise key
keyPath = &quot;Software\Network Associates\TVD\VirusScan Enterprise\CurrentVersion&quot;
key64Path = &quot;Software\WOW6432Node\Network Associates\TVD\VirusScan Enterprise\CurrentVersion&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path
End If

If RegKeyExists(HKLM, keyPath) Then
	objRegistry.GetStringValue HKLM,keyPath ,&quot;szProductVer&quot;, strVersion
	If Not IsNull(strVersion) Then
		WScript.Echo strVersion
		WScript.Quit
	End If
End If

&#039;Check for DesktopProtection key
keyPath = &quot;Software\McAfee\DesktopProtection&quot;
key64Path = &quot;Software\WOW6432Node\McAfee\DesktopProtection&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path
End If

If RegKeyExists(HKLM, keyPath) Then
	objRegistry.GetStringValue HKLM,keyPath ,&quot;szProductVer&quot;, strVersion
	If Not IsNull(strVersion) Then
		WScript.Echo strVersion
		WScript.Quit
	End If
End If

WScript.Echo &quot;Not Installed&quot;

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
29,McAfee,2015-01-05T20:22:01,",","Returns the version of the McAfee VirusScan Enterprise DAT file currently loaded.
Example: 6910",1,213927111,0,55,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,VirusScan Enterprise DAT Version,,,,,,,,,Windows,"&#039;========================================
&#039;McAfee VirusScan Enterprise DAT Version
&#039;========================================

&#039; Returns the DAT number for VSE


Option Explicit

Const HKLM = &amp;h80000002
Dim objReg	
Set objReg = Getx64RegistryProvider()	

Dim strServiceState
&#039; First get the state of the service
strServiceState = ServiceState(&quot;McShield&quot;)
If strServiceState = &quot;Not Installed&quot; Then
	&#039;No further tests are necessary
	WScript.Echo &quot;VirusScan Enterprise Not Installed&quot;
	WScript.Quit
End If

WScript.Echo GetDatVersion

Function GetDatVersion

	Dim intDatVersion,intDatVersionMinor
	Dim strRegPath

	strRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetDWORDValue HKLM,strRegPath,&quot;AVDatVersion&quot;,intDatVersion
		objReg.GetDWORDValue HKLM,strRegPath,&quot;AVDatVersionMinor&quot;,intDatVersionMinor

		If IsNumeric(intDatVersion)Then
			If IsNumeric(intDatVersionMinor) Then
				If CInt(intDatVersionMinor) = 0 Then
					GetDatVersion = intDatVersion
				Else
					GetDatVersion = intDatVersion&amp;&quot;.&quot;&amp;intDatVersionMinor
				End If
			Else
				GetDatVersion = intDatVersion
			End If
		Else
			WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT Version&quot;
		End If
	Else
		WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT Version&quot;
	End If
End Function &#039;GetDatVersion



Function GetMcAfeeProductRegRootKey(strProductString)
&#039; Retrieves McAfee key for a product
&#039; products are passed in and defined in the function

	Dim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey
	Dim strProductKeyPath

	&#039; select on input
	strProductString = UCase(strProductString)
	Select Case strProductString
		Case &quot;AGENT&quot;
			strProductSubKey = &quot;McAfee\Agent&quot;	
		Case &quot;AVENGINE&quot;
			strProductSubKey = &quot;McAfee\AVEngine&quot;
		Case &quot;DESKTOPPROTECTION&quot;
			strProductSubKey = &quot;McAfee\DesktopProtection&quot;
		Case &quot;EPO&quot;
			strProductSubKey = &quot;McAfee\ePolicy Orchestrator&quot;
		Case &quot;HIPS&quot;
			strProductSubKey = &quot;McAfee\HIP&quot;
		Case &quot;HIPSCORE&quot;
			strProductSubKey = &quot;McAfee\HIPSCore&quot;
		Case &quot;MCTRAY&quot;
			strProductSubKey = &quot;McAfee\McTray&quot;					
		Case &quot;SITEADVISOR&quot;
			strProductSubKey = &quot;McAfee\SiteAdvisor Enterprise Plus&quot;
		Case &quot;SYSTEMCORE&quot;
			strProductSubKey = &quot;McAfee\SystemCore&quot;
		Case &quot;VSCORE&quot;
			strProductSubKey = &quot;McAfee\VSCore&quot;
		Case &quot;NAIEPO&quot;
			strProductSubKey = &quot;Network Associates\ePolicy Orchestrator&quot;
		Case &quot;NAITVD&quot;
			strProductSubKey = &quot;Network Associates\TVD&quot;
		Case Else
			strProductSubKey = False
	End Select
			
	Const HKLM = &amp;h80000002
	
    
	strRootSoftwareKeyNative = &quot;Software&quot;
	strRootSoftwareKeyWow64 = &quot;Software\Wow6432Node&quot;
    If Not strProductSubKey = False Then
	    &#039; Assume not in both places on a 64-bit machine
		If RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey
		ElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey
		End If
	Else
		strProductKeyPath = False		
	End If
	
	GetMcAfeeProductRegRootKey = strProductKeyPath

End Function &#039;GetMcAfeeProductRegRootKey

Function RegKeyExists(sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function &#039;RegKeyExists

Function ServiceState(strServiceName)
&#039; This function determines if a service is in a bad state and returns
&#039; values indicating the state.  Examples: 
&#039; &quot;Stopped&quot;
&#039; &quot;Stopped Manual&quot;
&#039; &quot;Running Disabled&quot;
&#039; &quot;Not Installed&quot;

	Dim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState

	strWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;

	strState = &quot;&quot;
	strStartMode = &quot;&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
		&amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(strWMIQuery)
	
	If colItems.Count = 0 Then
		ServiceState = &quot;Not Installed&quot;
	Else
		For Each objItem In colItems
			If objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then
				strState = objItem.State
			End If
			If objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then
				strStartMode = objItem.StartMode
			End If
			ServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)
		Next
	End If

End Function &#039;ServiceState

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
30,McAfee,2015-01-05T20:22:01,",","Returns the age, in days, of the currently loaded DAT file for McAfee VirusScan Enterprise.
Example: 1",1,69663275,0,57,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,VirusScan Enterprise DAT Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; McAfee VirusScan Enterprise Dat Days Old
&#039;========================================

&#039; Returns, in days, the age of the currently applied DAT file

Option Explicit

Dim strServiceState
&#039; First get the state of the service
strServiceState = ServiceState(&quot;McShield&quot;)
If strServiceState = &quot;Not Installed&quot; Then
	&#039;No further tests are necessary
	WScript.Echo &quot;VirusScan Enterprise Not Installed&quot;
	WScript.Quit
End If

Const HKLM = &amp;h80000002
Dim objReg	
Set objReg = Getx64RegistryProvider()

WScript.Echo GetDatAgeInDays

Function GetDatAgeInDays

	Dim strDatDate,dtmDatDate,arrDatDateBits
	Dim strRegPath, intDaysOld

	strRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetStringValue HKLM,strRegPath,&quot;AVDatDate&quot;,strDatDate
		
		&#039;Date is in YYYY/MM/DD format, move to US/English
		If InStr(strDatDate,&quot;/&quot;) &gt; 0 Then &#039;valid value
			arrDatDateBits = Split(strDatDate,&quot;/&quot;)
			strDatDate = arrDatDateBits(1)&amp;&quot;/&quot;&amp;arrDatDateBits(2)&amp;&quot;/&quot;&amp;arrDatDateBits(0)
			If IsDate(strDatDate) Then
				intDaysOld = CInt(GetDaysOld(strDatDate))
				GetDatAgeInDays = intDaysOld
			Else
				WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT age&quot;
			End If
		Else &#039; Dat Date has no &quot;/&quot; in it and cannot be parsed or compared
			WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT age&quot;
		End If
	Else
		WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT age&quot;
	End If
End Function &#039;GetDatAgeInDays



Function GetMcAfeeProductRegRootKey(strProductString)
&#039; Retrieves McAfee key for a product
&#039; products are passed in and defined in the function

	Dim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey
	Dim strProductKeyPath

	&#039; select on input
	strProductString = UCase(strProductString)
	Select Case strProductString
		Case &quot;AGENT&quot;
			strProductSubKey = &quot;McAfee\Agent&quot;	
		Case &quot;AVENGINE&quot;
			strProductSubKey = &quot;McAfee\AVEngine&quot;
		Case &quot;DESKTOPPROTECTION&quot;
			strProductSubKey = &quot;McAfee\DesktopProtection&quot;
		Case &quot;EPO&quot;
			strProductSubKey = &quot;McAfee\ePolicy Orchestrator&quot;
		Case &quot;HIPS&quot;
			strProductSubKey = &quot;McAfee\HIP&quot;
		Case &quot;HIPSCORE&quot;
			strProductSubKey = &quot;McAfee\HIPSCore&quot;
		Case &quot;MCTRAY&quot;
			strProductSubKey = &quot;McAfee\McTray&quot;					
		Case &quot;SITEADVISOR&quot;
			strProductSubKey = &quot;McAfee\SiteAdvisor Enterprise Plus&quot;
		Case &quot;SYSTEMCORE&quot;
			strProductSubKey = &quot;McAfee\SystemCore&quot;
		Case &quot;VSCORE&quot;
			strProductSubKey = &quot;McAfee\VSCore&quot;
		Case &quot;NAIEPO&quot;
			strProductSubKey = &quot;Network Associates\ePolicy Orchestrator&quot;
		Case &quot;NAITVD&quot;
			strProductSubKey = &quot;Network Associates\TVD&quot;
		Case Else
			strProductSubKey = False
	End Select
			
	Const HKLM = &amp;h80000002
	
    
	strRootSoftwareKeyNative = &quot;Software&quot;
	strRootSoftwareKeyWow64 = &quot;Software\Wow6432Node&quot;
    If Not strProductSubKey = False Then
	    &#039; Assume not in both places on a 64-bit machine
		If RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey
		ElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey
		End If
	Else
		strProductKeyPath = False		
	End If
	
	GetMcAfeeProductRegRootKey = strProductKeyPath

End Function &#039;GetMcAfeeProductRegRootKey

Function ServiceState(strServiceName)
&#039; This function determines if a service is in a bad state and returns
&#039; values indicating the state.  Examples: 
&#039; &quot;Stopped&quot;
&#039; &quot;Stopped Manual&quot;
&#039; &quot;Running Disabled&quot;
&#039; &quot;Not Installed&quot;

	Dim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState

	strWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;

	strState = &quot;&quot;
	strStartMode = &quot;&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
		&amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(strWMIQuery)
	
	If colItems.Count = 0 Then
		ServiceState = &quot;Not Installed&quot;
	Else
		For Each objItem In colItems
			If objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then
				strState = objItem.State
			End If
			If objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then
				strStartMode = objItem.StartMode
			End If
			ServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)
		Next
	End If

End Function &#039;ServiceState

Function RegKeyExists(sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function &#039;RegKeyExists

Function GetDaysOld(strDate)
&#039;date format is MM/DD/YYYY 
	SetLocale(1033)
	Dim patternDate, today
	patternDate = CDate( strDate )
	today = CDate( now )
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function &#039;GetDaysOld

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
31,McAfee,2015-01-05T20:22:01,",","Returns the 64-bit and 32-bit engine versions for VirusScan Enterprise
Example: 5400.1158 (32-bit)  5400.1158 (64-bit)",1,2816391364,0,59,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:01,VirusScan Enterprise Engine Version,,,,,,,,,Windows,"&#039;========================================
&#039;McAfee VirusScan Enterprise Engine Version
&#039;========================================

&#039; Returns the version number of the McAfee Scan Engine


Option Explicit

Const HKLM = &amp;h80000002
Dim objReg	
Set objReg = Getx64RegistryProvider()

Dim strServiceState
&#039; First get the state of the service
strServiceState = ServiceState(&quot;McShield&quot;)
If strServiceState = &quot;Not Installed&quot; Then
	&#039;No further tests are necessary
	WScript.Echo &quot;VirusScan Enterprise Not Installed&quot;
	WScript.Quit
End If

Dim bHadOutput,strEngineVersion32,strEngineVersion64,bHas32
strEngineVersion32 = GetEngineVersion32
strEngineVersion64 = GetEngineVersion64

If Not (IsNull(strEngineVersion32) Or strEngineVersion32 = &quot;&quot;) Then
	WScript.Echo strEngineVersion32 &amp; &quot; (32-bit)&quot;
	bHas32 = True
End If
If Not (IsNull(strEngineVersion64) Or strEngineVersion64 = &quot;&quot;) Then
	WScript.Echo strEngineVersion64 &amp; &quot; (64-bit)&quot;
End If

If Not bHadOutput And Not bHas32 Then &#039; other engine variables were not present, use non-bitness-specific
	WScript.Echo GetEngineVersion &amp; &quot; (32-bit)&quot;
End If
	
Function GetEngineVersion32

	Dim intEngineVersion,intEngineVersionMinor
	Dim strRegPath

	strRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion32Major&quot;,intEngineVersion
		objReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion32Minor&quot;,intEngineVersionMinor

		If IsNumeric(intEngineVersion) And IsNumeric(intEngineVersionMinor) Then
			bHadOutput = True
			If CInt(intEngineVersionMinor) = 0 Then
				GetEngineVersion32 = intEngineVersion
			Else
				GetEngineVersion32 = intEngineVersion&amp;&quot;.&quot;&amp;intEngineVersionMinor
			End If
		Else
			bHadOutput = False
		End If
	Else
		bHadOutput = False
	End If
End Function &#039;GetEngineVersion32

Function GetEngineVersion64

	Dim intEngineVersion,intEngineVersionMinor
	Dim strRegPath

	strRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion64Major&quot;,intEngineVersion
		objReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion64Minor&quot;,intEngineVersionMinor

		If IsNumeric(intEngineVersion) And IsNumeric(intEngineVersionMinor) Then
			bHadOutput = True
			If CInt(intEngineVersionMinor) = 0 Then
				GetEngineVersion64 = intEngineVersion
			Else
				GetEngineVersion64 = intEngineVersion&amp;&quot;.&quot;&amp;intEngineVersionMinor
			End If
		Else
			bHadOutput = False
		End If
	Else
		bHadOutput = False
	End If
End Function &#039;GetEngineVersion64

Function GetEngineVersion

	Dim intEngineVersion,intEngineVersionMinor
	Dim strRegPath

	strRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersionMajor&quot;,intEngineVersion
		objReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersionMinor&quot;,intEngineVersionMinor

		If IsNumeric(intEngineVersion) And IsNumeric(intEngineVersionMinor) Then
			If CInt(intEngineVersionMinor) = 0 Then
				GetEngineVersion = intEngineVersion
			Else
				GetEngineVersion = intEngineVersion&amp;&quot;.&quot;&amp;intEngineVersionMinor
			End If
		Else
			WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Engine Version&quot;
		End If
	Else
		WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Engine Version&quot;
	End If
End Function &#039;GetEngineVersion




Function GetMcAfeeProductRegRootKey(strProductString)
&#039; Retrieves McAfee key for a product
&#039; products are passed in and defined in the function

	Dim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey
	Dim strProductKeyPath

	&#039; select on input
	strProductString = UCase(strProductString)
	Select Case strProductString
		Case &quot;AGENT&quot;
			strProductSubKey = &quot;McAfee\Agent&quot;	
		Case &quot;AVENGINE&quot;
			strProductSubKey = &quot;McAfee\AVEngine&quot;
		Case &quot;DESKTOPPROTECTION&quot;
			strProductSubKey = &quot;McAfee\DesktopProtection&quot;
		Case &quot;EPO&quot;
			strProductSubKey = &quot;McAfee\ePolicy Orchestrator&quot;
		Case &quot;HIPS&quot;
			strProductSubKey = &quot;McAfee\HIP&quot;
		Case &quot;HIPSCORE&quot;
			strProductSubKey = &quot;McAfee\HIPSCore&quot;
		Case &quot;MCTRAY&quot;
			strProductSubKey = &quot;McAfee\McTray&quot;					
		Case &quot;SITEADVISOR&quot;
			strProductSubKey = &quot;McAfee\SiteAdvisor Enterprise Plus&quot;
		Case &quot;SYSTEMCORE&quot;
			strProductSubKey = &quot;McAfee\SystemCore&quot;
		Case &quot;VSCORE&quot;
			strProductSubKey = &quot;McAfee\VSCore&quot;
		Case &quot;NAIEPO&quot;
			strProductSubKey = &quot;Network Associates\ePolicy Orchestrator&quot;
		Case &quot;NAITVD&quot;
			strProductSubKey = &quot;Network Associates\TVD&quot;
		Case Else
			strProductSubKey = False
	End Select
			
	Const HKLM = &amp;h80000002
	
    
	strRootSoftwareKeyNative = &quot;Software&quot;
	strRootSoftwareKeyWow64 = &quot;Software\Wow6432Node&quot;
    If Not strProductSubKey = False Then
	    &#039; Assume not in both places on a 64-bit machine
		If RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey
		ElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey
		End If
	Else
		strProductKeyPath = False		
	End If
	
	GetMcAfeeProductRegRootKey = strProductKeyPath

End Function &#039;GetMcAfeeProductRegRootKey

Function RegKeyExists(sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function &#039;RegKeyExists

Function ServiceState(strServiceName)
&#039; This function determines if a service is in a bad state and returns
&#039; values indicating the state.  Examples: 
&#039; &quot;Stopped&quot;
&#039; &quot;Stopped Manual&quot;
&#039; &quot;Running Disabled&quot;
&#039; &quot;Not Installed&quot;

	Dim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState

	strWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;

	strState = &quot;&quot;
	strStartMode = &quot;&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
		&amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(strWMIQuery)
	
	If colItems.Count = 0 Then
		ServiceState = &quot;Not Installed&quot;
	Else
		For Each objItem In colItems
			If objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then
				strState = objItem.State
			End If
			If objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then
				strStartMode = objItem.StartMode
			End If
			ServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)
		Next
	End If

End Function &#039;ServiceState

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
32,User,2015-01-05T20:22:02,",","If no user is logged in, returns the last user to log in is reported.  If a user is currently logged in, that user is returned.
Example: DOMAIN\Jane.Doe",1,7318847,0,61,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Last Logged In User,,,,,,,,,Windows,"&#039;========================================
&#039; Last Logged In User
&#039;========================================

&#039; This sensor will report the user that was logged in the last time
&#039; the sensor was run.  If there is no user logged in, it will return
&#039; the last user to log in.
&#039;
&#039; note - for this sensor to be effective, it must be reissued as a saved question

Option Explicit
Const HKLM = &amp;h80000002

Dim objWMIService, objReg, colComputer
Dim objComputer, strLastUser, strLastLastUser


On Error Resume Next


Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)

&#039; Get the last logged in user from registry
strLastUser = GetLastUser(objReg)

If Err.Number &lt;&gt; 0 Then
	&#039;WScript.Echo &quot;setting initially, line 24&quot; &amp; Err.Description
	Err.Number = 0
End If

Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
Set colComputer = objWMIService.ExecQuery (&quot;Select UserName from Win32_ComputerSystem&quot;)

For Each objComputer in colComputer
	If IsNull(strLastUser) Or strLastUser = &quot;&quot; Or strLastUser = False Then &#039; first run or error, try to set
		If Err.Number &lt;&gt; 0 Then
			&#039; WScript.Echo &quot;line 34&quot; &amp; Err.Description
			Err.Number = 0
		End If
		If objComputer.UserName &lt;&gt; &quot;&quot; Then &#039;someone is currently logged in
			If Err.Number &lt;&gt; 0 Then
				&#039; WScript.Echo &quot;line 39&quot; &amp; Err.Description
				Err.Number = 0
			End If		 
			SetLastUser objReg, objComputer.UserName

			strLastUser = objComputer.UserName &#039; this may set to no value if nobody is logged in
			If Err.Number &lt;&gt; 0 Then
				&#039; WScript.Echo &quot;setting on line 37&quot; &amp; Err.Description
				Err.Number = 0
			End If
		Else &#039; nobody is logged in and it&#039;s not yet been run
			SetLastUser objReg,&quot;Uninitialized - waiting for login&quot;
		End If
	Else &#039; this has previously been set, overwrite the registry value if someone is logged in
		If objComputer.UserName &lt;&gt; &quot;&quot; Then &#039; if someone is logged in
			SetLastUser objReg, objComputer.UserName
		Else &#039; No one is logged in and it&#039;s been run before
&#039;			WScript.Echo &quot;no user logged in and strLastUser is &quot; &amp; strLastUser
			SetLastUser objReg,&quot;Uninitialized - waiting for login&quot;
		End If
	End If
	
	&#039; whether anyone is logged in or nobody is logged in, echo out
	&#039; value in the registry which is either a login or the uninitialized phrase
	strLastUser = GetLastUser(objReg) &#039; pull again now that it&#039;s been set
	If Err.Number &lt;&gt; 0 Then
		&#039;WScript.Echo &quot;setting again, line 52&quot; &amp; Err.Description
		Err.Number = 0
	End If
	WScript.Echo strLastUser
Next


&#039; Cleanup
Set colComputer = Nothing
Set objWMIService = Nothing
Set objReg = Nothing

Function GetLastUser(objRegistry)
&#039; This function will look into the Tanium Registry Key to get the last logged in user
	
	Const HKLM = &amp;h80000002
	
	Dim strLastUserRegValueData, strTaniumPath, Result
	
	strTaniumPath = GetTaniumRegistryPath()
	
	Result = objReg.GetStringValue(HKLM,strTaniumPath &amp; &quot;\Sensor Data&quot;,&quot;LastLoggedInUser&quot;,strLastUserRegValueData)

	If strLastUserRegValueData = &quot;&quot; Then &#039; data is not initialized
		GetLastUser = False
	Else
		GetLastUser = strLastUserRegValueData
	End If
	
End Function &#039;GetLastUser

Function SetLastUser(objRegistry, strUserName)
&#039; This function will look into the Tanium Registry Key to push the currently
&#039; logged in user to the front of the array and push the previous last to the end
	
	Const HKLM = &amp;h80000002
	
	Dim strTaniumPath, strLastUser
	
	strTaniumPath = GetTaniumRegistryPath()
	
	If Not RegKeyExists(objRegistry, HKLM, strTaniumPath &amp; &quot;\Sensor Data&quot;) Then
		objRegistry.CreateKey HKLM, strTaniumPath &amp; &quot;\Sensor Data&quot;
	End If
	
	objReg.SetStringValue HKLM,strTaniumPath &amp; &quot;\Sensor Data&quot;,&quot;LastLoggedInUser&quot;,strUserName
	
End Function &#039;SetLastUser
	

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
33,Applications,2015-01-05T20:22:02,",","A list of the short names of all services currently in the stopped state.
Example: defragsvc",1,2254780098,0,63,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Stopped Service Short Name,,,,,,,,,Windows,select Name from win32_Service where State=&#039;Stopped&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,89,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
34,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates whether Forefront Realtime Monitoring is enabled.
Example: enabled",1,1453502334,0,65,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Realtime Monitoring Status,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Realtime Monitoring Status
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Real-Time Protection&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Real-Time Protection&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Real-Time Protection&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Real-Time Protection&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWordValue HKLM, strKey, &quot;DisableRealtimeMonitoring&quot;, strValue
	
	If IsNull(strValue) Then
		WScript.Echo &quot;Enabled&quot;
	Else
		If strValue = &quot;1&quot; Then
			WScript.Echo &quot;Disabled&quot;
		Else
			WScript.Echo &quot;Enabled&quot;
		End If
	End If
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
35,Microsoft Forefront,2015-01-05T20:22:02,",",Indicates the last time that a scan was run,1,2875871002,0,67,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Last Scan Run Date,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Last Scan Run
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;LastScanRun&quot;, binValue
	
	If Not IsNull(binValue) Then
		WScript.Echo BinaryToDate(binValue)
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
36,Microsoft Forefront,2015-01-05T20:22:02,",",indicates the last scan type,1,2835039726,0,69,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Last Scan Run Type,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Last Scan Type
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;LastScanType&quot;, dValue
	
	If Not IsNull(dValue) Then
		WScript.Echo GetScanType(dValue)
	Else
		WScript.Echo &quot;Scan Type not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider

&#039;===============================================================
&#039;Function GetScanType will return a string with the scan type that corresponds to the enum
&#039;  Parameter: iScanType - type of scan
&#039;  Return: a VARIANT string containing text type of scan
Function GetScanType(iScanType)
 Select case(iScanType)
   Case 1 : GetScanType= &quot;Quick Scan&quot;
   Case 2 : GetScanType= &quot;Full Scan&quot;
   Case Else GetScanType= &quot;Invalid Scan type&quot;
 End Select
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
37,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates the last time that the client AV signature was updated.
Example: 09/18/2012",1,4191267132,0,71,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client AS Signature Applied Date,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signature Applied Date
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;ASSignatureApplied&quot;, binValue
	
	If Not IsNull(binValue) Then
		
		WScript.Echo BinaryToDate(binValue)
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
38,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates the last time that the client AV signature was updated.
Example: 09/18/2012",1,3506422825,0,73,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client AV Signature Applied Date,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signature Applied Date
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;AVSignatureApplied&quot;, binValue
	
	If Not IsNull(binValue) Then
		
		WScript.Echo BinaryToDate(binValue)
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
39,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates the last time that the client AV signature was updated.
Example: 09/18/2012",1,488010600,0,75,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client NIS Signature Applied Date,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signature Applied Date
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;NISSignatureApplied&quot;, binValue
	
	If Not IsNull(binValue) Then
		
		WScript.Echo BinaryToDate(binValue)
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
40,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates the last time that the client AV signature was updated.
Example: 09/18/2012",1,2299414733,0,77,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Signatures Last Updated Date,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signature Applied Date
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastUpdated&quot;, binValue
	
	If Not IsNull(binValue) Then
		
		WScript.Echo BinaryToDate(binValue)
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
41,Microsoft Forefront,2015-01-05T20:22:02,",","The current version of the AV signature being used by Forefront.
Example: 1.85.1626.0",1,4008943778,0,79,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client AV Signature Version,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client AV Signature Version
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetStringValue HKLM, strKey, &quot;AVSignatureVersion&quot;, strValue
		
	If Not IsNull(strValue) Then
		WScript.Echo strValue
	Else
		WScript.Echo &quot;Signature version not found&quot;
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
42,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates how many days ago a new AS signature was applied.
Example: 8",1,3821169579,0,81,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client AV Signature Applied Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client AS Signature Applied Days Old
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;AVSignatureApplied&quot;, binValue
	
	If Not IsNull(binValue) Then
		words = Split(BinaryToDate(binValue))
		WScript.Echo GetDaysOld(words(0))
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
End If

&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	patternDate = CDate( strDate )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
43,Microsoft Forefront,2015-01-05T20:22:02,",","The current version of the AV signature being used by Forefront.
Example: 1.85.1626.0",1,4187016545,0,83,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client AS Signature Version,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client AV Signature Version
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetStringValue HKLM, strKey, &quot;ASSignatureVersion&quot;, strValue
		
	If Not IsNull(strValue) Then
		WScript.Echo strValue
	Else
		WScript.Echo &quot;Signature version not found&quot;
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
44,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates how many days ago a new AS signature was applied.
Example: 8",1,2636428026,0,85,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client AS Signature Applied Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client AS Signature Applied Days Old
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;ASSignatureApplied&quot;, binValue
	
	If Not IsNull(binValue) Then
		words = Split(BinaryToDate(binValue))
		WScript.Echo GetDaysOld(words(0))
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
End If

&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	patternDate = CDate( strDate )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
45,Microsoft Forefront,2015-01-05T20:22:02,",","The version of the Forefront NIS signature file on the client machine.
Example: 1.12.2131.0",1,1114146405,0,87,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client NIS Signature Version,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client NIS Signature Version
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetStringValue HKLM, strKey, &quot;NISSignatureVersion&quot;, strValue
		
	If Not IsNull(strValue) Then
		WScript.Echo strValue
	Else
		WScript.Echo &quot;Signature version not found&quot;
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
46,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates how many days ago a new AS signature was applied.
Example: 8",1,1247546398,0,89,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client NIS Signature Applied Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client AS Signature Applied Days Old
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;NISSignatureApplied&quot;, binValue
	
	If Not IsNull(binValue) Then
		words = Split(BinaryToDate(binValue))
		WScript.Echo GetDaysOld(words(0))
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
End If

&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	patternDate = CDate( strDate )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
47,Microsoft Forefront,2015-01-05T20:22:02,",",The version of  the Forefront client on the client machine,1,508630093,0,91,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Version,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Version
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware&quot;
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetStringValue HKLM, strKey, &quot;InstallLocation&quot;, strValue
		
	If Not IsNull(strValue) Then
		fileToCheck = strValue &amp; &quot;\msmpeng.exe&quot;
		Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
		WScript.Echo objFso.GetFileVersion(fileToCheck)
	Else
		WScript.Echo &quot;Client version not found&quot;
	End If
Else
	&#039; check for windows defender
	CheckWindowsDefender
End If

Sub CheckWindowsDefender
	strPath = &quot;c:\program files\windows defender\MsMpEng.exe&quot;
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	If objfso.FileExists(strPath) Then
		WScript.Echo objFSO.GetFileVersion(strPath)
	Else
		WScript.Echo &quot;Client version not found&quot;
	End If
End Sub

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
48,Microsoft Forefront,2015-01-05T20:22:02,",","The version of the engine being used by Forefront on the client machine.
Example: 1.1.5902.0",1,391298201,0,93,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Engine Version,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Engine Version
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetStringValue HKLM, strKey, &quot;EngineVersion&quot;, strValue
		
	If Not IsNull(strValue) Then
		WScript.Echo strValue
	Else
		WScript.Echo &quot;Engine version not found&quot;
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
49,Microsoft Forefront,2015-01-05T20:22:02,",","The version fo the Forefront NIS engine running on the client machine.
Example: 1.3.1106.0",1,2813418207,0,95,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client NIS Engine Version,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client NIS Engine Version
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetStringValue HKLM, strKey, &quot;NISEngineVersion&quot;, strValue
		
	If Not IsNull(strValue) Then
		WScript.Echo strValue
	Else
		WScript.Echo &quot;Engine version not found&quot;
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
50,Microsoft Forefront,2015-01-05T20:22:02,",","The version of the client spyware signatures used by Forefront.
Example: 1.20.3423.0",1,3973828276,0,97,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Spyware Signature Version,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Spyware Signature Version
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Signature Updates&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Signature Updates&quot;
	End If
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetStringValue HKLM, strKey, &quot;ASSignatureVersion&quot;, strValue
		
	If Not IsNull(strValue) Then
		WScript.Echo strValue
	Else
		WScript.Echo &quot;Signature version not found&quot;
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
51,Microsoft Forefront,2015-01-05T20:22:02,",",Indicates if a Scheduled Scan is enabled or not,0,2877564299,0,99,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Scheduled Scan Enabled,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Scheduled Scan Enabled
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
	dIsDefender = 1
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;ScheduleDay&quot;, dValue
	
	If Not IsNull(dValue) Then
		If dValue = 8 Then
			WScript.Echo &quot;No&quot;
		Else
			WScript.Echo &quot;Yes&quot;
		End If
	Else
		if dIsDefender =1 then
			WScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;
		else
			WScript.Echo &quot;Scan Type not found&quot;	
		end if
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
52,Microsoft Forefront,2015-01-05T20:22:02,",",Indicates the Scheduled Scan Type,0,1872660430,0,101,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Scheduled Scan Type,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Scheduled Scan Type
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
	dIsDefender = 1
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;ScanParameters&quot;, dValue
	
	If Not IsNull(dValue) Then
		If dValue = 1 Then
			WScript.Echo &quot;Quick Scan&quot;
		Else
			WScript.Echo &quot;Full Scan&quot;
		End If
	Else
		If dIsDefender = 1 Then
			WScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;
		Else
			WScript.Echo &quot;Quick Scan&quot;
		End If
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
53,Microsoft Forefront,2015-01-05T20:22:02,",","indicates the the scheduled scan day
Example: Sunday",1,3957460633,0,103,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Scheduled Scan Day,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Scheduled Scan Day
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
	dIsDefender = 1
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;ScheduleDay&quot;, dValue
	
	If Not IsNull(dValue) Then
		Select Case dValue
			Case 0
				WScript.Echo &quot;Daily&quot;
						
			Case 1
				WScript.Echo &quot;Sunday&quot;
			
			Case 2
				WScript.Echo &quot;Monday&quot;
				
			Case 3
				WScript.Echo &quot;Tuesday&quot;
				
			Case 4
				WScript.Echo &quot;Wednesday&quot;
				
			Case 5
				WScript.Echo &quot;Thursday&quot;
				
			Case 6
				WScript.Echo &quot;Friday&quot;
				
			Case 7
				WScript.Echo &quot;Saturday&quot;
		End Select
	Else
		if dIsDefender = 1 then
			WScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;
		else
			WScript.Echo &quot;Not found&quot;
		end if
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
54,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates the scheduled scan time
Example: 2:00 AM",0,2174883544,0,105,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Scheduled Scan Time,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Scheduled Scan Time
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
	dIsDefender = 1
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;ScheduleTime&quot;, dValue
	
	If Not IsNull(dValue) Then
		If dvalue = 0 Then
			WScript.Echo &quot;12:00 AM&quot;
		Else
			&#039; need to divide by 60 to get
			&#039; the hour
			dHour = dvalue / 60
			dTT = &quot;AM&quot;
			
			If dhour &gt; 12 Then
				dhour = dhour - 12
				dTT = &quot;PM&quot;
			End If
			
			WScript.Echo dhour &amp; &quot;:00 &quot; &amp; dTT
		End If
		&#039; divide by 60 to get the hour
	Else
		if dIsDefender = 1 then
			wscript.echo &quot;No Scheduled Scan: Windows Defender&quot;
		else 
			WScript.Echo &quot;2:00 AM&quot;
		end if
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
55,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates checking for definitions before running scheduled scan
Example: Yes",1,270604477,0,107,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Scheduled Scan Check Definitions,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Scheduled Scan Check definitions
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
	dIsDefender = 1
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;CheckForSignaturesBeforeRunningScan&quot;, dValue
	
	If Not IsNull(dValue) Then
		If dValue = 1 Then
			WScript.Echo &quot;Yes&quot;
		Else
			WScript.Echo &quot;No&quot;
		End if
	Else
		if dIsDefender = 1 then
			WScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;
		else
			WScript.Echo &quot;Not found&quot;
		end if
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
56,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates scheduled scan only when idle
Example: Yes",1,1096615317,0,109,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Scheduled Scan Only When Idle,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Scheduled Scan Only When Idle
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
	dIsDefender = 1
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;ScanOnlyIfIdle&quot;, dValue
	
	If Not IsNull(dValue) Then
		If dValue = 1 Then
			WScript.Echo &quot;Yes&quot;
		Else
			WScript.Echo &quot;No&quot;
		End if
	Else
		if dIsDefender = 1 then
			WScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;
		else
			WScript.Echo &quot;Yes&quot;
		end if
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
57,Microsoft Forefront,2015-01-05T20:22:02,",","Indicates Limit CPU usage for scan
Example: 50%",1,2645000905,0,111,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Forefront Client Scheduled Scan Limit CPU Usage,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Scheduled Scan Limit CPU Usage
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Scan&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Scan&quot;
End If

&#039; check for windows defender (win 8 and &gt;)
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Microsoft\Windows Defender\Scan&quot;
	If Not RegKeyExists(reg, HKLM, strKey) Then
		strKey = &quot;Software\Wow6432Node\Microsoft\Windows Defender\Scan&quot;
	End If
	dIsDefender = 1
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetDWORDValue HKLM, strKey, &quot;AvgCPULoadFactor&quot;, dValue
	
	If Not IsNull(dValue) Then
		WScript.Echo dvalue &amp; &quot;%&quot;
	Else
		if dIsDefender = 1 then
			WScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;
		else
			WScript.Echo &quot;50%&quot;
		end if
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
58,Sophos,2015-01-05T20:22:02,|,"Shows the details of two sophos services:  sophos anti-virus and the sophos autoupdate service.
Example: Service | StartMode | State | Healthy",1,2103988074,0,113,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Client Health,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Client Health
&#039;========================================

&#039; This sensor will return the status of the sophos services
&#039; and make a health determination
&#039; output looks like 

Option Explicit

Dim strSep 

strSep = &quot;|&quot;

GetSophosClientStatus(strSep)

Function GetSophosClientStatus(strSep)
&#039; This function will echo back the details of two sophos services:
&#039; sophos anti-virus and the sophos autoupdate service.
&#039; The output will look like:
&#039; Service|StartMode|State|Healthy

	Dim objWMIService, colItems
	Dim strComputer, strServiceDisplayName, strMainServiceStartMode, strMainServiceState
	Dim strUpdateServiceStartMode, strUpdateServiceState, strHealthy
	Dim objItem
	
	
	strComputer = &quot;.&quot;
	
	Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
	
	&#039; First the main service
	strMainServiceStartMode = &quot;&quot;
	strMainServiceState = &quot;&quot;
	strServiceDisplayName = &quot;sophos anti-virus&quot;

	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Service where DisplayName&quot; _
		&amp; &quot; = &#039;&quot;&amp;strServiceDisplayName&amp;&quot;&#039;&quot;)
	If (colItems.Count &gt; 0 )Then
		For Each objItem in colItems
			strMainServiceStartMode = objItem.StartMode
			strMainServiceState = objItem.State
		Next
	Else
		strMainServiceStartMode = &quot;Not Installed&quot;
		strMainServiceState = &quot;Not Installed&quot;
	End If
	
	If LCase(strMainServiceStartMode) = &quot;auto&quot; And LCase(strMainServiceState) = &quot;running&quot; Then
		strHealthy = &quot;Yes&quot;
	Else
		strHealthy = &quot;No&quot;
	End If
	&#039; part one of sensor output
	WScript.Echo strServiceDisplayName &amp; strSep &amp; strMainServiceStartMode _
		&amp; strSep &amp; strMainServiceState &amp; strSep &amp; strHealthy
		
	&#039; Next the sophos auto update service
	
	strUpdateServiceStartMode = &quot;&quot;
	strUpdateServiceState = &quot;&quot;
	strServiceDisplayName = &quot;sophos autoupdate service&quot;
	
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Service where DisplayName&quot; _
		&amp; &quot; = &#039;&quot;&amp;strServiceDisplayName&amp;&quot;&#039;&quot;)
	If ( colItems.Count &gt; 0 ) Then
		For Each objItem in colItems
			strUpdateServiceStartMode = objItem.StartMode
			strUpdateServiceState = objItem.State
		Next
	Else
		strUpdateServiceStartMode = &quot;Not Installed&quot;
		strUpdateServiceState = &quot;Not Installed&quot;
	End If

	If LCase(strUpdateServiceStartMode) = &quot;auto&quot; And LCase(strUpdateServiceState) = &quot;running&quot; Then
		strHealthy = &quot;Yes&quot;
	Else
		strHealthy = &quot;No&quot;
	End If
	WScript.Echo strServiceDisplayName &amp; strSep &amp; strUpdateServiceStartMode _
		&amp; strSep &amp; strUpdateServiceState &amp; strSep &amp; strHealthy
			
	&#039;Cleanup
	Set colItems = Nothing
	Set objWMIService = Nothing

End Function &#039;GetSophosClientStatus",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Service,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Start Mode,String,0,1,2,Status,String,0,1,3,Healthy,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
59,Sophos,2015-01-05T20:22:02,",","Returns the version of Sophos anti-virus installed on the client machine.
Example:  4.80.0",1,1244581312,0,115,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:02,Sophos Client Version,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Client Version
&#039;========================================


strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

Const HKLM = &amp;H80000002 

keyPath = &quot;Software\Sophos&quot;
key64Path = &quot;Software\WOW6432Node\Sophos&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

If RegKeyExists(HKLM, keyPath &amp; &quot;\SAVService\Application&quot;) Then
	WScript.Echo GetVersion(keyPath &amp; &quot;\SAVService\Application&quot;)

Else
	WScript.Echo &quot;Version not found&quot;
End If


Function GetVersion(fullKeyPath)
	objRegistry.GetStringValue HKLM,fullKeyPath ,&quot;Path&quot;, strDir
	If Not IsNull(strDir) Then
		strExe = &quot;SavMain.exe&quot;
		Set theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

		If theFso.FileExists(strDir &amp; strExe) Then
			WScript.Echo GetFileVersion(strDir &amp; strExe)
			WScript.Quit
		End If
		
		GetVersion = strVersion
		Exit Function
	End If	

	GetVersion = &quot;Version not found&quot;
End Function

function GetFileVersion(theFile)
	dim theFso, theVer
	set theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	theVer = theFso.getFileVersion(theFile)
	
	if theVer = &quot;&quot; then
		theVer = &quot;-1&quot;
	end If
	
	getFileVersion = theVer   
end Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
60,Sophos,2015-01-05T20:22:02,",","The engine version of Sophos AV installed on the client machine.
Example: 4.80.0",1,3528246009,0,117,1,Jim Olsen,1800,0,defined,Tanium,2015-01-05T20:22:02,Sophos Engine Version,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Engine Version
&#039;========================================

&#039; This sensor will return the value of the sophos AV detection engine

Set objRegistry = Getx64RegistryProvider()

Const HKLM = &amp;H80000002 

keyPath = &quot;Software\Sophos&quot;
key64Path = &quot;Software\WOW6432Node\Sophos&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

If RegKeyExists(HKLM, keyPath &amp; &quot;\SAVService\Application&quot;) Then
	WScript.Echo GetVersion(keyPath &amp; &quot;\SAVService\Application&quot;)
Else
	WScript.Echo &quot;Sophos Registry Not Found&quot;
	WScript.Quit
End If


Function GetVersion(fullKeyPath)
	objRegistry.GetStringValue HKLM,fullKeyPath ,&quot;Path&quot;, strDir
	If Not IsNull(strDir) Then
		strFile = &quot;veex.dll&quot;
		Set theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

		If theFso.FileExists(strDir &amp; strFile) Then
			WScript.Echo GetFileVersion(strDir &amp; strFile)
		Else
			WScript.Echo &quot;Engine File Not Found&quot;
		End If
	Else	
	GetVersion = &quot;Sophos Path Registry Value Not Found&quot;
	End If
End Function

Function GetFileVersion(theFile)
	dim theFso, theVer
	set theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	theVer = theFso.getFileVersion(theFile)
	
	if theVer = &quot;&quot; then
		theVer = &quot;-1&quot;
	end If
	
	getFileVersion = theVer   
end Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
61,Sophos,2015-01-05T20:22:02,",","The last time that Sophos AV was updated on the client machine.
Example: 2006-11-07T18:00:000Z",1,2221806865,0,119,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Last Update Time,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Last Update Time
&#039;========================================

&#039; This sensor will read a registry key and determine the last time
&#039; the software updated itself.

Option Explicit

&#039; return the time
WScript.Echo GetSophosLastUpdateTime


Function GetSophosLastUpdateTime
&#039; This function returns a time, in UTC, which is the last
&#039; successful update of Sophos

	
	Const HKLM = &amp;H80000002 
	
	Dim objRegistry
	Dim keyPath, key64Path, tZ, strFullKeyPath
	Dim dwordLastUpdateTime

	Set objRegistry = Getx64RegistryProvider()

	keyPath = &quot;Software\Sophos&quot;
	key64Path = &quot;Software\WOW6432Node\Sophos&quot;
	
	If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
		keyPath = key64Path
	
		If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
			WScript.Echo &quot;Not installed&quot;
			WScript.Quit
		End If
	End If
	
	tZ = GetClientTimeZoneBias &#039;time relative to GMT
	strFullKeyPath = keyPath &amp; &quot;\AutoUpdate\UpdateStatus&quot;

	If RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then
		objRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;LastUpdateTime&quot;, dwordLastUpdateTime
		GetSophosLastUpdateTime = DateAdd(&quot;h&quot;,tZ,(DateAdd(&quot;s&quot;,dwordLastUpdateTime,&quot;01/01/1970 00:00:00&quot;)))
	Else
		WScript.Echo &quot;Last Update Time Not Found&quot;
	End If
End Function &#039; GetSophosLastUpdateTime

Function GetClientTimeZoneBias
&#039; This will return the hour offset from GMT to be used in date math
	Dim objWMIService, colItems
	Dim strComputer, objItem
	
	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
	
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_TimeZone&quot;)
	
	For Each objItem in colItems
		&#039;Looks like -480
	    GetClientTimeZoneBias = objItem.Bias / 60
	Next
	
	&#039; Cleanup
	Set colItems = Nothing
	Set objWMIService = Nothing
End Function &#039;GetClientTimeZoneOffset

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
62,Sophos,2015-01-05T20:22:02,",","The last time Sophos AV scanned the client machine.
Example: 2006-11-07T18:00:000Z",1,2918720813,0,121,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Last Scan Time,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Last Scan Time
&#039;========================================

&#039; This sensor will read a registry key and determine the last time
&#039; the software updated itself.

Option Explicit

&#039; return the time
WScript.Echo GetSophosLastScanTime


Function GetSophosLastScanTime
&#039; This function returns a time, in UTC, which is the last
&#039; successful update of Sophos

	
	Const HKLM = &amp;H80000002 
	
	Dim objRegistry
	Dim keyPath, key64Path, tZ, strFullKeyPath
	Dim dwordLastScanTime

	Set objRegistry = Getx64RegistryProvider()

	keyPath = &quot;Software\Sophos&quot;
	key64Path = &quot;Software\WOW6432Node\Sophos&quot;
	
	If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
		keyPath = key64Path
	
		If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
			WScript.Echo &quot;Not installed&quot;
			WScript.Quit
		End If
	End If
	
	tZ = GetClientTimeZoneBias &#039;time relative to GMT
	strFullKeyPath = keyPath &amp; &quot;\SAVService\Status\LastScan&quot;

	If RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then
		objRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;EnterpriseScan&quot;, dwordLastScanTime
		GetSophosLastScanTime = DateAdd(&quot;h&quot;,tZ,(DateAdd(&quot;s&quot;,dwordLastScanTime,&quot;01/01/1970 00:00:00&quot;)))
	Else
		WScript.Echo &quot;Last Scan Time Not Found&quot;
	End If
End Function &#039; GetSophosLastScanTime

Function GetClientTimeZoneBias
&#039; This will return the hour offset from GMT to be used in date math
	Dim objWMIService, colItems
	Dim strComputer, objItem
	
	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
	
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_TimeZone&quot;)
	
	For Each objItem in colItems
		&#039;Looks like -480
	    GetClientTimeZoneBias = objItem.Bias / 60
	Next
	
	&#039; Cleanup
	Set colItems = Nothing
	Set objWMIService = Nothing
End Function &#039;GetClientTimeZoneOffset

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
63,Sophos,2015-01-05T20:22:02,",","Returns True or False whether Sophos AV Controlled App detection is installed.
Example: True",1,60117748,0,123,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Controlled App Detected,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Controlled App Detected
&#039;========================================

&#039; This sensor will read a registry key and determine if the machine
&#039; has a Controlled App detection according to Sophos AV

Option Explicit

&#039; return the time
WScript.Echo GetSophosControlledAppDetected


Function GetSophosControlledAppDetected
&#039; This function returns a time, in UTC, which is the last
&#039; successful update of Sophos

	
	Const HKLM = &amp;H80000002 
	
	Dim objRegistry
	Dim keyPath, key64Path, strFullKeyPath
	Dim dwordControlledAppDetected

	Set objRegistry = Getx64RegistryProvider()
	
	keyPath = &quot;Software\Sophos&quot;
	key64Path = &quot;Software\WOW6432Node\Sophos&quot;
	
	If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
		keyPath = key64Path
	
		If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
			WScript.Echo &quot;Not installed&quot;
			WScript.Quit
		End If
	End If
	
	strFullKeyPath = keyPath &amp; &quot;\SAVService\Status\Infected&quot;

	If RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then
		objRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;ControlledAppDetected&quot;, dwordControlledAppDetected
		If Not IsNull(dwordControlledAppDetected) And dwordControlledAppDetected = 0 Then
			GetSophosControlledAppDetected = &quot;False&quot;
		ElseIf Not IsNull(dwordControlledAppDetected) And dwordControlledAppDetected &gt; 0 Then
			GetSophosControlledAppDetected = &quot;True&quot;
		Else
			GetSophosControlledAppDetected = &quot;ControlledAppDetected Registry Value Not Found&quot; &#039;This should never happen
		End If
	Else
		WScript.Echo &quot;SAVService\Status\Infected Registry Value Not Found&quot;
	End If
End Function &#039; GetSophosControlledAppDetected

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
64,Sophos,2015-01-05T20:22:02,",","Returns True or False based on whether Sophos AV has detected infection or malware.
Example: True",1,3661718872,0,125,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Malware Detected,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Malware Detected
&#039;========================================

&#039; This sensor will read a registry key and determine if the machine
&#039; has a malware detection / infection according to Sophos AV

Option Explicit

&#039; return the time
WScript.Echo GetSophosInfected


Function GetSophosInfected
&#039; This function returns a time, in UTC, which is the last
&#039; successful update of Sophos

	
	Const HKLM = &amp;H80000002 
	
	Dim objRegistry
	Dim keyPath, key64Path, strFullKeyPath
	Dim dwordMalwareDetected

	Set objRegistry = Getx64RegistryProvider()

	keyPath = &quot;Software\Sophos&quot;
	key64Path = &quot;Software\WOW6432Node\Sophos&quot;
	
	If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
		keyPath = key64Path
	
		If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
			WScript.Echo &quot;Not installed&quot;
			WScript.Quit
		End If
	End If
	
	strFullKeyPath = keyPath &amp; &quot;\SAVService\Status\Infected&quot;

	If RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then
		objRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;MalwareDetected&quot;, dwordMalwareDetected
		If Not IsNull(dwordMalwareDetected) And dwordMalwareDetected = 0 Then
			GetSophosInfected = &quot;False&quot;
		ElseIf Not IsNull(dwordMalwareDetected) And dwordMalwareDetected &gt; 0 Then
			GetSophosInfected = &quot;True&quot;
		Else
			GetSophosInfected = &quot;MalwareDetected Registry Value Not Found&quot; &#039;This should never happen
		End If
	Else
		WScript.Echo &quot;SAVService\Status\Infected Registry Value Not Found&quot;
	End If
End Function &#039; GetSophosInfected

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
65,Sophos,2015-01-05T20:22:02,",","Returns True or False if Sophos AV has detected a potentially unwanted program.
Example: True",1,2583495206,0,127,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Potentially Unwanted Program Detected,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Potentially Unwanted Program Detected
&#039;========================================

&#039; This sensor will read a registry key and determine if the machine
&#039; has a PUA detection according to Sophos AV

Option Explicit

&#039; return the time
WScript.Echo GetSophosPUADetected


Function GetSophosPUADetected
&#039; This function returns a time, in UTC, which is the last
&#039; successful update of Sophos

	
	Const HKLM = &amp;H80000002 
	
	Dim objRegistry
	Dim keyPath, key64Path, strFullKeyPath
	Dim dwordPUADetected

	Set objRegistry = Getx64RegistryProvider()

	keyPath = &quot;Software\Sophos&quot;
	key64Path = &quot;Software\WOW6432Node\Sophos&quot;
	
	If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
		keyPath = key64Path
	
		If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
			WScript.Echo &quot;Not installed&quot;
			WScript.Quit
		End If
	End If
	
	strFullKeyPath = keyPath &amp; &quot;\SAVService\Status\Infected&quot;

	If RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then
		objRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;PUADetected&quot;, dwordPUADetected
		If Not IsNull(dwordPUADetected) And dwordPUADetected = 0 Then
			GetSophosPUADetected = &quot;False&quot;
		ElseIf Not IsNull(dwordPUADetected) And dwordPUADetected &gt; 0 Then
			GetSophosPUADetected = &quot;True&quot;
		Else
			GetSophosPUADetected = &quot;PUADetected Registry Value Not Found&quot; &#039;This should never happen
		End If
	Else
		WScript.Echo &quot;SAVService\Status\Infected Registry Value Not Found&quot;
	End If
End Function &#039; GetSophosPUADetected

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
66,Sophos,2015-01-05T20:22:02,",","Returns True or False if Sophos AV has detected suspicious behavior.
Example: True",1,762809308,0,129,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Suspicious Behavior Detected,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Suspicious Behavior Detected
&#039;========================================

&#039; This sensor will read a registry key and determine if the machine
&#039; has a Suspicious Behavior detection according to Sophos AV

Option Explicit

&#039; return the time
WScript.Echo GetSophosSuspiciousBehaviorDetected


Function GetSophosSuspiciousBehaviorDetected
&#039; This function returns a time, in UTC, which is the last
&#039; successful update of Sophos

	
	Const HKLM = &amp;H80000002 
	
	Dim objRegistry
	Dim keyPath, key64Path, strFullKeyPath
	Dim dwordSuspiciousBehaviorDetected

	Set objRegistry = Getx64RegistryProvider()

	keyPath = &quot;Software\Sophos&quot;
	key64Path = &quot;Software\WOW6432Node\Sophos&quot;
	
	If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
		keyPath = key64Path
	
		If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
			WScript.Echo &quot;Not installed&quot;
			WScript.Quit
		End If
	End If
	
	strFullKeyPath = keyPath &amp; &quot;\SAVService\Status\Infected&quot;

	If RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then
		objRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;SuspiciousBehaviorDetected&quot;, dwordSuspiciousBehaviorDetected
		If Not IsNull(dwordSuspiciousBehaviorDetected) And dwordSuspiciousBehaviorDetected = 0 Then
			GetSophosSuspiciousBehaviorDetected = &quot;False&quot;
		ElseIf Not IsNull(dwordSuspiciousBehaviorDetected) And dwordSuspiciousBehaviorDetected &gt; 0 Then
			GetSophosSuspiciousBehaviorDetected = &quot;True&quot;
		Else
			GetSophosSuspiciousBehaviorDetected = &quot;SuspiciousBehaviorDetected Registry Value Not Found&quot; &#039;This should never happen
		End If
	Else
		WScript.Echo &quot;SAVService\Status\Infected Registry Value Not Found&quot;
	End If
End Function &#039; GetSophosSuspiciousBehaviorDetected

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
67,Sophos,2015-01-05T20:22:02,",","Returns True or False if Sophos AV has detected suspicious files.
Example: True",1,3753226920,0,131,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Sophos Suspicious File Detected,,,,,,,,,Windows,"&#039;========================================
&#039; Sophos Suspicious File Detected
&#039;========================================

&#039; This sensor will read a registry key and determine if the machine
&#039; has a Suspicious File detection according to Sophos AV

Option Explicit

&#039; return the time
WScript.Echo GetSophosSuspiciousFileDetected


Function GetSophosSuspiciousFileDetected
&#039; This function returns a time, in UTC, which is the last
&#039; successful update of Sophos

	
	Const HKLM = &amp;H80000002 
	
	Dim objRegistry
	Dim keyPath, key64Path, strFullKeyPath
	Dim dwordSuspiciousFileDetected

	Set objRegistry = Getx64RegistryProvider()

	keyPath = &quot;Software\Sophos&quot;
	key64Path = &quot;Software\WOW6432Node\Sophos&quot;
	
	If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
		keyPath = key64Path
	
		If Not RegKeyExists(objRegistry, HKLM, keyPath) Then
			WScript.Echo &quot;Not installed&quot;
			WScript.Quit
		End If
	End If
	
	strFullKeyPath = keyPath &amp; &quot;\SAVService\Status\Infected&quot;

	If RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then
		objRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;SuspiciousFileDetected&quot;, dwordSuspiciousFileDetected
		If Not IsNull(dwordSuspiciousFileDetected) And dwordSuspiciousFileDetected = 0 Then
			GetSophosSuspiciousFileDetected = &quot;False&quot;
		ElseIf Not IsNull(dwordSuspiciousFileDetected) And dwordSuspiciousFileDetected &gt; 0 Then
			GetSophosSuspiciousFileDetected = &quot;True&quot;
		Else
			GetSophosSuspiciousFileDetected = &quot;SuspiciousFileDetected Registry Value Not Found&quot; &#039;This should never happen
		End If
	Else
		WScript.Echo &quot;SAVService\Status\Infected Registry Value Not Found&quot;
	End If
End Function &#039; GetSophosSuspiciousFileDetected

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
68,Symantec,2015-01-05T20:22:02,",","Version of Symantec AV installed on client machine.
Example: 11.0.6200.513",1,932508344,0,133,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Symantec Client Version,,,,,,,,,Windows,"&#039;========================================
&#039; Symantec Client Version
&#039;========================================

Option Explicit

Const HKLM = &amp;H80000002 
Const strExe = &quot;rtvscan.exe&quot;
&#039;SEP 12+ no longer include rtvscan, but instead RtvStart&#039;
Const strExe12 = &quot;RtvStart.exe&quot;

Dim objRegistry, objFso, strResult, keyPath, strDir

Set objRegistry = Getx32RegistryProvider()

strResult = &quot;&quot;

keyPath = &quot;SOFTWARE\Symantec\InstalledApps&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	strResult = &quot;Not Installed&quot;
End If


Set objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

&#039;check SAV Install Directory&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;SAV Install Directory&quot;, strDir
	If objFso.FileExists(strDir &amp; strExe) Then
		strResult = GetFileVersion(strDir &amp; strExe)
	End If
End If

&#039;check SAV Install Directory for 12&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;SAV Install Directory&quot;, strDir
	If objFso.FileExists(strDir &amp; strExe) Then
		strResult = GetFileVersion(strDir &amp; strExe12)
	End If
End If

&#039;check SAVCE&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;SAVCE&quot;, strDir
	If objFso.FileExists(strDir &amp; strExe) Then
		strResult GetFileVersion(strDir &amp; strExe)
	End If
End If

&#039;check SAVCE for SEP 12&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;SAVCE&quot;, strDir
	If objFso.FileExists(strDir &amp; strExe12) Then
		strResult = GetFileVersion(strDir &amp; strExe12)
	End If
End If

&#039;check NAVNT&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT&quot;, strDir
	If objFso.FileExists(strDir &amp; strExe) Then
		strResult = GetFileVersion(strDir &amp; strExe)
	End If
End If 

&#039;check NAV&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAV&quot;, strDir
	If objFso.FileExists(strDir &amp; strExe) Then
		strResult = GetFileVersion(strDir &amp; strExe)
	End If
End If 

If strResult = &quot;&quot; Then 
	WScript.Echo &quot;Not Installed&quot;
Else 
	WScript.Echo strResult
End If

function GetFileVersion(theFile)
	dim objFso, theVer
	set objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	theVer = objFso.getFileVersion(theFile)
	
	if theVer = &quot;&quot; then
		theVer = &quot;-1&quot;
	end If
	
	getFileVersion = theVer   
end Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx32RegistryProvider
    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems
    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript
    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv
    
    iArchType = 32
   
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx32RegistryProvider = objRegProv
End Function &#039; Getx32RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
69,Symantec,2015-01-05T20:22:02,",","Age in days of the last scan report by Symantec AV on the client machine if it exists.
Example: 9",1,1065011811,0,135,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Symantec Last Report Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Symantec Last Report Days Old
&#039;========================================

Option Explicit

&#039; Force correct date handling
SetLocale(1033)

Const HKLM = &amp;H80000002 
Const keyPath = &quot;SOFTWARE\Symantec\InstalledApps&quot;
&#039;SEP 12 uses a different path to the serstate.dat file&#039;
Const keyPath12 = &quot;SOFTWARE\Symantec\Symantec Endpoint Protection\CurrentVersion\Common Client\PathExpansionMap&quot;
Const strFile = &quot;serstate.dat&quot;
Const strFile12 = &quot;\Data\State\SerState.dat&quot;

Dim objRegistry, strResult, strDir, objFSO

Set objRegistry = Getx32RegistryProvider()

If Not RegKeyExists(HKLM, keyPath) Then
	strResult = &quot;Not Installed&quot;
End If


set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)


If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path
End If 

If Not RegKeyExists(HKLM, keyPath) Then
	strResult = &quot;Not Installed&quot;
End If

&#039; check SEP 12
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath12 ,&quot;APPDATABASE&quot;, strDir
	If objFSO.FileExists(strDir &amp; strFile12) Then
		strResult = GetReportDaysOld(strDir &amp; strFile12)
	End If
End If

&#039;check SAV Install Directory&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;SAV Install Directory&quot;, strDir
	If objFSO.FileExists(strDir &amp; strFile) Then
		strResult = GetReportDaysOld(strDir &amp; strFile)
	End If
End If

&#039;check SAVCE&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;SAVCE&quot;, strDir
	If objFSO.FileExists(strDir &amp; strFile) Then
		strResult = GetReportDaysOld(strDir &amp; strFile)
	End If
End If 

&#039;check NAVNT&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT&quot;, strDir
	If objFSO.FileExists(strDir &amp; strFile) Then
		strResult = GetReportDaysOld(strDir &amp; strFile)
	End If
End If

&#039;check NAV&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAV&quot;, strDir
	If objFSO.FileExists(strDir &amp; strFile) Then
		strResult = GetReportDaysOld(strDir &amp; strFile)
	End If
End If

If strResult = &quot;&quot; Then 
	WScript.Echo &quot;Not Installed&quot;
Else 
	WScript.Echo strResult
End if

function GetReportDaysOld(theFile)
	dim objFSO, theVer, reportDate, today
	set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	reportDate = FormatDateTime(objFSO.GetFile(theFile).DateLastModified,2)
	&#039;WScript.Echo (&quot;reportdate: &quot; &amp; reportDate)
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetReportDaysOld = DateDiff(&quot;d&quot;, reportDate, today)
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx32RegistryProvider
    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems
    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript
    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv
    
    iArchType = 32
   
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx32RegistryProvider = objRegProv
End Function &#039; Getx32RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
70,Symantec,2015-01-05T20:22:02,",","Age of Symantec AV virus definitions in days if installed on client machine.
Example: 12",1,558954146,0,137,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Symantec DAT Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Symantec DAT Days Old
&#039;========================================

Option Explicit

&#039; Force correct date handling
SetLocale(1033)

Const HKLM = &amp;H80000002 

Dim objRegistry, keyPath, keyPath12, strResult, strValue

Set objRegistry = Getx32RegistryProvider()

keyPath = &quot;Software\Symantec\SharedDefs&quot;
&#039;check for SEP 12, which uses a different location for definitions&#039;
keyPath12 = &quot;Software\Symantec\Symantec Endpoint Protection\CurrentVersion\SharedDefs&quot;

strResult = &quot;&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	strResult = &quot;Not Installed&quot;
End If

&#039;check NAVCORP_70 value at SEP 12 location&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath12 ,&quot;NAVCORP_70&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatDaysOld(strValue)
	End If
End If

&#039;check NAVCORP_70 value&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVCORP_70&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatDaysOld(strValue)
	End If
End If

&#039;check NAVNO_50_AP1 value&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNO_50_AP1&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatDaysOld(strValue)
	End If
End If

&#039;check NAVNT_50_AP1 value&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT_50_AP1&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatDaysOld(strValue)
	End If
End If 

If strResult = &quot;&quot; Then 
	WScript.Echo &quot;Dat value not found&quot;
Else 
	WScript.Echo strResult
End If

Function GetDatDaysOld(strValue)
	Dim words, datFile, strDat, datDate, today
	words = Split(strValue, &quot;\&quot;)
	datFile = words(UBound(words))
	words = Split(datFile, &quot;.&quot;)
	strDat = words(0)
	datDate = CDate( Mid(strDat, 5, 2) &amp; &quot;/&quot; &amp; Right(strDat, 2) &amp; &quot;/&quot; &amp; Left(strDat, 4) )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDatDaysOld = DateDiff(&quot;d&quot;, datDate, today)
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx32RegistryProvider
    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems
    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript
    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv
    
    iArchType = 32
   
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx32RegistryProvider = objRegProv
End Function &#039; Getx32RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
71,Trend Micro,2015-01-05T20:22:02,",","The version number of Trend Micro AV if installed on the client machine.
Example: 17.50.1366.0000",1,3327439715,0,139,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Trend Micro Client Version,,,,,,,,,Windows,"&#039;========================================
&#039; Trend Micro Client Version
&#039;========================================

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

Const HKLM = &amp;H80000002 

keyPath = &quot;Software\TrendMicro&quot;
key64Path = &quot;Software\WOW6432Node\TrendMicro&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

If RegKeyExists(HKLM, keyPath &amp; &quot;\CPM&quot;) Then
	objRegistry.GetStringValue HKLM, keyPath &amp; &quot;\CPM&quot; ,&quot;Version&quot;, strVersion

	If IsNull(strVersion) Then
		WScript.Echo &quot;Version not found&quot;
	Else
		objRegistry.GetStringValue HKLM, keyPath &amp; &quot;\CPM&quot; ,&quot;ServicePackVersion&quot;, strSPVersion
		If IsNull(strSPVersion) Or Not(CInt(strSPVersion) &gt; 0) Then
			WScript.Echo strVersion
		Else 
			WScript.Echo strVersion &amp; &quot; Service Pack &quot; &amp; strSPVersion
		End If
	End If
ElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\PC-cillinNTCorp\CurrentVersion&quot;) Then	
	objRegistry.GetStringValue HKLM, keyPath &amp; &quot;\PC-cillinNTCorp\CurrentVersion&quot; ,&quot;Application Path&quot;, strAppPath
	&#039;WScript.Echo &quot;file path: &quot; &amp; strAppPath
	
	Dim fso
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	If fso.FileExists(strAppPath &amp; &quot;PccNT.exe&quot;) Then
		WScript.Echo fso.GetFileVersion(strAppPath &amp; &quot;PccNT.exe&quot;)
	Else 
		WScript.Echo &quot;Trend Console not found&quot;
	End If 
Else
	WScript.Echo &quot;Not installed&quot;
	WScript.Quit
End If

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
72,Trend Micro,2015-01-05T20:22:02,",","Age of Trend Micro AV virus definitions in days if installed on the client machine.
Example: 4",1,1666713228,0,141,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Trend Micro Pattern Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Trend Micro Pattern Days Old
&#039;========================================

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

Const HKLM = &amp;H80000002 

&#039;Uses date math - set locale

SetLocale(1033)

keyPath = &quot;Software\TrendMicro&quot;
key64Path = &quot;Software\WOW6432Node\TrendMicro&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path
End If 

If Not RegKeyExists(HKLM, keyPath) Then
	WScript.Echo &quot;Not Installed&quot;
	WScript.Quit
End If

If RegKeyExists(HKLM, keyPath &amp; &quot;\PC-cillinNTCorp\CurrentVersion\Misc.&quot;) Then	
	objRegistry.GetStringValue HKLM, keyPath &amp; &quot;\PC-cillinNTCorp\CurrentVersion\Misc.&quot; ,&quot;NonCrcPatternDate&quot;, strPatternDate

	If Not IsNull(strPatternDate) Then
		WScript.Echo GetDaysOld(strPatternDate)
		WScript.Quit	
	End If
End If 

WScript.Echo &quot;Pattern date not found&quot;

function GetDaysOld(strDate)
	patternDate = CDate( Right(Left(strDate, 6), 2) &amp; &quot;/&quot; &amp; Right(strDate, 2) &amp; &quot;/&quot; &amp; Left(strDate, 4) )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
73,Trend Micro,2015-01-05T20:22:02,",","Version number of Trend Micro AV virus definitions if installed on the client machine.
Example: 9.501.50",1,1469085758,0,143,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Trend Micro Pattern Version,,,,,,,,,Windows,"&#039;========================================
&#039; Trend Micro Pattern Version 
&#039;========================================

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

Const HKLM = &amp;H80000002 

keyPath = &quot;Software\TrendMicro&quot;
key64Path = &quot;Software\WOW6432Node\TrendMicro&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

If RegKeyExists(HKLM, keyPath &amp; &quot;\PC-cillinNTCorp\CurrentVersion\Misc.&quot;) Then
	objRegistry.GetDWordValue HKLM, keyPath &amp; &quot;\PC-cillinNTCorp\CurrentVersion\Misc.&quot; ,&quot;InternalPatternVer&quot;, strInternalVersion
	objRegistry.GetDWordValue HKLM, keyPath &amp; &quot;\PC-cillinNTCorp\CurrentVersion\Misc.&quot; ,&quot;InternalNonCrcPatternVer&quot;, strNonCrcPatternVersion
	
	If Not IsNull(strInternalVersion) And strInternalVersion &lt;&gt; 0 Then
		WScript.Echo FormatPatternVersion(strInternalVersion)
		WScript.Quit
	ElseIf Not IsNull(strNonCrcPatternVersion) Then
		WScript.Echo FormatPatternVersion(strNonCrcPatternVersion)
		WScript.Quit
	End If
	WScript.Echo &quot;Pattern version not found&quot;
Else
	WScript.Echo &quot;Not installed&quot;
	WScript.Quit
End If

Function FormatPatternVersion(str)
	If Len(str) &gt;=6 Then
		FormatPatternVersion = Left(str, Len(str)-5) &amp; &quot;.&quot; &amp; Left(Right(str, 5), 3) &amp; &quot;.&quot; &amp; Right(str, 2)
		Exit Function
	Else
		FormatPatternVersion = &quot;0.&quot; &amp; Left(Right(str, 5), 3) &amp; &quot;.&quot; &amp; Right(str, 2)
		Exit Function
	End If
	FormatPatternVersion = &quot;&quot;
End Function

Function IsValidVersion(version)
	If IsNull(version) Or IsEmpty(version) Then
		IsValidVersion = False
		Exit Function
	End If 
	
	numberArr = Split(version, &quot;.&quot;)
	For Each number In numberArr
		If IsNumeric(number) Then
			&#039;Good to go.  keep looking
		Else
			IsValidVersion = False
			Exit Function
		End If
	Next
	IsValidVersion = True
End Function

Function VersionIsGreaterThan(version, compareToVersion)
	If Not IsValidVersion(version) Or Not IsValidVersion(compareToVersion) Then
		WScript.Echo &quot;not valid versions: &quot; &amp; version &amp; &quot;, &quot; &amp; compareToVersion
		Exit Function
	End If

	versionNumbers = Split(version, &quot;.&quot;)
	compareToVersionNumbers = Split(compareToVersion, &quot;.&quot;)
	
	For count = 0 To UBound(versionNumbers)
		versionNumber = versionNumbers(count)
		If UBound(compareToVersionNumbers) &gt;= count Then
			compareToVersionNumber = compareToVersionNumbers(count)
		Else
			compareToVersionNumber = -1
		End If 
		
		If versionNumber &gt; compareToVersionNumber Then
			VersionIsGreaterThan = True
			Exit function
		ElseIf versionNumber &lt; compareToVersionNumber Then
			VersionIsGreaterThan = False
			Exit function
		End If
	Next
	
	VersionIsGreaterThan = False
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
74,Applications,2015-01-05T20:22:02,",","Provides a list of processes currently running on the client machine.
Example: svchost.exe",1,4142232197,0,145,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Running Processes,,,,,,,,,Windows,select Caption from win32_process,WMIQuery,Linux,"#!/bin/bash
ps -ef | grep -v &quot; $$ &quot; | awk &#039;{ print substr($0,index($0,$8)) }&#039;
",UnixShell,Mac,"#!/bin/bash
ps -ef | grep -v &quot; $$ &quot; | awk &#039;{ print substr($0,index($0,$8)) }&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
75,Network,2015-01-05T20:22:02,",","Current IP Addresses of client machine.
Example: 192.168.1.1",1,3209138996,0,147,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,IP Address,,,,,,,,,Windows,select IPAddress from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/bash
ifconfig | grep -w inet | grep -v 127.0.0.1 | awk &#039;{print $2}&#039; | sed -e &#039;s/addr://&#039;
",UnixShell,Mac,"#!/bin/bash

ifconfig -a -u |grep &quot;inet&quot; | grep -v &quot;::1&quot; | grep -v &quot;127.0.0.1&quot;| awk &#039;{print $2}&#039; | cut -f1 -d&#039;%&#039;
",UnixShell,0,95,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
76,User,2015-01-05T20:22:02,",","Provides a list of users currently logged in to the client machine.  Includes Remote Desktop sessions on Windows.
Example: Administrator",1,1092986182,0,149,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Logged In Users,,,,,,,,,Windows,"&#039;========================================
&#039; Logged In Users
&#039;========================================

Option Explicit

Dim objWMIService,colItems,objItem,strUser,strUserDomain,strFullUser,i

Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;) 
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process Where Name=&#039;explorer.exe&#039;&quot;,,48)

i = 0
For Each objItem in colItems
	objItem.GetOwner strUser, strUserDomain
	strFullUser = strUserDomain &amp; &quot;\&quot; &amp; strUser
	i = i + 1
	WScript.Echo strFullUser
Next

If i = 0 Then
	Wscript.Echo &quot;No User&quot;
End If",VBScript,Linux,"#!/bin/bash
who -u | cut -d&quot; &quot; -f1 | sort | uniq
",UnixShell,Mac,"w -h | sort -u -t&#039; &#039; -k1,1 | awk &#039;{print $1}&#039;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
77,User,2015-01-05T20:22:02,",","Provides the last time a local administrator logged into the machine.
Example: Administrator 5/10/2012",1,2634431519,0,151,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Last Date of Local Administrator Login,,,,,,,,,Windows,"&#039;========================================
&#039; Last Date of Local Administrator Login
&#039;========================================

Option Explicit  

&#039;Uses date math - set locale

SetLocale(1033)
		
Dim objNetwork : Set objNetwork = CreateObject(&quot;WScript.Network&quot;) 
Dim objGroup : Set objGroup = GetObject(&quot;WinNT://.&quot;) 
objGroup.Filter = Array(&quot;user&quot;) 
Dim objUser 
For Each objUser In objGroup     
On Error Resume Next         
WScript.Echo objUser.name &amp; vbTab &amp; left(GetObject(objUser.adsPath).LastLogin,Instr(GetObject(objUser.adsPath).LastLogin,&quot; &quot;))     
On Error GoTo 0 
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,94,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
78,Active Directory,2015-01-05T20:22:02,",","The Active Directory organizational unit (OU) where the machine is located.
Example: CN=Computers,DC=corp,DC=com",1,21983240,0,153,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:02,AD Organizational Unit,,,,,,,,,Windows,"&#039;========================================
&#039; AD Organizational Unit
&#039;========================================


&#039; Returns a single column value
&#039; Only checks a single registry context

Const GPKey = &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy&quot;
Dim strSubKey,strValue,strSep,strKey,words,strHive,constHive,hasValues32,hasAnyResult
Dim hasValues64,strUserKey,strFullUserKey,bEchoOnlyValue
Dim objCtx,objReg,bSkipSecondCheckOverride

Dim dictOut
Set dictOut = CreateObject(&quot;Scripting.Dictionary&quot;)

bEchoOnlyValue = True
bSkipSecondCheckOverride = True &#039; Check in one place
strSubKey = &quot;\DataStore\Machine\0&quot;
strValue = &quot;DNName&quot;
strSep = &quot;~~&quot;

strKey = GPKey&amp;strSubKey

&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
   For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
         strUserName = GetUserForSIDLocal(objReg,strUserKey)
         If strUserName = False Then strUserName = strUserKey
         strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
         hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
         If hasValues32 Then hasAnyResult = True
      End If
   Next
Else &#039; was another hive
   hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
   If hasValues32 Then hasAnyResult = True
End If

&#039; Do not return second value set in different context unnecessarily
Dim strKeyPrefix,bSkipSecondContextCheck
bSkipSecondContextCheck = False
strKeyPrefix = Split(strKey,&quot;\&quot;)(0) &#039; Software, for instance, even for HEKY_USERS

Select Case Ucase(strKeyPrefix)
   Case &quot;SOFTWARE&quot;
      If bSkipSecondCheckOverride Then
         bSkipSecondContextCheck = True
      Else
         bSkipSecondContextCheck = False
      End If
   Case Else
      bSkipSecondContextCheck = True
End Select

If Is64 And Not bSkipSecondContextCheck Then
   Set objCtx = GetObjCtx(64)
   Set objReg = GetObjReg(objCtx)
   If strHive = &quot;HKEY_USERS&quot; Then
   &#039; go through each User&#039;s hive in 64-bit context
      For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
            strUserName = GetUserForSIDLocal(objReg,strUserKey)
            If strUserName = False Then strUserName = strUserKey
            strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
            hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
            If hasValues64 Then hasAnyResult = True   
         End If
      Next
   Else &#039; was another hive
      hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
      If hasValues64 Then hasAnyResult = True
   End If
End If

EchoOutDictFunctionFilter dictOut,&quot;Not Found&quot;,&quot;GetOUFromDN&quot;

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

   Dim Inparams, Outparams,arrNames,arrTypes,i,strValueName
   Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
   Inparams.Hdefkey = constHive
   Inparams.sSubkeyname = strKey
   Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
   
   arrNames = Outparams.sNames
   arrTypes = Outparams.Types

   If Not IsNull(arrNames) Then
      For i = LBound(arrNames) To UBound(arrNames)
         strValueName = arrNames(i)
         
         &#039;if strValue is found, echo
         If LCase(strValueName) = LCase(strValue) Then
            AddValToEchoDict dictOut, objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit, bEchoOnlyValue
            CheckValues = True
            Exit Function
         End If
      Next
   End If
   CheckValues = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit, bEchoOnlyValue)
   Dim strArch
   If intBit = 64 Then
      strArch = &quot;64-bit&quot;
   Else
      strArch = &quot;32-bit&quot;
   End If
   If bEchoOnlyValue Then
      GetDisplayString = strValue
   Else
      GetDisplayString = _
         strValue &amp; strSep &amp; _
         strType &amp; strSep &amp; _
         strArch
   End If
End Function

Function AddValToEchoDict(ByRef dicOut, objReg, objCtx, constHive, strKey, strValue, constType, intBit, bOnlyValueData)
   &#039; Note the key that was being searched, will be a hidden column
   Dim strOutputKey
   strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
   
   Dim objInParams, objOutParams
   Select Case constType
      Case REG_SZ  
         Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters
         objInParams.hDefKey = constHive
         objInParams.sSubKeyName = strKey
         objInParams.sValueName = strValue         
         Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)
         Else
            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_EXPAND_SZ
         Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters
         objInParams.hDefKey = constHive
         objInParams.sSubKeyName = strKey
         objInParams.sValueName = strValue         
         Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)
         Else  
            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_BINARY
         Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters
         objInParams.hDefKey = constHive
         objInParams.sSubKeyName = strKey
         objInParams.sValueName = strValue         
         Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)

         strBytes = &quot;&quot;
         For Each uByte in objOutParams.uValue
            strTemp = Hex(uByte)
            If Len(strTemp) &lt; 2 Then
               strTemp = &quot;0&quot; &amp; strTemp
            End If   
            strBytes = strBytes &amp; strTemp &amp; &quot; &quot;
         Next
         If bOnlyValueData Then
            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)
         Else
            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit, bOnlyValueData) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If         
      Case REG_DWORD
          Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
          objInParams.hDefKey = constHive
          objInParams.sSubKeyName = strKey
          objInParams.sValueName = strValue
          Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)
         Else     
            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_QWORD
          Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters
          objInParams.hDefKey = constHive
          objInParams.sSubKeyName = strKey
          objInParams.sValueName = strValue
          Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)
         Else     
            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_MULTI_SZ
          Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters
          objInParams.hDefKey = constHive
          objInParams.sSubKeyName = strKey
          objInParams.sValueName = strValue
          Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)
      
         arrValues = objOutParams.sValue
         strResponse = &quot;&quot;

         For Each strTemp In arrValues
            If bOnlyValueData Then
               AddToOut dictOut, GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit, bOnlyValueData)
            Else
               AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit) _
                  &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
            End If
         Next
   End Select
End Function

Function GetObjCtx(intArch)
   Dim objCtx
   Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
   objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
   objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
   Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
   Dim objLocator, objServices
   Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
   Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
   Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
   Dim Inparams, Outparams
   Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
   Inparams.Hdefkey = constHive
   Inparams.sSubkeyname = strKey
   Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
   GetSubKeys = Outparams.sNames
End Function

Function Is64 
   Dim objWMIService, colItems, objItem
   Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
   Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
   For Each objItem In colItems
      If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
         Is64 = True
      Else
         Is64 = False
      End If      
   Next
End Function


Function GetHiveConst(hive)
   Const HKEY_CLASSES_ROOT   = &amp;H80000000
   Const HKEY_CURRENT_USER   = &amp;H80000001
   Const HKEY_LOCAL_MACHINE  = &amp;H80000002
   Const HKEY_USERS          = &amp;H80000003

   Select Case UCase(hive)
      Case &quot;HKLM&quot;
         GetHiveConst = HKEY_LOCAL_MACHINE
      Case &quot;HKEY_LOCAL_MACHINE&quot;
         GetHiveConst = HKEY_LOCAL_MACHINE
      Case &quot;HKCR&quot;
         GetHiveConst = HKEY_CLASSES_ROOT
      Case &quot;HKEY_CLASSES_ROOT&quot;
         GetHiveConst = HKEY_CLASSES_ROOT
      Case &quot;HKEY_CURRENT_USER&quot;
         GetHiveConst = HKEY_CURRENT_USER
      Case &quot;HKEY_USERS&quot;
         GetHiveConst = HKEY_USERS
   End Select
   
   If IsEmpty(GetHiveConst) Then
      WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
      WScript.Quit
   End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

   Const HKLM = &amp;h80000002
   
   Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
   
   strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
   objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
   If Not IsNull(strUserData) Then
   &#039; strUserData would look like
   &#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
      intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
      &#039; strip off the dat file
      If intDatPos &gt; 0 Then &#039; must be in string
         strUserData = Left(strUserData,intDatPos - 1)
         &#039; find last backslash
         intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
         &#039; get right from that pos
         strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
         GetUserForSIDLocal = strUserData
      Else
         strUserData = False
      End If
   Else
      GetUserForSIDLocal = False
   End If
End Function &#039;GetUserForSIDLocal

Sub AddToOut(ByRef dictOut, strIn)
	If VarType(strIn) = vbString Then
		If Not dictOut.Exists(strIn) Then
			dictOut.Add strIn,1
		End If
	End If
End Sub

Function GetOUFromDN(strDN)
	Dim intFirstComma
	intFirstComma = InStr(strDN,&quot;,&quot;)
	If Not intFirstComma &gt; 0 Then
		GetOUFromDN = strDN
		Exit Function
	End If
	intFromRight = Len(strDN) - intFirstComma
	If intFromRight &gt;= 0 Then
		GetOUFromDN = Right(strDN,intFromRight)
	Else
		GetOUFromDN = strDN
	End If
End Function &#039;GetOUFromDN

Sub EchoOutDictFunctionFilter(ByRef dictOut,strNoResultsMessage, ByRef funcRef)
&#039;FuncRef returns a string which filters the key
	Dim strKey
	If dictOut.Count = 0 Then
		WScript.Echo strNoResultsMessage
		Exit Sub
	End If
	Dim out
	For Each strKey In dictOut
		Execute(&quot;out = &quot;&amp;funcRef&amp;&quot;(strKey)&quot;)
		WScript.Echo out
	Next
End Sub &#039;EchoOutDictFunctionFilter",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
79,Active Directory,2015-01-05T20:22:02,",","All computer groups (if any) that a computer is a member of in Active Directory.
Example: Berkeley Workstations",1,525163843,0,155,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:02,AD Computer Groups,,,,,,,,,Windows,"&#039;========================================
&#039; AD Computer Groups
&#039;========================================

On Error Resume Next
&#039; Constants required for name translate
CONST ADS_NAME_INITTYPE_GC = 3
CONST ADS_NAME_TYPE_NT4 = 3
CONST ADS_NAME_TYPE_1779 = 1

&#039;Get the NETBIOS name of the domain
SET objSystemInfo = CREATEOBJECT(&quot;ADSystemInfo&quot;) 
Dim strDomain
strDomain = objSystemInfo.DomainShortName
If IsEmpty(strDomain) Then
   WScript.Echo &quot;AD Information Unavailable&quot;
   WScript.Quit
End If

&#039; Get the name of the computer
SET objNetwork = CREATEOBJECT(&quot;Wscript.Network&quot;)
strComputer = objNetwork.ComputerName

&#039; Call function to return the distinguished name (DN) of the computer

dim strComputerDN
strComputerDN = getComputerDN(strComputer,strDomain)

If isEmpty(strComputerDN) Then
   wscript.echo &quot;Cannot connect to AD server&quot;
Else
	GetGroups(strComputerDN)
	 
	wscript.quit
End If

Function GetGroups(strDn)
&#039;	WScript.Echo &quot;looking at: &quot;&amp; strDN
	&#039;	On Error Resume Next
	Const E_ADS_PROPERTY_NOT_FOUND  = &amp;h8000500D
	 
	Set objUser = GetObject _
	    (&quot;LDAP://&quot; &amp; strDn)
	 
	intPrimaryGroupID = objUser.Get(&quot;primaryGroupID&quot;)
	arrMemberOf = objUser.GetEx(&quot;memberOf&quot;)
	 
	If Err.Number = E_ADS_PROPERTY_NOT_FOUND Then
	    WScript.Echo &quot;The memberOf attribute is not set.&quot;
	Else
	    For Each Group in arrMemberOf
	        WScript.Echo Group
	    Next
	End If
End Function

Function getComputerDN(BYVAL strComputer,BYVAL strDomain)
   &#039; Function to get the distinguished name of a computer
   &#039; from the NETBIOS name of the computer (strcomputer)
   &#039; and the NETBIOS name of the domain (strDomain) using
   &#039; name translate

   SET objTrans = CREATEOBJECT(&quot;NameTranslate&quot;)
   &#039; Initialize name translate using global catalog
   objTrans.Init ADS_NAME_INITTYPE_GC, &quot;&quot;
   &#039; Input computer name (NT Format)
   objTrans.SET ADS_NAME_TYPE_NT4, strDomain &amp; &quot;\&quot; &amp; strComputer &amp; &quot;$&quot;
   &#039; Get Distinguished Name.
   getComputerDN = objTrans.GET(ADS_NAME_TYPE_1779)
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
80,Operating System,2015-01-05T20:22:02,",","Time since reboot in days of the client machine.
Example: 48 days",1,3480890585,0,157,1,Jim Olsen,1800,0,defined,Tanium,2015-01-05T20:22:02,Uptime,,,,,,,,,Windows,"&#039;========================================
&#039; Uptime
&#039;========================================

strComputer = &quot;.&quot; &#039; Local computer

set objWMIDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
set objWMI = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
set colOS = objWMI.InstancesOf(&quot;Win32_OperatingSystem&quot;)
for each objOS in colOS
	objWMIDateTime.Value = objOS.LastBootUpTime
         
	If TimeSpan(objWMIDateTime.GetVarDate,Now) &gt; 0 Then
        Wscript.echo TimeSpan(objWMIDateTime.GetVarDate,Now) &amp; &quot; days&quot;
Else
        Wscript.echo &quot;Less than 1 day&quot;
        End If
next

Function TimeSpan(dt1, dt2) 
	If (isDate(dt1) And IsDate(dt2)) = false Then 
		TimeSpan = &quot;00:00:00&quot; 
		Exit Function 
        End If 
 
        seconds = Abs(DateDiff(&quot;S&quot;, dt1, dt2)) 
        minutes = seconds \ 60 
        hours = minutes \ 60 
        days = hours \ 24 
        minutes = minutes mod 60 
        seconds = seconds mod 60 
 
        TimeSpan = days
End Function",VBScript,Linux,"#!/bin/bash
line=$(cat /proc/uptime)
set -- $line
echo $1
",UnixShell,Mac,"#!/bin/bash

uptime | awk &#039;{
  # chops off &quot;up&quot; and everything before it:
  sub(/.*up[ ]+/,&quot;&quot;,$0)
  # chops off &quot;, # users&quot; and everything after it:       
  sub(/,[ ]+[0-9]+ user.*/,&quot;&quot;,$0)
  # cleans up extra spaces, i think:    
  sub(/,/,&quot;&quot;,$0)
  # obvious enough, prints the results                       
  print($0)
}&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
81,Operating System,2015-01-05T20:22:02,",","Returns data indicating that a reboot is required and, if so, for which reason.
Example: Yes",1,568581921,0,159,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Reboot Required,,,,,,,,,Windows,"&#039;========================================
&#039; Reboot Required
&#039;========================================

&#039;&#039; This sensor checks registry locations to determine if a reboot is required
&#039;&#039; For any reason


Option Explicit
RebootRequired

Function RebootRequired
&#039; This is the main function that determines if a reboot is necessary
&#039; it will have WScript.Echo output and also set a true / false value
&#039; as a return value so it can be used elsewhere

	Dim strFinalOutputString

	Dim strComputer

	Dim strWUAPath
	Dim strPendingFileRenamePath,strPendingFileRenameValueName
	Dim strUpdateExeVolatilePath,strUpdateExeVolatileWowPath,strUpdateExeVolatileFlagsVal
	Dim strRunOncePath,strRunOnceWowPath
	Dim strRunOnceSetupPath,strRunOnceSetupWowPath
	Dim strRunOnceExPath,strRunOnceExWowPath,strRunOnceExTitleVal

	Dim intUpdateExeVolatileFlagsResult

	Dim objReg

	&#039; The checks are all in the Local Machine hive
	Const HKLM = &amp;h80000002

	&#039;&#039; Case 1
	&#039; If the RebootRequired key exists at all, reboot is required
	&#039; Only seems to exist in the native registry (not in Wow6432Node)
	strWUAPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired&quot;

	&#039;&#039; Case 2
	&#039; If the Multi String value PendingRenameFileOperations exists at all, reboot is required
	strPendingFileRenamePath = &quot;SYSTEM\CurrentControlSet\Control\Session Manager&quot;
	strPendingFileRenameValueName = &quot;PendingFileRenameOperations&quot;

	&#039;&#039; Case 3
	&#039; If the UpdateExeVolatile key&#039;s DWORD value &#039;flags&#039; is 1 or 2, reboot is required
	&#039; Does exist in the native registry (in Wow6432Node) as well
	strUpdateExeVolatilePath = &quot;SOFTWARE\Microsoft\Updates\UpdateExeVolatile&quot;
	strUpdateExeVolatileWowPath = &quot;SOFTWARE\Wow6432Node\Microsoft\Updates\UpdateExeVolatile&quot;
	strUpdateExeVolatileFlagsVal = &quot;flags&quot;

	&#039;&#039; Case 4
	&#039;&#039; If there are any values in the RunOnce key, reboot is required
	&#039; Does exist in the native registry (in Wow6432Node) as well
	strRunOncePath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce&quot;
	strRunOnceWowPath = &quot;SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce&quot;

	&#039;&#039; Case 5
	&#039; If there is anything in the RunOnce\Setup key, reboot is required
	&#039; Does exist in the native registry (in Wow6432Node) as well
	strRunOnceSetupPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce\Setup&quot;
	strRunOnceSetupWowPath = &quot;SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce\Setup&quot;

	&#039;&#039; Case 6
	&#039; If there is anything in the RunOnceEx key&#039;s Title Value, a reboot is required
	&#039; Does exist in the native registry (in Wow6432Node) as well
	strRunOnceExPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx&quot;
	strRunOnceExWowPath = &quot;SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnceEx&quot;
	strRunOnceExTitleVal = &quot;Title&quot;

	&#039;&#039; Case 7
	&#039; RebootNeeded from UpdateSearcher class

	Set objReg=Getx64RegistryProvider()

	strFinalOutputString = &quot;&quot;

	&#039; Now we begin the process of checking the various registry areas to determine if a reboot is needed

	&#039; Case 1
	If RegKeyExists(objReg, HKLM, strWUAPath) Then
		strFinalOutputString = strFinalOutputString &amp; strWUAPath &amp; vbCrLf
	End If

	&#039; Case 2
	If MultiStringValueExists(objReg,HKLM,strPendingFileRenamePath,strPendingFileRenameValueName) Then
		strFinalOutputString = strFinalOutputString &amp; strPendingFileRenamePath &amp; &quot;: &quot; &amp; strPendingFileRenameValueName &amp; vbCrLf
	End If

	&#039; Case 3
	intUpdateExeVolatileFlagsResult = GetDWORDValue(objReg,HKLM,strUpdateExeVolatilePath,strUpdateExeVolatileFlagsVal)
	If intUpdateExeVolatileFlagsResult = 1 OR intUpdateExeVolatileFlagsResult = 2 Then
		strFinalOutputString = strFinalOutputString &amp; strUpdateExeVolatilePath &amp; &quot;: &quot; &amp; strUpdateExeVolatileFlagsVal &amp; vbCrLf
	End If

	intUpdateExeVolatileFlagsResult = GetDWORDValue(objReg,HKLM,strUpdateExeVolatileWowPath,strUpdateExeVolatileFlagsVal)
	If intUpdateExeVolatileFlagsResult = 1 OR intUpdateExeVolatileFlagsResult = 2 Then
		strFinalOutputString = strFinalOutputString &amp; strUpdateExeVolatileWowPath &amp; &quot;: &quot; &amp; strUpdateExeVolatileFlagsVal &amp; vbCrLf
	End If

	&#039; Case 4
	If ValuesExist(objReg,HKLM,strRunOncePath) Then
		strFinalOutputString = strFinalOutputString &amp; strRunOncePath &amp; vbCrLf
	End If

	If ValuesExist(objReg,HKLM,strRunOnceWowPath) Then
		strFinalOutputString = strFinalOutputString &amp; strRunOnceWowPath &amp; vbCrLf
	End If

	&#039; Case 5
	If ValuesExist(objReg,HKLM,strRunOnceSetupPath) Then
		strFinalOutputString = strFinalOutputString &amp; strRunOnceSetupPath &amp; vbCrLf
	End If

	If ValuesExist(objReg,HKLM,strRunOnceSetupWowPath) Then
		strFinalOutputString = strFinalOutputString &amp; strRunOnceSetupWowPath &amp; vbCrLf
	End If

	&#039; Case 6
	If StringValueExists(objReg,HKLM,strRunOnceExPath,strRunOnceExTitleVal) Then
		strFinalOutputString = strFinalOutputString &amp; strRunOnceExPath &amp; &quot;: &quot; &amp; strRunOnceExTitleVal &amp; vbCrLf
	End If

	If StringValueExists(objReg,HKLM,strRunOnceExWowPath,strRunOnceExTitleVal) Then
		strFinalOutputString = strFinalOutputString &amp; strRunOnceExWowPath &amp; &quot;: &quot; &amp; strRunOnceExTitleVal &amp; vbCrLf
	End If

	&#039; Case 7
	If UpdateSystemInfoRebootRequired Then
		strFinalOutputString = strFinalOutputString &amp; &quot;Microsoft.Update.SystemInfo:RebootRequired&quot; &amp; vbCrLf
	End If


	&#039;&#039; At the end of the process, if strFinalOutputString is &quot;&quot; the sensor output is &quot;No&quot;
	&#039;&#039; Otherwise, the output is the value of strFinalOutputString

	If strFinalOutputString = &quot;&quot; Then
		WScript.Echo &quot;No&quot;
		RebootRequired = false
	Else
		WScript.Echo &quot;Yes&quot; &amp; vbcrlf &amp; strFinalOutputString
		RebootRequired = true
	End If
End Function &#039;RebootRequired

Function ValuesExist(objRegistry, HIVE, strKeyPath)
&#039; This function checks to see if a registry value exists
&#039; and returns true or false
	Dim arrValueNames, arrTypes
	
	objRegistry.EnumValues HIVE, strKeyPath, arrValueNames, arrTypes
	
	If IsNull(arrValueNames) Then
		ValuesExist = false
	Else
		ValuesExist = true
	End If	
End Function

Function StringValueExists(objRegistry, HIVE, strKeyPath, strValueName)
	Dim strValue
	
	objRegistry.GetStringValue HIVE, strKeyPath, strValueName, strValue
	
	If IsNull(strValue) Then
		StringValueExists = false
	Else
		StringValueExists = true
	End If	
End Function

Function GetDWORDValue(objRegistry, HIVE, strKeyPath, strValueName)
	Dim uintValue
	
	objRegistry.GetDWORDValue HIVE, strKeyPath, strValueName, uintValue
	
	If IsNull(uintValue) Then
		GetDWORDValue = false
	Else
		GetDWORDValue = uintValue
	End If	
End Function

Function DWORDValueExists(objRegistry, HIVE, strKeyPath, strValueName)
	Dim uintValue
	
	objRegistry.GetDWORDValue HIVE, strKeyPath, strValueName, uintValue
	
	If IsNull(uintValue) Then
		DWORDValueExists = false
	Else
		DWORDValueExists = true
	End If
End Function

&#039; For checking multi-string value exists
Function MultiStringValueExists(objRegistry, HIVE, strKeyPath, strValueName)
	Dim arrValues

	objRegistry.GetMultiStringValue HIVE,strKeyPath,strValueName,arrValues

	If IsNull(arrValues) Then
		MultiStringValueExists = false
	Else
		MultiStringValueExists = true
	End If
End Function


&#039; For checking whether a key exists at all
Function RegKeyExists(objRegistry, sHive, sRegKey)
   Dim aValueNames, aValueTypes
   If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
      RegKeyExists = True
   Else
      RegKeyExists = False
   End If
End Function

Function UpdateSystemInfoRebootRequired()
&#039; This will return true if a reboot is needed
&#039; as indicated by the update.systeminfo object
   
	Dim objSystemInfo,bRebootRequired
   
	bRebootRequired = False
	Set objSystemInfo = WScript.CreateObject(&quot;Microsoft.Update.SystemInfo&quot;)
	
	bRebootRequired = objSystemInfo.rebootrequired 

	UpdateSystemInfoRebootRequired = bRebootRequired
	Set objSystemInfo = nothing
End Function &#039; UpdateSystemInfoRebootRequired


Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/bash
if [ -f /var/run/reboot-required ]; then
  echo &#039;Yes&#039;
else
  echo &#039;No&#039;
fi
",UnixShell,Mac,"#!/bin/bash
if [ -f /var/run/reboot-required ]; then
  echo &#039;Yes&#039;
else
  echo &#039;No&#039;
fi
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
82,Tags,2015-01-05T20:22:02,",","Any specified custom tags that have been set for this machine.  See the Custom Tagging Dashboard.
Example:  Development, Test-Machines",1,3004497651,0,161,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Custom Tags,,,,,,,,,Windows,"&#039;========================================
&#039; Custom Tags
&#039;========================================

Dim reg
Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)
const HKLM = &amp;H80000002

Dim strRegKey
strRegKey = GetTaniumRegistryPath() &amp; &quot;\Sensor Data\Tags&quot;

If Not RegKeyExists(reg, HKLM, strRegKey) Then
	reg.createKey HKLM, strRegKey
End If

reg.enumValues HKLM, strRegKey, arrValues

If Not IsNull(arrValues) Then
	For Each strValueName In arrValues
		WScript.Echo strValueName
	Next
End If


Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function


Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		GetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		GetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;GetTaniumRegistryPath",VBScript,Linux,"#!/bin/bash

TAGFILE=&quot;Tools/CustomTags.txt&quot;

if [ -e $TAGFILE ]; then
  cat $TAGFILE
else
  echo &quot;&quot;
fi
",UnixShell,Mac,"#!/bin/bash

TAGFILE=&quot;Tools/CustomTags.txt&quot;

if [ -e $TAGFILE ]; then
  cat $TAGFILE
else
  echo &quot;&quot;
fi
",UnixShell,0,85,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
83,Patch,2015-01-05T20:22:02,",","Sensor which looks at the patch results file to determine how many security patches are necessary.  Can be edited to determine what severity counts as a security patch.
Example:5",1,1999869038,0,163,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Security Patches Needed,,,,,,,,,Windows,"&#039;========================================
&#039; Security Patches Needed
&#039;========================================

&#039; sensor - security patches needed
&#039; This sensor will return a count of the number of patches required
&#039; provided they are security-related


Option Explicit

Dim strHighestSeverityThatCounts
&#039; This sensor is modifiable
&#039; customers can decide how to flag an update as countable in this sensor
&#039; by default, we include all available patches

&#039; This string value will determine what we count.  The valid values here are:
&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS

strHighestSeverityThatCounts = &quot;ALL&quot;

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, intCriticalThreshold
strSep = &quot;|&quot;
intCriticalThreshold = 5

Dim showSingleStatus
showSingleStatus = True

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\patchresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False

	&#039;note: intNone refers to patches with severity=none
	Dim intCritical, intImportant, intModerate, intLow, intNone, intSecurityBulletin
	
	intCritical = 0
	intImportant = 0
	intModerate = 0
	intLow = 0	
	intNone = 0
	intSecurityBulletin = 0
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				&#039;WScript.Echo words(0)
			Else 
				&#039;WScript.Echo &quot;Run upgraded Patch Scan&quot;
				WScript.Quit
			End If	
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next


&#039; A previously defined string value will determine what we count.  
&#039; The valid values here are:
&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS

			If Not isComplete Then
				If InStr(strLine, &quot;Already Installed&quot;) Then
					&#039;Do not echo since we only want to output &quot;Available&quot; patches
				Else
					hasOutput = True
					Select Case words(1)
					    Case &quot;Critical&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;CRITICALS&quot; Or _
					    		strHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _
					    		strHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    			intCritical = intCritical + 1
					    	End If
					    Case &quot;Important&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _
					    		strHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    			intImportant = intImportant + 1
					    	End If					    	

					    Case &quot;Moderate&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    		intModerate = intModerate + 1
					    	End If					    						    
					    Case &quot;Low&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    		intLow = intLow + 1
					    	End If									    
					    Case &quot;None&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    		intNone = intNone + 1
					    	End If									    
					End Select
					If LCase(words(2)) &lt;&gt; &quot;none&quot; Then &#039; there is an MS Security Bulletin ID associated
						intSecurityBulletin = intSecurityBulletin + 1
					End If
				End If
			Else
				&#039;If we&#039;re here, update has been queued
				&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				&#039;If InStr(strLine, &quot;Not Installed&quot;) Then
				&#039;	strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
				&#039;	WScript.Echo strLine
				&#039;End If
			End If 
		End If	
	Loop

	objReadFile.close

	If hasOutput Then &#039; output sum, ignoring the &#039;None&#039; category
		If strHighestSeverityThatCounts = &quot;MS_SECURITY_BULLETINS&quot; Then
			WScript.Echo intSecurityBulletin
		Else
			If intCritical + intImportant + intModerate + intLow + intNone &gt; 0 Then
				WScript.Echo intCritical + intImportant + intModerate + intLow + intNone &amp; &quot; updates&quot;
			Else
				WScript.Echo 0
			End If
		End If
	Else
		WScript.Echo 0
	End If

Else
   Wscript.echo &quot;Patch results output not found&quot;
End If

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
84,Network,2015-01-05T20:22:02,",","The domain name (if any) that the computer is joined to or configured for.
Example: intra.company.com",1,794103688,0,165,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Domain Name,,,,,,,,,Windows,select Domain from win32_ComputerSystem,WMIQuery,Linux,"#!/bin/bash
domainname
",UnixShell,Mac,"#!/bin/bash
domainname
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
85,Network,2015-01-05T20:22:02,",","Addresses of any configured DNS servers for active network adapters.
Example: 192.168.1.1, 8.8.8.8",1,3112892791,0,167,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,DNS Server,,,,,,,,,Windows,select DNSServerSearchOrder from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/bash
cat /etc/resolv.conf | while read line
do
	if [[ $line == nameserver* ]];
	then
		echo ${line#*&quot;nameserver&quot;}
	fi
done
",UnixShell,Mac,"#!/bin/bash
cat /etc/resolv.conf | while read line
do
	if [[ $line == nameserver* ]];
	then
		echo ${line#*&quot;nameserver&quot;}
	fi
done
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
86,Tanium Diagnostics,2015-01-05T20:22:02,",","The local IP address the client is using to communicate with the Tanium Server.
Example: 192.168.10.2",1,4264271977,0,169,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Tanium Client IP Address,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client IP Address
&#039;========================================

Dim strTaniumPath, strStatusPath
Dim strClientAddress, arrClientAddress, strIPAddress
Dim objReg


Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)

Const HKLM = &amp;h80000002

&#039;Tanium registry key paths
strTaniumPath = GetTaniumRegistryPath()
strStatusPath = strTaniumPath &amp; &quot;\Status&quot;

&#039;Pull the registry value out
objReg.GetStringValue HKLM, strStatusPath, &quot;ClientAddress&quot;, strClientAddress

arrClientAddress = Split(strClientAddress,&quot;_&quot;)

&#039; Final output
strIPAddress = Split(arrClientAddress(0),&quot;:&quot;)(2)

WScript.Echo strIPAddress

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function ParseTaniumIPEntry(strIPEntry)
&#039; This function will parse a Tanium IP address entry in the registry
	
	Dim strLeftSplit
	
	strLeftSplit = Left(strIPEntry,InStr(strIPEntry,&quot;_&quot;)-1)
	ParseTaniumIPEntry = Right(strLeftSplit,len(strLeftSplit)-InStrRev(strLeftSplit,&quot;:&quot;))

End Function &#039;ParseTaniumIPEntry",VBScript,Linux,"#!/bin/bash

grep ClientAddress TaniumClientStatus.ini | awk -F &#039;:&#039; &#039;{ print $NF }&#039;
",UnixShell,Mac,"#!/bin/bash

grep ClientAddress TaniumClientStatus.ini | awk -F &#039;:&#039; &#039;{ print $NF }&#039;
",UnixShell,0,8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
87,Tanium,2015-01-05T20:22:02,",","The Subnet in use by the Tanium Client.
Example: 192.168.10.0/24",1,1744818157,0,171,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Tanium Client Subnet,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Subnet
&#039;========================================

Option Explicit

Dim strTaniumIPAddress, strTaniumMask

strTaniumIPAddress = GetTaniumIPAddress
If strTaniumIPAddress = False Then 
	WScript.Echo &quot;Can&#039;t retrieve Tanium Client&#039;s IP address&quot;
End If

strTaniumMask = GetSubnetMaskForIP(strTaniumIPAddress)

WScript.Echo CalcNetworkAddress(strTaniumIPAddress,strTaniumMask) &amp; &quot;/&quot; &amp; MaskLength(strTaniumMask)

Function CalcNetworkAddress(strIP, strMask)
  &#039; Generates the Network Address from the IP and Mask
 
  &#039; Conversion of IP and Mask to binary
  Dim strBinIP : strBinIP = ConvertIPToBinary(strIP)
  Dim strBinMask : strBinMask = ConvertIPToBinary(strMask)
 
  &#039; Bitwise AND operation (except for the dot)
  Dim i, strBinNetwork
  For i = 1 to Len(strBinIP)
    Dim strIPBit : strIPBit = Mid(strBinIP, i, 1)
    Dim strMaskBit : strMaskBit = Mid(strBinMask, i, 1)
 
    If strIPBit = &quot;1&quot; And strMaskBit = &quot;1&quot; Then
      strBinNetwork = strBinNetwork &amp; &quot;1&quot;
    ElseIf strIPBit = &quot;.&quot; Then
      strBinNetwork = strBinNetwork &amp; strIPBit
    Else
      strBinNetwork = strBinNetwork &amp; &quot;0&quot;
    End If
  Next
 
  &#039; Conversion of Binary IP to Decimal
  CalcNetworkAddress= ConvertBinIPToDecimal(strBinNetwork)
End Function

Function MaskLength(strMask)
  &#039; Converts an subnet mask into a mask length in bits
 
  Dim arrOctets : arrOctets = Split(strMask, &quot;.&quot;)
  Dim i
  For i = 0 to UBound(arrOctets)
    Dim intOctet : intOctet = CInt(arrOctets(i))
    Dim j, intMaskLength
    For j = 0 To 7
      If intOctet And (2^(7 -j)) Then
        intMaskLength = intMaskLength + 1
      End If
    Next
  Next
  MaskLength = intMaskLength
End Function

Function ConvertBinIPToDecimal(strBinIP)
  &#039; Convert binary form of an IP back to decimal
 
  Dim arrOctets : arrOctets = Split(strBinIP, &quot;.&quot;)
  Dim i
  For i = 0 to UBound(arrOctets)
    Dim intOctet : intOctet = 0
    Dim j
    For j = 0 to 7
      Dim intBit : intBit = CInt(Mid(arrOctets(i), j + 1, 1))
      If intBit = 1 Then
        intOctet = intOctet + 2^(7 - j)
      End If
    Next
    arrOctets(i) = CStr(intOctet)
  Next
 
  ConvertBinIPToDecimal = Join(arrOctets, &quot;.&quot;)
End Function

Function ConvertIPToBinary(strIP)
  &#039; Converts an IP Address into Binary
 
  Dim arrOctets : arrOctets = Split(strIP, &quot;.&quot;)
  Dim i
  For i = 0 to UBound(arrOctets)
    Dim intOctet : intOctet = CInt(arrOctets(i))
    Dim strBinOctet : strBinOctet = &quot;&quot;
    Dim j
    For j = 0 To 7
      If intOctet And (2^(7 - j)) Then
        strBinOctet = strBinOctet &amp; &quot;1&quot;
      Else
        strBinOctet = strBinOctet &amp; &quot;0&quot;
      End If
    Next
    arrOctets(i) = strBinOctet
  Next
  ConvertIPToBinary = Join(arrOctets, &quot;.&quot;)
End Function

Function GetSubnetMaskForIP(strIP)
&#039;This function will return the subnet for a particular IP address

	Dim strIPAddress, strSubnet
	Dim objWMIService,colItems
	Dim objItem
	
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration&quot;,,48)
	
	On Error Resume Next
	For Each objItem in colItems
		If IsArray(objItem.IPAddress) Then
			If objItem.IPAddress(0)&lt;&gt;&quot;&quot; Then 
				For Each strIPAddress In objItem.IPAddress
					If strIPAddress = strIP Then
						For Each strSubnet In objItem.IPSubnet
							If InStr(strSubnet,&quot;.&quot;) &gt; 0 Then &#039;IPv4 subnet
								GetSubnetMaskForIP = strSubnet
							End If
						Next
					End If
				Next
			End If
		End If
	Next

	&#039;Cleanup
	Set colItems = Nothing
	Set objWMIService = Nothing

End Function &#039;GetSubnetMaskForIP

Function GetTaniumIPAddress
&#039; Returns the IP address that the client uses for Tanium activity
&#039; (talking to server and other clients)

	Dim strComputer, objReg, strCommand, objShell, objScriptExec
	Dim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords
	Dim strIPAddress, strTaniumPath, strClientAddress
	Dim strServerName
	
	strComputer = &quot;.&quot;
	Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	Const HKLM = &amp;h80000002
	
		
	&#039;&#039;###########Get Tanium Key on 64/32bit computers##########
	
	strTaniumPath = GetTaniumRegistryPath()
	
	
	&#039; if we can pull this from the registry (newer client version), just use that
	objReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\Status&quot;, &quot;ClientAddress&quot;, strClientAddress
	If strClientAddress &lt;&gt; &quot;&quot; Then
		strClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)
		strClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))
		&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;
		GetTaniumIPAddress = strClientAddress
		&#039;Cleanup
		Set objReg = Nothing
		Exit Function
	End If
	
	&#039;Otherwise use PathPing to determine client IP used by Tanium

	&#039;&#039;# Read the ServerName value

	objReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName

	strCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	strResults = objScriptExec.StdOut.ReadAll
	
	arrPathPingLines = Split(strResults, vbCrLf)
	For Each strPathPingLine In arrPathPingLines
		arrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)
		If UBound(arrPathPingWords) &gt; 0 Then
			If arrPathPingWords(0) = &quot;0&quot; Then
				strIPAddress = arrPathPingWords(1)
				Exit For
			End If
		End If	
	Next
	
	Set objShell = Nothing
	Set objScriptExec = Nothing
	Set objReg = Nothing

	If Not IsNull(strIPAddress) Then
		GetTaniumIPAddress = strIPAddress
	Else
		GetTaniumIPAddress = False
	End If
End Function &#039;GetTaniumIPAddress


Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
88,Security,2015-01-05T20:22:02,|,"Returns information on the BitLocker status of a machine.
Example: Drive | Device ID | Encryption Method",1,1281370578,0,173,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,BitLocker Details,,,,,,,,,Windows,"&#039;========================================
&#039; BitLocker Details
&#039;========================================

strComputer = &quot;.&quot;
Dim objWMIService
On Error Resume Next
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\CIMV2\Security\MicrosoftVolumeEncryption&quot;)
On Error Goto 0

If IsEmpty(objWMIService) Then
	&#039; Don&#039;t output any values --- just exit.  This matches other
	&#039; OSes where BitLocker is available, but not in use.
	WScript.Quit
End If 
 
Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_EncryptableVolume&quot;,,48)
Dim arEncryptionMethod
arEncryptionMethod = Array(&quot;None&quot;, &quot;AES 128 With Diffuser&quot;, &quot;AES 256 With Diffuser&quot;, &quot;AES 128&quot;, &quot;AES 256&quot;)
Dim arProtectionStatus
arProtectionStatus = Array(&quot;Protection Off&quot;, &quot;Protection On&quot;, &quot;Protection Unknown&quot;)
Dim arConversionStatus
arConversionStatus = Array(&quot;Fully Decrypted&quot;, &quot;Fully Encrypted&quot;, &quot;Encryption In Progress&quot;, &quot;Decryption In Progress&quot;, &quot;Encryption Paused&quot;, &quot;Decryption Paused&quot;)
Dim arLockStatus
arLockStatus = Array(&quot;Unlocked&quot;, &quot;Locked&quot;)
For Each objItem in colItems
 Dim EncryptionMethod
 Dim ProtectionStatus
 Dim ConversionStatus
 Dim EncryptionPercentage &#039;Percentage of the volume that is encrypted
 Dim VolumeKeyProtectorID
 Dim LockStatus
 
 objItem.GetEncryptionMethod EncryptionMethod
 objItem.GetProtectionStatus ProtectionStatus
 objItem.GetConversionStatus ConversionStatus, EncryptionPercentage
 objItem.GetKeyProtectors 0,VolumeKeyProtectorID
 objItem.GetLockStatus LockStatus
 
 strSep = &quot;|&quot;
 
 &#039;Drive Letter, Device ID, Encryption Method, Protection Status, Conversion Status, Encryption Percentage, Lock Status
 
 Wscript.Echo _
 	objItem.DriveLetter &amp; strSep &amp; _
 	arEncryptionMethod(EncryptionMethod) &amp; strSep &amp; _
 	arProtectionStatus(ProtectionStatus) &amp; strSep &amp; _
 	arConversionStatus(ConversionStatus) &amp; strSep &amp; _
 	EncryptionPercentage &amp; &quot;%&quot; &amp; strSep &amp; _
 	arLockStatus(LockStatus)
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Drive,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Device ID,String,0,1,2,Encryption Method,String,0,1,3,Protection Status,String,0,1,4,Conversion Status,String,0,1,5,Encryption Percentage,String,0,1,6,Lock Status,String,,,,,,,,,,,,,,,,String
89,Software,2015-01-05T20:22:02,",","Returns the number of application crashes that have occurred in the last number of days supplied to the sensor.
Example: 3",1,3027378756,0,175,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Number of Application Crashes in Last X Days,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Number of Application Crashes in Last X Days
&#039;========================================

Option Explicit
Dim strSep
Dim objWMIService, colEvents, objEvent
Dim dtmStart

strSep = &quot;|&quot;

&#039;Uses date math - set locale

SetLocale(1033)


dtmStart = GetTimeWrittenByDaysOld(||days||)

Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\.\root\cimv2&quot;) 

Set colEvents = objWMIService.ExecQuery _
    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _
        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _
        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)

Dim numCrashes
numCrashes = 0

For Each objEvent In colEvents
    Dim strMessage, arrLines, strLine, strApp, strModule, strTime
    
    strMessage = objEvent.Message
    arrLines = Split(strMessage, vbCrLf)
    
    Dim strIndex, strIndexXp

	&#039;just go through first line of log to grab app name
	strLine = arrLines(0)
	
	&#039;strIndex is for new OSes, strIndexXP for older...
	strIndex = &quot;Faulting application name: &quot;
	strIndexXp = &quot;Faulting application &quot;
	If Left(strLine, Len(strIndex)) = strIndex Then
		strApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)
	ElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then
		strApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)
	End If
	
    strTime = DatetimeToDate(objEvent.TimeWritten)
    	 
	If Not IsNull(strApp) And Not IsEmpty(strApp) Then
		numCrashes = numCrashes + 1
	End If
Next

WScript.Echo numCrashes

Function DatetimeToDate(strDate)
   DatetimeToDate = _
       CDate(Mid(strDate, 5, 2) &amp; _
       &quot;/&quot; &amp; _
       Mid(strDate, 7, 2) &amp; _
       &quot;/&quot; &amp; _
       Left(strDate, 4) &amp; _
       &quot; &quot; &amp; _
       Mid (strDate, 9, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 11, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 13, 2))
End Function

Function GetTimeWrittenByDaysOld(days)
   &#039;subtract &quot;days&quot; days worth of seconds

	Dim epoc, monthAgo   
   	epoc = date2epoch(Now()) - days*24*60*60
   	monthAgo = epoch2date(epoc)
   
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate monthAgo, True
	 
  	GetTimeWrittenByDaysOld = dateTime
End Function

function date2epoch(myDate)
   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)
end Function

function epoch2date(myEpoch)
   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)
end Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||days||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||days||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
90,Hardware,2015-01-05T20:22:02,",","The machine or chassis type for the machine.
Example: Server or Virtual",1,2728641061,0,177,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,Chassis Type,,,,,,,,,Windows,"&#039;========================================
&#039; Chassis Type
&#039;========================================

On Error Resume Next

strResult = &quot;Unknown&quot;

If IsVM Then
	strResult = &quot;Virtual&quot;
Else
	Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colChassis = objWMIService.ExecQuery(&quot;Select * from Win32_SystemEnclosure&quot;)
	
	For Each objChassis in colChassis
	    For  Each strChassisType in objChassis.ChassisTypes
	        Select Case strChassisType
	            Case 1
	                strResult = &quot;Other&quot;
	            Case 2
	                strResult = &quot;Unknown&quot;
	            Case 3
	                strResult = &quot;Desktop&quot;
	            Case 4
	                strResult = &quot;Low Profile Desktop&quot;
	            Case 5
	                strResult = &quot;Pizza Box&quot;
	            Case 6
	                strResult = &quot;Mini Tower&quot;
	            Case 7
	                strResult = &quot;Tower&quot;
	            Case 8
	                strResult = &quot;Portable&quot;
	            Case 9
	                strResult = &quot;Laptop&quot;
	            Case 10
	                strResult = &quot;Notebook&quot;
	            Case 11
	                strResult = &quot;Handheld&quot;
	            Case 12
	                strResult = &quot;Docking Station&quot;
	            Case 13
	                strResult = &quot;All-in-One&quot;
	            Case 14
	                strResult = &quot;Sub-Notebook&quot;
	            Case 15
	                strResult = &quot;Space Saving&quot;
	            Case 16
	                strResult = &quot;Lunch Box&quot;
	            Case 17
	                strResult = &quot;Main System Chassis&quot;
	            Case 18
	                strResult = &quot;Expansion Chassis&quot;
	            Case 19
	                strResult = &quot;Sub-Chassis&quot;
	            Case 20
	                strResult = &quot;Bus Expansion Chassis&quot;
	            Case 21
	                strResult = &quot;Peripheral Chassis&quot;
	            Case 22
	                strResult = &quot;Storage Chassis&quot;
	            Case 23
	                strResult = &quot;Rack Mount Chassis&quot;
	            Case 24
	                strResult = &quot;Sealed-Case PC&quot;
	            Case Else
	                strResult = &quot;Unknown&quot;
	            End Select
	    Next
	Next
End If 

WScript.Echo strResult

Function IsVM
	Dim sVMPlatform, sMake, sModel, sBIOSVersion,bIsVM

    &#039; Check the WMI information against known values

    bIsVM = false
    sVMPlatform = &quot;&quot;

    sMake = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Manufacturer&quot;)
    sModel = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Model&quot;)
    sBIOSVersion = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_BIOS&quot;, &quot;Version&quot;)

    &#039;WScript.Echo &quot;Manufacturer=&quot; &amp; sMake
    &#039;WScript.Echo &quot;Model=&quot; &amp; sModel
    &#039;WScript.Echo &quot;BIOSVersion=&quot; &amp; sBIOSVersion

    If sModel = &quot;Virtual Machine&quot; then

        &#039; Microsoft virtualization technology detected, assign defaults

        sVMPlatform = &quot;Hyper-V&quot;
        bIsVM = true

        &#039; Try to determine more specific values

        Select Case sBIOSVersion
        Case &quot;VRTUAL - 1000831&quot;
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 Beta or RC0&quot;
        Case &quot;VRTUAL - 5000805&quot;, &quot;BIOS Date: 05/05/08 20:35:56  Ver: 08.00.02&quot;
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 RTM&quot;
        Case &quot;VRTUAL - 3000919&quot; 
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 R2&quot;
        Case &quot;A M I  - 2000622&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005R2SP1 or VPC2007&quot;
        Case &quot;A M I  - 9000520&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005R2&quot;
        Case &quot;A M I  - 9000816&quot;, &quot;A M I  - 6000901&quot;
            bIsVM = true
            sVMPlatform = &quot;Windows Virtual PC&quot;
        Case &quot;A M I  - 8000314&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005 or VPC2004&quot;
        Case &quot;Xen - 0s&quot;
        	bIsVM = True
        	sVMPlatform = &quot;Xen&quot;
        Case &quot;Xen - 0&quot;
            bIsVM = True
            sVMPlatform = &quot;Xen&quot;
        End Select

    ElseIf sModel = &quot;VMware Virtual Platform&quot; then

        &#039; VMware detected

        sVMPlatform = &quot;VMware&quot;
        bIsVM = true

    ElseIf sModel  = &quot;VirtualBox&quot; then

        &#039; VirtualBox detected

        bIsVM = true
        sVMPlatform = &quot;VirtualBox&quot;

    Else 
        &#039; This computer does not appear to be a virtual machine.
    End if

    &#039; Set the return value

    If bIsVM Then
    	&#039; Let&#039;s not actually do anything here 
        &#039;WScript.Echo &quot;IsVirtualMachine=True&quot;
        &#039;WScript.Echo &quot;VirtualMachinePlatform=&quot; &amp; sVMPlatform
    Else
        &#039;WScript.Echo &quot;IsVirtualMachine=False&quot;
    End If

    IsVM = bIsVM

End Function

Function GetWmiPropertyValue(strNameSpace, strClassName, strPropertyName)
	Dim strPropertyValue, oWMIClass, oWMIProperties, objWMIService, colItems
	Dim objItem, objProperty
	Dim sLine
	
    On Error Resume Next

    strPropertyValue = &quot;&quot;
    set oWmiClass = getobject(&quot;winmgmts:&quot; &amp; strNameSpace).get(strClassName,&amp;h20000) &#039;amended
    set oWmiProperties = oWmiClass.Properties_

    Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; &quot;.&quot; &amp; &quot;\&quot; &amp; strNameSpace)
    Set colItems = objWMIService.ExecQuery(&quot;Select * from &quot; &amp; strClassName,,48)

    For Each objItem in colItems
        For Each objProperty in oWmiProperties
            sLine = &quot;&quot;
            &#039;WScript.Echo &quot;- &quot; &amp; objProperty.name &amp; &quot;: &quot; &amp; strPropertyName

            If objProperty.Name = strPropertyName Then
                If objProperty.IsArray = True Then
                    sLine = &quot;str&quot; &amp; objProperty.Name &amp; &quot; = Join(objItem.&quot; &amp; objProperty.Name &amp; &quot;, &quot; &amp; Chr(34) &amp; &quot;,&quot; &amp; Chr(34) &amp; &quot;)&quot; &amp; vbCrLf
                    sLine = sLine &amp; &quot;strPropertyValue =  str&quot; &amp; objProperty.Name
                &#039;ElseIf objProperty.CIMTYPE = 101 Then
                &#039;    bHasDates = True
                &#039;    sLine =  &quot;strPropertyValue =  WMIDateStringToDate(objItem.&quot; &amp; objProperty.Name &amp; &quot;)&quot;
                Else
                    sLine =  &quot;strPropertyValue =  objItem.&quot; &amp; objProperty.Name
                End If

                &#039;WScript.Echo sLine
                Execute sLine
            End If

        Next
    Next

    GetWmiPropertyValue = strPropertyValue
    
    &#039;Cleanup!
    set oWmiClass = Nothing
    set oWmiProperties = Nothing

    Set objWMIService = Nothing
    Set colItems = Nothing

End Function",VBScript,Linux,"#!/bin/bash
dmidecode -s chassis-type
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
91,Hardware,2015-01-05T20:22:02,|,"Returns details of attached physical monitors.
Example: Model Name, Serial Number, VESA Manufacturer ID, Manufacture Date",1,1502679547,0,179,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,Monitor Details,,,,,,,,,Windows,"&#039;========================================
&#039; Monitor Details
&#039;========================================

Option Explicit
Dim strSep
strSep = &quot;|&quot;
Dim WshShell
Set WshShell = WScript.CreateObject(&quot;WScript.Shell&quot;)
Dim strComputer, message

Dim intMonitorCount
Dim oRegistry, sBaseKey, sBaseKey2, sBaseKey3, skey, skey2, skey3
Dim sValue
dim i, iRC, iRC2, iRC3
Dim arSubKeys, arSubKeys2, arSubKeys3, arrintEDID
Dim strRawEDID
Dim ByteValue, strSerFind, strMdlFind
Dim intSerFoundAt, intMdlFoundAt, findit
Dim tmp, tmpser, tmpmdl, tmpctr
Dim batch, bHeader
batch = False

strComputer = &quot;.&quot;

If strcomputer = &quot;&quot; Then WScript.Quit
strComputer = UCase(strComputer)

If batch Then
Dim fso,logfile, appendout
logfile = wshShell.ExpandEnvironmentStrings(&quot;%userprofile%&quot;) &amp; &quot;\desktop\MonitorInfo.csv&quot;

&#039;setup Log
Const ForAppend = 8
Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
If Not fso.FileExists(logfile) Then bHeader = True
set appendout = fso.OpenTextFile(logfile, ForAppend, True)

If bHeader Then
appendout.writeline &quot;Computer,Model,Serial #,Vendor ID,Manufacture Date,Messages&quot;
End If
End If

Dim strarrRawEDID()
intMonitorCount=0
Const HKLM = &amp;H80000002 &#039;HKEY_LOCAL_MACHINE
&#039;get a handle to the WMI registry object
On Error Resume Next
Set oRegistry = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;/root/default:StdRegProv&quot;)

If Err &lt;&gt; 0 Then
If batch Then
EchoAndLog strComputer &amp; &quot;,,,,,&quot; &amp; Err.Description
Else
WScript.echo &quot;Failed. &quot; &amp; Err.Description,vbCritical + vbOKOnly,strComputer
WScript.Quit
End If
End If


sBaseKey = &quot;SYSTEM\CurrentControlSet\Enum\DISPLAY\&quot;
&#039;enumerate all the keys HKLM\SYSTEM\CurrentControlSet\Enum\DISPLAY\ 
iRC = oRegistry.EnumKey(HKLM, sBaseKey, arSubKeys)
For Each sKey In arSubKeys
&#039;we are now in the registry at the level of:
&#039;HKLM\SYSTEM\CurrentControlSet\Enum\DISPLAY\&lt;VESA_Monitor_ID\ 
&#039;we need to dive in one more level and check the data of the &quot;HardwareID&quot; value
sBaseKey2 = sBaseKey &amp; sKey &amp; &quot;\&quot;
iRC2 = oRegistry.EnumKey(HKLM, sBaseKey2, arSubKeys2)
For Each sKey2 In arSubKeys2
&#039;now we are at the level of:
&#039;HKLM\SYSTEM\CurrentControlSet\Enum\DISPLAY\&lt;VESA_Monitor_ID\&lt;PNP_ID&gt;\ 
&#039;so we can check the &quot;HardwareID&quot; value
oRegistry.GetMultiStringValue HKLM, sBaseKey2 &amp; sKey2 &amp; &quot;\&quot;, &quot;HardwareID&quot;, sValue
for tmpctr=0 to ubound(svalue)
If lcase(left(svalue(tmpctr),8))=&quot;monitor\&quot; then
&#039;If it is a monitor we will check for the existance of a control subkey
&#039;that way we know it is an active monitor
sBaseKey3 = sBaseKey2 &amp; sKey2 &amp; &quot;\&quot;
iRC3 = oRegistry.EnumKey(HKLM, sBaseKey3, arSubKeys3)
For Each sKey3 In arSubKeys3
&#039;Kaplan edit
strRawEDID = &quot;&quot;
If skey3=&quot;Control&quot; Then
&#039;If the Control sub-key exists then we should read the edid info
oRegistry.GetBinaryValue HKLM, sbasekey3 &amp; &quot;Device Parameters\&quot;, &quot;EDID&quot;, arrintEDID
If vartype(arrintedid) &lt;&gt; 8204 then &#039;and If we don&#039;t find it...
strRawEDID=&quot;EDID Not Available&quot; &#039;store an &quot;unavailable message
else
for each bytevalue in arrintedid &#039;otherwise conver the byte array from the registry into a string (for easier processing later)
strRawEDID=strRawEDID &amp; chr(bytevalue)
Next
End If
&#039;now take the string and store it in an array, that way we can support multiple monitors
redim preserve strarrRawEDID(intMonitorCount)
strarrRawEDID(intMonitorCount)=strRawEDID
intMonitorCount=intMonitorCount+1
End If
Next
End If
Next
Next
Next
&#039;*****************************************************************************************
&#039;now the EDID info for each active monitor is stored in an array of strings called strarrRawEDID
&#039;so we can process it to get the good stuff out of it which we will store in a 5 dimensional array
&#039;called arrMonitorInfo, the dimensions are as follows:
&#039;0=VESA Mfg ID, 1=VESA Device ID, 2=MFG Date (M/YYYY),3=Serial Num (If available),4=Model Descriptor
&#039;5=EDID Version
&#039;*****************************************************************************************
On Error Resume Next
dim arrMonitorInfo()
redim arrMonitorInfo(intMonitorCount-1,5)
dim location(3)
for tmpctr=0 to intMonitorCount-1
If strarrRawEDID(tmpctr) &lt;&gt; &quot;EDID Not Available&quot; then
&#039;*********************************************************************
&#039;first get the model and serial numbers from the vesa descriptor
&#039;blocks in the edid. the model number is required to be present
&#039;according to the spec. (v1.2 and beyond)but serial number is not
&#039;required. There are 4 descriptor blocks in edid at offset locations
&#039;&amp;H36 &amp;H48 &amp;H5a and &amp;H6c each block is 18 bytes long
&#039;*********************************************************************
location(0)=mid(strarrRawEDID(tmpctr),&amp;H36+1,18)
location(1)=mid(strarrRawEDID(tmpctr),&amp;H48+1,18)
location(2)=mid(strarrRawEDID(tmpctr),&amp;H5a+1,18)
location(3)=mid(strarrRawEDID(tmpctr),&amp;H6c+1,18)

&#039;you can tell If the location contains a serial number If it starts with &amp;H00 00 00 ff
strSerFind=chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;Hff)
&#039;or a model description If it starts with &amp;H00 00 00 fc
strMdlFind=chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;Hfc)

intSerFoundAt=-1
intMdlFoundAt=-1
for findit = 0 to 3
If instr(location(findit),strSerFind)&gt;0 then
intSerFoundAt=findit
End If
If instr(location(findit),strMdlFind)&gt;0 then
intMdlFoundAt=findit
End If
Next

&#039;If a location containing a serial number block was found then store it
If intSerFoundAt&lt;&gt;-1 then
tmp=right(location(intSerFoundAt),14)
If instr(tmp,chr(&amp;H0a))&gt;0 then
tmpser=trim(left(tmp,instr(tmp,chr(&amp;H0a))-1))
Else
tmpser=trim(tmp)
End If
&#039;although it is not part of the edid spec it seems as though the
&#039;serial number will frequently be preceeded by &amp;H00, this
&#039;compensates for that
If left(tmpser,1)=chr(0) then tmpser=right(tmpser,len(tmpser)-1)
else
tmpser=&quot;Not Found&quot;
End If

&#039;If a location containing a model number block was found then store it
If intMdlFoundAt&lt;&gt;-1 then
tmp=right(location(intMdlFoundAt),14)
If instr(tmp,chr(&amp;H0a))&gt;0 then
tmpmdl=trim(left(tmp,instr(tmp,chr(&amp;H0a))-1))
else
tmpmdl=trim(tmp)
End If
&#039;although it is not part of the edid spec it seems as though the
&#039;serial number will frequently be preceeded by &amp;H00, this
&#039;compensates for that
If left(tmpmdl,1)=chr(0) then tmpmdl=right(tmpmdl,len(tmpmdl)-1)
else
tmpmdl=&quot;Not Found&quot;
End If

&#039;**************************************************************
&#039;Next get the mfg date
&#039;**************************************************************
Dim tmpmfgweek,tmpmfgyear,tmpmdt
&#039;the week of manufacture is stored at EDID offset &amp;H10
tmpmfgweek=asc(mid(strarrRawEDID(tmpctr),&amp;H10+1,1))

&#039;the year of manufacture is stored at EDID offset &amp;H11
&#039;and is the current year -1990
tmpmfgyear=(asc(mid(strarrRawEDID(tmpctr),&amp;H11+1,1)))+1990

&#039;store it in month/year format
tmpmdt=month(dateadd(&quot;ww&quot;,tmpmfgweek,datevalue(&quot;1/1/&quot; &amp; tmpmfgyear))) &amp; &quot;/&quot; &amp; tmpmfgyear

&#039;**************************************************************
&#039;Next get the edid version
&#039;**************************************************************
&#039;the version is at EDID offset &amp;H12
Dim tmpEDIDMajorVer, tmpEDIDRev, tmpVer
tmpEDIDMajorVer=asc(mid(strarrRawEDID(tmpctr),&amp;H12+1,1))

&#039;the revision level is at EDID offset &amp;H13
tmpEDIDRev=asc(mid(strarrRawEDID(tmpctr),&amp;H13+1,1))

&#039;store it in month/year format
tmpver=chr(48+tmpEDIDMajorVer) &amp; &quot;.&quot; &amp; chr(48+tmpEDIDRev)

&#039;**************************************************************
&#039;Next get the mfg id
&#039;**************************************************************
&#039;the mfg id is 2 bytes starting at EDID offset &amp;H08
&#039;the id is three characters long. using 5 bits to represent
&#039;each character. the bits are used so that 1=A 2=B etc..
&#039;
&#039;get the data
Dim tmpEDIDMfg, tmpMfg
dim Char1, Char2, Char3
Dim Byte1, Byte2
tmpEDIDMfg=mid(strarrRawEDID(tmpctr),&amp;H08+1,2)
Char1=0 : Char2=0 : Char3=0
Byte1=asc(left(tmpEDIDMfg,1)) &#039;get the first half of the string
Byte2=asc(right(tmpEDIDMfg,1)) &#039;get the first half of the string
&#039;now shift the bits
&#039;shift the 64 bit to the 16 bit
If (Byte1 and 64) &gt; 0 then Char1=Char1+16
&#039;shift the 32 bit to the 8 bit
If (Byte1 and 32) &gt; 0 then Char1=Char1+8
&#039;etc....
If (Byte1 and 16) &gt; 0 then Char1=Char1+4
If (Byte1 and 8) &gt; 0 then Char1=Char1+2
If (Byte1 and 4) &gt; 0 then Char1=Char1+1

&#039;the 2nd character uses the 2 bit and the 1 bit of the 1st byte
If (Byte1 and 2) &gt; 0 then Char2=Char2+16
If (Byte1 and 1) &gt; 0 then Char2=Char2+8
&#039;and the 128,64 and 32 bits of the 2nd byte
If (Byte2 and 128) &gt; 0 then Char2=Char2+4
If (Byte2 and 64) &gt; 0 then Char2=Char2+2
If (Byte2 and 32) &gt; 0 then Char2=Char2+1

&#039;the bits for the 3rd character don&#039;t need shifting
&#039;we can use them as they are
Char3=Char3+(Byte2 and 16)
Char3=Char3+(Byte2 and 8)
Char3=Char3+(Byte2 and 4)
Char3=Char3+(Byte2 and 2)
Char3=Char3+(Byte2 and 1)
tmpmfg=chr(Char1+64) &amp; chr(Char2+64) &amp; chr(Char3+64)

&#039;**************************************************************
&#039;Next get the device id
&#039;**************************************************************
&#039;the device id is 2bytes starting at EDID offset &amp;H0a
&#039;the bytes are in reverse order.
&#039;this code is not text. it is just a 2 byte code assigned
&#039;by the manufacturer. they should be unique to a model
Dim tmpEDIDDev1, tmpEDIDDev2, tmpDev

tmpEDIDDev1=hex(asc(mid(strarrRawEDID(tmpctr),&amp;H0a+1,1)))
tmpEDIDDev2=hex(asc(mid(strarrRawEDID(tmpctr),&amp;H0b+1,1)))
If len(tmpEDIDDev1)=1 then tmpEDIDDev1=&quot;0&quot; &amp; tmpEDIDDev1
If len(tmpEDIDDev2)=1 then tmpEDIDDev2=&quot;0&quot; &amp; tmpEDIDDev2
tmpdev=tmpEDIDDev2 &amp; tmpEDIDDev1

&#039;**************************************************************
&#039;finally store all the values into the array
&#039;**************************************************************
&#039;Kaplan adds code to avoid duplication...

If Not InArray(tmpser,arrMonitorInfo,3) Then
arrMonitorInfo(tmpctr,0)=tmpmfg
arrMonitorInfo(tmpctr,1)=tmpdev
arrMonitorInfo(tmpctr,2)=tmpmdt
arrMonitorInfo(tmpctr,3)=tmpser
arrMonitorInfo(tmpctr,4)=tmpmdl
arrMonitorInfo(tmpctr,5)=tmpVer
End If
End If
Next

&#039;For now just a simple screen print will suffice for output.
&#039;But you could take this output and write it to a database or a file
&#039;and in that way use it for asset management.
i = 0
for tmpctr = 0 to intMonitorCount-1
If arrMonitorInfo(tmpctr,1) &lt;&gt; &quot;&quot; And arrMonitorInfo(tmpctr,0) &lt;&gt; &quot;PNP&quot; Then
If batch Then
EchoAndLog strComputer &amp; &quot;,&quot; &amp; arrMonitorInfo(tmpctr,4) &amp; &quot;,&quot; &amp; _
arrMonitorInfo(tmpctr,3)&amp; &quot;,&quot; &amp; arrMonitorInfo(tmpctr,0) &amp; &quot;,&quot; &amp; _
arrMonitorInfo(tmpctr,2)
Else
Dim strModel, strSerial, strVesa, strManDate
strModel = arrMonitorInfo(tmpctr,4)
strSerial = arrMonitorInfo(tmpctr,3)
strVesa = arrMonitorInfo(tmpctr,0)
strManDate = arrMonitorInfo(tmpctr,2)

message = message &amp; &quot;Monitor &quot; &amp; chr(i+65) &amp; &quot;)&quot; &amp; VbCrLf &amp; _
&quot;Model Name: &quot; &amp; arrMonitorInfo(tmpctr,4) &amp; VbCrLf &amp; _
&quot;Serial Number: &quot; &amp; arrMonitorInfo(tmpctr,3)&amp; VbCrLf &amp; _
&quot;VESA Manufacturer ID: &quot; &amp; arrMonitorInfo(tmpctr,0) &amp; VbCrLf &amp; _
&quot;Manufacture Date: &quot; &amp; arrMonitorInfo(tmpctr,2) &amp; VbCrLf &amp; vbCrLf

If InStr(strManDate, &quot;/&quot;) &gt; 0 Then
	Dim words
	words = Split(strManDate, &quot;/&quot;)
	If UBound(words) &gt; 0 Then
		strManDate = words(1) &amp; &quot;-&quot; &amp; words(0)
	End If
End If

WScript.Echo _
	strModel &amp; strSep &amp;_
	strSerial &amp; strSep &amp;_
	strVesa &amp; strSep &amp;_
	strManDate

&#039;wscript.echo &quot;..........&quot; &amp; &quot;Device ID: &quot; &amp; arrMonitorInfo(tmpctr,1)
&#039;wscript.echo &quot;..........&quot; &amp; &quot;EDID Version: &quot; &amp; arrMonitorInfo(tmpctr,5)
i = i + 1
End If
End If
Next

If not batch Then
&#039; WScript.echo message , vbInformation + vbOKOnly,strComputer &amp; &quot; Monitor Info&quot;
End If

Function InArray(strValue,List,Col)
Dim i
For i = 0 to UBound(List)
If List(i,col) = cstr(strValue) Then
InArray = True
Exit Function
End If
Next
InArray = False
End Function

Sub EchoAndLog (message)
&#039;Echo output and write to log
Wscript.Echo message
AppendOut.WriteLine message
End Sub",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Model Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Serial Number,String,0,1,2,VESA Manufacturer ID,String,0,1,3,Manufacture Date,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
92,Hardware,2015-01-05T20:22:02,|,"A multi-column sensor that provides CPU details: system type, CPU description, speed, # of processors, # of cores, and # of logical processors.
Example: x64-based PC | Intel(R) Xeon(R) CPU X3430 | 2390 Mhz | 1 | 4 | 4",1,4055028299,0,181,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,CPU Details,,,,,,,,,Windows,"&#039;========================================
&#039; CPU Details
&#039;========================================

On Error Resume Next

strComputer = &quot;.&quot; 
Set objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)
Set colCSes = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_ComputerSystem&quot;)

For Each objCS In colCSes
	systemType = objCS.SystemType
	If(Left(systemType, 1) = &quot;X&quot;) Then 
		systemType = &quot;x&quot; &amp; Right(systemType, Len(systemType) -1)
	End If 
	numProcessors = objCS.NumberOfProcessors
Next

numCores = 0
numLogicalProcessors = 0
Dim strProcName, intSpeed, strSpeed

Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) 
For Each objItem in colItems 
	numCores = numCores + CInt(objItem.NumberOfCores)
	numLogicalProcessors = numLogicalProcessors + CInt(objItem.NumberOfLogicalProcessors)
	strProcName = objItem.Name
	intSpeed = objItem.MaxClockSpeed
Next


if instr(strProcName, &quot;@&quot;) &gt; 0 Then
	strProcName = Trim(Left(strProcName, InStr(strProcName, &quot;@&quot;) - 1))
End If

&#039;Check all properties to make sure they exist
strProcName = CleanWhitespace(trim(strProcName))
If strProcName = &quot;&quot; Then
	strProcName = &quot;N/A&quot;
End If

If intSpeed = &quot;&quot; Then
	strSpeed = &quot;N/A&quot;
Else
	intSpeed = CInt(intSpeed/10)*10
	strSpeed = CStr(intSpeed) &amp; &quot; Mhz&quot;
End If

If numProcessors = 0 Then
	numProcessors = &quot;N/A&quot;
End If

strOs = GetOS
If numLogicalProcessors = 0 Then
	&#039;if this is not available, then numProcessors
	&#039;is actually the Logical Processors count

	numLogicalProcessors = numProcessors

	&#039;Windows 2000 isn&#039;t supported for logical processors
	If InStr(strOs, &quot;2000&quot;) &gt; 0 Then
		numProcessors = &quot;Unsupported&quot;
	ElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then
		numProcessors = &quot;XP SP3 Required&quot;
	ElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then
		&#039;For Win Server 2003 SEE KB 932370
		&#039;http://support.microsoft.com/kb/932370/
		numProcessors = &quot;KB932370 Required&quot;
	Else
		numProcessors = &quot;N/A&quot;
	End If
End If

If numCores = 0 Then
	&#039;Windows 2000 isn&#039;t supported for cores
	If InStr(strOs, &quot;2000&quot;) &gt; 0 Then
		numCores = &quot;Unsupported&quot;
	ElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then
		numCores = &quot;SP3 Required&quot;
	ElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then
		&#039;For Win Server 2003 SEE KB 932370
		&#039;http://support.microsoft.com/kb/932370/
		numCores = &quot;KB932370 Required&quot;
	Else
		numCores = &quot;N/A&quot;
	End If
End If



WScript.Echo _
	systemType &amp; &quot;|&quot; &amp; _
	strProcName &amp; &quot;|&quot; &amp; _
	strSpeed &amp; &quot;|&quot; &amp; _
	numProcessors &amp; &quot;|&quot; &amp; _
	numCores &amp; &quot;|&quot; &amp; _
	numLogicalProcessors
	
Function CleanWhitespace(strStarter)
	intStarter = Len(strStarter)
	For i = intStarter to 2 Step -1
		strChars = Space(i)
		strStarter = Replace(strStarter, strChars, &quot; &quot;)
	Next
	cleanWhitespace = strStarter
End Function

Function GetOS
	Set oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    
	Set oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)    
	Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    
	For Each objItem In colItems       
	strStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   
	&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   
	if Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   
	strOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   
	Else   
	strOS = strStrip1
	End IF   
	GetOS = Trim(strOS)
	Next
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,System Type,Numeric,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,CPU,Numeric,0,1,2,CPU Speed,Numeric,0,1,3,Total Physical Processors,Numeric,0,1,4,Total Cores,Numeric,0,1,5,Total Logical Processors,Numeric,,,,,,,,,,,,,,,,,,,,,Numeric
93,Hardware,2015-01-05T20:22:02,",","Current total CPU consumption in %.
Example: 50%",1,1260646358,0,183,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,CPU Consumption,,,,,,,,,Windows,"&#039;========================================
&#039; CPU Consumption
&#039;========================================

Const HKLM = &amp;H80000002 
strComputer = &quot;.&quot;

Set objWMIService = _
  	GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)

Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)
For Each objItem in colProcItems
	N1 = objItem.PercentProcessorTime
	D1 = objItem.TimeStamp_Sys100NS
Next

WScript.sleep(3000)
	
Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)
For Each objItem in colProcItems
	N2 = objItem.PercentProcessorTime
	D2 = objItem.TimeStamp_Sys100NS
Next

numLogicalProcessors = 0

Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) 
For Each objItem in colItems 
	Dim intLogicalProcessors 
	intLogicalProcessors = 1
	
	On Error Resume Next
	intLogicalProcessors = CInt(objItem.NumberOfLogicalProcessors)
	On Error Goto 0

	numLogicalProcessors = numLogicalProcessors + intLogicalProcessors
Next

&#039; CounterType - PERF_100NSEC_TIMER
&#039; Formula = ((N2 - N1) / (D2 - D1)) x 100
If ( 0 = (D2-D1) ) Or D1 &gt; D2 then
	WScript.echo &quot;System Timestamp Error&quot;
ElseIf N1 &gt; N2 Then
	WScript.Echo &quot;Performance Counter Error&quot;
Else
	percentage = Round(100 - ((N2 - N1) / (D2 - D1)) * 100 / numLogicalProcessors, 0)
	WScript.echo percentage &amp; &quot; %&quot;
End if

Set wmi_service = nothing",VBScript,Linux,"#!/bin/bash
cpu=`top -bn 1 | awk &#039;{print $9}&#039; | tail -n +8 | awk &#039;{s+=$1} END {print s}&#039;`
echo &quot;${cpu} %&quot;
",UnixShell,Mac,"#!/bin/bash
cpu=$(top -o cpu -l1 | awk &#039;{print substr($0,24,5)}&#039; | tail -n +13 | awk &#039;{s+=$1} END {print s}&#039;) ; echo ${cpu} %
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
94,Hardware,2015-01-05T20:22:02,",","Descriptions of any installed disk drives, including external or USB drives.
Example: ST3808110AS ATA Device",1,945314213,0,185,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Disk Drives,,,,,,,,,Windows,select Caption from Win32_DiskDrive,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
95,Hardware,2015-01-05T20:22:02,",","The amount of total disk space per drive.
Example: C: 100 GB",1,4244410676,0,187,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,Disk Total Space,,,,,,,,,Windows,"&#039;========================================
&#039; Disk Total Space
&#039;========================================

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; _
    &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colDisks = objWMIService.ExecQuery _
    (&quot;Select * from Win32_LogicalDisk&quot;)
For Each objDisk in colDisks
 &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID
    
    If Not IsNull(objDisk.Size) Then
	    dblSize = CDbl(objDisk.Size)
	    dblSize = dblSize / 1024 / 1024 / 1024
	    intSize = CInt(dblSize)
		WScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intSize &amp; &quot; GB&quot;
    End If
Next",VBScript,Linux,"#!/bin/bash
df -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line
do
	set -- $line
	echo $7: $3
done
",UnixShell,Mac,"#!/bin/bash
df -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\// { print $9&quot;: &quot; $2 }&#039;
",UnixShell,0,8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
96,Hardware,2015-01-05T20:22:02,",","The amount of free disk space per drive.
Example: C: 40 GB",1,1302957088,0,189,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Disk Free Space,,,,,,,,,Windows,"&#039;========================================
&#039; Disk Free Space
&#039;========================================

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; _
    &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colDisks = objWMIService.ExecQuery _
    (&quot;Select * from Win32_LogicalDisk&quot;)

For Each objDisk in colDisks
  If Not IsNull(objDisk.FreeSpace) Then
    dblFree = CDbl(objDisk.FreeSpace)
    dblFree = dblFree / 1024 / 1024 / 1024
    intFree = CInt(dblFree)
    Wscript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intFree &amp; &quot; GB&quot;
  END IF
Next",VBScript,Linux,"#!/bin/bash
df -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line
do
	set -- $line
	echo $7: $5
done
",UnixShell,Mac,"#!/bin/bash
df -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\// { print $9&quot;: &quot; $4 }&#039;
",UnixShell,0,10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
97,Hardware,2015-01-05T20:22:02,",","The percentage of used disk space per partition.
Example: C: 24%",1,533135859,0,191,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Disk Used Percentage,,,,,,,,,Windows,"&#039;========================================
&#039; Disk Used Percentage
&#039;========================================

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; _
    &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colDisks = objWMIService.ExecQuery _
    (&quot;Select * from Win32_LogicalDisk&quot;)
For Each objDisk in colDisks
 &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID
    
    If Not IsNull(objDisk.Size) And Not IsNull(objDisk.FreeSpace) Then
        dblPercent = ((CDbl(objDisk.Size) - CDbl(objDisk.FreeSpace)) / CDbl(objDisk.Size)) * 100
        intPercent = CInt(dblPercent)
        WScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intPercent &amp; &quot;%&quot;
    End If
Next",VBScript,Linux,"#!/bin/bash
df -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line
do
    set -- $line
    echo $7: $6
done
",UnixShell,Mac,"#!/bin/bash
df -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\// { print $9&quot;: &quot; $5 }&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
98,Operating System,2015-01-05T20:22:02,",","File system type of the C drive.
Example: NTFS",1,2207214962,0,193,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Disk Type of C:,,,,,,,,,Windows,Select FileSystem from Win32_LogicalDisk where Caption = &#039;c:&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
99,Hardware,2015-01-05T20:22:02,",","Returns the total amount of installed RAM, in Megabytes.
Example: 2048 MB",1,4279567267,0,195,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,RAM,,,,,,,,,Windows,"&#039;========================================
&#039; RAM
&#039;========================================

strComputer = &quot;.&quot;

Set objWMIService = GetObject(&quot;winmgmts:&quot; _
&amp; &quot;{impersonationLevel=impersonate}!\\&quot; _
&amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colComputer = objWMIService.ExecQuery _
(&quot;Select * from Win32_ComputerSystem&quot;)

For Each objComputer in colComputer
   intRamMB = int((objComputer.TotalPhysicalMemory) /1048576)+1
   Wscript.Echo intRamMB &amp; &quot; MB&quot;
Next

WScript.Quit",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
100,Operating System,2015-01-05T20:22:02,",","Returns the percentage of used (committed) memory on a system.
Example: 27 percent",1,2177703669,0,197,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Memory Consumption,,,,,,,,,Windows,"&#039;========================================
&#039; Memory Consumption
&#039;========================================

Option Explicit

Dim objWMIService, colItems, objItem, strLinePercentCommittedBytesInUse

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
 
&#039;Gets MEMORY Usage
Set colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)
For Each objItem In colItems  
 strLinePercentCommittedBytesInUse = objItem.PercentCommittedBytesInUse
 wscript.echo strLinePercentCommittedBytesInUse &amp; &quot; %&quot;
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
101,Network,2015-01-05T20:22:02,|,"Returns information on network adapters.
Example:Intel(R) Centrino(R) Ultimate-N 6300 AGN|Intel Corporation|Ethernet 802.3|00:24:D7:21:9C:70|65 Mbps|Wi-Fi",1,3009680784,0,199,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,Network Adapter Details,,,,,,,,,Windows,"&#039;========================================
&#039; Network Adapter Details
&#039;========================================

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapter&quot;,,48)

Dim arrNdisAdapters
Set arrNdisAdapters = GetNdisArray

For Each objItem in colItems
	If _
		InStr(objItem.AdapterType, &quot;Ethernet&quot;) &gt; 0 Or _
		InStr(objItem.AdapterType, &quot;Wireless&quot;) &gt; 0 _
	Then
			
		dblSpeed = CDbl(objItem.Speed) / 1000000
		If (arrNdisAdapters.count &gt; 0) Then
			For Each objAdapter in arrNdisAdapters
				If objAdapter.InstanceName = objItem.Name Then
					dblSpeed = CDbl(objAdapter.NdisLinkSpeed) / 10000
				End If
			Next
		End If
		strSpeed = dblSpeed &amp; &quot; Mbps&quot;

		WScript.Echo _
			objItem.Name &amp; &quot;|&quot; &amp; _
			objItem.Manufacturer &amp; &quot;|&quot; &amp; _
			objItem.AdapterType &amp; &quot;|&quot; &amp; _
			objItem.MACAddress &amp; &quot;|&quot; &amp; _
			strSpeed &amp; &quot;|&quot; &amp; _
			objItem.NetConnectionID
	End If
Next

Function GetNdisArray
	Const cWMINameSpace = &quot;root/wmi&quot;
	Const cWMIInstance = &quot;MSNdis_LinkSpeed&quot;
	Const strComputerName = &quot;.&quot;
	
	Dim strWinMgmts, objWMI, listAdapters, objAdapter
	
	strWinMgMts = &quot;winmgmts:{impersonationLevel=impersonate}!//&quot; &amp; strComputerName &amp; &quot;/&quot; &amp; cWMINameSpace
	Set objWMI = GetObject(strWinMgMts)
	
	Set listAdapters = objWMI.InstancesOf(cWMIInstance)
	Set GetNdisArray = listAdapters
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Adapter Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Manufacturer,String,0,1,2,Adapter Type,String,0,1,3,MAC Address,String,0,1,4,Speed,String,0,1,5,Network Connection ID,String,,,,,,,,,,,,,,,,,,,,,String
102,Hardware,2015-01-05T20:22:02,",","Name of BIOS.
Example: Phoenix ROM BIOS PLUS Version 1.10 A10",1,367063513,0,201,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,BIOS Name,,,,,,,,,Windows,select Caption from win32_BIOS,WMIQuery,Linux,"#!/bin/sh
LINUX=`uname -o | grep -c -i linux`

if [ $LINUX -eq 1 ]
then
dmidecode -s bios-vendor
fi
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
103,Hardware,2015-01-05T20:22:02,",","Release date of the BIOS.
Example: 20080436.2.314.851300+000",1,3798171813,0,203,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,BIOS Release Date,,,,,,,,,Windows,"&#039; =================
&#039; BIOS Release Date
&#039; =================

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)

Set win32bios = objWMIService.ExecQuery(&quot;select * from win32_BIOS&quot;)

For Each objItem in win32bios

	Dim releaseDate, biosYear, biosMonth, biosDate
	releaseDate = objItem.ReleaseDate
	biosYear = Mid(releaseDate, 1, 4)
	biosMonth = Mid(releaseDate, 5, 2) 
    	biosDate = Mid(releaseDate, 7, 2)
	WScript.Echo biosMonth &amp; &quot;/&quot; &amp; biosDate &amp; &quot;/&quot; &amp; biosYear

Next",VBScript,Linux,"#!/bin/bash
dmidecode -s bios-release-date
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,WMIDate
104,Hardware,2015-01-05T20:22:02,",","Version of the BIOS.
Example: A11",1,833799742,0,205,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,BIOS Version,,,,,,,,,Windows,select SMBIOSBIOSVersion from win32_BIOS,WMIQuery,Linux,"#!/bin/bash
dmidecode -s bios-version
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
105,Applications,2015-01-05T20:22:02,|,"Provides a list of applications that are running at the present time on the client machine.
Example: Google Chrome | 23.0.1271.64",1,1559751995,0,207,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:02,Running Applications,,,,,,,,,Windows,"&#039;========================================
&#039; Running Applications
&#039;========================================

&#039; This sensor will list the pretty names of running applications.
&#039; it is a multiple column sensor, and a hidden column will show the
&#039; process name.

strSep = &quot;|&quot;
&#039; Sensor output looks like:
&#039; Running Application | Version | Process Name

SetLocale(1033)

showDuplicates = False 
showVersion = True
recordUsageStats = True

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select Caption, Name, ExecutablePath, CreationDate from Win32_Process&quot;,,48)

Dim nameDictionary, processDictionary
Set nameDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)
Set processDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039;ADD PROCESS NAME IN LOWER CASE
&#039;nameDictionary.Add &quot;hppusg.exe&quot;, &quot;Some HP Application&quot;
&#039;nameDictionary.Add &quot;taniumclient.exe&quot;, &quot;TANIUM CLIENT&quot;

&#039;array used to print output (no dictionary since we need duplicates)
Dim arrOutput()
intSize = 0
ReDim Preserve arrOutput(intSize)

strComputer = &quot;.&quot;
Const HKLM = &amp;h80000002
Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

regPath = GetTaniumRegistryPath() &amp; &quot;\Sensor Data\Applications&quot;
If Not RegKeyExists(reg, HKLM, regPath) Then
	reg.createKey HKLM, regPath
End If

&#039; if recording Usage stats, then we need to record when we first started 
&#039; recording usage stats
If recordUsageStats Then 
	reg.GetStringValue HKLM, regPath, &quot;UsageStatsStart&quot;, strUsageStatsStart
	
	If IsNull(strUsageStatsStart) Or IsEmpty(strUsageStatsStart) Then 
		reg.SetStringValue HKLM, regPath, &quot;UsageStatsStart&quot;, CStr(Now())
	End If
End If 

&#039;SET UP INSTALLED APPLICATIONS PROCESS DICTIONARY TO FACILITATE ACCESS LATER
Dim installedProcs
Set installedProcs = CreateObject(&quot;scripting.dictionary&quot;)

installedRegPath = GetTaniumRegistryPath() &amp; &quot;\Sensor Data\Applications\Installed&quot;
If Not RegKeyExists(reg, HKLM, regPath) Then
	reg.createKey HKLM, installedRegPath
Else	
	reg.EnumKey HKLM, installedRegPath, arrAppKeys
	if not isNull(arrAppKeys) Then
		For Each appKey In arrAppKeys
			fullAppKey = installedRegPath &amp; &quot;\&quot; &amp; appKey
			reg.EnumKey HKLM, fullAppKey, arrProcKeys
			If Not IsNull(arrProcKeys) Then
				For Each procKey In arrProcKeys
					fullProcKey = fullAppKey &amp; &quot;\&quot; &amp; procKey
					reg.GetStringValue HKLM, fullProcKey, &quot;Path&quot;, strPath
					reg.GetStringValue HKLM, fullProcKey, &quot;Process&quot;, strProc
					If Right(strPath, 1) &lt;&gt; &quot;\&quot; Then
						strPath = strPath &amp; &quot;\&quot;
					End If	
					If Not installedProcs.Exists(strPath &amp; strProc) Then
						installedProcs.Add strPath &amp; strProc, fullAppKey
&#039;						WScript.Echo &quot;added: &quot; &amp; installedProcs.Item(strPath &amp; strProc)
					End If	
				Next
			End If
		Next
	End If
End If

For Each objItem in colItems
	If InStr(LCase(objItem.ExecutablePath), &quot;windows\system32\&quot;) = 0 Then
	    Dim fso
	    Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	    If fso.FileExists(objItem.ExecutablePath) Then
    		Dim strOutput, fileVersion, fileVersionOutput, fullName

	    	Set execFile = fso.GetFile(objItem.ExecutablePath)
	    	
    		fileVersion = fso.GetFileVersion(objItem.ExecutablePath)
    		fileVersionOutput = &quot;N/A&quot;
	    	If showVersion Then
	    		If fileVersion &lt;&gt; &quot;&quot; Then
	    			fileVersionOutput = fileVersion
	    		Else
	    			fileVersionOutput = &quot;N/A&quot;
	    		End If
			End If 
			
   			fullName = nameDictionary.Item(LCase(objItem.Name))

			If IsEmpty(fullName) Then
				fullName = GetDescription(execFile.ParentFolder.Path, objItem.Name)
			End If
						
			If fullName = &quot;&quot; Then
				fullName = objItem.Name
			End If
			&#039; sensor output looks like:
			&#039; Application Name | Version | Process
   			strOutput = fullName &amp; strSep &amp; fileVersionOutput &amp; strSep &amp; objItem.Caption
    		
 			If not ArrayContains(arrOutput, strOutput) Or showDuplicates Then
				arrOutput(intSize) = strOutput
				intSize = intSize + 1
				ReDim Preserve arrOutput(intSize)
			End If
			
			&#039;Process Last Started, First Started, etc.
			creationDate = objItem.CreationDate
			strDate = WMIDateStringToDate(creationDate)
			StoreData execFile.ParentFolder.Path, objItem.Name, fullName, fileVersion, cstr(strDate), reg, HKLM, regPath, false
			
			&#039;Look in installed processes for match, if yes then update data
			strKey = execFile.ParentFolder.Path &amp; &quot;\&quot; &amp; objItem.Name
			If installedProcs.Exists(strKey) Then
				installedAppKey = installedProcs.Item(strKey)
				
				StoreData execFile.ParentFolder.Path, objItem.Name, fullName, fileVersion, cstr(strDate), reg, HKLM, installedAppKey, True
				
				&#039;Also add &quot;Application&quot; value to process key
				reg.GetStringValue HKLM, installedAppKey, &quot;Description&quot;, strApp
				
				reg.SetStringValue HKLM, regPath&amp;&quot;\&quot;&amp;GetKeyName(objItem.Name), &quot;Application&quot;, strApp
			End If
	    End If
	End If
Next

For Each output In arrOutput 
	WScript.Echo output
Next

Function GetKeyName(strProcess)
	words = Split(strProcess, &quot;.&quot;)
	GetKeyName = words(0)
End Function

Function StoreData(strPath, strProc, fullName, version, strDate, objReg, hive, baseRegKey, isInstalled)
	Dim regKey
	
	If isInstalled Then
		regKey = baseRegKey
	Else
		regKey = baseRegKey &amp; &quot;\&quot; &amp; GetKeyName(strProc)
	End If
	
	If Not RegKeyExists(objReg, hive, regKey) Then
		objReg.createKey hive, regKey
	End If
	

	&#039;only update file-specific data if not installed
	If Not isInstalled Then
		publisher = GetPublisher(strPath, strProc)
		objReg.SetStringValue hive, regKey, &quot;Publisher&quot;, publisher
		objReg.SetStringValue hive, regKey, &quot;Version&quot;, version
		objReg.SetStringValue hive, regKey, &quot;Description&quot;, fullName
		objReg.SetStringValue hive, regKey, &quot;Path&quot;, strPath
		objReg.SetStringValue hive, regKey, &quot;Process&quot;, strProc
	End If
		
	&#039;always update first/last data	
	Dim strFirstStart, strLastStart
	&#039;Get &quot;First Start&quot;, compare value
	objReg.GetStringValue hive, regKey, &quot;First Start&quot;, strFirstStart
	If IsNull(strFirstStart) Then
		objReg.SetStringValue hive, regKey, &quot;First Start&quot;, strDate
	Else
		&#039;Check if first start value needs to be replaced
		diff = DateDiff(&quot;d&quot;, strFirstStart, strDate)
		If diff &lt; 0 Then
			objReg.SetStringValue hive, regKey, &quot;First Start&quot;, strDate
		End If
	End If
	
	&#039;Get &quot;Last Start&quot;, compare value
	objReg.GetStringValue hive, regKey, &quot;Last Start&quot;, strLastStart
	If IsNull(strLastStart) Then
		objReg.SetStringValue hive, regKey, &quot;Last Start&quot;, strDate
	Else
		&#039;Check if first start value needs to be replaced
		diff = DateDiff(&quot;d&quot;, strLastStart, strDate)
		If diff &gt; 0 Then
			objReg.SetStringValue hive, regKey, &quot;Last Start&quot;, strDate
		End If
	End If
	
	&#039; record the number of times seen, if enabled
	If recordUsageStats Then
		
		&#039; Assuming the usual time that this sensor runs is once every 5 minutes,
		&#039; never record and increment usage stats more often than once every 4
		&#039; minutes.  This stops us from recording an increment more often, in 
		&#039; the case that someone uses the sensor in some other question
		objReg.GetStringValue hive, regKey, &quot;LastStatUpdate&quot;, strLastUpdate
		
		bRecordUpdate = False
		If IsNull(strLastUpdate) Or IsEmpty(strLastUpdate) Then 
			bRecordUpdate = True
		Else 
			intSecondsPast = DateDiff(&quot;s&quot;, CDate(strLastUpdate), Now())
			
			&#039; allow the update if its very close to 5 minutes
			If(intSecondsPast &gt;= 270) Then 
				bRecordUpdate = True
			End If
		End If
		
		If bRecordUpdate Then 
			&#039; key for usage stats is month-day-year
			strUsageKey = Month(Now) &amp; &quot;-&quot; &amp; Year(Now) &amp; &quot;-Usage&quot;
			objReg.GetDWORDValue hive, regKey, strUsageKey, intNumSeen
			
			If IsNull(intNumSeen) Or IsEmpty(intNumSeen) Then
				intNumSeen = 0
			End If
			
			intNumSeen = intNumSeen + 1
			
			objReg.SetDWORDValue hive, regKey, strUsageKey, intNumSeen
			objReg.SetStringValue hive, regKey, &quot;LastStatUpdate&quot;, CStr(Now())
		End If
	End If 
	
End Function


Function ArrayContains(arr, str)
	For Each obj In arr 
		If obj = str Then
			ArrayContains = True
			Exit Function
		End If
	Next
	ArrayContains = False
End Function

Function GetAttributeIndex(folderPath, attrTarget)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	For i = 0 to 400
		attrName = objFolder.GetDetailsOf(objFolder.Items, i)
		If LCase(attrName) = LCase(attrTarget) Then
			GetAttributeIndex = i
			Exit Function
		End If
	Next
	
End Function

Function GetFileProperty(folderPath, fileName, fileProperty)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	GetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)
End Function

Function GetDescription(folderPath, fileName)
	descIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)
	If IsEmpty(descIndex) Then
		descIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)
	End If
	GetDescription = GetFileProperty(folderPath, fileName, descIndex)
End Function

Function GetPublisher(folderPath, fileName)
	descIndex = GetAttributeIndex(folderPath, &quot;Company&quot;)
	GetPublisher = GetFileProperty(folderPath, fileName, descIndex)
End Function

Function WMIDateStringToDate(dtmInstallDate)
   WMIDateStringToDate = CDate(Mid(dtmInstallDate, 5, 2) &amp; &quot;/&quot; &amp; _
   Mid(dtmInstallDate, 7, 2) &amp; &quot;/&quot; &amp; Left(dtmInstallDate, 4))
End Function

&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	patternDate = CDate( strDate )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,48,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Version,Version,1,1,2,Process Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
106,Applications,2015-01-05T20:22:02,",","Returns the version of Internet Explorer installed on a system.
Example:8.0.6001.18702",1,1140552555,0,209,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:02,Internet Explorer Version,,,,,,,,,Windows,"&#039;========================================
&#039; Internet Explorer Version
&#039;========================================

Const HKEY_LOCAL_MACHINE = &amp;H80000002
strComputer = &quot;.&quot;
Set oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; _
    strComputer &amp; &quot;\root\default:StdRegProv&quot;)
strKeyPath = &quot;SOFTWARE\Microsoft\Internet Explorer&quot;
strValueName = &quot;Version&quot;
strValueName2 = &quot;svcVersion&quot;
On Error Resume Next
oReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName2,strValue
If strValue &lt;&gt; &quot;&quot; Then
	WScript.Echo strValue
	WScript.Quit
End If

oReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue
Wscript.Echo  strValue",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
107,Operating System,2015-01-05T20:22:02,",","The Service Pack level of the machine if available, and ""No Service Pack found"" if unavailable.
Example: Service Pack 1",1,2881145629,0,211,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:02,Service Pack,,,,,,,,,Windows,"&#039;========================================
&#039; Service Pack
&#039;========================================

On Error Resume Next

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)

Set colItems = objWMIService.ExecQuery(&quot;select CSDVersion from win32_operatingsystem&quot;)

For Each objItem in colItems
if not isnull(objItem.CSDVersion) then
	WScript.Echo objItem.CSDVersion
	WScript.Quit
End if
Next

WScript.Echo &quot;No Service Pack found&quot;",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
108,Operating System,2015-01-05T20:22:02,",","Returns the build number of the installed operating system.
Example:7601",1,3770282786,0,213,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,Operating System Build Number,,,,,,,,,Windows,select BuildNumber from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
109,Operating System,2015-01-05T20:22:02,",","Returns the date the OS was installed.
Example: 8/24/2012",1,1982695066,0,215,1,Jim Olsen,43200,0,defined,Tanium,2015-01-05T20:22:02,Operating System Install Date,,,,,,,,,Windows,"&#039;========================================
&#039; Operating System Install Date
&#039;========================================

&#039; This sensor uses date math which is locale specific
SetLocale(GetTaniumLocale)

Set dtmConvertedDate = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)

Set colOperatingSystems = objWMIService.ExecQuery _
    (&quot;Select * from Win32_OperatingSystem&quot;)

For Each objOperatingSystem in colOperatingSystems
    dtmConvertedDate.Value = objOperatingSystem.InstallDate
    dtmInstallDate = dtmConvertedDate.GetVarDate
    
    
    words = Split(dtmInstallDate, &quot; &quot;)
    Wscript.Echo words(0)
Next

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
110,Java,2015-01-05T20:22:02,|,"Returns a list of all installed Java runtimes on the client machine.
Example: Java(TM) 6 Update 20",1,3993657420,0,217,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,Installed Java Runtimes,,,,,,,,,Windows,"&#039;========================================
&#039; Installed Java Runtimes
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039; This sensor will return information in the uninstall areas of the registry.
&#039; There are two hidden columns which can be filtered on despite the fact that
&#039; they&#039;re hidden, and can also feed actions.
&#039; if the uninstallstring is msi based, it is altered to show the
&#039; silent uninstall options and marked as &quot;Is Uninstallable&quot;
&#039; finally, if it&#039;s a user installed application, it will note that
&#039; The columns look like:
&#039; Name|Version|Silent Uninstall String|Uninstallable

SensorRandomize()

Dim hasJava 
hasJava = False

&#039; This sensor uses date math which is locale specific
SetLocale(GetTaniumLocale) &#039;us/english

Set objRegistry = Getx64RegistryProvider()

keyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall&quot;
key64Path = &quot;SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall&quot;

Const HKLM = &amp;H80000002
Const HKEY_USERS = &amp;H80000003

&#039; list out 32-bit applications on a 64-bit system
If RegKeyExists(HKLM, key64Path) Then
	objRegistry.EnumKey HKLM, key64Path, arrSubKeys
	GetApplications HKLM,key64path,arrSubKeys
End If

&#039; list out 32-bit applications on a 32-bit system, or 64-bit applications
&#039; on a 64-bit system.
If RegKeyExists(HKLM, keyPath) Then
	objRegistry.EnumKey HKLM, keypath, arrSubKeys
	GetApplications HKLM,keypath,arrSubKeys
End If

&#039; Also list out applications installed to HKEY_Users areas
&#039; which will be appended to the arrSubKeys
objRegistry.EnumKey HKEY_USERS, &quot;&quot;, arrUserKeys
For Each strSIDkey In arrUserKeys
	If RegKeyExists(HKEY_USERS, strSIDKEY&amp;&quot;\&quot;&amp;keyPath) Then
		objRegistry.EnumKey HKEY_USERS, strSIDkey&amp;&quot;\&quot;&amp;keyPath, arrSubKeys
		GetApplications HKEY_USERS,strSIDKey&amp;&quot;\&quot;&amp;keyPath,arrSubKeys
	End If
Next

If Not(hasJava) Then
	WScript.Echo &quot;Java not installed&quot;
End If

Function IsJava(strName)
	If ContainsString(strName, &quot;(^Java\(TM\) \d Update)|(^Java \d Update)|(^Java 2 Runtime Environment)|(^Java Runtime Environment)&quot;) Then
		IsJava = True
		Exit Function
	Else
		IsJava = False
	End If
End Function

Function GetApplications(HIVE, keypath,arrSubKeys)
	Set applications = CreateObject(&quot;Scripting.Dictionary&quot;)
	
	If Not IsNull(arrSubKeys) Then
		For Each key in arrSubKeys
			objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;DisplayName&quot;, displayName
			objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;DisplayVersion&quot;, version
			objRegistry.GetDWORDValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;SystemComponent&quot;, systemComponent	
			objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;UninstallString&quot;, uninstallString	
			objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;ParentKeyName&quot;, parentKey	
			&#039; on error goto 0
			&#039; assume it&#039;s not uninstallable
			bUninstallable = &quot;Not Uninstallable&quot;
					
			If displayName &lt;&gt; &quot;&quot; _
				And Not IsNull(uninstallString) _ 
				And IsNull(parentKey) _
				And InStr(displayName, &quot;Hotfix&quot;) = 0 _
				And InStr(displayName, &quot;Update for&quot;) = 0 _
		 		And InStr(displayName, &quot;Security Update for&quot;) = 0 _
		 	Then 
		 		If InStr(LCase(uninstallString), &quot;msiexec&quot;) Then
		 			&#039; replace any /I with /X and add silent flags
		 			uninstallString = Replace(uninstallString,&quot;/I&quot;,&quot;/X&quot;) &amp; &quot; /qn /noreboot&quot; 
		  			bUninstallable = &quot;Is Uninstallable&quot;
		  		End If
		 		If IsNull(systemComponent) Or systemComponent = 0 Then
					If IsNull(version) Then
						version = &quot;&quot;
					End If
					&#039; This is a multi-column sensor.  Last two columns are hidden.
	
					displayString = displayName &amp; &quot;|&quot; &amp; version &amp; &quot;|&quot; &amp; uninstallString &amp; &quot;|&quot; &amp; bUninstallable
	
					&#039; treat displayString as the unique value - cannot be listed twice.
					If Not applications.Exists(displayName) Then
						&#039;Check for various Java Installation patterns
						If IsJava(displayName) Then
							applications.Add displayName, displayString
							hasJava = True
						End If	
					End If 	
				End If 	
			End If 
		Next
	End If
	
	SortDictionary applications, 1 &#039; This calls a sorting function specific to dictionaries
	arrApplicationsKeys = applications.Keys
	For Each strKey In arrApplicationsKeys
		&#039; final output of the sensor
		WScript.Echo applications.Item(strKey)
	Next
End Function &#039;GetApplications

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function SortDictionary(objDict, intSort)
 &#039;   objDict - the dictionary to sort
 &#039;   intSort - the field to sort (1=key, 2=item)
 
   &#039; declare constants
   Const dictKey  = 1
   Const dictItem = 2
 
   &#039; declare our variables
   Dim strDict()
   Dim objKey
   Dim strKey,strItem
   Dim X,Y,Z
 
   &#039; get the dictionary count
   Z = objDict.Count
 
   &#039; we need more than one item to warrant sorting
   If Z &gt; 1 Then
     &#039; create an array to store dictionary information
     ReDim strDict(Z,2)
     X = 0
     &#039; populate the string array
     For Each objKey In objDict
         strDict(X,dictKey)  = CStr(objKey)
         strDict(X,dictItem) = CStr(objDict(objKey))
         X = X + 1
     Next
 
     &#039; perform a a shell sort of the string array
     For X = 0 To (Z - 2)
       For Y = X To (Z - 1)
         If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) &gt; 0 Then
             strKey  = strDict(X,dictKey)
             strItem = strDict(X,dictItem)
             strDict(X,dictKey)  = strDict(Y,dictKey)
             strDict(X,dictItem) = strDict(Y,dictItem)
             strDict(Y,dictKey)  = strKey
             strDict(Y,dictItem) = strItem
         End If
       Next
     Next
 
     &#039; erase the contents of the dictionary object
     objDict.RemoveAll
 
     &#039; repopulate the dictionary with the sorted information
     For X = 0 To (Z - 1)
       objDict.Add strDict(X,dictKey), strDict(X,dictItem)
     Next
 
   End If
 End Function &#039;SortDictionary


Function ContainsString(strToCheck, strRegex)
&#039;	If isDebug Then WScript.Echo &quot;About to check: &quot; &amp; strToCheck

	If IsNull(strToCheck) Or IsEmpty(strToCheck) Then
		ContainsString = False
		Exit Function
	End If

	Dim re, matches
	Set re = New RegExp
	re.Pattern = strRegex
	Set matches = re.Execute(strToCheck)
	If matches.Count &gt; 0 Then
		If isDebug Then WScript.Echo &quot;   match: &quot; &amp; matches(0) &amp; &quot;, strRegex: &quot; &amp; strRegex
		ContainsString = True
		Exit Function
	End If
	ContainsString = False
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,0,1,0,JRE,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Version,String,1,1,2,Uninstaller,String,0,1,3,Uninstallable,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
111,Java,2015-01-05T20:22:02,|,"Returns the state of the Java Auto Update service, per architecture.
Example: Enabled 32-bit",1,3134254821,0,219,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Java Auto Update,,,,,,,,,Windows,"&#039;========================================
&#039; Java Auto Update
&#039;========================================

Option Explicit

Const HKLM = &amp;H80000002

Dim b32BitJavaFound, b64BitJavaFound
b32BitJavaFound = False
b64BitJavaFound = False

b32BitJavaFound = CheckForJavaAndUpdatePolicy(32)
If Is64 Then
	b64BitJavaFound = CheckForJavaAndUpdatePolicy(64)
End If

If Not b32BitJavaFound And Not b64BitJavaFound Then
	&#039; Only print this if neither bit of java was found
	WScript.Echo &quot;Java Not Found&quot;
End If


Function CheckForJavaAndUpdatePolicy(intBit)
	Dim strRuntimeInstalledKey, strUpdatePolicyKey, intRegToUse, strArch, strValue
	Dim objCtx, objReg, bJavaFound
	
	bJavaFound = False

	strRuntimeInstalledKey = &quot;SOFTWARE\Javasoft\Java Runtime Environment&quot;
	strUpdatePolicyKey = &quot;SOFTWARE\JavaSoft\Java Update\Policy&quot;
	
	intRegToUse = 32
	If Is64 Then 
		intRegToUse = 64 &#039; always use highest available registry
	End if
	
	Set objCtx = GetObjCtx(intRegToUse)
	Set objReg = GetObjReg(objCtx)

	strArch = &quot;32-bit&quot;
	If intBit = 64 Then
		strArch = &quot;64-bit&quot;
	End If
	
	If Is64 And intBit = 32 Then
		&#039; special case of looking for 32 bit jvms on 64 bit machines
		strRuntimeInstalledKey = &quot;SOFTWARE\WOW6432Node\Javasoft\Java Runtime Environment&quot;
		strUpdatePolicyKey = &quot;SOFTWARE\WOW6432Node\JavaSoft\Java Update\Policy&quot;
	End If	
	
	If RegKeyExists(objReg, objCtx, HKLM, strRuntimeInstalledKey) Then
		bJavaFound = True
		If RegKeyExists(objReg, objCtx, HKLM, strUpdatePolicyKey) Then
			strValue = GetDWordValue(objReg, objCtx, HKLM, strUpdatePolicyKey, &quot;EnableJavaUpdate&quot;)
		
			If Not IsNull(strValue) Then
				If strValue = 1 Then
					WScript.Echo &quot;Enabled|&quot; &amp; strArch
				Else
					WScript.Echo &quot;Disabled|&quot; &amp; strArch
				End If
			End If
		Else 
			&#039; case where jvm installed, but no Java Update reg branch available
			WScript.Echo &quot;Disabled|&quot; &amp; strArch
		End If
	End If
	
	CheckForJavaAndUpdatePolicy = bJavaFound
End Function

Function GetDWordValue(objReg, objCtx, constHive, strKey, strValue)
	Dim objInParams, objOutParams, objValue
    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
    objInParams.hDefKey = constHive
    objInParams.sSubKeyName = strKey
    objInParams.sValueName = strValue
    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
	objValue = objOutParams.uValue
	If IsNull(objOutParams.uValue) Then
		GetDWordValue = Null
	Else
		GetDWordValue = CStr(objOutParams.uValue)
	End If	
End Function

Function RegKeyExists(objReg, objCtx, constHive, strKey)
	Dim objNames, objTypes, objValues, Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	If Outparams.ReturnValue = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If		
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function

Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Status,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Architecture,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
112,Patch,2015-01-05T20:22:02,|,"Multi-column Sensor that shows operating system patches that can be installed to this computer.  The title, severity, bulletin, date, total package size, and KB article for the patch are displayed.
Example: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663",1,259673374,0,221,1,Jim Olsen,60,0,defined,Tanium,2015-01-05T20:22:02,Available Patches,,,,,,,,,Windows,"&#039;========================================
&#039; Available Patches
&#039;========================================

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, bAirgapped, strAirgapUrl
Dim dictScanResultFiles,strCustomCabSupportVal,bCustomCabSupport
Dim strScansPath, strToolsPath

strSep = &quot;|&quot;

&#039;title|severity|bulletins|date|download|filename|status|guid|package size|kb|cve|Unique ID|Reboot Required|Revision|Endpoint Impact

bAirgapped = False
strAirgapUrl = &quot;AIRGAP_LOCAL_SERVER_URL/Dropoff/&quot;
If( Not(Left(strAirgapUrl, 19) = &quot;AIRGAP_LOCAL_SERVER&quot;)) Then 
	bAirgapped = True  &#039; the AIRGAP url is rewritten by the install process, so this
	                   &#039; set to true will mean we need to airgap the urls
End If


strToolsPath = GetTaniumDir(&quot;Tools&quot;)
strScansPath = GetTaniumDir(&quot;Tools\Scans&quot;)
strCustomCabSupportVal = LCase(GetPatchManagementValueFromRegistry(&quot;CustomCabSupport&quot;))
If strCustomCabSupportVal = &quot;true&quot; Or strCustomCabSupportVal = &quot;yes&quot; Then
	Set dictScanResultFiles = GetValidScanFiles &#039; retrieves all
	bCustomCabSupport = True
	
	&#039; True if you need to support custom support cabs
	&#039; Typically set with the Distribute Custom Patch Scan Cabs job
	&#039; If above is true:
	&#039; Use the Distribute Custom Patch Scan Cabs package /CustomDownloadURLFolder flag to set a value such as
	&#039; http://myserver.com/folder
	&#039; ensure that if the url is retrieved via https that all Tanium servers will trust the certificate presented
	&#039; The server chosen to host the patch files must have enough space for all patch files
	&#039; (typically XP Custom Support Patches)
	&#039; Note that the URL will be lowercase but Microsoft will provide updates in Mixed-Case
	&#039; so be sure to place on a web server which ignores case sensitivity when URLs/Files
	&#039; are accessed - no case sensitive web servers, please
	
	Dim strCustomDownloadURLFolder
	&#039; Set this value using the /CustomDownloadURLFolder flag when you distribute a custom
	&#039; cab file using Distribute Custom Patch Scan Cabs package. The same folder must be used with all custom cab files
	strCustomDownloadURLFolder = _
		EnsureSuffix(GetPatchManagementValueFromRegistry(&quot;CustomDownloadURLFolder&quot;),&quot;/&quot;)
	If strCustomDownloadURLFolder = &quot;&quot; Then &#039; value was not appropriately set
		&#039; this will appear as the download URL instead
		strCustomDownloadURLFolder = &quot;http://Set.This.Value.When.Distributing.Custom.Cab/see_available_patches_sensor/&quot;
	End If
Else
	bCustomCabSupport = False
	&#039; standard scan file support
	Set dictScanResultFiles = CreateObject(&quot;Scripting.Dictionary&quot;)
	dictScanResultFiles.Add strScansPath&amp;&quot;patchresultsreadable.txt&quot;,&quot;wsusscn2.cab&quot;
End If

&#039;-------------

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set dictScanResultFiles = GetValidScanFiles

For Each fn In dictScanResultFiles.Keys
	EchoScanResults(fn)
Next

Function EchoScanResults(strScanFile)
	&#039;Set up exclusions list
	Dim excludeFile
	excludeFile = strToolsPath &amp; &quot;\patch-exclude.txt&quot;
	
	Dim objExclusions
	Set objExclusions = GetPatchExclusions(excludeFile)
	
	If objFSO.FileExists(fn) Then
		Set objReadFile = objFSO.OpenTextFile(fn, 1, False)
	
		Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
		
		hasOutput = False
		
		Do While Not objReadFile.AtEndOfStream
			strLine = objReadFile.ReadLine
	
			&#039;CHECK FOR MULTI-URL PATCHES
			words = Split(strLine, strSep)
			
			&#039;Ignore old Patch Results format without separator
			If UBound(words) &lt; 4 Then 
				If left(words(0), 4) = &quot;Scan&quot; Then
					hasOutput = True
					WScript.Echo words(0)
				&#039;Else 
	&#039;				WScript.Echo &quot;Run upgraded Patch Scan&quot;
	&#039;				WScript.Quit
				End If	
	&#039;		ElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then
			Else
				arrFilenames = Split(words(5), &quot;,&quot;)
				&#039;patch filename must be in Tools\Patch directory for queue
				Dim fso
				Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
				
				strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
				
				isComplete = True
				For Each strFilename In arrFilenames
					If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
						isComplete = False
					End If			
				Next
	
				If Not isComplete Then
					hasOutput = True
					If InStr(strLine, &quot;Already Installed&quot;) Then
						&#039;if InStr(strLine, &quot;(KB&quot;) Then
						&#039;	strLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)
						&#039;End If
						&#039;Do not echo since we only want to output &quot;Installed&quot; patches
					Else
						&#039;Check to see if KB article should be excluded
						If Not IsExclusion(strLine, objExclusions) Then
							WScript.Echo RewriteLine(strLine)
						End If
					End If
				Else
					&#039;If we&#039;re here, update has been queued
					&#039;Do not echo since we only want to output &quot;Installed&quot; patches
					&#039;If InStr(strLine, &quot;Not Installed&quot;) Then
					&#039;	strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
					&#039;	WScript.Echo strLine
					&#039;End If
				End If 
			End If	
		Loop
	
		If Not hasOutput Then
			WScript.Echo &quot;All available patches queued for installation&quot;
		End If
	
		objReadFile.close
	Else
	   &#039; Wscript.echo &quot;Patch results output not found&quot;
	End if

End Function &#039;EchoScanResults

Function RewriteLine(strLine) 
	Dim strResult, arrTokens, strDownloads, strFilenames, i, x
	strResult = strLine
	If bAirgapped Then 
		&#039; if the system is running airgapped, then we need to rewrite
		&#039; all of the patch location URLs to have the internal url
		&#039; we have to pull out the url and file name values, then recreate the
		&#039; line
		arrTokens = Split(strLine, &quot;|&quot;)
		strFilenames = Split(arrTokens(5), &quot;,&quot;)

		strDownloads = strAirgapUrl &amp; strFilenames(0)
		For i=1 To UBound(strFilenames)
			strDownloads = strDownloads &amp; &quot;,&quot; &amp; strAirgapUrl &amp; strFilenames(i)
		Next

		strResult = arrTokens(0)
		For i=1 To Ubound(arrTokens) 
			If i=4 Then 
				strResult = strResult &amp; &quot;|&quot; &amp; strDownloads
			Else
				strResult = strResult &amp; &quot;|&quot; &amp; arrTokens(i)
			End If 
		Next
	End If
	&#039; Consider also XP Custom Support Downloads
	&#039; which may be at a different URL
	If bCustomCabSupport Then
		strResult = ReplaceCustomXPURL(strResult,strCustomDownloadURLFolder)
	End If
	RewriteLine = strResult
End Function

Function RegKeyExists(reg, sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function IsExclusion(strLine, objDic)
	Dim colKeys, strKey
	colKeys = objDic.Keys
	For Each strKey in colKeys
		If InStr(strLine, strSep &amp; strKey &amp; strSep) &lt;&gt; 0 Then
			IsExclusion = True
			Exit Function
		End If
	Next
	
	IsExclusion = False
End Function

Function GetPatchExclusions(strFile)
	Dim oDic
	Set oDic = CreateObject(&quot;scripting.dictionary&quot;)
	
	Dim fso
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	Const ForReading = 1
	If fso.FileExists(strFile) Then
		Dim objFile
		Set objFile = fso.OpenTextFile(strFile, ForReading)
		
		Dim strLine
		Do While objFile.AtEndOfStream &lt;&gt; True
			strLine = Trim(objFile.ReadLine)
			
			&#039;Ignore lines that start with #
			If Left(strLine, 1) &lt;&gt; &quot;#&quot; Then
				oDic.Item(strLine) = &quot;placeholder&quot;
			End If
		Loop
	End If
	
	Set GetPatchExclusions = oDic
End Function

Function GetValidScanFiles
	&#039; if global constant bCustomCabSupport is True
	&#039; Returns a dictionary of valid scan results files
	&#039; which are those that are based on cab files which exist
	Dim dictScanResultFiles,objFSO,objCabFolder,objFile,strToolsDir
	Dim strExtraCabDir,strResultsReadablePath,strScanDir,strCabPath
	Set dictScanResultFiles = CreateObject(&quot;Scripting.Dictionary&quot;)	
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	strToolsDir = GetTaniumDir(&quot;Tools&quot;)
	strScanDir = GetTaniumDir(&quot;Tools\Scans&quot;)
	If bCustomCabSupport Then
		strExtraCabDir = strToolsDir&amp;&quot;ExtraPatchCabs&quot;
		If objFSO.FolderExists(strExtraCabDir) Then
			Set objCabFolder = objFSO.GetFolder(strExtraCabDir)
			For Each objFile In objCabFolder.Files
				If LCase(Right(objFile.Name,4)) = &quot;.cab&quot; Then
					strResultsReadablePath = strScanDir&amp;&quot;patchresultsreadable-&quot;&amp;objFile.Name&amp;&quot;.txt&quot;
					If Not dictScanResultFiles.Exists(strResultsReadablePath) Then
						dictScanResultFiles.Add strResultsReadablePath,objFile.Name
					End If
				End If
			Next
		End If
	End If
	
	&#039; always add the default distributed wsusscn2.cab
	strCabPath = strToolsDir &amp; &quot;wsusscn2.cab&quot;
	If objFSO.FileExists(strCabPath) And Not dictScanResultFiles.Exists(strCabPath) Then
		dictScanResultFiles.Add strScanDir&amp;&quot;patchresultsreadable.txt&quot;,&quot;wsusscn2.cab&quot;
	End If

	Set GetValidScanFiles = dictScanResultFiles
End Function &#039;GetValidScanFiles

Function EnsureSuffix(strIn,strSuffix)

	If Not Right(strIn,Len(strSuffix)) = strSuffix Then
		EnsureSuffix = strIn&amp;strSuffix
	Else
		EnsureSuffix = strIn
	End If
	
End Function &#039;EnsureSuffix

Function ReplaceCustomXPURL(strLine,strCustomDownloadURLFolder)
	&#039; a line may look like
	&#039; strLine = &quot;Security Update for Internet Explorer 6 for Windows XP Service Pack 3 (KB2953522) Custom Support|Critical|MS14-030|2014-05|http://download.windowsupdate.com/msdownload/update/csa/secu/2014/05/windowsxp-kb2953522-x86-custom-enu_c6820e06d430fa90266689e71652327c057737ea.exe,http://download.windowsupdate.com/msdownload/update/csa/secu/2014/05/windowscrapola-kb2453252-x86-custom-enu_hohogreedo.exe|windowsxp-kb2953522-x86-custom-enu_c6820e06d430fa90266689e71652327c057737ea.exe,windowsxp-kb2453252-x86-custom-enu_abacab.exe|Not Installed|1c5202d5-2f75-4f1a-a97e-506891aa31a1|0 B|KB2953522|None|fc73bc9ddef26aea82a337dff0897c13|Maybe|11|Normal&quot;
	&#039; For each mention of the file (in the downloadURL and the file name) there is
	&#039; a data string which does not appear in the actual name of the file made available
	&#039; from Microsoft. This function finds and removes that text.
	
	Dim strBytesVal,strDownloadURLsField,arrLine
	arrLine = Split(strLine,strSep)
	If UBound(arrLine) &gt; 7 Then
		&#039; likely valid
		strDownloadURLsField = arrLine(4)
		&#039; LCase(strBytesVal) seems to be &quot;0 b&quot; but unsure if reliable
		strBytesVal = arrline(8)
		&#039; also the phrase &quot;custom support&quot; seems to follow the KB indicator in title but unsure if reliable
		&#039; so use either
		If LCase(strBytesVal) = &quot;0 b&quot; Or InStr(LCase(strLine),&quot;) custom support&quot;&amp;strSep) &gt; 0 Then &#039; seems to indicate Custom XP Patches
			&#039; manipulate the downloadURLs to remove everything between the last _ and the last .
			Dim arrDownloadURLs,strDownloadURL,dictUselessData
			arrDownloadURLs = Split(strDownloadURLsField,&quot;,&quot;)
			Set dictUselessData = CreateObject(&quot;Scripting.Dictionary&quot;) &#039; hold the bits we strip away from filenames
			Dim intLastDotPos,intLastUnderscorePos,strUselessData,intLastForwardSlashPos
			Dim strOriginalDownloadPrefix,strNewDownloadURL,strCommaSepDownloadURLs
			For Each strDownloadURL In arrDownloadURLs
				intLastDotPos = InStrRev(strDownloadURL,&quot;.&quot;)
				intLastUnderscorePos = InStrRev(strDownloadURL,&quot;_&quot;)
				&#039; will also replace the URL prefix (up to the file)
				intLastForwardSlashPos = InStrRev(strDownloadURL,&quot;/&quot;)
				strOriginalDownloadPrefix = Left(strDownloadURL,intLastForwardSlashPos)
				strUselessData = Mid(strDownloadURL,intLastUnderscorePos,intLastDotPos-intLastUnderscorePos)
				If Not dictUselessData.Exists(strUselessData) Then dictUselessData.Add strUselessData,1 &#039; save for later replacement
				strNewDownloadURL = Replace(Replace(strDownloadURL,strUselessData,&quot;&quot;),strOriginalDownloadPrefix,strCustomDownloadURLFolder)
				strCommaSepDownloadURLs = strCommaSepDownloadURLs&amp;&quot; &quot;&amp;strNewDownloadURL
			Next
			strCommaSepDownloadURLs = Replace(Trim(strCommaSepDownloadURLs),&quot; &quot;,&quot;,&quot;)
			&#039; Replace the Download URLs field from original line with the new comma separated value
			strLine = Replace(strLine,strDownloadURLsField,strCommaSepDownloadURLs,1,-1,vbTextCompare)
			&#039; remove this unnecessary data anywhere it might exist in the files column
			Dim strNewFilesField
			strNewFilesField = arrLine(5)
			For Each strUselessData In dictUselessData.Keys
				strNewFilesField = Replace(strNewFilesField,strUselessData,&quot;&quot;,1,-1,vbTextCompare)
			Next
			strLine = Replace(strLine,arrLine(5),strNewFilesField)
		End If
	End If
	ReplaceCustomXPURL = strLine
End Function &#039;ReplaceCustomXPURL

Function GetPatchManagementValueFromRegistry(strPatchManagementValue)

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPatchManagementValueData, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client\PatchManagement&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client\PatchManagement&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPatchManagementValueData = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\&quot;&amp;strPatchManagementValue)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPatchManagementValueData = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPatchManagementValueData = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\&quot;&amp;strPatchManagementValue)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPatchManagementValueData = &quot;&quot; Then
  		GetPatchManagementValueFromRegistry = strPatchManagementValueData
  	Else
  		GetPatchManagementValueFromRegistry = &quot;&quot;
  	End If
End Function &#039;GetPatchManagementValueFromRegistry",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,117,0,1,0,Title,String,0,1,10,CVE ID,String,1,1,11,Tanium Patch ID,String,0,1,12,Reboot Required,String,0,1,13,Revision,String,0,1,14,Endpoint Impact,String,0,1,1,Severity,String,0,1,2,Bulletins,String,0,1,3,Date,String,1,1,4,Download,String,1,1,5,Filename,String,1,1,6,Status,String,1,1,7,GUID,String,0,1,8,Package Size,DataSize,0,1,9,KB Article,String,String
113,Patch,2015-01-05T20:22:02,|,"Multi-column Sensor that shows operating system patches that are installed to this computer.  The title, severity, bulletin, date, total package size, and KB article for the patch are displayed.
Example: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663",1,2517008879,0,223,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Installed Patches,,,,,,,,,Windows,"&#039;========================================
&#039; Installed Patches
&#039;========================================

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput
strSep = &quot;|&quot;

&#039;title|severity|bulletins|date|download|filename|status|guid|package size|kb|cve

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\patchresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				WScript.Echo words(0)
			&#039;Else 
&#039;				WScript.Echo &quot;Run upgraded Patch Scan&quot;
&#039;				WScript.Quit
			End If	
&#039;		ElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next

			If Not isComplete Then
				hasOutput = True
				If InStr(strLine, &quot;Already Installed&quot;) Then
					if InStr(strLine, &quot;(KB&quot;) Then
						strLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)
					End If
					WScript.Echo strLine
				Else
					&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				End If
			Else
				&#039;If we&#039;re here, update has been queued
				&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				&#039;If InStr(strLine, &quot;Not Installed&quot;) Then
				&#039;	strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
				&#039;	WScript.Echo strLine
				&#039;End If
			End If 
		End If	
	Loop

	If Not hasOutput Then
		WScript.Echo &quot;All available patches queued for installation&quot;
	End If

	objReadFile.close
Else
   Wscript.echo &quot;Patch results output not found&quot;
End if
WScript.Quit()

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,210,0,1,0,Title,String,0,1,10,CVE ID,String,1,1,11,Tanium Patch ID,String,0,1,12,Revision,String,,,,,,,,,,,0,1,1,Severity,String,0,1,2,Bulletins,String,0,1,3,Date,String,1,1,4,Download,String,1,1,5,Filename,String,1,1,6,Status,String,1,1,7,GUID,String,0,1,8,Package Size,DataSize,0,1,9,KB Article,String,String
114,Patch,2015-01-05T20:22:02,|,"Shows information about patches that are installing on endpoints when the question is asked.
Example: Title | Severity | KB Article",1,221242344,0,225,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Patches Currently Installing,,,,,,,,,Windows,"&#039;========================================
&#039; Patches Currently Installing
&#039;========================================

&#039; sensor - patches currently installing
&#039; This sensor will report the patches currently installing
&#039; the columns look like
&#039; title|severity|KB Article

Option Explicit

Const FORREADING = 1

Dim objFSO,objTextFile,strInstallingCurrentlyTextFilePath
Dim strScanDir

Dim strSep : strSep = &quot;|&quot;
Dim strLine,arrLine,strGUID,strCVE

Set objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)

strScanDir = GetTaniumDir(&quot;Tools\Scans&quot;)
strInstallingCurrentlyTextFilePath = strScanDir &amp; &quot;\installingcurrently.txt&quot;

If Not objFSO.FileExists(strInstallingCurrentlyTextFilePath) Then
	Set objFSO = Nothing
	WScript.Quit
End If

&#039; read contents of file
Set objTextFile = objFSO.OpenTextFile(strInstallingCurrentlyTextFilePath,FORREADING)

While objTextFile.AtEndOfStream = False
	strLine = objTextFile.ReadLine
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
		If UBound(arrLine) &gt; 1 Then
			WScript.Echo strLine
		Else
			&#039; WScript.Echo &quot;Error parsing results file&quot;
		End If
	Else
		&#039; WScript.Echo &quot;Error parsing results file&quot;
	End If
Wend

objTextFile.Close
Set objTextFile = Nothing
Set objFSO = Nothing

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Severity,String,0,1,2,KB Article,String,0,1,3,Tanium Patch ID,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
115,Patch,2015-01-05T20:22:02,",","Returns Yes or No depending on whether the patch installer script is running.  This differs from the sensor ""Patches Currently Installing"" which returns the patches that are installing on endpoints.
Example: Yes",1,2350222692,0,227,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Currently Running Patch Installer,,,,,,,,,Windows,"&#039;========================================
&#039; Currently Running Patch Installer
&#039;========================================

&#039;&#039; sensor to report on if a machine has been running a command and command line passed in
&#039; for longer than a time threshold - modified for patch install

Option Explicit

Dim intSecondsOldThreshold,strExecutableName,strCommandLinePartial
Dim strSep

intSecondsOldThreshold = 30
strExecutableName = &quot;cscript.exe&quot;
strCommandLinePartial = &quot;install-patches.vbs&quot;

ExecutionStartTimeSecondsOld strExecutableName,strCommandLinePartial

Sub ExecutionStartTimeSecondsOld(strExecutable, strCommandLineMatch)
&#039; This function will return the execution start time of exectuable / command line
&#039; instances running.  if the executable
&#039; passed in is running with a command line that matches part of what
&#039; the CommandLineMatch parameter, it will be added to the count.  If the count is greater
&#039; than one, we can assume this process is already running, so don&#039;t run the scan.

	Const HKLM = &amp;h80000002
	
	Dim objWMIService,colItems
	Dim objItem,strCmd,intRunningCount,intSecondsOld

	strCommandLineMatch = LCase(strCommandLineMatch)
	intRunningCount = 0
	On Error Resume Next
	
	SetLocale(1033) &#039; Uses Date Math which requires us/english to work correctly
	
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	
	Set colItems = objWMIService.ExecQuery(&quot;Select CreationDate,CommandLine from Win32_Process where Name = &#039;&quot;&amp;strExecutable&amp;&quot;&#039;&quot;,,48)
	For Each objItem in colItems
		strCmd = LCase(objItem.CommandLine)
		If InStr(strCmd,strCommandLineMatch) &gt; 0 Then
			intRunningCount = intRunningCount + 1
		End If
		If intRunningCount &gt; 0 Then
			intSecondsOld = GetSecondsOld(ConvertDate(objItem.CreationDate))
			If IsNumeric(intSecondsOld) Then
				If intSecondsOld &gt; intSecondsOldThreshold Then
					WScript.Echo &quot;Yes&quot;
					WScript.Quit
				Else
					WScript.Echo &quot;No&quot;
					WScript.Quit
				End If
			End If
		Else
			WScript.Echo &quot;No&quot;
			WScript.Quit
		End If
	Next
	On Error Goto 0
	
End Sub &#039;ExecutionStartTimeSecondsOld

Function ConvertDate(dtString)
&#039;SetLocale outside of function in global scope
	If Not GetLocale = 1033 Then
		WScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;
		WScript.Quit
	End If
	
	Dim dtDate
	dtDate = left(dtString,InStr(dtString,&quot;.&quot;)-1)
	
	dtDate = CDate(Mid(dtDate, 5, 2) &amp; &quot;/&quot; &amp; _
		Mid(dtDate, 7, 2) &amp; &quot;/&quot; &amp; Left(dtDate, 4) _
		&amp; &quot; &quot; &amp; Mid (dtDate, 9, 2) &amp; &quot;:&quot; &amp; _
		Mid(dtDate, 11, 2) &amp; &quot;:&quot; &amp; Mid(dtDate, _
		13, 2))
	ConvertDate = dtDate
End Function &#039;ConvertDate

Function GetSecondsOld(strDate)
	Dim objDate
	If IsDate(strDate) Then
		objDate = FormatDateTime(strDate, 0)
	Else
		GetSecondsOld = &quot;Bad Date Value to GetSecondsOld&quot;
	End If
	GetSecondsOld = DateDiff(&quot;s&quot;, objDate, Now())
End Function &#039;GetSecondsOld",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
116,Patch,2015-01-05T20:22:02,|,"Multi-column Sensor that shows operating system patches that have been excluded on this computer.  The title, severity, bulletin, date, total package size, and KB article for the patch are displayed.
Example: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663",1,3551011466,0,229,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Patch Exclusions,,,,,,,,,Windows,"&#039;========================================
&#039; Patch Exclusions
&#039;========================================

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput
strSep = &quot;|&quot;

&#039;title|severity|bulletins|date|download|filename|status|guid|package size|kb|cve

Dim strScansPath, strToolsPath
strToolsPath = GetTaniumDir(&quot;Tools&quot;)
strScansPath = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = strScansPath &amp; &quot;\patchresultsreadable.txt&quot;

&#039;Set up exclusions list
Dim excludeFile
excludeFile = strToolsPath &amp; &quot;\patch-exclude.txt&quot;

Dim objExclusions
Set objExclusions = GetPatchExclusions(excludeFile)

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				WScript.Echo words(0)
			&#039;Else 
&#039;				WScript.Echo &quot;Run upgraded Patch Scan&quot;
&#039;				WScript.Quit
			End If	
&#039;		ElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next

			If Not isComplete Then
				hasOutput = True
				If InStr(strLine, &quot;Already Installed&quot;) Then
					&#039;if InStr(strLine, &quot;(KB&quot;) Then
					&#039;	strLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)
					&#039;End If
					&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				Else
					&#039;Check to see if KB article should be excluded
					If IsExclusion(strLine, objExclusions) Then
						WScript.Echo strLine
					End If
				End If
			Else
				&#039;If we&#039;re here, update has been queued
				&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				&#039;If InStr(strLine, &quot;Not Installed&quot;) Then
				&#039;	strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
				&#039;	WScript.Echo strLine
				&#039;End If
			End If 
		End If	
	Loop

	If Not hasOutput Then
		WScript.Echo &quot;All available patches queued for installation&quot;
	End If

	objReadFile.close
Else
   Wscript.echo &quot;Patch results output not found&quot;
End if
WScript.Quit()

Function RegKeyExists(reg, sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath


Function IsExclusion(strLine, objDic)
	Dim colKeys, strKey
	colKeys = objDic.Keys
	For Each strKey in colKeys
		If InStr(strLine, strSep &amp; strKey &amp; strSep) &lt;&gt; 0 Then
			IsExclusion = True
			Exit Function
		End If
	Next
	
	IsExclusion = False
End Function

Function GetPatchExclusions(strFile)
	Dim oDic
	Set oDic = CreateObject(&quot;scripting.dictionary&quot;)
	
	Dim fso
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	Const ForReading = 1
	If fso.FileExists(strFile) Then
		Dim objFile
		Set objFile = fso.OpenTextFile(strFile, ForReading)
		
		Dim strLine
		Do While objFile.AtEndOfStream &lt;&gt; True
			strLine = Trim(objFile.ReadLine)
			
			&#039;Ignore lines that start with #
			If Left(strLine, 1) &lt;&gt; &quot;#&quot; Then
				oDic.Item(strLine) = &quot;placeholder&quot;
			End If
		Loop
	End If
	
	Set GetPatchExclusions = oDic
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,0,1,0,Title,String,0,1,10,CVE ID,String,,,,,,,,,,,,,,,,,,,,,0,1,1,Severity,String,0,1,2,Bulletins,String,0,1,3,Date,String,1,1,4,Download,String,1,1,5,Filename,String,1,1,6,Status,String,1,1,7,GUID,String,0,1,8,Package Size,String,0,1,9,KB Article,String,String
117,Patch,2015-01-05T20:22:02,",","Provides a high level snapshot view of the patch application status of the environment.
Example: More than 5 Critical Patches Required",1,1773001148,0,231,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Available Patch Status,,,,,,,,,Windows,"&#039;========================================
&#039; Available Patch Status
&#039;========================================

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, intCriticalThreshold
strSep = &quot;|&quot;
intCriticalThreshold = 5

Dim showSingleStatus
showSingleStatus = True

&#039;title|severity|bulletins|date|download|filename|status|package size|kb

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\patchresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False

	&#039;note: intNone refers to patches with severity=none
	Dim intCritical, intImportant, intModerate, intLow, intNone
	
	intCritical = 0
	intImportant = 0
	intModerate = 0
	intLow = 0	
	intNone = 0
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				WScript.Echo words(0)
			Else 
				WScript.Echo &quot;Run upgraded Patch Scan&quot;
				WScript.Quit
			End If	
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next

			If Not isComplete Then
				If InStr(strLine, &quot;Already Installed&quot;) Then
					&#039;Do not echo since we only want to output &quot;Available&quot; patches
				Else
					hasOutput = True
					Select Case words(1)
					    Case &quot;Critical&quot;
					    	intCritical = intCritical + 1
					    Case &quot;Important&quot;
					    	intImportant = intImportant + 1
					    Case &quot;Moderate&quot;
					    	intModerate = intModerate + 1
					    Case &quot;Low&quot;
					    	intLow = intLow + 1
					    Case &quot;None&quot;
					    	intNone = intNone + 1
					End Select
					
				End If
			Else
				&#039;If we&#039;re here, update has been queued
				&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				&#039;If InStr(strLine, &quot;Not Installed&quot;) Then
				&#039;	strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
				&#039;	WScript.Echo strLine
				&#039;End If
			End If 
		End If	
	Loop

	objReadFile.close

	If hasOutput Then
		If intCritical &gt; 5 Then
			WScript.Echo &quot;More than 5 Critical Patches Required&quot;
			If showSingleStatus Then WScript.Quit
		End If
		If intCritical &gt; 0 Then
			WScript.Echo &quot;Critical Patches Required&quot;
			If showSingleStatus Then WScript.Quit
		End If
		If intImportant &gt; 0 Then
			WScript.Echo &quot;Important Patches Required&quot;
			If showSingleStatus Then WScript.Quit
		End If
		If intModerate &gt; 0 Then
			WScript.Echo &quot;Moderate Patches Required&quot;
			If showSingleStatus Then WScript.Quit
		End If
		If intLow &gt; 0 Then
			WScript.Echo &quot;Low Patches Required&quot;
			If showSingleStatus Then WScript.Quit
		End If
		If intNone &gt; 0 Then
			WScript.Echo &quot;Non-Severe Patches Required&quot;
			If showSingleStatus Then WScript.Quit
		End If
	Else
		WScript.Echo &quot;No Security Patches Required&quot;
	End If

Else
   Wscript.echo &quot;Patch results output not found&quot;
End if

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,5,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
118,Patch,2015-01-05T20:22:02,|,"Pulls patches which have failed to install out of a client's patch history.
Example: title | error | date",1,2775576456,0,233,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Patch Failures,"{""parameters"":[{""helpString"":""Enter Yes, or No, to return failures for applicable patches only"",""value"":"""",""promptText"":""Yes/No"",""defaultValue"":"""",""requireSelection"":true,""label"":""Show failures only for needed patches"",""key"":""ShowOnlyIfApplicable"",""values"":[""Yes"",""No""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Patch Failures
&#039;========================================

&#039; sensor: patch failures
&#039; paramterized sensor which can show failures for all patches
&#039; or only for patches which are failed but necessary

Option Explicit

Const FORREADING = 1

Dim objFSO,objTextFile
Dim dictHistory
Dim strScanDir
Dim strHistoryTextReadableFilePath
Dim strSep : strSep = &quot;|&quot;
Dim strLine,arrLine,strGUID,strCVE
Dim strTitle,strKB,strBulletin,strDate,strException,strSeverity
Dim dictResults,bShowOnlyIfApplicable,strShowOnlyIfApplicable
Dim strResultsReadableFilePath,strInstallStatus,strTaniumPatchID

&#039; take parameter
strShowOnlyIfApplicable=Trim(Unescape(&quot;||ShowOnlyIfApplicable||&quot;))

Select Case LCase(strShowOnlyIfApplicable)
	Case &quot;yes&quot;
		bShowOnlyIfApplicable = True
	Case &quot;true&quot;
		bShowOnlyIfApplicable = True
	Case &quot;no&quot;
		bShowOnlyIfApplicable = False
	Case &quot;false&quot;
		bShowOnlyIfApplicable = False
	Case &quot;&quot;
		bShowOnlyIfApplicable = True
	Case Else
		WScript.Echo &quot;Parameter must be Yes or No, Quitting&quot;
		WScript.Quit
End Select


Set objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)
strScanDir = GetTaniumDir(&quot;Tools\Scans&quot;)

strHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;
strResultsReadableFilePath = strScanDir&amp;&quot;patchresultsreadable.txt&quot;

If Not objFSO.FileExists(strHistoryTextReadableFilePath) Then
	WScript.Echo &quot;Cannot find History file&quot;
	Set objFSO = Nothing
	WScript.Quit
End If

&#039;uses date math, may need locale set
SetLocale(GetTaniumLocale)

Set dictHistory = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; read History into dictionary
Set objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)
While objTextFile.AtEndOfStream = False
	strLine = objTextFile.ReadLine
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
		If UBound(arrLine) &gt; 0 Then
			If Not dictHistory.Exists(strLine) Then
				dictHistory.Add strLine,1
			End If
		Else
			&#039; WScript.Echo &quot;Error parsing results file&quot;
		End If
	Else
		&#039; WScript.Echo &quot;Error parsing results file&quot;
	End If
Wend
objTextFile.Close

Set dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)
If bShowOnlyIfApplicable Then
	&#039; We will tie the GUID in history to the GUID here - if it exists in patch results and if it says
	&#039; not installed, only then will we write it
	&#039; Read results into dictionary
	Set objTextFile = objFSO.OpenTextFile(strResultsReadableFilePath,FORREADING)
	While objTextFile.AtEndOfStream = False
		strLine = objTextFile.ReadLine
		&#039; WScript.Echo strLIne 
		&#039;element 5 must be not installed
		arrLine = Split(strLine,strSep)
		If IsArray(arrLine) Then
			If UBound(arrLine) &gt; 0 Then
				&#039; pull GUID to use as key
				strGUID = arrLine(7)
				If Not (UBound(arrLine) &gt; 4 And dictResults.Exists(strGUID)) Then
					dictResults.Add strGUID,strLine
				End If
			Else
				&#039; WScript.Echo &quot;Error parsing results file&quot;
			End If
		Else
			&#039; WScript.Echo &quot;Error parsing results file&quot;
		End If
	Wend
	objTextFile.Close
End If


Dim strkey

For Each strkey In dictHistory.Keys
	&#039; WScript.Echo dictHistory.Item(strkey)
	strLine = strkey
	&#039; 13 History Columns
	&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|PatchID
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
		If UBound(arrLine) &gt; 11 Then
			If LCase(arrLine(1)) = &quot;installation&quot; And LCase(arrLine(2)) = &quot;failed&quot; Then
				&#039; install failure
				&#039; report title, kb, bulletin, date, and exception
				strGUID = arrLine(0)
				strTitle=arrLine(6)
				strKB=arrLine(10)
				strBulletin=arrLine(9)
				strCVE = arrLine(11)
				On Error Resume Next
				&#039; Convert from UTC to Local and show only the date
				strDate = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)
				If Err.Number &lt;&gt; 0 Then
					strDate = &quot;Unknown&quot;
					Err.Clear
				End If
				On Error Goto 0
				strException=arrLine(3)
				strSeverity=arrLine(8)
				If UBound(arrLine) &gt; 12 Then
					strTaniumPatchID=arrLine(13)
				Else
					strTaniumPatchID=&quot;Unknown&quot;
				End If
				If bShowOnlyIfApplicable Then
					If dictResults.Exists(strGUID) Then
						strInstallStatus = Split(dictResults.Item(strGUID),&quot;|&quot;)(6)
						If LCase(strInstallStatus) = &quot;not installed&quot; Then
							WScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _
								&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _
								&amp;strSep&amp;strTaniumPatchID
						End If
					End If
				Else
					WScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _
						&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _
						&amp;strSep&amp;strTaniumPatchID
				End If
			End If
		Else
			&#039; WScript.Echo &quot;History Line malformed - needs 11 fields&quot;
		End If
	Else
		&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable
	End If
Next

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale

Function GetTZBias
&#039; This functiong returns the number of minutes
&#039; (positive or negative) to add to current time to get UTC
&#039; considers daylight savings

	Dim objLocalTimeZone, intTZBiasInMinutes


	For Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)
		intTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone
	Next

	GetTZBias = intTZBiasInMinutes
		
End Function &#039;GetTZBias",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||ShowOnlyIfApplicable||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||ShowOnlyIfApplicable||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Error,String,0,1,2,Date,String,0,1,3,KB Article,String,0,1,4,Bulletin ID,String,0,1,5,Severity,String,0,1,6,Tanium Patch ID,String,,,,,,,,,,,,,,,,String
119,Patch,2015-01-05T20:22:02,|,"Sensor which shows information about patches queued for install.
Example: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663",1,1076605530,0,235,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Queued Patches,,,,,,,,,Windows,"&#039;========================================
&#039; Queued Patches
&#039;========================================

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput
strSep = &quot;|&quot;

&#039;title|severity|bulletins|date|download|filename|status|package size|kb|cve

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\patchresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				WScript.Echo words(0)
			&#039;Else 
&#039;				WScript.Echo &quot;Run upgraded Patch Scan&quot;
&#039;				WScript.Quit
			End If	
&#039;		ElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next

			If Not isComplete Then
				hasOutput = True
				If InStr(strLine, &quot;Already Installed&quot;) Then
					if InStr(strLine, &quot;(KB&quot;) Then
						strLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)
					End If
					&#039;Do not echo since we only want to output &quot;Queued&quot; patches
					&#039;WScript.Echo strLine
&#039;				Else
					&#039;Do not echo since we only want to output &quot;Queued&quot; patches
				End If
			Else
				&#039;If we&#039;re here, update has been queued 
				If InStr(strLine, &quot;Not Installed&quot;) Then
					strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
					WScript.Echo strLine
				End If
			End If 
		End If	
	Loop

	If Not hasOutput Then
		WScript.Echo &quot;All available patches queued for installation&quot;
	End If

	objReadFile.close
Else
   Wscript.echo &quot;Patch results output not found&quot;
End if
WScript.Quit()

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,0,1,0,TItle,String,1,1,10,CVE ID,String,1,1,11,Tanium Patch ID,String,1,1,12,Reboot Required,String,1,1,13,Revision,String,1,1,14,Endpoint Impact,String,0,1,1,Severity,String,0,1,2,Bulletins,String,0,1,3,Date,String,1,1,4,Download,String,1,1,5,FIlename,String,1,1,6,Status,String,1,1,7,GUID,String,0,1,8,Package Size,String,0,1,9,KB Article,String,String
120,Hardware,2015-01-05T20:22:02,",","Returns whether the client machine is 64-bit or 32-bit (x86).
Example: X86-based PC",0,1742036917,0,237,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,x64/x86?,,,,,,,,,Windows,"&#039; x64-x86.vbs - returns the architecture of the machine

Option Explicit

If Is64() Then
	WScript.Echo &quot;x64-based PC&quot;
Else
	WScript.Echo &quot;x86-based PC&quot;
End If

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If
	Next
End Function",VBScript,Linux,"#!/bin/bash
#http://www.stata.com/support/faqs/windows/64-bit-compliance/

arch=`uname -a | tr &#039;[A-Z]&#039; &#039;[a-z]&#039;`;

if [[ &quot;${arch}&quot; == *x86_64* ]]; then
	echo &quot;x64-based PC&quot;;
elif [[ &quot;${arch}&quot; == *ia64* ]]; then
	echo &quot;x64-based PC&quot;;
elif [[ &quot;${arch}&quot; == *i686* ]]; then
	echo &quot;x86-based PC&quot;;
 
else
	echo &quot;&quot;;
fi
",UnixShell,Mac,"#!/bin/bash
#http://www.stata.com/support/faqs/windows/64-bit-compliance/

arch=`uname -a | tr &#039;[A-Z]&#039; &#039;[a-z]&#039;`;

if [[ &quot;${arch}&quot; == *x86_64* ]]; then
	echo &quot;x64-based PC&quot;;
elif [[ &quot;${arch}&quot; == *ia64* ]]; then
	echo &quot;x64-based PC&quot;;
elif [[ &quot;${arch}&quot; == *i686* ]]; then
	echo &quot;x86-based PC&quot;;
 
else
	echo &quot;&quot;;
fi
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
121,Operating System,2015-01-05T20:22:02,",","The version of the Windows Update Agent on the client machine.
Example: 7.6.7600.256",1,2835566148,0,239,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:02,WUA Version,,,,,,,,,Windows,"&#039;========================================
&#039; WUA Version
&#039;========================================
Option Explicit

WuaVersion()
WScript.Quit

Function WuaVersion
	Dim strOutput, fso, strSysDir, strWuaDll
	
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	strSysDir = GetSystemDir
	strWuaDll = strSysDir &amp; &quot;\wuaueng.dll&quot;
	If fso.FileExists(strWuaDll) Then
		strOutput = fso.GetFileVersion(strWuaDll)
	Else 
		strOutput = &quot;WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;
	End If
	
	WScript.Echo strOutput
End Function 

Function GetSystemDir 
	Dim fso, fsoSys, strWinDir, strSysDir
	Set fsoSys = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	&#039;Check for 64-bit sysnative directory to avoid win redirect
	strWinDir = fsoSys.GetSpecialFolder(0)
	strSysDir = strWinDir &amp; &quot;\sysnative&quot;
	
	If Not fsoSys.FolderExists(strSysDir) Then
		strSysDir = fsoSys.GetSpecialFolder(1)
	End If
	GetSystemDir = strSysDir
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
122,Operating System,2015-01-05T20:22:02,",","Returns Enabled if the user has access to Windows Update Agent configuration settings and Disabled if not.
Example: Enabled",1,2504149222,0,241,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:02,WUA User Access Enabled,,,,,,,,,Windows,"&#039;========================================
&#039; WUA User Access Enabled
&#039;========================================
Option Explicit

If (checkForWuaAccessDisabled = True) Then
	WScript.Echo &quot;Disabled&quot;
Else
	WScript.Echo &quot;Enabled&quot;
End If
WScript.Quit

Function checkForWuaAccessDisabled

	Dim strComputer, strKeyPath, strValueName, strValue, reg, result
	
	Const HKLM = &amp;H80000002 
	strComputer = &quot;.&quot;
	
	Set reg = _
	    GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	    &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	
	
	strKeyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer&quot;
	strValueName = &quot;NoWindowsUpdate&quot;
	strValue = 0
	reg.getDWordValue HKLM, strKeyPath, strValueName, strValue
	If strValue &lt;&gt; 1 Then
		checkForWuaAccessDisabled = False
		Exit Function
	End If
	
	strKeyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer&quot;
	strValueName = &quot;NoDevMgrUpdate&quot;
	strValue = 0
	reg.getDWordValue HKLM, strKeyPath, strValueName, strValue
	If strValue &lt;&gt; 1 Then
		checkForWuaAccessDisabled = False
		Exit Function
	End If	
	
	strKeyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Control Panel\don&#039;t load&quot;
	strValueName = &quot;wuaucpl.cpl&quot;
	strValue = null
	reg.getStringValue HKLM, strKeyPath, strValueName, strValue
	If IsNull(strValue) Then
		checkForWuaAccessDisabled = False
		Exit Function
	End If

	checkForWuaAccessDisabled = True

End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
123,Applications,2015-01-05T20:22:02,|,"Details about all running services on the client machine, including name, display name, running status, and startup mode.
Example: MDM | Machine Debug Manager | Running | Auto",1,2384520458,0,243,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Service Details,,,,,,,,,Windows,"&#039;========================================
&#039; Service Details
&#039;========================================

getServiceDetails()
WScript.Quit

Function getServiceDetails()
	&#039;Check to see if Windows Update Service needs to be enabled and/or stopped at end
	Dim objWMIService, colComputer, objComputer
	
	Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
	Set colServices = objWMIService.ExecQuery (&quot;select DisplayName, State, StartMode from win32_Service&quot;)    
	
	For Each objService in colServices
		strServiceName = objService.Name
		strServiceDisplayName = objService.DisplayName
		strServiceStatus = objService.State
		strServiceMode = objService.StartMode
		WScript.Echo strServiceName &amp; &quot;|&quot; &amp; strServiceDisplayName &amp; &quot;|&quot; &amp; strServiceStatus &amp; &quot;|&quot; &amp; strServiceMode
	Next

End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Service Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Service Display Name,String,0,1,2,Service Status,String,0,1,3,Service Startup Mode,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
124,Operating System,2015-01-05T20:22:02,|,"The settings for the Windows Update Agent on the client machine.
Automatic Install|Every Day 3:00 AM",1,4118090245,0,245,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,WUA Settings,,,,,,,,,Windows,"&#039;
&#039; wua-settings.vbs
&#039;
&#039; Retrieves the settings for automatic update
&#039;

Option Explicit

Dim objAutoUpdate, objSettings
Dim strLevel, strScheduledTime

Set objAutoUpdate = CreateObject(&quot;Microsoft.Update.AutoUpdate&quot;)
Set objSettings = objAutoUpdate.Settings

strLevel=&quot;Unknown&quot;
strScheduledTime=&quot;N/A&quot;

Select Case objSettings.NotificationLevel
    Case 0
    	strLevel = &quot;Not Configured&quot;
    Case 1
        strLevel = &quot;Disabled&quot;
    Case 2
      	strLevel = &quot;User Prompted Before Downloading&quot;
      	&#039;strScheduledTime = GetScheduledString(objSettings)
    Case 3
		strLevel = &quot;User Prompted Before Installing&quot;             
      	&#039;strScheduledTime = GetScheduledString(objSettings)
    Case 4
     	strLevel = &quot;Automatic Install&quot;       
      	strScheduledTime = GetScheduledString(objSettings)
End Select

WScript.Echo strLevel &amp; &quot;|&quot; &amp; strScheduledTime

Function GetScheduledString(objSettings)
	Dim strResult, strScheduledTime

	Select Case objSettings.ScheduledInstallationDay
	    Case 0
	        strResult = &quot;Every Day&quot;
	    Case 1
	        strResult = &quot;Sunday&quot;
	    Case 2
	        strResult = &quot;Monday&quot;
	    Case 3
	        strResult = &quot;Tuesday&quot;
	    Case 4
	        strResult = &quot;Wednesday&quot;
	    Case 5
	        strResult = &quot;Thursday&quot;
	    Case 6
	        strResult = &quot;Friday&quot;
	    Case 7
	        strResult = &quot;Saturday&quot;
	    Case Else
	        strResult = &quot;Unknown&quot;
	End Select
	
	If objSettings.ScheduledInstallationTime = 0 Then
	    strResult = strResult &amp; &quot; 12:00 AM&quot;
	ElseIf objSettings.ScheduledInstallationTime = 12 Then
	    strResult = strResult &amp; &quot; 12:00 PM&quot;
	Else
	    If objSettings.ScheduledInstallationTime &gt; 12 Then
	        intScheduledTime = objSettings.ScheduledInstallationTime - 12
	        strScheduledTime = intScheduledTime &amp; &quot;:00 PM&quot;
	    Else
	        strScheduledTime = objSettings.ScheduledInstallationTime &amp; &quot;:00 AM&quot;
	    End If
	    strResult = strResult &amp; &quot; &quot; &amp; strScheduledTime
	End If

	GetScheduledString = strResult
End Function &#039; GetScheduledString",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Mode,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Schedule,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
125,Applications,2015-01-05T20:22:02,|,"3rd party applications that are not up to the latest published version.  This multi-column Sensor provides the name of the software, the publisher, the architecture (32-bit or 64-bit), the current version, the latest version, and the status
Example: ""Adobe Reader | Adobe | 32-bit | 10.1.4 | 10.1.4 | Up to Date",1,4203533580,0,247,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Out of Date Managed Applications,,,,,,,,,Windows,"&#039;========================================
&#039; Out of Date Managed Applications
&#039;========================================

Option Explicit
Dim strSep
strSep = &quot;|&quot;

Dim strSearch
strSearch = &quot;Out of Date&quot;

Dim strReadablePath
strReadablePath = GetTaniumDir(&quot;&quot;) &amp; &quot;\Tools\Scans\maresultsreadable.txt&quot;

Dim objFso
Set objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

If objFso.FileExists(strReadablePath) Then
	Dim objReadFile
	Set objReadFile = objFSO.OpenTextFile(strReadablePath, 1, False)

	Dim strLine
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine
		
		If InStr(strLine, strSearch) &gt; 0 Or InStr(strLine, &quot;Error:&quot;) Then
			WScript.Echo strLine
		End If
	Loop
Else
	WScript.Echo &quot;Error: managed applications results not found&quot;
End If

Function RegKeyExists(reg, sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Publisher,String,0,1,2,Architecture,String,0,1,3,Current Version,String,0,1,4,Latest Version,String,0,1,5,Status,String,1,1,6,Filename,String,1,1,7,Download,String,1,1,8,Command,String,,,,,,String
126,Applications,2015-01-05T20:22:02,|,"3rd party applications that are up to the latest published version.  This multi-column Sensor provides the name of the software, the publisher, the architecture (32-bit or 64-bit), the current version, the latest version, and the status
Example: ""Adobe Reader | Adobe | 32-bit | 10.1.4 | 10.1.4 | Up to Date",1,4122594545,0,249,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,Up to Date Managed Applications,,,,,,,,,Windows,"&#039;========================================
&#039; Up to Date Managed Applications
&#039;========================================
Option Explicit
Dim strSep
strSep = &quot;|&quot;

Dim strSearch
strSearch = &quot;Up to Date&quot;

Dim strReadablePath
strReadablePath = GetTaniumDir(&quot;&quot;) &amp; &quot;\Tools\Scans\maresultsreadable.txt&quot;

Dim objFso
Set objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

If objFso.FileExists(strReadablePath) Then
	Dim objReadFile
	Set objReadFile = objFSO.OpenTextFile(strReadablePath, 1, False)

	Dim strLine
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine
		
		If InStr(strLine, strSearch) &gt; 0 Or InStr(strLine, &quot;Error:&quot;) Then
			WScript.Echo strLine
		End If
	Loop
Else
	WScript.Echo &quot;Error: managed applications results not found&quot;
End If

Function RegKeyExists(reg, sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Publisher,String,0,1,2,Architecture,String,0,1,3,Current Version,String,0,1,4,Latest Version,String,0,1,5,Status,String,1,1,6,Filename,String,1,1,7,Download,String,1,1,8,Command,String,,,,,,String
127,Hardware,2015-01-05T20:22:02,",","The speed of the processor in Mhz.
Example: 3200 Mhz",1,1646244079,0,251,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,CPU Speed Mhz,,,,,,,,,Windows,"&#039;========================================
&#039; CPU Speed Mhz
&#039;========================================

On Error Resume Next

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)

Set colItems = objWMIService.ExecQuery(&quot;select MaxClockSpeed from win32_processor&quot;)

For Each objItem in colItems
    strSpeed = objItem.MaxClockSpeed
    intSpeed = CInt(CInt(strSpeed)/10)*10
    WScript.Echo intSpeed &amp; &quot; Mhz&quot;
Next",VBScript,Linux,"#!/bin/bash
line=$(grep -m 1 -i &quot;cpu MHz&quot; /proc/cpuinfo)
set -- $line
TGHZ=&quot;`echo ${line#*:} | awk &#039;{ printf &quot;%0.1f&quot;, $0/1000 }&#039;`&quot;
TMHZ=&quot;`echo &quot;$TGHZ&quot; | awk &#039;{ print ($0 * 1000) }&#039;`&quot;
#echo &quot;$TGHZ GHz&quot;
echo &quot;$TMHZ MHz&quot;
",UnixShell,Mac,"#!/bin/bash
ftemp=$(mktemp -t &#039;apps.xml&#039;)
system_profiler -xml SPHardwareDataType &gt; &quot;$ftemp&quot;

cpu=`/usr/libexec/PlistBuddy -c &quot;Print :0:_items:0:current_processor_speed&quot; $ftemp 2&gt;/dev/null | awk -F &#039; &#039; &#039;{print $1}&#039;`
t=&quot;$(echo &quot;$cpu*1000&quot; | bc)&quot;
echo $t | awk -F &#039;.&#039; &#039;{print $1&quot; Mhz&quot;}&#039;

rm -rf &quot;$ftemp&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
128,Software,2015-01-05T20:22:02,",","Indicates whether the client machine has been online for more than 30 days.
Example: Less than 30 days",1,1263879283,0,253,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:02,High Uptime,,,,,,,,,Windows,"&#039;========================================
&#039; High Uptime
&#039;========================================

strComputer = &quot;.&quot;     
set objWMIDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)  
set objWMI = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
set colOS = objWMI.InstancesOf(&quot;Win32_OperatingSystem&quot;)  

&#039;Uses date math - set locale

SetLocale(1033)

for each objOS in colOS   
objWMIDateTime.Value = objOS.LastBootUpTime              
If TimeSpan(objWMIDateTime.GetVarDate,Now) &gt; 30 Then          
Wscript.echo TimeSpan(objWMIDateTime.GetVarDate,Now) &amp; &quot; days&quot;  
Else          
Wscript.echo &quot;Less than30&quot;          
End If  
next    
Function TimeSpan(dt1, dt2)    
If (isDate(dt1) And IsDate(dt2)) = false Then     
TimeSpan = &quot;00:00:00&quot;     
Exit Function           
End If              
seconds = Abs(DateDiff(&quot;S&quot;, dt1, dt2))           
minutes = seconds \ 60           
hours = minutes \ 60           
days = hours \ 24           
minutes = minutes mod 60           
seconds = seconds mod 60              
TimeSpan = days  
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
129,Miscellaneous,2015-01-05T20:22:02,",","Lists the specified number of processes that are using the highest amount of CPU.
Example: cmd",1,2711879278,0,255,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,High CPU Processes,"{""parameters"":[{""maximum"":50,""stepSize"":1,""helpString"":""Enter the number of processes to return"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Processes"",""minimum"":1,""key"":""numOutput"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; High CPU Processes
&#039;========================================

topNum = Trim(Unescape(&quot;||numOutput||&quot;))
If Not IsNumeric(topNum) Then 
	WScript.Echo &quot;Parameter Not Number&quot;
	WScript.Quit
End If 
topNum = Cint(topNum)

printPercent = false
Const HKLM = &amp;H80000002 
strComputer = &quot;.&quot;

Set objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)

Const MaxCharacters = 255
Const adBSTR = 8 
Const adDouble = 5

Set DataList = CreateObject(&quot;ADOR.Recordset&quot;)
DataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters
DataList.Fields.Append &quot;ProcessCPU1&quot;, adDouble
DataList.Fields.Append &quot;ProcessCPU2&quot;, adDouble
DataList.Fields.Append &quot;ProcessCPUDiff&quot;, adDouble
DataList.Open

Dim total1, total2, totalDiff

Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   
For Each objItem in colProcItems
   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then
      DataList.AddNew
      DataList(&quot;ProcessName&quot;) = objItem.Name
      DataList(&quot;ProcessCPU1&quot;) = objItem.PercentProcessorTime
      DataList.Update
   ElseIf objItem.Name = &quot;_Total&quot; Then 
      total1 = CDbl(objItem.PercentProcessorTime)
   End If
Next

sleep = 5
WScript.Sleep(sleep * 1000)

Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   
For Each objItem in colProcItems
   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then
      
      DataList.MoveFirst
      DataList.Find(&quot;ProcessName = &#039;&quot;&amp; objItem.Name&amp;&quot;&#039;&quot;)

      If DataList.EOF Then
              WScript.Echo &quot;** Not Found **&quot;
      Else
         DataList(&quot;ProcessCPU2&quot;) = objItem.PercentProcessorTime
         DataList(&quot;ProcessCPUDiff&quot;) = DataList(&quot;ProcessCPU2&quot;) - DataList(&quot;ProcessCPU1&quot;)
         DataList.Update
           &#039;WScript.Echo &quot;name: &quot; &amp; DataList.Fields.Item(&quot;ProcessName&quot;) &amp; &quot;, cpu 1: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU1&quot;) &amp; &quot;, cpu 2: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU2&quot;)
      End if
   ElseIf objItem.Name = &quot;_Total&quot; Then 
      total2 = CDbl(objItem.PercentProcessorTime)
      totalDiff = total2 - total1
   End If
Next

DataList.Sort = &quot;ProcessCPUDiff DESC&quot;
DataList.MoveFirst
i = 1
Do Until DataList.EOF  Or i &gt; topNum
   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))
   If printPercent Then
      strPrint = strPrint &amp; &quot; (&quot; &amp; Round(DataList.Fields.Item(&quot;ProcessCPUDiff&quot;) / totalDiff * 100, 0) &amp; &quot;%)&quot;
   End if   
   WScript.Echo strPrint
   DataList.MoveNext
   i = i + 1
Loop

WScript.Quit

&#039;removes .exe and process number at end of 
Function CleanString(str)
	words = Split(str, &quot;#&quot;)
	str = words(0)
	CleanString = str

	If Right(str, 4) = &quot;.exe&quot; Then
		str = Left(str, Len(str) - 4)
	End If 
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||numOutput||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||numOutput||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
130,Miscellaneous,2015-01-05T20:22:02,",","Lists the specified number processes based on ordering on amount of memory used.
Example: cmd",1,1527458369,0,257,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:02,High Memory Processes,"{""parameters"":[{""maximum"":50,""stepSize"":1,""helpString"":""Enter the number of processes to return"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Processes"",""minimum"":1,""key"":""numOutput"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; High Memory Processes
&#039;========================================

topNum = Trim(Unescape(&quot;||numOutput||&quot;))
If Not IsNumeric(topNum) Then 
	WScript.Echo &quot;Parameter Not Number&quot;
	WScript.Quit
End If 
topNum = Cint(topNum)

printMemory = false

Dim objWMIService, objItem, colItems, query
Dim strComputer, strList


strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer&amp; &quot;\root\cimv2&quot;)

Const MaxCharacters = 255
Const adBSTR = 8 
Const adDouble = 5
Set DataList = CreateObject(&quot;ADOR.Recordset&quot;)
DataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters
DataList.Fields.Append &quot;ProcessMemory&quot;, adDouble

DataList.Open

Set colProcs = objWMIService.ExecQuery(&quot;Select Name, WorkingSetSize From Win32_Process&quot;)
For Each proc in colProcs
   DataList.AddNew
   DataList(&quot;ProcessName&quot;) = proc.Name
   DataList(&quot;ProcessMemory&quot;) = round(cdbl(proc.WorkingSetSize)/1024/1024, 0)
   DataList.Update
Next
DataList.Sort = &quot;ProcessMemory DESC&quot;
DataList.MoveFirst
i = 1
Do Until DataList.EOF Or i &gt; topNum
   Set field = DataList.Fields
   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))
   If printMemory Then
      strPrint = strPrint &amp; &quot; (&quot; &amp; DataList.Fields.Item(&quot;ProcessMemory&quot;) &amp; &quot; Mb)&quot;
   End if   
   WScript.Echo strPrint
   DataList.MoveNext
   i = i + 1
Loop

WScript.Quit

&#039;removes .exe and process number at end of process
Function CleanString(str)
	words = Split(str, &quot;#&quot;)
	str = words(0)

	If Right(str, 4) = &quot;.exe&quot; Then
		str = Left(str, Len(str) - 4)
	End If 
	CleanString = str
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||numOutput||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||numOutput||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
131,Hardware,2015-01-05T20:22:02,",","If a drive has less free space than the configured threshold, the drive and remaining free space is returned.  The threshold defaults to 2048 MB and can be altered.
Example: C: 1 GB",1,1043670154,0,259,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:02,Disk Free Space Below Threshold,,,,,,,,,Windows,"&#039;========================================
&#039; Disk Free Space Below Threshold
&#039;========================================

mbThreshold = 2048

strComputer = &quot;.&quot;  
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
Set colDisks = objWMIService.ExecQuery (&quot;Select * from Win32_LogicalDisk where DriveType=3&quot;)    
For Each objDisk in colDisks      
FreeMB = objDisk.FreeSpace/1024000    
if (FreeMB &lt;&gt; &quot;&quot; and FreeMB &lt; mbThreshold and FreeMB &lt;&gt; 0) THEN      
FreeGB = FreeMB/1024      
Wscript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; Round(FreeGB) &amp; &quot; GB&quot;    
END IF  
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
132,Applications,2015-01-05T20:22:03,",","Returns a list of all services currently stopped on the client machine.
Example: DHCP Client",1,3188527889,0,261,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Stopped Service,,,,,,,,,Windows,select Caption from win32_Service where State=&#039;Stopped&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
first=true
launchctl list | while read line
do
    set -- $line
if ( $first ); 
then
	first=false
else
	if [ &quot;$2&quot; == &quot;0&quot; ]; 
	then
		echo $3
	fi
fi
done
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
133,SQL,2015-01-05T20:22:03,",","The number of databases in SQL Server on the client machine.
Example: 4",1,3271577967,0,263,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Database Count,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Database Count
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit
Dim dictInstances, strInstance, objConnection

Set dictInstances = GetMSSQLInstances()

For Each strInstance In dictInstances.Keys
 	Dim objRecordSet, objRecord, strValue
	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  
	
	On Error Resume Next
	objConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)
	
	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 
	
	On Error Goto 0
	
	objRecordSet.Open &quot;select count(name) as count from master..sysdatabases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  
	objRecordSet.MoveFirst  
	For each objRecord in objRecordSet.Properties    
		strValue = objRecordSet(&quot;count&quot;)    
		WScript.echo strValue &amp; GetMSSQLSensorInstanceStr(strInstance)
		objRecordSet.MoveNext    
		If (objRecordset.EOF = True) THEN       
			objRecordset.Close       
			Exit For    
		End If 
	Next 
Next
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
134,SQL,2015-01-05T20:22:03,",","Returns the Edition of SQL Server installed on the client machine if it exists.
Example: Enterprise Edition (64-bit)",1,749653644,0,265,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Server Edition,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Server Edition
&#039;========================================
Option Explicit

Const MAX_SQL_NUMBER = 15
Const DEBUG_OUT = False
Dim strValueName, strSKUName, strEdition, strVersion, strArchitecture 
Dim objWMI, dictWMIs, objProp, strOut, dictServices

Set dictWMIs = CreateObject(&quot;Scripting.Dictionary&quot;)
Set dictServices = CreateObject(&quot;Scripting.Dictionary&quot;)
	
BuildSQLCompMgmtWMIsDict(dictWMIs)

PrintProp &quot;SKUNAME&quot;

Function IsMultiple(ByRef dictWMIs)

	If dictWMIs.Count &gt; 1 Then
		IsMultiple = True
	Else
		IsMultiple = False
	End If
	
End Function &#039;IsMultiple

Sub PrintProp(strProp)
	Dim intOutCount
	intOutCount = 1
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
	Else
		For Each objWMI In dictWMIs.Keys
			strOut = GetSQLServiceAdvancedProp(strProp,objWMI)
			If Len(strOut) &gt; 0 Then
				intOutCount = intOutCount + 1
				WScript.Echo strOut
			Else
				WScript.Echo &quot;SQL Not Found&quot;
				DebugPrint &quot;SQL Property Not Found&quot;
			End If
		Next
	End If

End Sub &#039;PrintProp 

Function PrintServices
	BuildSQLServicesNames objWMI,dictServices
	&#039; Print Services
	Dim strService
	For Each strService In dictServices.Keys
		WScript.Echo strService
	Next
End Function &#039;PrintServices

Function GetBitnessFromSKU(strSKUName)
&#039; Returns appropriate bitness from SKU value
	Dim strArchitecture
	If Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then
	    strArchitecture = &quot;64-bit&quot;
	Else
	    strArchitecture = &quot;32-bit&quot;
	End If
	GetBitnessFromSKU = strArchitecture
	
End Function &#039;GetBitnessFromSKU

Function GetCleanEdition(strSKUName)
&#039; Removes bitness from SKU value
	Dim strEdition
	If Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then
	    strEdition = Left(strSKUName, Instr(strSKUName, &quot; (&quot;))
	Else
	    strEdition = strSKUName
	End If

	GetCleanEdition = strEdition
	
End Function &#039;CleanSKU

Function GetSQLServiceAdvancedProp(strProp,ByRef objWMI)
&#039; Property Names may change for different SQL versions
&#039;SQLSTATES,VERSION,SPLEVEL,CLUSTERED,INSTALLPATH,DATAPATH,LANGUAGE,FILEVERSION,
&#039;VSNAME,REGROOT,SKU,SKUNAME,INSTANCEID,STARTUPPARAMETERS,ERRORREPORTING,DUMPDIR,
&#039;SQMREPORTING,ISWOW64
	On Error Resume Next
	Dim strOut, intType, strPropVal, colResults
	strProp = UCase(strProp) &#039; text matches will happen when uppercased
	Set colResults = objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)
	For Each objProp In colResults
	    If objProp.PropertyName = strProp Then
	    	intType = objProp.PropertyValueType
	    	If Err.Number &lt;&gt; 0 Then
				DebugPrint Err.Description &amp; &quot; inttype is &quot; &amp; objProp.PropertyValueType
				Err.Clear
			End If	
	    	If intType = 0 Then
	        	strOut = objProp.PropertyStrValue
		      	If Err.Number &lt;&gt; 0 Then
					DebugPrint Err.Description &amp; &quot; strout is &quot; &amp; objProp.PropertyStrValue
					Err.Clear
				End If	  	
	        Else
	        	strOut = objProp.PropertyNumValue
	        End If
		End If
	Next

	Err.Clear
	On Error Goto 0
	GetSQLServiceAdvancedProp = strOut

	If DEBUG_OUT = True Then
		WScript.Echo &quot;Debug, listing all props &quot;
		On Error Resume Next
		For Each objProp In colResults
	    	intType = objProp.PropertyValueType

	    	If intType = 0 Then
	        	strOut = objProp.PropertyStrValue	
	        Else
	        	strOut = objProp.PropertyNumValue
	        End If
		WScript.Echo &quot;Property name: &quot;&amp;objProp.PropertyName&amp;&quot;, valuetype: &quot;&amp;intType&amp;&quot;, value: &quot;&amp;strOut
	   	Next
	 End If
End Function &#039;GetSQLServiceAdvancedProp

Sub BuildSQLServicesNames(ByRef objWMI,ByRef dictServices)

	Dim strService
	
	For Each objProp In objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)
		strService = objProp.ServiceName
		If Not IsNull(strService) Then
			If Not dictServices.Exists(strService) Then
				dictServices.Add strService,1
			End If
		End If
	Next
		
End Sub &#039;BuildSQLServicesNames

Sub DebugPrint(ByRef strToPrint)

	If DEBUG_OUT Then
		WScript.Echo strToPrint
	End If
End Sub &#039;DebugPrint

Sub BuildSQLCompMgmtWMIsDict(ByRef dictWMIs)

	&#039; Define a constant MAX_SQL_NUMBER in global scope
	Dim objWMI,i,strWMINameSpace
	On Error Resume Next

    &#039; First try 2005
    strWMINameSpace = &quot;WINMGMTS:\\.\root\Microsoft\SqlServer\ComputerManagement&quot;
    Set objWMI = GetObject(strWMINameSpace)
    If Err.Number = 0 Then
    	dictWMIs.Add objWMI,strWMINameSpace
    	DebugPrint strWMINameSpace
    Else
    	Err.Clear
    	&#039; Loop through 2008 to 2012 and beyond
        For i = 10 To MAX_SQL_NUMBER
        	strWMINameSpace = &quot;WINMGMTS:\\.\root\Microsoft\SqlServer\ComputerManagement&quot;&amp;CStr(i)
        	Set objWMI = GetObject(strWMINameSpace)
        	If Err.Number = 0 Then
        		dictWMIs.Add objWMI,strWMINameSpace
        		DebugPrint strWMINameSpace
        	Else
        		Err.Clear
        	End If
        Next
	End If
	
	Err.Clear
	On Error Goto 0
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
		WScript.Quit
	End If
	
End Sub &#039;BuildSQLCompMgmtWMIsDict",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
135,SQL,2015-01-05T20:22:03,",","Product version from SQL Server on client machine.
Example: 10.50.1617.0",1,2195303088,0,267,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Product Version,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Product Version
&#039;========================================
Option Explicit

Const MAX_SQL_NUMBER = 15
Const DEBUG_OUT = False
Dim strValueName, strSKUName, strEdition, strVersion, strArchitecture 
Dim objWMI, dictWMIs, objProp, strOut, dictServices

Set dictWMIs = CreateObject(&quot;Scripting.Dictionary&quot;)
Set dictServices = CreateObject(&quot;Scripting.Dictionary&quot;)
	
BuildSQLCompMgmtWMIsDict(dictWMIs)

PrintProp(&quot;VERSION&quot;)

Function IsMultiple(ByRef dictWMIs)

	If dictWMIs.Count &gt; 1 Then
		IsMultiple = True
	Else
		IsMultiple = False
	End If
	
End Function &#039;IsMultiple

Sub PrintSPLevel
	Dim strProp,intOutCount

	strProp = &quot;SPLEVEL&quot;
	intOutCount = 1
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
	Else
		For Each objWMI In dictWMIs.Keys
			strOut = GetSQLServiceAdvancedProp(strProp,objWMI)
			If Len(strOut) &gt; 0 Then
				intOutCount = intOutCount + 1
				If strOut = 0 Then
					WScript.Echo &quot;RTM&quot;
				ElseIf IsNumeric(strOut) Then
					WScript.Echo &quot;SP&quot;&amp;strOut
				Else
					WScript.Echo strOut
				End If
			Else
				WScript.Echo &quot;SQL Not Found&quot;
				DebugPrint &quot;SQL Property Not Found&quot;
			End If
		Next
	End If

End Sub &#039;PrintProp 

Sub PrintProp(strProp)
	Dim intOutCount
	intOutCount = 1
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
	Else
		For Each objWMI In dictWMIs.Keys
			strOut = GetSQLServiceAdvancedProp(strProp,objWMI)
			If Len(strOut) &gt; 0 Then
				intOutCount = intOutCount + 1
				WScript.Echo strOut
			Else
				WScript.Echo &quot;SQL Not Found&quot;
				DebugPrint &quot;SQL Property Not Found&quot;
			End If
		Next
	End If

End Sub &#039;PrintProp 

Function PrintServices
	BuildSQLServicesNames objWMI,dictServices
	&#039; Print Services
	Dim strService
	For Each strService In dictServices.Keys
		WScript.Echo strService
	Next
End Function &#039;PrintServices

Function GetBitnessFromSKU(strSKUName)
&#039; Returns appropriate bitness from SKU value
	Dim strArchitecture
	If Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then
	    strArchitecture = &quot;64-bit&quot;
	Else
	    strArchitecture = &quot;32-bit&quot;
	End If
	GetBitnessFromSKU = strArchitecture
	
End Function &#039;GetBitnessFromSKU

Function GetCleanEdition(strSKUName)
&#039; Removes bitness from SKU value
	Dim strEdition
	If Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then
	    strEdition = Left(strSKUName, Instr(strSKUName, &quot; (&quot;))
	Else
	    strEdition = strSKUName
	End If

	GetCleanEdition = strEdition
	
End Function &#039;CleanSKU

Function GetSQLServiceAdvancedProp(strProp,ByRef objWMI)
&#039; Property Names may change for different SQL versions
&#039;SQLSTATES,VERSION,SPLEVEL,CLUSTERED,INSTALLPATH,DATAPATH,LANGUAGE,FILEVERSION,
&#039;VSNAME,REGROOT,SKU,SKUNAME,INSTANCEID,STARTUPPARAMETERS,ERRORREPORTING,DUMPDIR,
&#039;SQMREPORTING,ISWOW64
	On Error Resume Next
	Dim strOut, intType, strPropVal, colResults
	strProp = UCase(strProp) &#039; text matches will happen when uppercased
	Set colResults = objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)
	For Each objProp In colResults
	    If objProp.PropertyName = strProp Then
	    	intType = objProp.PropertyValueType
	    	If Err.Number &lt;&gt; 0 Then
				DebugPrint Err.Description &amp; &quot; inttype is &quot; &amp; objProp.PropertyValueType
				Err.Clear
			End If	
	    	If intType = 0 Then
	        	strOut = objProp.PropertyStrValue
		      	If Err.Number &lt;&gt; 0 Then
					DebugPrint Err.Description &amp; &quot; strout is &quot; &amp; objProp.PropertyStrValue
					Err.Clear
				End If	  	
	        Else
	        	strOut = objProp.PropertyNumValue
	        End If
		End If
	Next

	Err.Clear
	On Error Goto 0
	GetSQLServiceAdvancedProp = strOut

	If DEBUG_OUT = True Then
		WScript.Echo &quot;Debug, listing all props &quot;
		On Error Resume Next
		For Each objProp In colResults
	    	intType = objProp.PropertyValueType

	    	If intType = 0 Then
	        	strOut = objProp.PropertyStrValue	
	        Else
	        	strOut = objProp.PropertyNumValue
	        End If
		WScript.Echo &quot;Property name: &quot;&amp;objProp.PropertyName&amp;&quot;, valuetype: &quot;&amp;intType&amp;&quot;, value: &quot;&amp;strOut
	   	Next
	 End If
End Function &#039;GetSQLServiceAdvancedProp

Sub BuildSQLServicesNames(ByRef objWMI,ByRef dictServices)

	Dim strService
	
	For Each objProp In objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)
		strService = objProp.ServiceName
		If Not IsNull(strService) Then
			If Not dictServices.Exists(strService) Then
				dictServices.Add strService,1
			End If
		End If
	Next
		
End Sub &#039;BuildSQLServicesNames

Sub DebugPrint(ByRef strToPrint)

	If DEBUG_OUT Then
		WScript.Echo strToPrint
	End If
End Sub &#039;DebugPrint

Sub BuildSQLCompMgmtWMIsDict(ByRef dictWMIs)

	&#039; Define a constant MAX_SQL_NUMBER in global scope
	Dim objWMI,i,strWMINameSpace
	On Error Resume Next

    &#039; First try 2005
    strWMINameSpace = &quot;WINMGMTS:\\.\root\Microsoft\SqlServer\ComputerManagement&quot;
    Set objWMI = GetObject(strWMINameSpace)
    If Err.Number = 0 Then
    	dictWMIs.Add objWMI,strWMINameSpace
    	DebugPrint strWMINameSpace
    Else
    	Err.Clear
    	&#039; Loop through 2008 to 2012 and beyond
        For i = 10 To MAX_SQL_NUMBER
        	strWMINameSpace = &quot;WINMGMTS:\\.\root\Microsoft\SqlServer\ComputerManagement&quot;&amp;CStr(i)
        	Set objWMI = GetObject(strWMINameSpace)
        	If Err.Number = 0 Then
        		dictWMIs.Add objWMI,strWMINameSpace
        		DebugPrint strWMINameSpace
        	Else
        		Err.Clear
        	End If
        Next
	End If
	
	Err.Clear
	On Error Goto 0
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
		WScript.Quit
	End If
	
End Sub &#039;BuildSQLCompMgmtWMIsDict",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
136,SQL,2015-01-05T20:22:03,",","Product level for SQL Server on client machine.
Example: SP4",1,482346946,0,269,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Product Level,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Product Level
&#039;========================================
Option Explicit

Const MAX_SQL_NUMBER = 15
Const DEBUG_OUT = False
Dim strValueName, strSKUName, strEdition, strVersion, strArchitecture 
Dim objWMI, dictWMIs, objProp, strOut, dictServices

Set dictWMIs = CreateObject(&quot;Scripting.Dictionary&quot;)
Set dictServices = CreateObject(&quot;Scripting.Dictionary&quot;)
	
BuildSQLCompMgmtWMIsDict(dictWMIs)

PrintSPLevel

Function IsMultiple(ByRef dictWMIs)

	If dictWMIs.Count &gt; 1 Then
		IsMultiple = True
	Else
		IsMultiple = False
	End If
	
End Function &#039;IsMultiple

Sub PrintSPLevel
	Dim strProp,intOutCount

	strProp = &quot;SPLEVEL&quot;
	intOutCount = 1
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
	Else
		For Each objWMI In dictWMIs.Keys
			strOut = GetSQLServiceAdvancedProp(strProp,objWMI)
			If Len(strOut) &gt; 0 Then
				intOutCount = intOutCount + 1
				If strOut = 0 Then
					WScript.Echo &quot;RTM&quot;
				ElseIf IsNumeric(strOut) Then
					WScript.Echo &quot;SP&quot;&amp;strOut
				Else
					WScript.Echo strOut
				End If
			Else
				WScript.Echo &quot;SQL Not Found&quot;
				DebugPrint &quot;SQL Property Not Found&quot;
			End If
		Next
	End If

End Sub &#039;PrintProp 

Sub PrintProp(strProp)
	Dim intOutCount
	intOutCount = 1
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
	Else
		For Each objWMI In dictWMIs.Keys
			strOut = GetSQLServiceAdvancedProp(strProp,objWMI)
			If Len(strOut) &gt; 0 Then
				intOutCount = intOutCount + 1
				WScript.Echo strOut
			Else
				WScript.Echo &quot;SQL Not Found&quot;
				DebugPrint &quot;SQL Property Not Found&quot;
			End If
		Next
	End If

End Sub &#039;PrintProp 

Function PrintServices
	BuildSQLServicesNames objWMI,dictServices
	&#039; Print Services
	Dim strService
	For Each strService In dictServices.Keys
		WScript.Echo strService
	Next
End Function &#039;PrintServices

Function GetBitnessFromSKU(strSKUName)
&#039; Returns appropriate bitness from SKU value
	Dim strArchitecture
	If Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then
	    strArchitecture = &quot;64-bit&quot;
	Else
	    strArchitecture = &quot;32-bit&quot;
	End If
	GetBitnessFromSKU = strArchitecture
	
End Function &#039;GetBitnessFromSKU

Function GetCleanEdition(strSKUName)
&#039; Removes bitness from SKU value
	Dim strEdition
	If Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then
	    strEdition = Left(strSKUName, Instr(strSKUName, &quot; (&quot;))
	Else
	    strEdition = strSKUName
	End If

	GetCleanEdition = strEdition
	
End Function &#039;CleanSKU

Function GetSQLServiceAdvancedProp(strProp,ByRef objWMI)
&#039; Property Names may change for different SQL versions
&#039;SQLSTATES,VERSION,SPLEVEL,CLUSTERED,INSTALLPATH,DATAPATH,LANGUAGE,FILEVERSION,
&#039;VSNAME,REGROOT,SKU,SKUNAME,INSTANCEID,STARTUPPARAMETERS,ERRORREPORTING,DUMPDIR,
&#039;SQMREPORTING,ISWOW64
	On Error Resume Next
	Dim strOut, intType, strPropVal, colResults
	strProp = UCase(strProp) &#039; text matches will happen when uppercased
	Set colResults = objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)
	For Each objProp In colResults
	    If objProp.PropertyName = strProp Then
	    	intType = objProp.PropertyValueType
	    	If Err.Number &lt;&gt; 0 Then
				DebugPrint Err.Description &amp; &quot; inttype is &quot; &amp; objProp.PropertyValueType
				Err.Clear
			End If	
	    	If intType = 0 Then
	        	strOut = objProp.PropertyStrValue
		      	If Err.Number &lt;&gt; 0 Then
					DebugPrint Err.Description &amp; &quot; strout is &quot; &amp; objProp.PropertyStrValue
					Err.Clear
				End If	  	
	        Else
	        	strOut = objProp.PropertyNumValue
	        End If
		End If
	Next

	Err.Clear
	On Error Goto 0
	GetSQLServiceAdvancedProp = strOut

	If DEBUG_OUT = True Then
		WScript.Echo &quot;Debug, listing all props &quot;
		On Error Resume Next
		For Each objProp In colResults
	    	intType = objProp.PropertyValueType

	    	If intType = 0 Then
	        	strOut = objProp.PropertyStrValue	
	        Else
	        	strOut = objProp.PropertyNumValue
	        End If
		WScript.Echo &quot;Property name: &quot;&amp;objProp.PropertyName&amp;&quot;, valuetype: &quot;&amp;intType&amp;&quot;, value: &quot;&amp;strOut
	   	Next
	 End If
End Function &#039;GetSQLServiceAdvancedProp

Sub BuildSQLServicesNames(ByRef objWMI,ByRef dictServices)

	Dim strService
	
	For Each objProp In objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)
		strService = objProp.ServiceName
		If Not IsNull(strService) Then
			If Not dictServices.Exists(strService) Then
				dictServices.Add strService,1
			End If
		End If
	Next
		
End Sub &#039;BuildSQLServicesNames

Sub DebugPrint(ByRef strToPrint)

	If DEBUG_OUT Then
		WScript.Echo strToPrint
	End If
End Sub &#039;DebugPrint

Sub BuildSQLCompMgmtWMIsDict(ByRef dictWMIs)

	&#039; Define a constant MAX_SQL_NUMBER in global scope
	Dim objWMI,i,strWMINameSpace
	On Error Resume Next

    &#039; First try 2005
    strWMINameSpace = &quot;WINMGMTS:\\.\root\Microsoft\SqlServer\ComputerManagement&quot;
    Set objWMI = GetObject(strWMINameSpace)
    If Err.Number = 0 Then
    	dictWMIs.Add objWMI,strWMINameSpace
    	DebugPrint strWMINameSpace
    Else
    	Err.Clear
    	&#039; Loop through 2008 to 2012 and beyond
        For i = 10 To MAX_SQL_NUMBER
        	strWMINameSpace = &quot;WINMGMTS:\\.\root\Microsoft\SqlServer\ComputerManagement&quot;&amp;CStr(i)
        	Set objWMI = GetObject(strWMINameSpace)
        	If Err.Number = 0 Then
        		dictWMIs.Add objWMI,strWMINameSpace
        		DebugPrint strWMINameSpace
        	Else
        		Err.Clear
        	End If
        Next
	End If
	
	Err.Clear
	On Error Goto 0
	If dictWMIs.Count = 0 Then
		WScript.Echo &quot;SQL Not Found&quot;
		WScript.Quit
	End If
	
End Sub &#039;BuildSQLCompMgmtWMIsDict",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
137,SQL,2015-01-05T20:22:03,",",,1,3796118374,0,271,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Database Sizes,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Buffer Hit Ratio
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit

Dim dictInstances, strInstance, objConnection

Set dictInstances = GetMSSQLInstances()

For Each strInstance In dictInstances.Keys
	Dim objRecordSet, objRecordSet2, objConnection2, Record, strDatabase, strDBSize
	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  
	Set objConnection2 = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  
	
	On Error Resume Next
	objConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)
	
	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 
	
	On Error Goto 0
	
	objRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  
	
	For Each Record In objRecordSet.Properties    
		strDatabase = objRecordSet(&quot;name&quot;)    
		objConnection2.Open GenMSSQLConnectionStr(strInstance, strDatabase)    
		
		If objConnection2.Errors.Count &gt; 0 Then 
			WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
			Exit For
		End If 
		
		On Error Goto 0
		
		objRecordSet2.Open &quot;Select cast(size * 8/1024.0 as decimal(18,2)) SpaceUsed_MB From SYS.database_files where type_desc = &#039;ROWS&#039;&quot;, objConnection2, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC       
		strDBSize = objRecordSet2(&quot;SpaceUsed_MB&quot;)       
		WScript.echo strDatabase &amp; &quot; &quot; &amp; strDBSize &amp; &quot;MB&quot; &amp; GetMSSQLSensorInstanceStr(strInstance)
		objRecordset2.Close    
		objConnection2.Close     
		ObjRecordSet.MoveNext    
		If (ObjRecordset.EOF = True) Then       
			objRecordset.Close       
			Exit For    
		End If     
	Next 
Next
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
138,SQL,2015-01-05T20:22:03,",",,1,77425467,0,273,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Log Sizes,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Log Sizes
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit

Dim dictInstances, strInstance, objConnection

Set dictInstances = GetMSSQLInstances()

For Each strInstance In dictInstances.Keys
	Dim objRecordSet, objRecordSet2, objConnection2, Record, strDatabase, strDBSize
	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  
	Set objConnection2 = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  
	On Error Resume Next
	objConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)
	
	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 
	On Error Goto 0

	objRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  
	For each Record in objRecordSet.Properties    
		strDatabase = objRecordSet(&quot;name&quot;)    
		&#039;SpaceUsed_MB = 0     
		objConnection2.Open GenMSSQLConnectionStr(strInstance, strDatabase) 

		If objConnection.Errors.Count &gt; 0 Then 
			WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
			Exit For
		End If 
		On Error Goto 0

		objRecordSet2.Open &quot;Select cast(size * 8/1024.0 as decimal(18,2)) SpaceUsed_MB From SYS.database_files where type_desc = &#039;LOG&#039;&quot;, objConnection2, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC       
		strDBSize = objRecordSet2(&quot;SpaceUsed_MB&quot;)       
		WScript.echo StrDatabase &amp; &quot; &quot; &amp; StrDBSize &amp; &quot;MB&quot; &amp; GetMSSQLSensorInstanceStr(strInstance)      
		objRecordset2.Close    
		objConnection2.Close     
		objRecordSet.MoveNext    
		If (ObjRecordset.EOF = True) THEN       
			objRecordset.Close       
			Exit For    
		End If     
	Next 
Next
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
139,SQL,2015-01-05T20:22:03,",",,1,1240245618,0,275,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Database Recovery Mode,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Database Recovery Mode
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit
Dim dictInstances, strInstance, objConnection

Set dictInstances = GetMSSQLInstances()

For Each strInstance In dictInstances.Keys
	Dim objRecordSet, objRecordSet2, Record, strDatabase, strDBRecovery

	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;) 
	Set objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  
	On Error Resume Next
	objConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)
	
	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 
	
	On Error Goto 0
	
	objRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  
	For Each Record In objRecordSet.Properties    
		strDatabase = objRecordSet(&quot;name&quot;)    
		objRecordSet2.Open &quot;select databasepropertyex([name],&#039;Recovery&#039;) as [Recovery] from dbo.sysdatabases where name=&quot; &amp; &quot;&#039;&quot; &amp; strDatabase &amp; &quot;&#039;&quot;, _         
			objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC       
		strDBRecovery = objRecordSet2(&quot;Recovery&quot;)       
		WScript.echo strDatabase &amp; &quot; &quot; &amp; strDBRecovery &amp; GetMSSQLSensorInstanceStr(strInstance)
		objRecordset2.Close     
		ObjRecordSet.MoveNext    
		If (ObjRecordset.EOF = True) Then       
			objRecordset.Close       
			Exit For    
		End If     
	Next 
Next
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
140,Applications,2015-01-05T20:22:03,|,"A multi-column Sensor that shows processes that have crashed yesterday, including the instance number to capture multiple crashes by the same process.
Example: firefox.exe | 3",1,607666494,0,277,1,Jim Olsen,43200,0,defined,Tanium,2015-01-05T20:22:03,Application Crashes Yesterday,,,,,,,,,Windows,"&#039;========================================
&#039; Application Crashes Yesterday
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit

SensorRandomize()

Dim strSep
Dim objWMIService, colEvents, objEvent, intCount
Dim dtmStart, dtmEnd

strSep = &quot;|&quot;
intCount = 0

dtmStart = GetYesterdayStart
dtmEnd = GetYesterdayEnd

&#039;Dictionary object used to track duplicate processes
Dim oDic
Set oDic = CreateObject(&quot;scripting.dictionary&quot;)

Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\.\root\cimv2&quot;) 

Set colEvents = objWMIService.ExecQuery _
    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _
        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _
        &amp; &quot;TimeWritten &lt; &#039;&quot; &amp; dtmEnd &amp; &quot;&#039; AND &quot; _
        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)


For Each objEvent In colEvents
    Dim strMessage, arrLines, strLine, strApp, strModule, strTime
    
    strMessage = objEvent.Message
    arrLines = Split(strMessage, vbCrLf)
    
    Dim strIndex, strIndexXp

	&#039;just go through first line of log to grab app name
	strLine = arrLines(0)
	
	&#039;strIndex is for new OSes, strIndexXP for older...
	strIndex = &quot;Faulting application name: &quot;
	strIndexXp = &quot;Faulting application &quot;
	If Left(strLine, Len(strIndex)) = strIndex Then
		strApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)
	ElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then
		strApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)
	End If
	
	Dim intInstance
	If oDic.Exists(strApp) Then
		oDic.Item(strApp) = oDic.Item(strApp) + 1
		intInstance = oDic.Item(strApp)
	Else
		oDic.Item(strApp) = 1
		intInstance = 1
	End If
	
    strTime = DatetimeToDate(objEvent.TimeWritten)
    	 
	WScript.Echo strApp &amp; strSep &amp; intInstance
	intCount = intCount + 1
	&#039;&amp; strSep &amp; strTime 
	&#039;&amp; strSep &amp; dtmStart &amp; strSep &amp; objEvent.TimeWritten &amp; strSep &amp; dtmEnd
Next

If intCount = 0 Then
	WScript.Echo &quot;No Application Crashes Found&quot; &amp; strSep
End if

Function GetYesterdayStart
	Dim dtmYesterday
	dtmYesterday = Date() - 1
&#039;	WScript.Echo dtmYesterday
	
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate dtmYesterday, False
	 
  	GetYesterdayStart = dateTime
End Function

Function GetYesterdayEnd
	Dim dtmYesterday
	dtmYesterday = Date()
&#039;	WScript.Echo dtmYesterday
	
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate dtmYesterday, False
	 
  	GetYesterdayEnd = dateTime
End Function

Function DatetimeToDate(strDate)
   DatetimeToDate = _
       CDate(Mid(strDate, 5, 2) &amp; _
       &quot;/&quot; &amp; _
       Mid(strDate, 7, 2) &amp; _
       &quot;/&quot; &amp; _
       Left(strDate, 4) &amp; _
       &quot; &quot; &amp; _
       Mid (strDate, 9, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 11, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 13, 2))
End Function

Function GetTimeWrittenByDaysOld(days)
   &#039;subtract &quot;days&quot; days worth of seconds

	Dim epoc, monthAgo   
   	epoc = date2epoch(Now()) - days*24*60*60
   	monthAgo = epoch2date(epoc)
   
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate monthAgo, True
	 
  	GetTimeWrittenByDaysOld = dateTime
End Function

function date2epoch(myDate)
   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)
end Function

function epoch2date(myEpoch)
   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)
end Function
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,4,0,1,0,Process,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Instance #,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
141,Operating System,2015-01-05T20:22:03,",","Returns the date of the last system crash that occurred.
Example: 8/2/2012",1,1724798097,0,279,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:03,Last System Crash,,,,,,,,,Windows,"&#039;========================================
&#039; Last System Crash
&#039;========================================

Dim strValueName, strKey

strValueName = &quot;DumpFile&quot;
strDumpsDirName = &quot;MinidumpDir&quot;

&#039;Uses date math - set locale

SetLocale(GetTaniumLocale)

strKey = &quot;SYSTEM\CurrentControlSet\Control\CrashControl&quot;

Set objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)
Const HKLM = &amp;h80000002

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

&#039;Get main dump file
Dim mainDumpDate
If RegKeyExists(objReg, HKLM, strKey) Then
	objReg.GetExpandedStringValue HKLM, strKey, strValueName, strValue

	If fso.FileExists(strValue) Then
		
		Set objFile = fso.GetFile(strValue)
		mainDumpDate = objfile.DateLastModified
	End If
Else
	WScript.Echo &quot;Error, Dump key not found: HKLM\SYSTEM\CurrentControlSet\Control\CrashControl&quot;
End If


&#039;Examine minidump folder
Dim newestMini

If RegKeyExists(objReg, HKLM, strKey) Then
	objReg.GetExpandedStringValue HKLM, strKey, strDumpsDirName, strDumpDir

	If fso.FolderExists(strDumpDir) Then
		Set oFolder = fso.GetFolder(strDumpDir)
		For Each sFile In oFolder.Files
			If Right(LCase(sFile.Name), 4) = &quot;.dmp&quot; Then
			    If newestMini = &quot;&quot; Then
			        Set newestMini = sFile
			    Else
			        If newestMini.DateLastModified &lt; sFile.DateLastModified Then
			          Set newestMini = sFile
			        End If
			    End If
			End If
		Next	
	End If
End If



If newestMini = &quot;&quot; And mainDumpDate = &quot;&quot; Then
	WScript.Echo &quot;No system crashes found&quot;
	WScript.Quit
End If

Dim responseDate
If newestMini = &quot;&quot; Then	
	responseDate = mainDumpDate
ElseIf mainDumpDate = &quot;&quot; Then
	responseDate = newestMini.DateLastModified
Else
	If newestMini.DateLastModified &lt; mainDumpDate Then
		responseDate = mainDumpDate
	Else
		responseDate = newestMini.DateLastModified	
	End If
End If

Dim arrTemp
arrTemp = Split(responseDate)
responseDate = arrTemp(0)

WScript.Echo responseDate

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
142,Operating System,2015-01-05T20:22:03,",","Returns the date at which the last system crash occurred.
Example:5/2/2012",1,1815821395,0,281,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Last System Crash in X Days,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query and return system crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""dayThresh"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Last System Crash in X Days
&#039;========================================

dayThresh = LCase(Trim(Unescape(&quot;||dayThresh||&quot;)))
&#039;dayThresh = LCase(Trim(Unescape(&quot;1&quot;)))
If Not IsNumeric(dayThresh) Then 
    WScript.Echo &quot;Parameter Not Number&quot;
    WScript.Quit
End If 
dayThresh = Cint(dayThresh)

Dim strValueName, strKey

strValueName = &quot;DumpFile&quot;
strDumpsDirName = &quot;MinidumpDir&quot;

strKey = &quot;SYSTEM\CurrentControlSet\Control\CrashControl&quot;

Set objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)
Const HKLM = &amp;h80000002

&#039;Uses date math - set locale

SetLocale(GetTaniumLocale)

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

&#039;Get main dump file
Dim mainDumpDate
If RegKeyExists(objReg, HKLM, strKey) Then
	objReg.GetExpandedStringValue HKLM, strKey, strValueName, strValue

	If fso.FileExists(strValue) Then
		
		Set objFile = fso.GetFile(strValue)
		mainDumpDate = objfile.DateLastModified
	End If
Else
	WScript.Echo &quot;Error, Dump key not found: HKLM\SYSTEM\CurrentControlSet\Control\CrashControl&quot;
End If


&#039;Examine minidump folder
Dim newestMini

If RegKeyExists(objReg, HKLM, strKey) Then
	objReg.GetExpandedStringValue HKLM, strKey, strDumpsDirName, strDumpDir

	If fso.FolderExists(strDumpDir) Then
		Set oFolder = fso.GetFolder(strDumpDir)
		For Each sFile In oFolder.Files
		    If newestMini = &quot;&quot; Then
		        Set newestMini = sFile
		    Else
		        If newestMini.DateLastModified &lt; sFile.DateLastModified Then
		          Set newestMini = sFile
		        End If
		    End If
		Next
	End If
End If



If newestMini = &quot;&quot; And mainDumpDate = &quot;&quot; Then
	WScript.Echo &quot;No system crashes found&quot;
	WScript.Quit
End If

Dim responseDate
If newestMini = &quot;&quot; Then	
	responseDate = mainDumpDate
ElseIf mainDumpDate = &quot;&quot; Then
	responseDate = newestMini.DateLastModified
Else
	If newestMini.DateLastModified &lt; mainDumpDate Then
		responseDate = mainDumpDate
	Else
		responseDate = newestMini.DateLastModified	
	End If
End If

current = Now()
dayDiff = DateDiff(&quot;d&quot;, responseDate, current)

Dim arrTemp
If dayDiff &lt;= dayThresh Then
	arrTemp = Split(responseDate)
	responseDate = arrTemp(0)

	WScript.Echo responseDate
Else 
	WScript.Echo &quot;No system crashes in day range&quot;
End If	

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||dayThresh||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||dayThresh||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
143,Applications,2015-01-05T20:22:03,|,"A parameterized Sensor that queries for any processes that have crashed in the last X days.
Example: chrome.exe",1,1265351278,0,283,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Application Crashes in Last X Days,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Application Crashes in Last X Days
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit
Dim strSep
Dim objWMIService, colEvents, objEvent, intCount
Dim dtmStart

strSep = &quot;|&quot;
intCount = 0

&#039;Uses date math - set locale

SetLocale(1033)

dtmStart = GetTimeWrittenByDaysOld(||days||)
&#039;dtmStart = GetTimeWrittenByDaysOld(7)

Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\.\root\cimv2&quot;) 

Set colEvents = objWMIService.ExecQuery _
    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _
        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _
        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)

For Each objEvent In colEvents
    Dim strMessage, arrLines, strLine, strApp, strModule, strTime
    
    strMessage = objEvent.Message
    arrLines = Split(strMessage, vbCrLf)
    
    Dim strIndex, strIndexXp

	&#039;just go through first line of log to grab app name
	strLine = arrLines(0)
	
	&#039;strIndex is for new OSes, strIndexXP for older...
	strIndex = &quot;Faulting application name: &quot;
	strIndexXp = &quot;Faulting application &quot;
	If Left(strLine, Len(strIndex)) = strIndex Then
		strApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)
	ElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then
		strApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)
	End If
	
    strTime = DatetimeToDate(objEvent.TimeWritten)
    
    Dim strDate, arrTemp
    arrTemp = Split(strTime)
    strDate = arrTemp(0)
	WScript.Echo strApp &amp; strSep &amp; strDate
	intCount = intCount + 1
Next

If intCount = 0 Then
	WScript.Echo &quot;No Application Crashes Found&quot; &amp; strSep
End if

Function DatetimeToDate(strDate)
   DatetimeToDate = _
       CDate(Mid(strDate, 5, 2) &amp; _
       &quot;/&quot; &amp; _
       Mid(strDate, 7, 2) &amp; _
       &quot;/&quot; &amp; _
       Left(strDate, 4) &amp; _
       &quot; &quot; &amp; _
       Mid (strDate, 9, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 11, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 13, 2))
End Function

Function GetTimeWrittenByDaysOld(days)
   &#039;subtract &quot;days&quot; days worth of seconds

	Dim epoc, monthAgo   
   	epoc = date2epoch(Now()) - days*24*60*60
   	monthAgo = epoch2date(epoc)
   
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate monthAgo, True
	 
  	GetTimeWrittenByDaysOld = dateTime
End Function

function date2epoch(myDate)
   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)
end Function

function epoch2date(myEpoch)
   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)
end Function
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||days||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||days||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Process,String,,,,,,,,,,,,,,,,,,,,,,,,,,1,1,1,Date,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
144,Network,2015-01-05T20:22:03,|,"Returns the SSID name and signal strength of a connected wireless network where signal strength is 0-5.
Example: linksys|4",1,99939055,0,285,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:03,Wireless Network SSID Strength,,,,,,,,,Windows,"&#039;========================================
&#039; Wireless Network SSID Strength
&#039;========================================

&#039; This sensor uses netsh output to display details about wireless LAN

Option Explicit

Dim strSep

strSep = &quot;|&quot;
				
&#039; This is a multi-column sensor whose output looks like
&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal

GetWirelessNetworkDetails strSep

Function GetWirelessNetworkDetails(strSep)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine, strState, strSSID, strSignal, intSignal
	Dim bPrintLine, bNewInterface
	
	strCommand = &quot;netsh wlan show interfaces&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	For Each strNetshLine In arrNetshResults
		If InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then
			bNewInterface = True	&#039; if there&#039;s a new Name, it&#039;s time to note a new group
		End If
		If InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then
			strState = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then
			strSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then
			strSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove the percentage
			intSignal = CInt(CInt(strSignal) / 20)
			bPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.
		End If
		If bNewInterface And bPrintLine Then
			&#039; if it&#039;s a new group, and at last line in the new group, print
			WScript.Echo strSSID &amp; strSep &amp; intSignal
			bPrintLine = False
		End If
	Next
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetWirelessNetworkDetails",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
# cah
# Created 20140620
# Modified
# looking for wireless network SSIDs actively connected 
# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |
# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm

AIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;
RADIO=&quot;unknown&quot;

DEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)
#echo $DEVID
DEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)

#Get SSID
SSID=$(networksetup -getairportnetwork $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039;)
#echo $SSID

if [ ! &quot;$SSID&quot; ] ; then
	SSID=&quot;Not Available&quot;	
	SIGNAL=&quot;Not Available&quot;
fi

if [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then
  PWR=$( $AIRPATH/airport -I | awk -F&quot;agrCtlRSSI:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )
# This is to convert from power to MS dummy gauge
    if  (( $PWR &lt;= &quot;-100&quot; )) ; then
  	SIGNAL=&quot;0&quot;
   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then
  	SIGNAL=&quot;1&quot;
   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then
  	SIGNAL=&quot;2&quot;
   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then
  	SIGNAL=&quot;3&quot;
   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then
  	SIGNAL=&quot;4&quot;
   else
  	SIGNAL=&quot;5&quot;
  fi  
else 
  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )
  if [ ! &quot;$STATE&quot; ] ; then
    STATE=&quot;off&quot;
    echo &quot;$STATE&quot;
  fi
fi

echo &quot;$SSID | $SIGNAL  ($PWR dB)  &quot;

exit
",UnixShell,0,0,0,1,0,SSID,Numeric,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Strength (0-5),Numeric,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
145,Operating System,2015-01-05T20:22:03,",","Returns the currently logged in user, and No User if nobody is logged in.
Example: Domain\JDoe",1,1913997657,0,287,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Username,,,,,,,,,Windows,"&#039;========================================
&#039; Username
&#039;========================================

Option Explicit

Dim strComputer, objWMIService, colComputer, objComputer

strComputer = &quot;.&quot;    
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
Set colComputer = objWMIService.ExecQuery (&quot;Select UserName from Win32_ComputerSystem&quot;)    

For Each objComputer in colComputer     
	if objComputer.UserName &lt;&gt; &quot;&quot; Then     
		Wscript.Echo StripDuplicateDomains(objComputer.UserName)
	Else     
		Wscript.Echo &quot;No User&quot;     
	End If  
Next    

WScript.Quit
&#039; End

Function StripDuplicateDomains(strInput)
    &#039; Removes duplicate domain prefixes
    Dim arrWords,strResult
    strResult = strInput
    
    If InStr(strInput,&quot;\&quot;) Then
        arrWords = Split(strInput,&quot;\&quot;)
        If UBound(arrWords) &gt;= 2 And LCase(arrWords(0)) = LCase(arrWords(1)) Then
            &#039; Remove duplicate
            strResult = arrWords(0) &amp; &quot;\&quot; &amp; arrWords(2)
    	End If
    End if
    
    StripDuplicateDomains = strResult
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
146,Network,2015-01-05T20:22:03,",","Returns the SSID (name) of a wireless network a machine is connected to.
Example: linksys",1,1466668831,0,289,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Wireless Network Connected SSID,,,,,,,,,Windows,"&#039;========================================
&#039; Wireless Network Connected SSID
&#039;========================================

&#039; This sensor uses netsh output to display details about wireless LAN

Option Explicit

Dim strSep

strSep = &quot;|&quot;
				
GetConnectedWirelessNetwork strSep

Function GetConnectedWirelessNetwork(strSep)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine, strState, strSSID
	Dim bPrintLine, bNewInterface, bConnected
	
	strCommand = &quot;netsh wlan show interfaces&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	bConnected = False &#039;assume no connections
	
	For Each strNetshLine In arrNetshResults
		If InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then
			bNewInterface = True	&#039; if there&#039;s a new Name, it&#039;s time to note a new group
		End If
		If InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then
			strState = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then
			strSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then
			bPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.
		End If
		If bNewInterface And bPrintLine Then
			&#039; if it&#039;s a new group, and at last line in the new group, print
			If InStr(LCase(strState),&quot;connected&quot;) &gt; 0 Then
				WScript.Echo strSSID
				bConnected = True
			End If
			bNewInterface = False
			bPrintLine = False
		End If
	Next
	
	If Not bConnected Then
		WScript.Echo &quot;:No Connection:&quot;
	End If
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetConnectedWirelessNetwork",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash

/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk &#039;/ SSID/ {print substr($0, index($0, $2))}&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
147,Network,2015-01-05T20:22:03,|,"Returns details of all wireless networks a machine can see, whether they are connected or not.  Details include SSID, Network Type, Authentication Method, and Encryption Level.
Example: hotspotwifi | Infrastructure | WPA2-Personal",1,2233537498,0,291,1,Jim Olsen,300,,,,2015-01-05T20:22:03,Wireless Networks Visible,,,,,,,,,Windows,"&#039;========================================
&#039; Wireless Networks Visible
&#039;========================================

&#039; This sensor uses netsh output to display all visible 
&#039; SSIDs

Option Explicit

Dim strSep, strSSIDWhiteList,arrSSIDWhiteList

strSep = &quot;|&quot;
&#039; This is a multi-column sensor whose output looks like
&#039; SSID|Network Type|Authentication|Encryption

strSSIDWhiteList = &quot;&quot;
&#039;strSSIDWhiteList = &quot;linksys&quot;
&#039;strSSIDWhiteList = &quot;ATTNET,ApprovedSSID1,ApprovedSSID2,etc ...&quot;

GetSSIDs strSep, strSSIDWhiteList

Function GetSSIDs(strSep, strSSIDWhiteList)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine, strSSID, strNetworkType,strAuthentication, strEncryption
	Dim bPrintLine, bNewSSID
	
	strCommand = &quot;netsh wlan show networks&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	For Each strNetshLine In arrNetshResults
		If InStr(strNetshLine,&quot;ssid&quot;) &gt; 0 Then
			bNewSSID = True	&#039; if there&#039;s SSD, it&#039;s time to note a new group
			strSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then
			strNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then
			strAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;encryption&quot;) &gt; 0 Then
			strEncryption = Trim(Split(strNetshLine,&quot;:&quot;)(1))
			bPrintLine = True &#039; If we&#039;ve found an Encryption Value, it&#039;s time to print the line.
		End If
		If bNewSSID And bPrintLine And Not InStr(LCase(strSSIDWhiteList), LCase(strSSID)) &gt; 0 Then
			&#039; if it&#039;s a new group, and at last line in the new group, print
			WScript.Echo strSSID &amp; strSep &amp; strNetworkType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strEncryption
			bNewSSID = False
			bPrintLine = False
		End If
	Next
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetSSIDs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
# cah
# Created 20140906
# Modified
# looking for SSIDs via airport

/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s | grep -v &quot;^$&quot; | grep -v &quot;SSID BSSID  &quot; |grep -v &quot;IBSS network&quot;| sed &#039;s/..:..//g&#039; | sed &#039;s/ -..  ... *//g&#039; | sed &#039;s/\(::\).*  .. /\1 /&#039; | sed &#039;s/WPA\(.*\) WPA2\(.*\)/WPA WPA2 \1 \2/g&#039; | sed &#039;s/(/ /g&#039; | sed &#039;s/)/ /g&#039; | sed &#039;s/::/ | |/g&#039; | sed &#039;s/WPA2/WPA2|/&#039; | sed &#039;s/NONE/NONE|NONE|/g&#039; | sed &#039;s/WEP/WEP|WEP/g&#039; | sed &#039;s/WPA \([^W][^P]\)/WPA| \1/g&#039;
",UnixShell,0,0,0,1,0,SSID,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Network Type,String,0,1,2,Authentication,String,0,1,3,Encryption,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
148,Network,2015-01-05T20:22:03,|,"Details of currently active wireless network connection by client machine.  Details include SSID, MAC address, connection state, network type, radio type, authentication, receive rate, transmit rate, and signal strength.
Example: hotspotwifi | xx-xx-xx-xx-xx-xx | connected | Infrastructure | 802.11g | WPA2-Personal | 54 | 54 | 99%",1,4267153065,0,293,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:03,Wireless Network Details,,,,,,,,,Windows,"&#039;========================================
&#039; Wireless Network Details
&#039;========================================

&#039; This sensor uses netsh output to display details about wireless LAN

Option Explicit

Dim strSep

strSep = &quot;|&quot;
				
&#039; This is a multi-column sensor whose output looks like
&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal 0-5

GetWirelessNetworkDetails strSep

Function GetWirelessNetworkDetails(strSep)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine, strName, strMAC, strState, strSSID
	Dim strNetworkType, strRadioType, strAuthentication
	Dim strReceiveRate, strTransmitRate, strSignal, intSignal
	Dim bPrintLine, bNewInterface
	
	strCommand = &quot;netsh wlan show interfaces&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	For Each strNetshLine In arrNetshResults
		If InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then
			bNewInterface = True	&#039; if there&#039;s a new Name, it&#039;s time to note a new group
			strName = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then
			strMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))
		End If
		If InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then
			strState = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then
			strSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then
			strNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;radio type&quot;) &gt; 0 Then
			strRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If		
		If InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then
			strAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;receive rate&quot;) &gt; 0 Then
			strReceiveRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;
		End If
		If InStr(strNetshLine,&quot;transmit rate&quot;) &gt; 0 Then
			strTransmitRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;
		End If
		If InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then
			strSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove %
			intSignal = CInt(CInt(strSignal) / 20)
			bPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.
		End If
		If bNewInterface And bPrintLine Then
			&#039; if it&#039;s a new group, and at last line in the new group, print
			WScript.Echo strSSID &amp; strSep &amp; strMAC &amp; strSep &amp; strState &amp; strSep &amp; strNetworkType _
				&amp; strSep &amp; strRadioType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strReceiveRate &amp; strSep _
				&amp; strTransmitRate &amp; strSep &amp; intSignal
			bNewInterface = False
			bPrintLine = False
		End If
	Next
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetWirelessNetworkDetails",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
# cah
# Created 20140616
# Modified
# looking for wireless network SSIDs actively connected 
# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |
# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm

AIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;
RADIO=&quot;unknown&quot;

DEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)
#echo $DEVID
DEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)

#Get SSID
SSID=$(networksetup -getairportnetwork $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039;)
#echo $SSID

if [ ! &quot;$SSID&quot; ] ; then
	SSID=&quot;Not Available&quot;
	NETWORKTYPE=&quot;Not Available&quot;
	AUTHENTICATION=&quot;Not Available&quot;
	RECEIVE=&quot;Not Available&quot;
	TRANSMIT=&quot;Not Available&quot;
	SIGNAL=&quot;Not Available&quot;
fi

if [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then
  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )
  NETWORKTYPE=$( $AIRPATH/airport -I | grep &quot;op mode:&quot; | awk -F&quot;: &quot; &#039;{print $2}&#039; )
  AUTHENTICATION=$( $AIRPATH/airport -I | grep &quot;link auth&quot; | awk &#039;{print $3}&#039; )
  RECEIVE=$( $AIRPATH/airport -I | awk -F&quot;lastTxRate:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )
  TRANSMIT=$RECEIVE
  PWR=$( $AIRPATH/airport -I | awk -F&quot;agrCtlRSSI:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )
 This is to convert from power to MS dummy gauge
    if  (( $PWR &lt;= &quot;-100&quot; )) ; then
  	SIGNAL=&quot;0&quot;
   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then
  	SIGNAL=&quot;1&quot;
   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then
  	SIGNAL=&quot;2&quot;
   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then
  	SIGNAL=&quot;3&quot;
   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then
  	SIGNAL=&quot;4&quot;
   else
  	SIGNAL=&quot;5&quot;
  fi  
else 
  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )
  if [ ! &quot;$STATE&quot; ] ; then
    STATE=&quot;off&quot;
  fi
fi

#echo $SSID

echo &quot;$SSID | $DEVMAC | $STATE |  $NETWORKTYPE | $RADIO | $AUTHENTICATION | $RECEIVE Mbps | $TRANSMIT Mbps | $SIGNAL  ($PWR dB)  &quot;

exit
",UnixShell,0,0,0,1,0,SSID,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,MAC,String,0,1,2,State,String,0,1,3,Network Type,String,0,1,4,Radio,String,0,1,5,Authentication,String,0,1,6,Receive,String,0,1,7,Transmit,String,0,1,8,Signal (0-5),String,,,,,,String
149,Network,2015-01-05T20:22:03,|,"Returns the SSID name, the IP Address, and the MAC address of connected wireless networks only if the Tanium Client is using those networks to communicate.
Example: linksys|192.168.10.5|00D55FED214C1A2C",1,4206488295,0,295,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:03,Wireless Network Used by Tanium,,,,,,,,,Windows,"&#039;========================================
&#039; Wireless Network Used by Tanium
&#039;========================================

&#039; This sensor uses netsh output to display details about wireless LAN
&#039; if the IP is used by the Tanium Client


Option Explicit

Dim strSep, strTaniumIPAddress, strTaniumMAC

strTaniumIPAddress = GetTaniumIPAddress
If strTaniumIPAddress = False Then 
	WScript.Echo &quot;Can&#039;t retrieve Tanium Client&#039;s IP address&quot;
End If

strTaniumMAC = GetMACByIP(strTaniumIPAddress)

strSep = &quot;|&quot;
			
&#039; This is a multi-column sensor whose output looks like
&#039; SSID|IPAddress|MAC

GetTaniumWirelessNetworkDetailsFromMAC strSep, strTaniumMAC, strTaniumIPAddress

Function GetTaniumWirelessNetworkDetailsFromMAC(strSep, strMACArg, strIPAddressArg)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine, strState, strSSID, strSignal, intSignal
	Dim bPrintLine, bNewInterface, strMAC
	Dim bFoundMAC
	
	strCommand = &quot;netsh wlan show interfaces&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	bFoundMAC = False
	
	For Each strNetshLine In arrNetshResults
		If InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then
			bNewInterface = True	&#039; if there&#039;s a new Name, it&#039;s time to note a new group
		End If
		If InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then
			strState = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then
			strSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
	If InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then
			strMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))
			If LCase(strMAC) = LCase(strMACArg) Then
				bFoundMAC = True
			End If
		End If		
		If InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then
			strSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove the percentage
			intSignal = CInt(CInt(strSignal) / 20)
			bPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.
		End If
		If bNewInterface And bPrintLine And bFoundMAC Then
			&#039; if it&#039;s a new group, and at last line in the new group, and we found MAC, print
			strIPAddressArg = left(strIPAddressArg,len(strIPAddressArg)-4)
			WScript.Echo strSSID &amp; strSep &amp; strIPAddressArg &amp; strSep &amp; intSignal
			bPrintLine = False
		End If
	Next
	
	If Not bFoundMAC Then
		WScript.Echo &quot;:Wired:&quot;
	End If
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetWirelessNetworkDetailsFromMAC

Function GetTaniumIPAddress
&#039; Modified from the ua-scan code to remove the subnet and last octet calculations
&#039; which are irrelevant for these purposes.
&#039; Returns the IP address that the client uses for Tanium activity
&#039; (talking to server and other clients)

	Dim strComputer, objReg, strCommand, objShell, objScriptExec
	Dim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords
	Dim strIPAddress, strTaniumPath, strClientAddress
	Dim strServerName
	
	strComputer = &quot;.&quot;
	Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	Const HKLM = &amp;h80000002
	
		
	&#039;&#039;###########Get Tanium Key on 64/32bit computers##########
	
	strTaniumPath = GetTaniumRegistryPath()
	
	
	&#039; if we can pull this from the registry (newer client version), just use that
	objReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\Status&quot;, &quot;ClientAddress&quot;, strClientAddress
	If strClientAddress &lt;&gt; &quot;&quot; Then
		strClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)
		strClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))
		&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;
		GetTaniumIPAddress = strClientAddress
		&#039;Cleanup
		Set objReg = Nothing
		Exit Function
	End If
	
	&#039;Otherwise use PathPing to determine client IP used by Tanium

	&#039;&#039;# Read the ServerName value

	objReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName

	strCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	strResults = objScriptExec.StdOut.ReadAll
	
	arrPathPingLines = Split(strResults, vbCrLf)
	For Each strPathPingLine In arrPathPingLines
		arrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)
		If UBound(arrPathPingWords) &gt; 0 Then
			If arrPathPingWords(0) = &quot;0&quot; Then
				strIPAddress = arrPathPingWords(1)
				Exit For
			End If
		End If	
	Next
	
	Set objShell = Nothing
	Set objScriptExec = Nothing
	Set objReg = Nothing

	If Not IsNull(strIPAddress) Then
		GetTaniumIPAddress = strIPAddress
	Else
		GetTaniumIPAddress = False
	End If
End Function &#039;GetTaniumIPAddress


Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function GetMACByIP(strIP)

	Dim strFoundIP, strFoundMAC, bFound
	Dim objWMIService, colItems, objItem
	
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration&quot;,,48)
	
	For Each objItem in colItems
		If Not IsNull(objItem.IPAddress) Then
			For Each strFoundIP In objItem.IPAddress
				If strIP = strFoundIP Then
					bFound = True
					strFoundMAC = objItem.MACAddress
				End If
			Next
		End If
	Next
	
	If bFound Then
		GetMACByIP = strFoundMAC
	Else
		GetMACByIP = False
	End If
	
	&#039;Cleanup
	Set colItems = Nothing
	Set objWMIService = Nothing

End Function &#039;GetMACByIP",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
# cah
# Created 20140620
# Modified
# looking for wireless network SSIDs actively used by Tanium client.i&#039;ve 
# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |
# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm

AIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;
RADIO=&quot;unknown&quot;

DEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)
#echo $DEVID
DEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)

TANIUMIP=$( netstat -atn | grep 17472 | awk &#039;{print $4}&#039;|grep 17472|awk -F\. &#039;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}&#039; | sort -u )

WIRELESSIP=$( networksetup -getinfo Wi-Fi | grep &quot;IP address&quot; | grep -v &quot;IPv6&quot; | awk &#039;{print $3}&#039; )

if [ &quot;$TANIUMIP&quot;==&quot;$WIRELESSIP&quot; ] ; then

	#Get SSID
	SSID=$(networksetup -getairportnetwork $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039;)

	if [ ! &quot;$SSID&quot; ] ; then
		SSID=&quot;Not Available&quot;	
		SIGNAL=&quot;Not Available&quot;
	fi

	if [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then
	  PWR=$( $AIRPATH/airport -I | awk -F&quot;agrCtlRSSI:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )
	# This is to convert from power to MS dummy gauge
		if  (( $PWR &lt;= &quot;-100&quot; )) ; then
		SIGNAL=&quot;0&quot;
	   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then
		SIGNAL=&quot;1&quot;
	   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then
		SIGNAL=&quot;2&quot;
	   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then
		SIGNAL=&quot;3&quot;
	   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then
		SIGNAL=&quot;4&quot;
	   else
		SIGNAL=&quot;5&quot;
	  fi
	  echo &quot;$SSID | $TANIUMIP | $SIGNAL  ($PWR dB)  &quot;  
	else 
	  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )
	  if [ ! &quot;$STATE&quot; ] ; then
		STATE=&quot;:Wired:||&quot;
		echo &quot;$STATE&quot;
	  fi
	fi
	
fi

exit
",UnixShell,0,0,0,1,0,SSID,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,IP Address,String,0,1,2,Signal Strength,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
150,Network,2015-01-05T20:22:03,",","Returns MAC addresses for all IP enabled network connections.
Example:00:0C:29:68:6A:D8",1,1208633896,0,297,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:03,MAC Address,,,,,,,,,Windows,select MACAddress from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/bash
ifconfig | grep -i -o -e hwaddr.*:.. -e ether.*:.. | grep -o ..:..:..:..:..:.. | while read line
do
	echo ${line}
done
",UnixShell,Mac,"networksetup -listallhardwareports | egrep -A 2 &quot;(: Ethernet|: AirPort|: Wi-Fi)&quot; | grep &quot;Ethernet Address&quot; | cut -f 3- -d &#039; &#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
151,Network,2015-01-05T20:22:03,",","Whether or not a machine has an network adapter set to DHCP.  Note, a machine may have multiple active adapters and may return multiple lines.  If a machine has multiple adapters on DCHP, TRUE is returned only once.
Example: TRUE, FALSE",1,1154425412,0,299,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,DHCP Enabled?,,,,,,,,,Windows,select DHCPEnabled from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
152,Network,2015-01-05T20:22:03,",","Returns the current status of the Windows firewalls.
Example: DomainProfile enabled",1,889071797,0,301,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Firewall Status,,,,,,,,,Windows,"&#039;========================================
&#039; Firewall Status
&#039;========================================

On Error Resume Next

const HKLM = &amp;H80000002
const strKeyPath = &quot;SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\&quot;
const strValueName = &quot;EnableFirewall&quot;
strComputer = &quot;.&quot;

Set oReg=GetObject( _
   &quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp;_
   strComputer &amp; &quot;\root\default:StdRegProv&quot;)

WScript.Echo GetFirewallStatus(strKeyPath, &quot;DomainProfile&quot;, strValueName)
WScript.Echo GetFirewallStatus(strKeyPath, &quot;PublicProfile&quot;, strValueName)
WScript.Echo GetFirewallStatus(strKeyPath, &quot;StandardProfile&quot;, strValueName)

Function GetFirewallStatus(path, policy, valName)
   oReg.GetDWORDValue HKLM,path &amp; policy, valName, dwValue
   If Not IsNull(dwValue) Then
      If dwValue = 0 Then
         GetFirewallStatus = policy &amp; &quot; disabled&quot;
      ElseIf dwValue = 1 Then 
         GetFirewallStatus = policy &amp; &quot; enabled&quot;
      End If
   Else
      &#039;Policy not found, ignore
   End If   
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
system_profiler SPFirewallDataType | grep -i &quot;Mode&quot; | grep -v &quot;Stealth Mode&quot; | awk -F&#039;: &#039; &#039; { print $2 } &#039;
",UnixShell,0,8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
153,Miscellaneous,2015-01-05T20:22:03,|,"Returns a set of columns with details about open shares on a machine.
Example: name | path | status | type | permissions",1,93198492,0,303,1,Jim Olsen,1800,0,defined,Tanium,2015-01-05T20:22:03,Open Share Details,,,,,,,,,Windows,"&#039;========================================
&#039; Open Share Details
&#039;========================================

Set dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; Add one line for each admin user that you do not want listed in the sensor output.  
&#039; dictBlacklist.Add LCase(&quot;NomadSHR&quot;), True


Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Share where caption != &#039;Default Share&#039; AND caption != &#039;Remote Admin&#039; AND caption != &#039;Remote IPC&#039;&quot;,,48)

strSep = &quot;|&quot;

hasResults = False
For Each objItem in colItems
	strType = &quot;Other&quot;
	Select Case objItem.Type
		Case 0
			strType = &quot;Disk Drive&quot;
		Case 1	
			strType = &quot;Print Queue&quot;
		Case 2
			strType = &quot;Device&quot;
		Case 3
			strType = &quot;IPC&quot;
		Case else
	End Select
	strShareName = objItem.Name
	&#039;strPerms = GetPerms(strShareName)
    strResult = strShareName &amp; strSep &amp; objItem.Path &amp; strSep &amp; objItem.Status &amp; strSep &amp; strType &amp; strSep &amp; strPerms &amp; GetPerms(strShareName)
    
    bShouldList = True
    For Each strItem In dictBlacklist.Keys
        If InStr(LCase(strResult), strItem) &gt; 0 Then 
            bShouldList = False
        End If
    Next

    If bShouldList Then 
        WScript.Echo strResult
        hasResults = True
    End If 
Next

If Not hasResults Then
	WScript.Echo &quot;No shares&quot;
End If

 
Function GetPerms(strShareName)
	 Dim ArrResult()
	 intSize= 0
	 ReDim Preserve ArrResult(intSize)
     &#039;wscript.echo strShareName
     Dim objWMIService : Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	 
     Dim colItems : Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_LogicalShareSecuritySetting where NAME=&quot; &amp; &quot;&#039;&quot; &amp; strShareName &amp; &quot;&#039;&quot;)
	 For Each objItem In colItems
         
         intRtn = objItem.GetSecurityDescriptor(wmiSecurityDescriptor)
     
         colDACLs = wmiSecurityDescriptor.DACL
         
         For Each objACE In colDACLs
			 
             Set objUserGroup = objACE.Trustee
             
             Select Case objACE.AccessMask
                 Case 1179817 strPermission = &quot;READ&quot;
                 Case 1245631 strPermission = &quot;CHANGE&quot;
                 Case 2032127 strPermission = &quot;FULL CONTROL&quot;
             End Select
             ReDim Preserve ArrResult(intSize)
             &#039;wscript.echo (Ucase(objUserGroup.Name)) &amp; &quot; | &quot; &amp; strPermission
		
		 ArrResult(intSize) = (Ucase(objUserGroup.Name)) &amp; &quot;-&quot; &amp; strPermission
		 &#039;wscript.echo intSize
		 intSize = intSize + 1
         Next
     Next
	 GetPerms = Join(ArrResult, &quot;\&quot;)
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Path,String,0,1,2,Status,String,0,1,3,Type,String,0,1,4,Permissions,String,,,,,,,,,,,,,,,,,,,,,,,,,,String
154,Security,2015-01-05T20:22:03,|,"Returns various data about a machines externally or locally defined Password Policy.
Example: maximum age | minimum age | enforced history | minimum length | lockout duration | lockout threshold | lockout observation window",1,2417208908,0,305,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:03,Password Policy Details,,,,,,,,,Windows,"&#039;========================================
&#039; Password Policy Details
&#039;========================================

On Error Resume Next

Dim objRoot, objDomain, strSep
&#039;Maximum Password Age | Minimum Password Age | Enforced Password History | Minimum Password Length | Lockout Duration| Lockout Threshold |Lockout Observation Window
strSep = &quot;|&quot;

Set objRoot = GETOBJECT(&quot;LDAP://RootDSE&quot;)
Set objDomain = GETOBJECT(&quot;LDAP://&quot; &amp; objRoot.GET(&quot;defaultNamingContext&quot;))

If IsEmpty(objDomain) Then
GetSecPolDetails strSep
Else

maximumPasswordAge = int(Int8ToSec(objDomain.GET(&quot;maxPwdAge&quot;)) / 86400) &#039;convert to days
minimumPasswordAge = Int8ToSec(objDomain.GET(&quot;minPwdAge&quot;)) / 86400  &#039;convert to days
minimumPasswordLength = objDomain.GET(&quot;minPwdLength&quot;)
accountLockoutDuration = Int8ToSec(objDomain.GET(&quot;lockoutDuration&quot;)) / 60  &#039;convert to minutes
lockoutThreshold = objDomain.GET(&quot;lockoutThreshold&quot;) 
lockoutObservationWindow = Int8ToSec(objDomain.GET(&quot;lockoutObservationWindow&quot;)) / 60 &#039;convert to minutes
passwordHistory = objDomain.GET(&quot;pwdHistoryLength&quot;)

wscript.echo maximumPasswordAge &amp; &quot; days&quot; &amp; strSep &amp; _
	     minimumPasswordAge &amp; &quot; days&quot; &amp; strSep &amp; _
	     passwordHistory &amp; &quot; passwords remembered&quot; &amp; strSep &amp; _
	     minimumPasswordLength &amp; &quot; characters&quot; &amp; strSep &amp; _
	     accountLockoutDuration &amp; &quot; minutes&quot; &amp; strSep &amp; _
	     lockoutThreshold &amp; &quot; invalid logon attempts&quot; &amp; strSep &amp; _
	     lockoutObservationWindow &amp; &quot; minutes&quot;
	     

End If


FUNCTION GetSecPolDetails(strSep)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetAccResults, strNetAccResults
	Dim strNetAccLine, strMinAge, strMaxAge, strPWDHist, strMinLength
	Dim strLockDur, strLockThresh, strLockWindow
	Dim bPrintLine, bNewInterface
	
	strCommand = &quot;net accounts&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetAccResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetAccResults = Split(LCase(strNetAccResults),vbCrLf)

	For Each strNetAccLine In arrNetAccResults
		If InStr(strNetAccLine,&quot;minimum password age&quot;) &gt; 0 Then
			strMinAge = Trim(Split(strNetAccLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetAccLine, &quot;maximum password&quot;) &gt; 0 Then
			strMaxAge = Trim(Split(strNetAccLine,&quot;: &quot;)(1))
		End If
		If InStr(strNetAccLine, &quot;minimum password length&quot;) &gt; 0 Then
			strMinLength = Trim(Split(strNetAccLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetAccLine, &quot;password history&quot;) &gt; 0 Then
			strPWDHist = Trim(Split(strNetAccLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetAccLine, &quot;password history&quot;) &amp; InStr(strNetAccLine, &quot;none&quot;) Then
			strPWDHist = &quot;0&quot;
		End If
		If InStr(strNetAccLine, &quot;lockout threshold&quot;) &gt; 0 Then
			strLockThresh = Trim(Split(strNetAccLine,&quot;:&quot;)(1))
		End If	
		If InStr(strNetAccLine, &quot;lockout threshold&quot;) &amp; InStr(strNetAccLine, &quot;never&quot;) Then
			strLockThresh = &quot;0&quot;
		End If		
		If InStr(strNetAccLine,&quot;lockout duration&quot;) &gt; 0 Then
			strLockDur = Trim(Split(strNetAccLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetAccLine,&quot;lockout observation&quot;) &gt; 0 Then
			strLockWindow = Trim(Split(strNetAccLine,&quot;:&quot;)(1))
		End If
		
	Next
	&#039;WScript.Echo strMaxAge &amp; &quot; days&quot; &amp; strSep &amp; strMinAge &amp;  &quot; days&quot; &amp; strSep &amp; strPWDHist &amp; &quot; passwords remembered&quot; &amp;  strSep &amp; strMinLength &amp;  &quot; characters&quot; &amp; strSep &amp; strLockDur &amp;  &quot; minutes&quot; &amp; strSep &amp; strLockThresh &amp;  &quot; invalid logon attempts&quot; &amp; strSep &amp; strLockWindow  &amp; &quot; minutes&quot;

	WScript.Echo strPWDHist &amp; &quot; passwords remembered&quot; &#039;&amp;  strSep &amp; strMinLength &amp;  &quot; characters&quot; &amp; strSep &amp; strLockDur &amp;  &quot; minutes&quot; &amp; strSep &amp; strLockThresh &amp;  &quot; invalid logon attempts&quot; &amp; strSep &amp; strLockWindow  &amp; &quot; minutes&quot;




	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
END FUNCTION &#039;GetSecPolDetails

FUNCTION Int8ToSec(BYVAL objInt8)
        &#039; Function to convert Integer8 attributes from
        &#039; 64-bit numbers to seconds.
        DIM lngHigh, lngLow
        lngHigh = objInt8.HighPart
        &#039; Account for error in IADsLargeInteger property methods.
        lngLow = objInt8.LowPart
        IF lngLow &lt; 0 THEN
            lngHigh = lngHigh + 1
        END IF
        Int8ToSec = -(lngHigh * (2 ^ 32) + lngLow) / (10000000)
END FUNCTION",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Maximum Password Age,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Minimum Password Age,String,0,1,2,Enforced Password History,String,0,1,3,Minimum Password Length,String,0,1,4,Lockout Duration,String,0,1,5,Lockout Threshold,String,0,1,6,Lockout Observation Window,String,,,,,,,,,,,,,,,,String
155,Unmanaged Assets,2015-01-05T20:22:03,|,"IP addresses of machines in the network that do not have the Tanium Client running.  When possible, unmanaged assets will return the IP address, the machine name, and the MAC address
Example: 192.168.1.2 | my-machine-name | 00-22-9a-3e-91-5f",1,174166312,0,307,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Unmanaged Assets,,,,,,,,,Windows,"&#039;========================================
&#039; Unmanaged Applications
&#039;========================================

Option Explicit

&#039;&#039; ---- Begin Customer Modifiable ----
&#039; This minutes old threshold will determine how new a file must be
&#039; in order to have results reported by the sensor. Ideally this would
&#039; match the reissuance frequency of the scan
Dim intMinutesOldThreshold
intMinutesOldThreshold = 60
&#039; ---- End Customer Modifiable ---&#039;

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput
&#039;ip address|name|mac address

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;uaresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	Dim dtmModified,minutesOld
	dtmModified = objFSO.GetFile(fn).DateLastModified
	If IsDate(dtmModified) Then
		minutesOld = GetMinutesOld(dtmModified)
		If CDbl(minutesOld) &gt;= intMinutesOldThreshold Then
			WScript.Echo &quot;Results older than &quot; &amp; intMinutesOldThreshold &amp; &quot; - waiting to rescan&quot;
			WScript.Quit(0)
		End If
	End If

	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)
	
	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False
	
	Do While Not objReadFile.AtEndOfStream
		hasOutput = True
		strLine = objReadFile.ReadLine

		WScript.Echo strLine
	Loop
	objReadFile.Close
	
	If Not hasOutput Then
		WScript.Echo &quot;Unmanaged assets not found&quot;
	End If
Else
   Wscript.echo &quot;Unmanaged Asset scan results not found&quot;
End if
WScript.Quit()


Function GetMinutesOld(strDate)
	Dim patternDate,today
	patternDate = CDate( strDate )
	today = CDate( now )
	GetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)
End Function


Function RegKeyExists(reg, sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,IP Address,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Computer Name,String,0,1,2,MAC Address,String,0,1,3,MAC Organization,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
156,Hardware,2015-01-05T20:22:03,",","Returns a list of USB storage devices currently plugged in to the client machine.
Example: USB Mass Storage Device",1,4284507739,0,309,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,USB Storage Devices,,,,,,,,,Windows,"&#039;========================================
&#039; USB Storage Devices
&#039;========================================

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PnPEntity where (Status=&#039;OK&#039; and Service=&#039;USBSTOR&#039;)&quot;,,48)

hasResults = False

For Each objItem in colItems
	hasResults = True
    Wscript.Echo objItem.Caption
Next

If Not hasResults Then
	WScript.Echo &quot;No devices&quot;
End If",VBScript,Linux,"#!/bin/bash
for udi in $(/usr/bin/hal-find-by-capability --capability storage)
do
    device=$(hal-get-property --udi $udi --key block.device)
    vendor=$(hal-get-property --udi $udi --key storage.vendor)
    model=$(hal-get-property --udi $udi --key storage.model)
    if [[ $(hal-get-property --udi $udi --key storage.bus) = &quot;usb&quot; ]]
    then
        parent_udi=$(hal-find-by-property --key block.storage_device --string $udi)
        mount=$(hal-get-property --udi $parent_udi --key volume.mount_point)
        label=$(hal-get-property --udi $parent_udi --key volume.label)
        media_size=$(hal-get-property --udi $udi --key storage.removable.media_size)
        size=$(( $media_size / ( 1000 * 1000 * 1000 ) ))
#        printf &quot;$vendor  $model  $device  $mount  $label &quot;${size}GB&quot; \n&quot;
        printf &quot;$vendor $model &quot;${size}GB&quot; \n&quot;
    fi
done
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
157,Security,2015-01-05T20:22:03,",","Returns the users which have no screen saver password set.
Example: Domain\John.Doe",1,1417112132,0,311,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:03,No Screen Saver Password,,,,,,,,,Windows,"&#039;========================================
&#039; No Screen Saver Password
&#039;========================================

strComputer = &quot;.&quot;
Set objWMIService = GetObject(_
    &quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(_
    &quot;Select * from Win32_Desktop&quot;)
For Each objItem in colItems
	If objItem.ScreenSaverSecure = False Then
		If InStr(LCase(objItem.Name), &quot;nt authority&quot;) = 0 Then
			WScript.Echo objItem.Name
		End If	
	End If
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
158,Operating System,2015-01-05T20:22:03,",","Outputs True if USB storage devices connected to the client machine are set to write protected mode and false if not.
Example: False",1,3595988712,0,313,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,USB Write Protected,,,,,,,,,Windows,"&#039;========================================
&#039; USB Write Protected
&#039;========================================

&#039; This sensor will output True if USB storage devices are
&#039; set to write protect mode and false if not

Option Explicit

If USBWriteProtected Then
	WScript.Echo &quot;True&quot;
Else
	WScript.Echo &quot;False&quot;
End If

Function USBWriteProtected
&#039; This function will look into the registry to determine if USB storage devices
&#039; are write protected

	Const HKLM = &amp;H80000002

	Dim objRegistry, objWMIService
	Dim strComputer
	Dim strUSBWriteProtectKey
	Dim strUSBWriteProtectValueName, dwordWriteProtectValue

	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
		&amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;) 

	Set objRegistry = _
		GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
		&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	

	strUSBWriteProtectKey = &quot;SYSTEM\CurrentControlSet\Control\StorageDevicePolicies&quot;
	strUSBWriteProtectValueName = &quot;WriteProtect&quot; &#039; This is a DWORD value

	If Not RegKeyExists(objRegistry, HKLM, strUSBWriteProtectKey) Then
		USBWriteProtected = False
	End If
	
	objRegistry.GetDWORDValue HKLM, strUSBWriteProtectKey, strUSBWriteProtectValueName, dwordWriteProtectValue
	
	If IsNull(dwordWriteProtectValue) Then
		USBWriteProtected = False
	Else 
		If dwordWriteProtectValue = 1 Then
			USBWriteProtected = True
		End IF
	End If
	
	&#039;Cleanup
	Set objWMIService = Nothing
	Set objRegistry = Nothing
	
End Function &#039;USBWriteProtected

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
159,Network,2015-01-05T20:22:03,|,"Any established connections currently being made from a process that is not allowed or to a destination that is not allowed.  This multi-column Sensor displays the process responsible for the connection, the display name of the process (if available), and the target IP Address and port.  Processes and IP ranges can be excluded in the Sensor definition.
Example: chrome.exe | Google Chrome | 173.194.79.99:80",1,1509255291,0,315,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Non-Approved Established Connections,,,,,,,,,Windows,"&#039;========================================
&#039; Non-Approved Established Connections
&#039;========================================

showProcess = True
showPort = True
showDNSName = False

Dim strcommand, results, excludeProcesses, excludeSubnets, taniumDebug, excludeProcessesFilePath, excludeSubnetsFilePath
Dim strSep : strSep = &quot;|&quot;
excludeProcessesFilePath = GetTaniumDir(&quot;Tools\IR&quot;) &amp; &quot;excluded-processes.dat&quot;
excludeSubnetsFilePath = GetTaniumDir(&quot;Tools\IR&quot;) &amp; &quot;excluded-subnets.dat&quot;

&#039; This is a multi-column sensor that looks like:
&#039;Process|Name|Target IP

Dim objFSO : Set objFSO = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
If objFSO.FileExists(excludeProcessesFilePath) Then
	&#039;exclude processes file exists - read from file
	excludeProcesses = LoadDATFileAsArray(excludeProcessesFilePath)
Else
	&#039;exclude processes file doesn&#039;t exist - specify processes below
	excludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;
	&#039;excludeProcesses = &quot;chrome.exe&quot;
	&#039;excludeProcesses = &quot;iexplore.exe&quot;
	&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;
	&#039;excludeProcesses = &quot;trillian.exe&quot;
	excludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)
End If 

If objFSO.FileExists(excludeSubnetsFilePath) Then
	&#039;exclude subnets file exists - read from file
	excludeSubnets = LoadDATFileAsArray(excludeSubnetsFilePath)
Else
	&#039;exclude subnets file doesn&#039;t exist - specify subnets below
	excludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;
	&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;
	excludeSubnets = Split(excludeSubnets, &quot;,&quot;)
End If 


taniumDebug = False

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
query = &quot;select name, executablepath, processId from win32_process&quot;
Set colResults = objWMIService.ExecQuery(query)

&#039;dictionary for process-app pairs
Set processes = CreateObject(&quot;Scripting.Dictionary&quot;)

For Each result In colResults 
   processId = CStr(result.ProcessId)
   processPath = result.ExecutablePath
   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later
Next

strcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; Chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find &quot; &amp; Chr(34) &amp; &quot;ESTABLISHED&quot; &amp; Chr(34)

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strPingResults = LCase(objScriptExec.StdOut.ReadAll)

results = Split(strPingResults, vbCrLf)
j = 0

For Each line In results
   line = cleanWhitespace(Trim(line))
   
   If line &lt;&gt; &quot;&quot; Then 
	   lineResults = Split(line)
	   i = 0
	   Dim strPort, strPid, strConnectionType, strForeignIp, strApp
	   For Each word In lineResults
	      If i = 1 Then
	         strPort = word
	      ElseIf i = 2 Then
	         strForeignIp = word
	      ElseIf i = 3 Then
	         strConnectionType = word
	      ElseIf i = 4 Then
	         strPid = word
	      End If
	      
	      i = i + 1
	   Next
	   
	   &#039;DO NOT INCLUDE EXCLUDED APPS
	   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path
	   arrAppEntry = Split(strAppEntry,&quot;,&quot;)
	   strAppExe = arrAppEntry(0)
	   strAppPath = arrAppEntry(1)
	   
	   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))
	   
	   &#039;DO NOT INCLUDE EXCLUDED SUBNETS
	   isNotExcludedSubnet = Not(ContainedInSubnet(strForeignIp, excludeSubnets))
	   
	   If Not(IsEmpty(strAppExe)) _
	      And isNotExcludedApp _ 
	      And isNotExcludedSubnet Then
	
		  If Not showPort Then 
		  	arrTemp = Split(strForeignIp, &quot;:&quot;)
			strForeignIp = arrTemp(0)
		  End If
	
			If showDNSName Then
				arrTemp = Split(strForeignIp, &quot;:&quot;)
				strForeignIp = ReverseDNSLookup(arrTemp(0))
				If UBound(arrTemp) &gt;=1 Then 
					strForeignIp = strForeignIp &amp; &quot;:&quot; &amp; arrTemp(1)
				End If
			End If 
			
	      If showProcess Then
	      	results(j) = strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIp
	      Else
	        results(j) = strSep &amp; strSep &amp; strForeignIp
	      End If	
	   Else
	      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp
	      results(j) = &quot;&quot;   
	   End If 
	   
	   j = j + 1
	End If
Next

results = RemDups(results)

If UBound(results) &lt; 1 Then
	If GetLocale() &lt;&gt; 1033 Then
		WScript.Echo &quot;English Language OS Required&quot;
	End If
End If

For Each result In results 
   WScript.Echo result
Next

WScript.Quit

Function ReverseDNSLookup(strIPAddress)
	ReverseDNSLookup = strIPAddress	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	Set objExecCommand = objShell.Exec(&quot;%comspec% /c nslookup &quot; &amp; strIPAddress)
	
	strResults = objExecCommand.StdOut.ReadAll
	
	If InStr(strResults, &quot;Name:&quot;) Then
		arrNameTemp = Split(strResults, &quot;Name:&quot;)
		arrName = Split(Trim(arrNameTemp(1)), Chr(13))
		
		ReverseDNSLookup = arrName(0)
	End If	
End Function

Function LoadDATFileAsArray(strFilePath)
	Dim objFSO : Set objFSO = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	Dim responseDict : Set responseDict = CreateObject(&quot;Scripting.Dictionary&quot;)
		
	If objFSO.FileExists(strFilePath) Then
        Dim objDatFile, strLine
        Set objDatFile = objFso.OpenTextFile(strFilePath, 1)
        
        &#039;read in all entries, one per line
        Do While objDatFile.AtEndOfStream &lt;&gt; True
            strLine = LCase(Trim(objDatFile.ReadLine))
			If strLine &lt;&gt; &quot;&quot; And Left(strLine, 1) &lt;&gt; &quot;&#039;&quot; And Not responseDict.Exists(strLine) Then 
				responseDict.Add strLine, True
			End If
        Loop
    End If
	LoadDATFileAsArray = responseDict.Keys
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function ContainedInSubnet(str, arr)
   Dim strIp, strSubnet, strMask
   temp = Split(str, &quot;:&quot;)
   strIp = temp(0)

   For Each item In arr
      If InStr(item, &quot;-&quot;) Then &#039;Subnet range
         temp = Split(item, &quot;-&quot;)
         lower = Split(temp(0), &quot;:&quot;)
         upper = Split(temp(1), &quot;:&quot;)
         lowerSubnet = Trim(lower(0))
         lowerMask = Trim(lower(1))
         upperSubnet = Trim(upper(0))
         upperMask = Trim(upper(1))
         
         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _
            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then
            ContainedInSubnet = True
            Exit Function
         End If 
      Else &#039;Single subnet
         parts = Split(item, &quot;:&quot;)
         strSubnet = Trim(parts(0))
         strMask = Trim(parts(1))
         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then
            ContainedInSubnet = True
            Exit Function
         End If
      End If 
   Next
   ContainedInSubnet = False
End Function

Function ContainedInArray(str, arr)
   For Each item In arr 
      If str = Trim(item) Then
         ContainedInArray = True
         Exit Function
      End If   
   Next
   ContainedInArray = False
End Function

Function cleanWhitespace(strStarter)
   intStarter = Len(strStarter)
	For i = intStarter To 2 Step -1
      strChars = Space(i)
      strStarter = Replace(strStarter, strChars, &quot; &quot;)
   Next
   cleanWhitespace = strStarter
End Function

Function RemDups(ByVal anArray)
   Dim d, item, thekeys
   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)
   d.removeall
   d.CompareMode = 0
   For Each item In anArray
      If Len(item) &gt; 0 Then
         If Not d.Exists(item) Then d.Add item, item
      End If
   Next
   thekeys = d.keys
   Set d = Nothing
   RemDups = thekeys
End Function

Function Subnet(strAddress, strMask)
   intSubnetLength = SubnetLength(strMask)
   Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))
End Function

Function SubnetLength(strMask)
   strMaskBinary = StringToBinary(strMask)
   SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))
End Function

Function BinaryToString(strBinary)
   For intOctetPos = 1 To 4
      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)
      intOctet = 0
      intValue = 1
      For intBinaryPos = 1 To Len(strOctetBinary)
         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue
         intValue = intValue * 2
      Next
      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)
   Next
End Function

Function StringToBinary(strAddress)
   objAddress = Split(strAddress, &quot;.&quot;, -1)
   For Each strOctet In objAddress
      intOctet = CInt(strOctet)
      strOctetBinary = &quot;&quot;
      For x = 1 To 8
         If intOctet Mod 2 &gt; 0 Then
            strOctetBinary = &quot;1&quot; &amp; strOctetBinary
         Else
            strOctetBinary = &quot;0&quot; &amp; strOctetBinary
         End If
         intOctet = Int(intOctet / 2)
      Next
      StringToBinary = StringToBinary &amp; strOctetBinary
   Next
End Function

Function ProcessNameToApplicationName(strExecutablePath, strExecutableName)
&#039; This function will return the full application name of a running executable

		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		
		arrPathParts = Split(strExecutablePath,&quot;\&quot;)

		If UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process
			ProcessNameToApplicationName = strExecutableName
			Set fso = Nothing
			Exit Function
		End If
		strExecutable = arrPathParts(UBound(arrPathParts))
		
		If fso.FileExists(strExecutablePath) Then
			Dim strOutput, fileVersion, fileVersionOutput, fullName
		
			Set execFile = fso.GetFile(strExecutablePath)
			fullName = GetDescription(execFile.ParentFolder.Path, strExecutable)
			If Not fullName = &quot;&quot; Then
				ProcessNameToApplicationName = fullName
			Else
				ProcessNameToApplicationName = strExecutableName
			End If
		Else &#039; file doesn&#039;t exist or inaccessible
			ProcessNameToApplicationName = strExecutableName
		End If

End Function &#039;ProcessNameToApplicationName

Function GetDescription(folderPath, fileName)
	descIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)
	If IsEmpty(descIndex) Then
		descIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)
	End If
	GetDescription = GetFileProperty(folderPath, fileName, descIndex)
End Function

Function GetFileProperty(folderPath, fileName, fileProperty)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	GetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)
End Function

Function GetAttributeIndex(folderPath, attrTarget)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	For i = 0 To 50
		attrName = objFolder.GetDetailsOf(objFolder.Items, i)
		If LCase(attrName) = LCase(attrTarget) Then
			GetAttributeIndex = i
			Exit Function
		End If
	Next
	
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash

lsof -iTCP -sTCP:ESTABLISHED -P +c 15 -n|grep -v &quot;COMMAND&quot; |while read line
do
        set -- $line
        second=`echo $9|cut -d&#039;&gt;&#039; -f 2`
        echo $1\|\|$second
done
",UnixShell,0,120,0,1,0,Process,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Name,String,0,1,2,Target IP,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
160,Network,2015-01-05T20:22:03,|,"Returns details of ad-hoc wireless networks are hosted in your environment.  Details include SSID, Mode, Max Clients, Auth, Status, BSSID, Radio Type, Channel, and Connections.
Example: personalwifi | ad-hoc | 1 | Open | active | xx:xx:xx:xx:xx:xx | 802.11g | 11 | 1",1,3397569679,0,317,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:03,Hosted Wireless Ad-Hoc Networks,,,,,,,,,Windows,"&#039;========================================
&#039; Hosted Wireless Ad-Hoc Networks
&#039;========================================

&#039; This sensor uses netsh output to display details about wireless LAN

Option Explicit

Dim strSep

strSep = &quot;|&quot;
				
&#039; This is a multi-column sensor whose output looks like
&#039; SSID|Mode|Max Clients|Auth|Status|BSSID|Radio Type|Channel|Connections

GetHostedAdHocDetails strSep

Function GetHostedAdHocDetails(strSep)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine
	Dim strMode,strHostedSSID,strMaxClients,strAuth
	Dim strStatus,strBSSID,strRadioType,strChannel,strConnectedClients
	Dim bPrintLine, bNewHostedNetwork
	
	strCommand = &quot;netsh wlan show hostednetwork&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	For Each strNetshLine In arrNetshResults
		strNetshLine = Trim(strNetshLine)
		If InStr(strNetshLine,&quot;hosted network settings&quot;) = 1 Then
			bNewHostedNetwork = True	&#039; if there&#039;s a new hosted network settings entry, it&#039;s time to note a new group
		End If
		If InStr(strNetshLine, &quot;mode&quot;) = 1 Then
			strMode = Trim(Split(strNetshLine,&quot;: &quot;)(1))
		End If
		If InStr(strNetshLine, &quot;ssid name&quot;) = 1 Then
			strHostedSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
			&#039; ssid is presented in quotes, remove
			strHostedSSID = RemoveOuterCharacters(strHostedSSID,Chr(34))
		End If
		If InStr(strNetshLine, &quot;max number of clients&quot;) = 1 Then
			strMaxClients = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;authentication&quot;) = 1 Then
			strAuth = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;status&quot;) = 1 Then
			strStatus = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If	
		If InStr(strNetshLine,&quot;bssid&quot;) = 1 Then
			strBSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;radio type&quot;) = 1 Then
			strRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;channel&quot;) = 1 Then
			strChannel = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;number of clients&quot;) = 1 Then &#039; last entry
			strConnectedClients = Trim(Split(strNetshLine,&quot;:&quot;)(1))
			bPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.
		End If
		If bNewHostedNetwork And bPrintLine Then
			&#039; if it&#039;s a new group, and at last line in the new group, print
			If strStatus = &quot;started&quot; Then
				WScript.Echo strHostedSSID &amp; strSep &amp; strMode &amp; strSep &amp; strMaxClients &amp; strSep &amp; strAuth _
					&amp; strSep &amp; strStatus &amp; strSep &amp; strBSSID &amp; strSep &amp; strRadioType &amp; strSep _
					&amp; strChannel &amp; strSep &amp; strConnectedClients
			End If
			bNewHostedNetwork = False
			bPrintLine = False
		End If
	Next
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetHostedAdHocDetails

Function RemoveOuterCharacters(strTemp,strChar)
	Dim intStrLen
	
	intStrLen = Len(strTemp)
	If InStr(strTemp,strChar) = 1 Then
		strTemp = Right(strTemp,intStrLen - 1)
	End If
	intStrLen = Len(strTemp) &#039; has new length
	If InStr(strTemp,strChar) = intStrLen Then
		strTemp = Left(strTemp,intStrLen - 1)
	End If
	
	RemoveOuterCharacters = strTemp
	
End Function &#039;RemoveOuterCharacters",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
# cah
# Created 20140621
# Modified
# looking for Ad-Hoc networks
# windows output to try to match: SSID | Mode | Max Clients | Auth | Status | BSSID | Radio Type | Channel | Connections | 

AIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;


#Get SSID
IFS=$&#039;\n&#039; # Set delimiter to IFS
SSIDArray=(` $AIRPATH/airport -s  `)
#echo $SSIDArray[1]



i=0
found=false 
ANS=()
for ssid in &quot;${SSIDArray[@]}&quot;
do 
	:
	if [ $found == &quot;true&quot; ] ; then
		#echo $ssid | grep -v &quot;^$&quot; | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/..:..//g&#039; | sed &#039;s/ -..  ... *//g&#039; | sed &#039;s/\(::\).*  .. /\1 /&#039; | sed &#039;s/WPA\(.*\) WPA2\(.*\)/WPA WPA2 \1 \2/g&#039; | sed &#039;s/(/ /g&#039; | sed &#039;s/)/ /g&#039; | sed &#039;s/::/ | |/g&#039; | sed &#039;s/WPA2/WPA2|/&#039; | sed &#039;s/NONE/NONE|NONE|/g&#039; | sed &#039;s/WEP/WEP|WEP/g&#039; | sed &#039;s/WPA \([^W][^P]\)/WPA| \1/g&#039; | awk &#039;{print $0,&quot;\n&quot;}&#039;
		MySSID=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^\(.*\) ..:..:..:..:..:.. .*/ \1 /g&#039; )
		BSSID=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^.* \(..:..:..:..:..:..\) .*/ \1 /g&#039; )
		Channel=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^.* ..:..:..:..:..:.. //&#039; | awk &#039;{print $2}&#039; ) 	
		Auth=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^.* ..:..:..:..:..:.. //&#039; | awk &#039;{print $5}&#039; ) 
		echo &quot;$MySSID|$Mode|$MaxClients|$Auth|$Status|$BSSID|$Radio|$Channel|$Connections&quot; | grep -v &quot;^|||||||$&quot;
	else
		teststring=$(echo $ssid | grep IBSS)
		MySSID=&quot;&quot;
		Mode=&quot;&quot;
		MaxClients=&quot;&quot;
		Auth=&quot;&quot;
		Status=&quot;&quot;
		BSSID=&quot;&quot;
		Radio=&quot;&quot;
		Channel=&quot;&quot;
		Connections=&quot;&quot;
		if [[ &quot;$teststring&quot; == *IBSS*network* ]] ; then
			found=true
		fi
  	fi
  	((i++))
done
",UnixShell,0,0,0,1,0,SSID,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Mode,String,0,1,2,Max Clients,String,0,1,3,Auth,String,0,1,4,Status,String,0,1,5,BSSID,String,0,1,6,Radio Type,String,0,1,7,Channel,String,0,1,8,Connections,String,,,,,,String
161,Network,2015-01-05T20:22:03,",","Details of currently active wireless network connection using WEP authentication by client machine.  Details include SSID, MAC address, connection state, network type, radio type, authentication, receive rate, transmit rate, and signal strength.
Example: hotspotwifi | xx-xx-xx-xx-xx-xx | connected | Infrastructure | 802.11g | WEP | 54 | 54 | 99%",1,3394404860,0,319,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:03,Wireless Networks Using WEP,,,,,,,,,Windows,"&#039;========================================
&#039; Wireless Networks Using WEP
&#039;========================================

&#039; This sensor uses netsh output to display details about wireless LAN
&#039; returns details of those which have &#039;wep&#039; as the encryption type

Option Explicit

Dim strSep

strSep = &quot;|&quot;
				
&#039; This is a multi-column sensor whose output looks like
&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal 0-5

GetWepEncryptedWirelessNetworkDetails strSep

Function GetWepEncryptedWirelessNetworkDetails(strSep)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine, strName, strMAC, strState, strSSID
	Dim strNetworkType, strRadioType, strAuthentication
	Dim strReceiveRate, strTransmitRate, strSignal, intSignal
	Dim bPrintLine, bNewInterface
	
	strCommand = &quot;netsh wlan show interfaces&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	For Each strNetshLine In arrNetshResults
		If InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then
			bNewInterface = True	&#039; if there&#039;s a new Name, it&#039;s time to note a new group
			strName = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then
			strMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))
		End If
		If InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then
			strState = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then
			strSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then
			strNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;radio type&quot;) &gt; 0 Then
			strRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If		
		If InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then
			strAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;receive rate&quot;) &gt; 0 Then
			strReceiveRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;
		End If
		If InStr(strNetshLine,&quot;transmit rate&quot;) &gt; 0 Then
			strTransmitRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;
		End If
		If InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then
			strSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove %
			intSignal = CInt(CInt(strSignal) / 20)
			bPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.
		End If
		If bNewInterface And bPrintLine Then
			&#039; if it&#039;s a new group, and at last line in the new group, print
			If InStr(LCase(strAuthentication),&quot;wep&quot;) &gt; 0 Then
				WScript.Echo strSSID &amp; strSep &amp; strMAC &amp; strSep &amp; strState &amp; strSep &amp; strNetworkType _
					&amp; strSep &amp; strRadioType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strReceiveRate &amp; strSep _
					&amp; strTransmitRate &amp; strSep &amp; intSignal
			End If
			bNewInterface = False
			bPrintLine = False
		End If
	Next
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetWepEncryptedWirelessNetworkDetails",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
# cah
# Created 20140616
# Modified
# looking for wireless networks using WEP and providing their details
# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |
# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm

AIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;
RADIO=&quot;unknown&quot;

#Get the wireless interface and mac address
DEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)
DEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)

IFS=$&#039;\n&#039; # Set delimiter to IFS
SSIDArray=(` $AIRPATH/airport -s | grep -e &quot;\sWEP$&quot; | grep -v &quot;^&amp;&quot; | sed &quot;s/ ..:.*$//g&quot; `)

i=0
ANS=()
for ssid in &quot;${SSIDArray[@]}&quot;
do
	:
	SSID=&quot;$ssid&quot;
	((i++))

	if [ ! &quot;$SSID&quot; ] ; then
		SSID=&quot;Not Available&quot;
		NETWORKTYPE=&quot;Not Available&quot;
		AUTHENTICATION=&quot;Not Available&quot;
		RECEIVE=&quot;Not Available&quot;
		TRANSMIT=&quot;Not Available&quot;
		SIGNAL=&quot;Not Available&quot;
	fi

	if [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then
	  STATE=&quot;visible&quot;
	  NETWORKTYPE=&quot;unknown&quot;
	  AUTHENTICATION=&quot;WEP&quot;
	  RECEIVE=&quot;unknown&quot;
	  TRANSMIT=$RECEIVE
	  PWR=$( $AIRPATH/airport -s | grep &quot;$SSID&quot; | awk -F&quot;..:..:.. &quot; &#039;{print $2}&#039;| awk &#039;{print $1}&#039;| grep -v &quot;^$&quot; )
	 #This is to convert from power to MS dummy gauge
		if  (( $PWR &lt;= &quot;-100&quot; )) ; then
		SIGNAL=&quot;0&quot;
	   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then
		SIGNAL=&quot;1&quot;
	   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then
		SIGNAL=&quot;2&quot;
	   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then
		SIGNAL=&quot;3&quot;
	   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then
		SIGNAL=&quot;4&quot;
	   else
		SIGNAL=&quot;5&quot;
	  fi  
	else 
	  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )
	  if [ ! &quot;$STATE&quot; ] ; then
		STATE=&quot;off&quot;
	  fi
	fi

	echo &quot;$SSID , $DEVMAC , $STATE ,  $NETWORKTYPE , $RADIO , $AUTHENTICATION , $RECEIVE , $TRANSMIT , $SIGNAL  ($PWR dB)  &quot;

done
exit
",UnixShell,0,0,0,1,0,SSID,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,MAC,String,0,1,2,State,String,0,1,3,Netwrok Type,String,0,1,4,Radio,String,0,1,5,Authentication,String,0,1,6,Receive,String,0,1,7,Transmit,String,0,1,8,Signal 0-5,String,,,,,,String
162,Network,2015-01-05T20:22:03,|,"Details of wireless networks that are currently open and unencrypted.  Details include SSID, MAC address, connection state, network type, radio type, authentication, receive rate, transmit rate, and signal strength.
Example: hotspotwifi | xx-xx-xx-xx-xx-xx | connected | Infrastructure | 802.11g | WEP | 54 | 54 | 99%",1,1569955801,0,321,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:03,Unencrypted Wireless Networks,,,,,,,,,Windows,"&#039;========================================
&#039; Unencrypted Wireless Networks
&#039;========================================

&#039; This sensor uses netsh output to display details about wireless LAN
&#039; returns details of those which have &#039;open&#039; as the encryption type

Option Explicit

Dim strSep

strSep = &quot;|&quot;
				
&#039; This is a multi-column sensor whose output looks like
&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal 0-5

GetUnencryptedWirelessNetworkDetails strSep

Function GetUnencryptedWirelessNetworkDetails(strSep)

	Dim objShell,objScriptExec
	Dim strCommand, arrNetshResults, strNetshResults
	Dim strNetshLine, strName, strMAC, strState, strSSID
	Dim strNetworkType, strRadioType, strAuthentication
	Dim strReceiveRate, strTransmitRate, strSignal, intSignal
	Dim bPrintLine, bNewInterface
	
	strCommand = &quot;netsh wlan show interfaces&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	
	strNetshResults = LCase(objScriptExec.StdOut.ReadAll)
	arrNetshResults = Split(LCase(strNetshResults),vbCrLf)
	
	For Each strNetshLine In arrNetshResults
		If InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then
			bNewInterface = True	&#039; if there&#039;s a new Name, it&#039;s time to note a new group
			strName = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then
			strMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))
		End If
		If InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then
			strState = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then
			strSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then
			strNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine, &quot;radio type&quot;) &gt; 0 Then
			strRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If		
		If InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then
			strAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))
		End If
		If InStr(strNetshLine,&quot;receive rate&quot;) &gt; 0 Then
			strReceiveRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;
		End If
		If InStr(strNetshLine,&quot;transmit rate&quot;) &gt; 0 Then
			strTransmitRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;
		End If
		If InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then
			strSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove %
			intSignal = CInt(CInt(strSignal) / 20)
			bPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.
		End If
		If bNewInterface And bPrintLine Then
			&#039; if it&#039;s a new group, and at last line in the new group, print
			If LCase(strAuthentication) = &quot;open&quot; Then
				WScript.Echo strSSID &amp; strSep &amp; strMAC &amp; strSep &amp; strState &amp; strSep &amp; strNetworkType _
					&amp; strSep &amp; strRadioType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strReceiveRate &amp; strSep _
					&amp; strTransmitRate &amp; strSep &amp; intSignal
			End If
			bNewInterface = False
			bPrintLine = False
		End If
	Next
	
	&#039;Cleanup
	Set objScriptExec = Nothing
	Set objShell = Nothing
End Function &#039;GetUnencryptedWirelessNetworkDetails",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
# cah
# Created 20140616
# Modified 20140730
# looking for unencrypted wireless networks and providing their details
# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |
# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm

AIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;
RADIO=&quot;unknown&quot;

#Get the wireless interface and mac address
DEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)
DEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)

IFS=$&#039;\n&#039; # Set delimiter to IFS
SSIDArray=(` $AIRPATH/airport -s | grep -e &quot;\sNONE$&quot; | grep -v &quot;^&amp;&quot; | sed &quot;s/ ..:.*$//g&quot; `)

i=0
ANS=()
for ssid in &quot;${SSIDArray[@]}&quot;
do
	:
	SSID=&quot;$ssid&quot;
	((i++))

	if [ ! &quot;$SSID&quot; ] ; then
		SSID=&quot;Not Available&quot;
		NETWORKTYPE=&quot;Not Available&quot;
		AUTHENTICATION=&quot;Not Available&quot;
		RECEIVE=&quot;Not Available&quot;
		TRANSMIT=&quot;Not Available&quot;
		SIGNAL=&quot;Not Available&quot;
	fi

	if [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then
	  STATE=&quot;visible&quot;
	  NETWORKTYPE=&quot;unknown&quot;
	  AUTHENTICATION=&quot;none &quot;
	  RECEIVE=&quot;unknown&quot;
	  TRANSMIT=$RECEIVE
	  PWR=$( $AIRPATH/airport -s | grep &quot;$SSID&quot; | awk -F&quot;..:..:.. &quot; &#039;{print $2}&#039; | awk &#039;{print $1}&#039; )

	 #This is to convert from power to MS dummy gauge
		if  (( $PWR &lt;= &quot;-100&quot; )) ; then
		SIGNAL=&quot;0&quot;
	   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then
		SIGNAL=&quot;1&quot;
	   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then
		SIGNAL=&quot;2&quot;
	   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then
		SIGNAL=&quot;3&quot;
	   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then
		SIGNAL=&quot;4&quot;
	   else
		SIGNAL=&quot;5&quot;
	  fi  
	else 
	  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )
	  if [ ! &quot;$STATE&quot; ] ; then
		STATE=&quot;off&quot;
	  fi
	fi

	echo &quot;$SSID | $DEVMAC | $STATE |  $NETWORKTYPE | $RADIO | $AUTHENTICATION | $RECEIVE | $TRANSMIT | $SIGNAL  ( $PWR dB)&quot;

done
exit
",UnixShell,0,2,0,1,0,SSID,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,MAC,String,0,1,2,State,String,0,1,3,Network Type,String,0,1,4,Radio,String,0,1,5,Authentication,String,0,1,6,Receive,String,0,1,7,Transmit,String,0,1,8,Signal 0-5,String,,,,,,String
163,User,2015-01-05T20:22:03,|,"Provides the terminal services session information, similar to what is available from the ""query session"" command.
Example:console|Administrator|1|Active||",1,75018363,0,323,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,User Sessions,,,,,,,,,Windows,"&#039;========================================
&#039; User Sessions
&#039;========================================

&#039; Returns information about the current sessions on the local machine
&#039; 

Option Explicit

On error resume next
Dim strValue, myRegExp, objShell, objExec, strLine, objSplit

Set myRegExp = New RegExp
myRegExp.IgnoreCase = True
myRegExp.Global = True
myRegExp.Pattern = &quot;\s{2,}&quot;

Set objShell = WScript.CreateObject(&quot;WScript.Shell&quot;)
If Is64() Then 
	Set objExec = objshell.exec(&quot;cmd /c c:\windows\sysnative\qwinsta&quot;)
Else 
	Set objExec = objshell.exec(&quot;cmd /c qwinsta&quot;)
End If 

objExec.StdOut.ReadLine()
Do While Not objExec.Stdout.AtEndOfStream
	strLine = myRegExp.Replace(objExec.StdOut.ReadLine(),&quot;|&quot;)

	If InStr(strLine,&quot;rdp&quot;) or InStr(strLine,&quot;console&quot;) then
		If InStr(strLine,&quot;disc&quot;) then
			strLine = &quot;|&quot; &amp; strLine
		End If 
		If InStr(strLine, &quot;console&quot;)&gt;0 And InStr(strLine, &quot;Conn&quot;)&gt;0 Then
		    &#039; If console line, but no user logged in, add column
			strLine = Replace(strLine, &quot;console|&quot;, &quot;console||&quot;)
		End If
		strLine = replace(strLine,&quot;&gt;&quot;,&quot;&quot;)
		strLine = replace(strLine,&quot; &quot;,&quot;&quot;)
		strLine = replace(strLine,&quot;rdp-tcp|&quot;,&quot;rdp-tcp||&quot;)
		
		objSplit = Split(strLine, &quot;|&quot;)
		If ojbSplit.Count = 4 Then
			strLine = strLine + &quot;|&quot;
		End If 	
			
		WScript.echo strLine
	End if	
Loop 


Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If
	Next
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,0,1,0,Session Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,User Name,String,0,1,2,ID,String,0,1,3,State,String,0,1,4,Type,String,0,1,5,Device,String,,,,,,,,,,,,,,,,,,,,,String
164,Tanium,2015-01-05T20:22:03,",","Returns whether a machine has the application management tools which may be necessary for parameterized actions or sensor-fed actions.
Example: Yes",1,1688928675,0,325,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Has Application Management Tools,,,,,,,,,Windows,"&#039;========================================
&#039; Has Application Management Tools
&#039;========================================

Option Explicit


&#039;--------------------
&#039; Set These Variables
Dim strDesiredVersion
&#039; a string value which is a verison like
&#039; 4.1.314.7060
&#039; which is used to determine whether the files are the correct version

strDesiredVersion = &quot;6.2.314.8513&quot;
&#039;----------------------
Dim objFSO
Dim strToolsDir
Dim bHasAllLatestFiles, arrApplicationManagementToolsFiles, strFile
Dim objTextFile, strVersionLine, strFileVersion

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

strToolsDir = GetTaniumDir(&quot;Tools&quot;)

&#039; This array holds the files to check for
arrApplicationManagementToolsFiles = Array(&quot;taskkill.vbs&quot;,&quot;startservice.vbs&quot;,&quot;stopservice.vbs&quot;)

bHasAllLatestFiles = True &#039; assume OK until checks fail

For Each strFile In arrApplicationManagementToolsFiles
	If Not objFSO.FileExists(strToolsDir&amp;strFile) Then
		WScript.Echo &quot;Missing &quot; &amp; strFile
		bHasAllLatestFiles = False
	End If
	If objFSO.FileExists(strToolsDir&amp;strFile) Then
		Set objTextFile = objFSO.OpenTextFile(strToolsDir&amp;strFile)
		strVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line
		If Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line
			WScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;
			bHasAllLatestFiles = False
		Else &#039; we have a version number, not split to check
			strFileVersion = Trim(Split(strVersionLine,&quot;tanium file version:&quot;)(1))
			If strFileVersion &lt;&gt; strDesiredVersion Then
				WScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion
				bHasAllLatestFiles = False
			End If
		End If
		objTextFile.Close
	End If
Next

If bHasAllLatestFiles Then
	WScript.Echo &quot;Yes&quot;
Else
	WScript.Echo &quot;No&quot;
End If

&#039;Cleanup
Set objTextFile = Nothing
Set objFSO = Nothing

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,14,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
165,Tanium,2015-01-05T20:22:03,",","Returns whether a machine has the hardware tools, which are used to identify specific types of hardware.
Example: Yes",1,2581054686,0,327,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Has Hardware Tools,,,,,,,,,Windows,"&#039;Tanium File Version:6.2.314.8513
&#039; sensor - Has Hardware Tools

Option Explicit
&#039;--------------------
&#039; Set These Variables
Dim strDesiredVersion
&#039; a string value which is a version like
&#039; 4.1.314.7060
&#039; which is used to determine whether the files are the correct version

strDesiredVersion = &quot;6.2.314.8513&quot;
&#039;----------------------
Dim objFSO
Dim strToolsDir
Dim bHasAllLatestFiles, arrHardwareToolsTextFiles, arrHardwareToolsBinFiles, strFile
Dim objTextFile, strVersionLine, strFileVersion

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

strToolsDir = GetTaniumDir(&quot;Tools\Hardware&quot;)

&#039; This array holds the text files to check for
arrHardwareToolsTextFiles = Array()
    
&#039; This array holds the binary files to check for
arrHardwareToolsBinFiles = Array(&quot;usb.ids&quot;)

bHasAllLatestFiles = True &#039; assume OK until checks fail

For Each strFile In arrHardwareToolsTextFiles
    If Not objFSO.FileExists(strToolsDir&amp;strFile) Then
        WScript.Echo &quot;Missing &quot; &amp; strFile
        bHasAllLatestFiles = False
    End If
    If objFSO.FileExists(strToolsDir&amp;strFile) Then
        Set objTextFile = objFSO.OpenTextFile(strToolsDir&amp;strFile)
        strVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line
        If Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line
            WScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;
            bHasAllLatestFiles = False
        Else &#039; we have a version number, not split to check
            strFileVersion = Trim(Split(strVersionLine,&quot;tanium file version:&quot;)(1))
            If strFileVersion &lt;&gt; strDesiredVersion Then
                WScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion
                bHasAllLatestFiles = False
            End If
        End If
        objTextFile.Close
    End If
Next

For Each strFile In arrHardwareToolsBinFiles
    If Not objFSO.FileExists(strToolsDir&amp;strFile) Then
        WScript.Echo &quot;Missing &quot; &amp; strFile
        bHasAllLatestFiles = False
    End If
Next


If bHasAllLatestFiles Then
    WScript.Echo &quot;Yes&quot;
Else
    WScript.Echo &quot;No&quot;
End If

&#039;Cleanup
Set objTextFile = Nothing
Set objFSO = Nothing

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
    Dim aValueNames, aValueTypes
    If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
        RegKeyExists = True
    Else
        RegKeyExists = False
    End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
166,Tanium,2015-01-05T20:22:03,",","Returns whether a machine has the Tanium Standard Utilities
Example: Yes",1,1782389954,0,329,1,Jim Olsen,900,,,,2015-01-05T20:22:03,Has Tanium Standard Utilities,,,,,,,,,Windows,"&#039;========================================
&#039; Has Tanium Standard Utilities
&#039;========================================

&#039; this action will look to see if the client has
&#039; all necessary standard utilities files

Option Explicit
&#039;--------------------
&#039; Set These Variables
Dim strDesiredVersion,strDesiredFCIVVersion,strDesiredGrepBinaryVersion
Dim strDesiredGrepDepVersion,strGrepDepFileVersion,strGrepBinaryFileVersion

&#039; a string value which is a version like
&#039; 4.2.314.7111
&#039; which is used to determine whether the bundle has the correct version
&#039; updating the content will cause the bundle number to change and all files will
&#039; be sent to the endpoint again. This is to handle the case where
&#039; binary files are not versioned, such as with Yara

&#039; The top line of the version file
&#039;Tanium File Version: &lt;version string below&gt;
strDesiredVersion = &quot;6.2.314.8513&quot;

&#039; -------------------
&#039; Binaries we can version
strDesiredGrepBinaryVersion = &quot;2.5.4.3331&quot;
strDesiredGrepDepVersion = &quot;1.12.2872.39125&quot;

Dim objFSO
Dim strDirToCheck,objTextFile
Dim bHasAllLatestFiles,arrTextFilesToCheck,strFile,strVersionLine,strFileVersion
Dim strFCIVFile,strFCIVFileVersion,strGrepBinary,strGrepDep,strHandleTool,strListDLLs2
Dim strListDLLs,strStreamsTool,strAutorunsTool
Dim strYara,strYarac

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

strDirToCheck = GetTaniumDir(&quot;Tools\StdUtils&quot;)

arrTextFilesToCheck = Array(&quot;copy-to-tanium-dir-predist.vbs&quot;,&quot;runas-allusers-wrapper.vbs&quot;,&quot;ver\bundle.cfg&quot;)

&#039; Grep is required
strGrepBinary=strDirToCheck&amp;&quot;grep\bin\grep.exe&quot;
strGrepDep=strDirToCheck&amp;&quot;grep\bin\libiconv2.dll&quot;

&#039;Yara binaries are required
strYara=strDirToCheck&amp;&quot;yara\yara&quot;&amp;GetBitness&amp;&quot;.exe&quot;
strYarac=strDirToCheck&amp;&quot;yara\yarac&quot;&amp;GetBitness&amp;&quot;.exe&quot;

bHasAllLatestFiles = True
For Each strFile In arrTextFilesToCheck
	If Not objFSO.FileExists(strDirToCheck&amp;strFile) Then
		WScript.Echo &quot;Missing &quot; &amp; strFile
		bHasAllLatestFiles = False
	End If
	If objFSO.FileExists(strDirToCheck&amp;strFile) Then
		Set objTextFile = objFSO.OpenTextFile(strDirToCheck&amp;strFile)
		strVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line
		If Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line
			WScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;
			bHasAllLatestFiles = False
		Else &#039; we have a version number, not split to check
			strFileVersion = Split(strVersionLine,&quot;tanium file version:&quot;)(1)
			If Trim(strFileVersion) &lt;&gt; Trim(strDesiredVersion) Then
				WScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion
				bHasAllLatestFiles = False
			End If
		End If
		objTextFile.Close
	End If
Next

&#039; check a Grep dependency
If Not objFSO.FileExists(strGrepDep) Then
	WScript.Echo &quot;Missing &quot; &amp; strGrepDep
	bHasAllLatestFiles = False
End If
If objFSO.FileExists(strGrepDep) Then

	strGrepDepFileVersion = objFSO.GetFileVersion(strGrepDep)
	If Not strGrepDepFileVersion = strDesiredGrepDepVersion Then
		bHasAllLatestFiles = False
		WScript.Echo strGrepDep &amp;&quot; version: &quot;&amp;strGrepDepFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredGrepDepVersion
	End If
End If


&#039; check Grep binary
If Not objFSO.FileExists(strGrepBinary) Then
	WScript.Echo &quot;Missing &quot; &amp; strGrepBinary
	bHasAllLatestFiles = False
End If
If objFSO.FileExists(strGrepBinary) Then
	strGrepBinaryFileVersion = GetFileVersion(strGrepBinary)
	If Not strGrepBinaryFileVersion = strDesiredGrepBinaryVersion Then
		bHasAllLatestFiles = False
		WScript.Echo strGrepBinary &amp;&quot; version: &quot;&amp;strGrepBinaryFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredGrepBinaryVersion
	End If
End If

If Not objFSO.FileExists(strYara) Then
	bHasAllLatestFiles = False
	WScript.Echo &quot;Missing &quot; &amp; strYara
End If

If Not objFSO.FileExists(strYarac) Then
	bHasAllLatestFiles = False
	WScript.Echo &quot;Missing &quot; &amp; strYarac
End If

If bHasAllLatestFiles Then
	WScript.Echo &quot;Yes&quot;
Else
	WScript.Echo &quot;No&quot;
End If

Function GetFileVersion(strPath)
	Dim objFSO
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	If objFSO.FileExists(strPath) Then
		GetFileVersion = objFSO.GetFileVersion(strPath)
	Else
		GetFileVerison = -1
	End If
End Function &#039;GetFileVersion

Function GetTaniumDir(strSubDir)
	Dim strComputer, key32path, key64path, keyPath, reg
	Dim strPath
	strComputer = &quot;.&quot;
	Const HKLM = &amp;h80000002
    
	key32Path = &quot;Software\Tanium\Tanium Client&quot;
	key64Path = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
	Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
    
	If RegKeyExists(reg, HKLM, key64Path) Then
		keyPath = key64Path
	ElseIf RegKeyExists(reg, HKLM, key32Path) Then
		keyPath = key32Path
	End If
    
	reg.GetStringValue HKLM,keyPath,&quot;Path&quot;, strPath

	If strSubDir &lt;&gt; &quot;&quot; Then
		strSubDir = &quot;\&quot; &amp; strSubDir
	End If	

	Dim fso
	Set fso = WScript.CreateObject(&quot;Scripting.FileSystemObject&quot;)
	If fso.FolderExists(strPath) Then
		If Not fso.FolderExists(strPath &amp; strSubDir) Then
			fso.CreateFolder(strPath &amp; strSubDir)
		End If
		GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
	End If
End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function


Function GetBitness
	If Not Is64 Then
		GetBitness = &quot;32&quot;
	Else
		GetBitness = &quot;64&quot;
	End If
End Function &#039;GetBitness

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If
	Next
End Function &#039; Is64",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,18,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
167,Patch,2015-01-05T20:22:03,",","Determines when the patch cab file is to be considered out of date and, therefore, a machine receives a new copy via the ""Patch Management - Deploy Patch Scan Files"" Scheduled Action.  By default, a machine will get a refreshed copy of the cab file from the ring every 24 hours.
Example: Yes",1,3197527816,0,331,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Patch Cab Out of Date,,,,,,,,,Windows,"&#039;========================================
&#039; Patch Cab Out of Date
&#039;========================================

Option Explicit

Dim intAgeThreshold,fso,objFile,minutesOld,strToolsDir,strCabPath
intAgeThreshold = 60*24       &#039;in minutes

strToolsDir = GetTaniumDir(&quot;Tools&quot;)
strCabPath = strToolsDir &amp; &quot;\wsusscn2.cab&quot;

Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

&#039;Uses date math - set locale

SetLocale(1033)

If fso.FileExists(strCabPath) Then
	Set objFile = fso.GetFile(strCabPath)
	minutesOld = GetMinutesOld(objFile.DateLastModified)
	if cdbl(minutesOld) &gt;= intAgeThreshold Then
	  Wscript.echo  &quot;Yes&quot;
	Else
	  Wscript.echo  &quot;No&quot;
	End If
Else
	WScript.Echo &quot;Patch CAB not found&quot;
	&#039;WScript.Echo &quot;Yes&quot;
End If
Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

&#039;date format is MM/DD/YYYY 
function GetMinutesOld(strDate)
	Dim patternDate,today
	patternDate = CDate( strDate )
	today = CDate( now )
	GetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
168,Patch,2015-01-05T20:22:03,",","Whether a machine has all patch tools necessary.
Example: Yes",1,2033984358,0,333,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Has Patch Tools,,,,,,,,,Windows,"&#039;========================================
&#039; Has Patch Tools
&#039;========================================

Option Explicit

&#039; sensor - Has Patch Tools
&#039; this action will look to see if the client has
&#039; various files related to patching
&#039; this checks the version string of all related patch files
&#039; and whether the cab file exists.

&#039;--------------------
&#039; Set These Variables
Dim strDesiredVersion
&#039; an string value which is a verison like
&#039; 4.1.314.7060
&#039; which is used to determine whether the files are the correct version

strDesiredVersion = &quot;6.2.314.8513&quot;
&#039;----------------------
Dim objFSO
Dim strPatchToolsDir
Dim bHasAllLatestFiles, arrPatchToolsFiles, strFile
Dim objTextFile, strVersionLine, strFileVersion
Dim strCabFile


Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

strPatchToolsDir = GetTaniumDir(&quot;Tools&quot;)

&#039; This array holds the files to check for
arrPatchToolsFiles = Array(&quot;run-patch-scan.vbs&quot;,&quot;install-patches.vbs&quot;,&quot;uninstall-patch.vbs&quot;,&quot;add-patch-exclusion.vbs&quot;, _
    &quot;remove-patch-exclusion.vbs&quot;, &quot;delete-queued-patch.vbs&quot;, &quot;add-patch-whitelist-entry.vbs&quot;, &quot;remove-patch-whitelist-entry.vbs&quot;)
strCabFile = &quot;Wsusscn2.cab&quot;

bHasAllLatestFiles = True &#039; assume OK until checks fail

For Each strFile In arrPatchToolsFiles
	If Not objFSO.FileExists(strPatchToolsDir&amp;strFile) Then
		WScript.Echo &quot;Missing &quot; &amp; strFile
		bHasAllLatestFiles = False
	End If
	If objFSO.FileExists(strPatchToolsDir&amp;strFile) Then
		Set objTextFile = objFSO.OpenTextFile(strPatchToolsDir&amp;strFile)
		strVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line
		If Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line
			WScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;
			bHasAllLatestFiles = False
		Else &#039; we have a version number, not split to check
			strFileVersion = Split(strVersionLine,&quot;tanium file version:&quot;)(1)
			If strFileVersion &lt;&gt; strDesiredVersion Then
				WScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion
				bHasAllLatestFiles = False
			End If
		End If
		objTextFile.Close
	End If
Next

If Not objFSO.FileExists(strPatchToolsDir&amp;strCabFile) Then &#039; if the cab file doesn&#039;t exist, report
	WScript.Echo &quot;Missing updates definition file&quot;
	bHasAllLatestFiles = False
End If

If bHasAllLatestFiles Then
	WScript.Echo &quot;Yes&quot;
Else
	WScript.Echo &quot;No&quot;
End If

&#039;Cleanup
Set objTextFile = Nothing
Set objFSO = Nothing

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,30,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
169,Patch,2015-01-05T20:22:03,",","Sensor that determines if the machine has not been scanned for patches in over 2 days.  If so, scan immediately.  Do not scan if the WUA Agent version is less than the supported version (6.1.0022.4).
Example: Yes",1,3369151052,0,335,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Is Patch Scan Force Time,,,,,,,,,Windows,"&#039;========================================
&#039; Is Patch Scan Force Time
&#039;========================================

Option Explicit

Dim objFSO,bIsScanForceTime
Dim intDaysThreshold,strScansDir,strResultsPath,objFile,words,daysOld

intDaysThreshold = 2
&#039; If the patch scan hasn&#039;t occurred on the
&#039; in the last 2 days, this sensor will be used to 
&#039; force a patch scan in conjunction with a
&#039; scheduled action

strScansDir = GetTaniumDir(&quot;Tools\Scans&quot;)
strResultsPath = strScansDir &amp; &quot;\patchresultsreadable.txt&quot;

bIsScanForceTime = False

Set objFSO = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

If objFSO.FileExists(strResultsPath) Then
	Set objFile = objFSO.GetFile(strResultsPath)
	words = Split(objFile.DateLastModified, &quot; &quot;)
	daysOld = GetDaysOld(words(0))
Else
	WScript.Echo &quot;Cannot Find Patch Results&quot;
	bIsScanForceTime = True
End If

If CInt(daysOld) &gt;= intDaysThreshold Then
WScript.Echo &quot;Patch Results Too Old&quot;
	bIsScanForceTime = True
End If

&#039; finally, do not force the scan if the WUA version is too low
WUAVersionTooLowForScanForceTime bIsScanForceTime

If bIsScanForceTime Then
  Wscript.echo  &quot;Yes&quot;
Else
  Wscript.echo  &quot;No&quot;
End If

&#039;&#039; --- &#039;&#039;
Function WUAVersionTooLowForScanForceTime(ByRef bIsScanForceTime)
	Dim strOutput, strSysDir, strWuaDll, i
	Dim strNeededVersion, arrNeededVersion
	Dim strVersion, arrVersion, intVersionPiece, bOldVersion
	
	&#039;adjust as required version changes
	strNeededVersion = &quot;6.1.0022.4&quot;
	arrNeededVersion = Split(strNeededVersion,&quot;.&quot;)
	
	strSysDir = GetSystemDir		
	strWuaDll = strSysDir &amp; &quot;\wuaueng.dll&quot;
	If objFSO.FileExists(strWuaDll) Then
		strVersion = objFSO.GetFileVersion(strWuaDll)
		&#039; WScript.Echo &quot;Current Version is &quot; &amp; strVersion
		&#039; WScript.Echo &quot;Required Version is &quot; &amp; strNeededVersion
		If strVersion &lt;&gt; strNeededVersion Then
		arrVersion = Split(strVersion, &quot;.&quot;)
		&#039; We assume there will be 4 fields, if not throw error
			If UBound(arrVersion) &lt;&gt; 3 Then
				bIsScanForceTime = False
				strOutput = &quot;Error: Cannot determine Windows Update Agent version, does not look like X.X.X.X&quot;
			Else
				bOldVersion = False &#039;assume version is good
				&#039; loop through each part
				&#039; if any individual part is less than its corresponding required part
				For i = 0 To UBound(arrVersion)
					If CInt(arrVersion(i)) &lt; CInt(arrNeededVersion(i)) Then
						&#039; WScript.Echo arrVersion(i) &amp; &quot; &lt; &quot; &amp; arrNeededVersion(i)
						bOldVersion = True
						Exit For &#039; No further checking necessary, it&#039;s out of date
					End If
				Next
				If bOldVersion Then 
					strOutput = &quot;Error: WUA Version is less than supported version &quot; &amp; strNeededVersion
					bIsScanForceTime = False
				End If
			End If
		Else
			&#039; versions are the same
		End If
	Else 
		strOutput = &quot;Error - WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;
		bIsScanForceTime = False
	End If

End Function &#039;WUAVersionTooLowForScanForceTime

Function GetSystemDir 
	Dim strWinDir,strSysDir
	
	&#039;Check for 64-bit sysnative directory to avoid win redirect
	strWinDir = objFSO.GetSpecialFolder(0)
	strSysDir = strWinDir &amp; &quot;\sysnative&quot;
	
	If Not objFSO.FolderExists(strSysDir) Then
		strSysDir = objFSO.GetSpecialFolder(1)
	End If
	GetSystemDir = strSysDir
End Function &#039; GetSystemDir


&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	Dim patternDate,today
	patternDate = CDate( strDate )
	today = CDate(FormatDateTime(Date(), 2))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
170,Patch,2015-01-05T20:22:03,",","Whether a machine has any patch files queued for install.
Example: Yes",1,679909726,0,337,1,Jim Olsen,60,0,defined,Tanium,2015-01-05T20:22:03,Has Patch Files,,,,,,,,,Windows,"&#039;========================================
&#039; Has Patch Files
&#039;========================================

Option Explicit

Dim strPatchesDir,fso,folder,files
strPatchesDir = GetTaniumDir(&quot;Tools\Patches&quot;)

Set fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set folder = fso.GetFolder(strPatchesDir)
Set files = folder.Files

If files.Count = 0 Then
	WScript.Echo &quot;No&quot;
Else
	WScript.Echo &quot;Yes&quot;
End If

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
171,Patch,2015-01-05T20:22:03,",","A sensor which can be edited to perform client side calculations on when it's time to scan for patches.  By default, it will always be patch scan time when evaluated as long as the WUA agent version is at least the minimum supported version (6.1.0022.4), and frequency is adjusted via the ""Patch Management - Run Patch Scan"" Scheduled Action.  
Example: Yes",1,3021311021,0,339,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Is Patch Scan Time,,,,,,,,,Windows,"&#039;========================================
&#039; Is Patch Scan Time
&#039;========================================

&#039; This sensor will do client side work to
&#039; determine when it&#039;s time to scan for patches

Option Explicit

Dim bIsScanTime
bIsScanTime = True

&#039; Global objects the functions may as well use
Dim objFSO,objReg

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

WUAVersionTooLowForScanTime bIsScanTime

If bIsScanTime Then
	WScript.Echo &quot;Yes&quot;
Else
	WScript.Echo &quot;No&quot;
End If

&#039; --- Helper Functions --- &#039;

Function WUAVersionTooLowForScanTime(ByRef bIsScanTime)
	Dim strOutput, strSysDir, strWuaDll, i
	Dim strNeededVersion, arrNeededVersion
	Dim strVersion, arrVersion, intVersionPiece, bOldVersion
	
	&#039;adjust as required version changes
	strNeededVersion = &quot;6.1.0022.4&quot;
	arrNeededVersion = Split(strNeededVersion,&quot;.&quot;)
	
	strSysDir = GetSystemDir		
	strWuaDll = strSysDir &amp; &quot;\wuaueng.dll&quot;
	If objFSO.FileExists(strWuaDll) Then
		strVersion = objFSO.GetFileVersion(strWuaDll)
		&#039; WScript.Echo &quot;Current Version is &quot; &amp; strVersion
		&#039; WScript.Echo &quot;Required Version is &quot; &amp; strNeededVersion
		If strVersion &lt;&gt; strNeededVersion Then
		arrVersion = Split(strVersion, &quot;.&quot;)
		&#039; We assume there will be 4 fields, if not throw error
			If UBound(arrVersion) &lt;&gt; 3 Then
				bIsScanTime = False
				strOutput = &quot;Error: Cannot determine Windows Update Agent version, does not look like X.X.X.X&quot;
			Else
				bOldVersion = False &#039;assume version is good
				&#039; loop through each part
				&#039; if any individual part is less than its corresponding required part
				For i = 0 To UBound(arrVersion)
					If CInt(arrVersion(i)) &lt; CInt(arrNeededVersion(i)) Then
						bOldVersion = True
						Exit For &#039; No further checking necessary, it&#039;s out of date
					End If
				Next
				If bOldVersion Then 
					strOutput = &quot;Error: WUA Version is less than supported version &quot; &amp; strNeededVersion
					bIsScanTime = False
				End If
			End If
		Else
			&#039; versions are the same
		End If
	Else 
		strOutput = &quot;Error - WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;
		bIsScanTime = False
	End If

End Function &#039;WUAVersionTooLowForScanTime
Function GetSystemDir 
	Dim strWinDir,strSysDir
	
	&#039;Check for 64-bit sysnative directory to avoid win redirect
	strWinDir = objFSO.GetSpecialFolder(0)
	strSysDir = strWinDir &amp; &quot;\sysnative&quot;
	
	If Not objFSO.FolderExists(strSysDir) Then
		strSysDir = objFSO.GetSpecialFolder(1)
	End If
	GetSystemDir = strSysDir
End Function &#039; GetSystemDir",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
172,Tanium,2015-01-05T20:22:03,",","Indicates whether the client machine has temporary files resulting from the install of the Tanium Client by the Client Deploy Tool
Example: yes",1,2616273872,0,341,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Has Tanium Client Install Files,,,,,,,,,Windows,"&#039;========================================
&#039; Has Tanium Client Install Files
&#039;========================================

&#039; This sensor will report on the existence of any file
&#039; in the C:\Tanium directory specified in the array below
&#039; The accompanying action which uses this sensor as a key will
&#039; delete the files it finds within

Option Explicit

Dim objFSO
Dim strTaniumDir
Dim bHasFilesToDelete,arrFilesToDelete,strFile

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

strTaniumDir = &quot;C:\Tanium\&quot;

arrFilesToDelete = Array(&quot;dodeploy.exe&quot;, &quot;dodeploy.log&quot;, &quot;postdeploy.exe&quot;, &quot;postdeploy.log&quot;, _
	&quot;predeploy.exe&quot;, &quot;predeploy.log&quot;, &quot;SetupClient.exe&quot;, &quot;tanium.pub&quot;)

bHasFilesToDelete = False
For Each strFile In arrFilesToDelete
	If  objFSO.FileExists(strTaniumDir&amp;strFile) Then
		&#039;WScript.Echo &quot;Should Delete &quot; &amp; strFile
		bHasFilesToDelete = True
	End If
Next

If bHasFilesToDelete Then
	WScript.Echo &quot;Yes&quot;
Else
	WScript.Echo &quot;No&quot;
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
173,Tanium Diagnostics,2015-01-05T20:22:03,",","Evaluates whether a machine has stale Tanium Client data - long running processes, old action status/log files, action folders, or sensor output.
Example: Yes",1,3005061811,0,343,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Has Stale Tanium Client Data,,,,,,,,,Windows,"&#039;========================================
&#039; Has Stale Tanium Client Data
&#039;========================================
&#039; This  sensor  will  return  Yes  if   a
&#039; machine has processes running from  the
&#039; Tanium sensor or action directory  that
&#039; have been running longer than a day,
&#039; has  stale  action  status or log files 
&#039; older than 4 days, has stale sensor 
&#039; output data older than a day, has old
&#039; action folders, has stale string /node data

Option Explicit

Dim intProcessesThreshold,intSensorDataThreshold,intStaleStatusFilesThreshold,dictDumps,bExtraDumpFiles
Dim intStaleActionFoldersThreshold,intStaleFilesWantedDownloadThreshold,intStaleQNAThreshold,intMaxClientRAMInMB,MIN_CLIENT_STRING_NODE_THRESHOLD

intProcessesThreshold = 1440  &#039; one day in minutes
intSensorDataThreshold = 1440  &#039; one day in minutes
intStaleStatusFilesThreshold = 5670 &#039; 4 days in minutes
intStaleQNAThreshold = 1440 &#039; one day in minutes
intStaleActionFoldersThreshold = 2880 &#039;two days in minutes
intStaleFilesWantedDownloadThreshold = 0 &#039;comment out this line and uncomment next to enable
&#039;intStaleFilesWantedDownloadThreshold = 5670 &#039;4 days in minutes
&#039; report stale string data when Client RAM is above this value
intMaxClientRAMInMB = 0 &#039; comment out this line and uncomment next
&#039; intMaxClientRAMInMB = 200 &#039; Uncomment to check for client &gt; 200
&#039;set a minimum value which must match the value
&#039; MIN_CLIENT_MEMORY_RESTART_THRESHOLD
&#039; in the corresponding Clean Stale Client Data Action
MIN_CLIENT_STRING_NODE_THRESHOLD = 50

SetLocale(1033) &#039; Uses Date Math which may require us/english to work correctly

&#039; count and remove dump files
Set dictDumps = CreateObject(&quot;Scripting.Dictionary&quot;)
PopulateDumpFilesDict dictDumps
bExtraDumpFiles = HasOldDumpFiles(dictDumps)


If HasStaleProcesses(intProcessesThreshold) Or _
		HasStaleSensorData(intSensorDataThreshold) Or _
		HasStaleActionStatusAndLogFiles(intStaleStatusFilesThreshold) Or _ 
		HasStaleActionFolders(intStaleActionFoldersThreshold) Or _
		HasStaleQNAFiles(intStaleQNAThreshold) Or _ 
		HasStaleFilesWantedDownloads(intStaleFilesWantedDownloadThreshold) Or _
		ClientRAMThresholdHitNoRestart(intMaxClientRAMInMB) Or _
		bExtraDumpFiles Then
	WScript.Echo &quot;Yes&quot;
Else
	WScript.Echo &quot;No&quot;
End If

Sub PopulateDumpFilesDict(ByRef dictDump)
	&#039; builds a dictionary of dump files

	Dim objFSO,strTaniumDir,objFolder,objFile,strFileName
	Dim strFilePath,strFileCreated
	
	strTaniumDir = GetTaniumDir(&quot;&quot;)
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	For Each objFile In objFSO.GetFolder(strTaniumDir).Files
		strFileName = objFile.Name
		If Mid(strFileName,Len(strFileName) - 3,Len(strFileName)) = &quot;.dmp&quot; Then
			If Not dictDump.Exists(objFile.Path) Then
				dictDump.Add objFile.Path,objFile.DateCreated
			End If
		End If
	Next

End Sub &#039;PopulateDumpFilesDict

Function HasOldDumpFiles(ByRef dictDumps)

	&#039; keep last dump file
	Dim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Dim strDumpPath,dtmLatestDate,strLastDumpPath,strDumpDate,intCount
	
	&#039; which dump file was the latest - do not delete
	dtmLatestDate = CDate(&quot;07/06/1978&quot;)
	For Each strDumpPath In dictDumps.Keys
		strDumpDate = dictDumps.Item(strDumpPath)
		If IsDate(strDumpDate) Then
			If CDate(strDumpDate) &gt; dtmLatestDate Then
				dtmLatestDate = CDate(strDumpDate)
				strLastDumpPath = strDumpPath
			End If
		End If
	Next
	
	intCount = 0
	For Each strDumpPath In dictDumps.Keys
		If Not strDumpPath = strLastDumpPath Then
			intCount = intCount + 1
		End If
	Next
	
	If intCount &gt; 0 Then
		HasOldDumpFiles = True
		WScript.Echo &quot;Unnecessary Dump Files&quot;
	Else
		HasOldDumpFiles = False
	End If
	
End Function &#039;HasOldDumpFiles

Function HasStaleProcesses(intThreshold)
	
	Dim bHasStaleProcesses,objWMIService,strPID,colItems,objItem
	Dim intAge,strCmd
	
	bHasStaleProcesses = False &#039; assume false until tested
	&#039; We may get errors getting the age of some system processes
	On Error Resume Next
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process&quot;,,48)
	For Each objItem In colItems
		strCmd = LCase(objItem.CommandLine)
		If (InStr(strCmd, &quot;tanium client\vb\&quot;) &gt; 0 Or InStr(strCmd, &quot;tanium client\downloads\&quot;) &gt; 0) Then
			intAge = GetAgeInMinutesWMI(objItem.CreationDate)
			strPid = objItem.ProcessId
			If intAge &gt;= intThreshold Then
				bHasStaleProcesses = True
				Exit For
			End If
		End If
	Next
	On Error Goto 0
	
	If bHasStaleProcesses Then WScript.Echo &quot;Stale Processes&quot;
	HasStaleProcesses = bHasStaleProcesses
	
End Function &#039;HasStaleProcesses

Function HasStaleSensorData(intThreshold)
	&#039; returns true or false
	
	Dim bHasStaleSensorData,fso,strVBDir,intAge,objFolder,file
	
	bHasStaleSensorData = False &#039; assume false until tested
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	strVBDir = GetTaniumDir(&quot;VB&quot;)
	
	If fso.FolderExists(strVBDir) Then
		Set objFolder = fso.GetFolder(strVBDir)
		
		For Each file In objFolder.Files
			intAge = GetMinutesOld(file.DateLastModified)
			If intAge &gt;= intThreshold Then
				bHasStaleSensorData = True
				Exit For
			End If
		Next
	End If
	
	If bHasStaleSensorData Then WScript.Echo &quot;Stale Sensor Data&quot;
	HasStaleSensorData = bHasStaleSensorData
	
End Function &#039;HasStaleSensorData

Function HasStaleActionStatusAndLogFiles(intThreshold)
	&#039; returns true or false
	
	Dim bHasStaleActionStatusAndLogFiles,fso,strVBDir,intAge,objFolder,file
	Dim arrWords1,strExt,arrWords2,strDownloadsDir
	bHasStaleActionStatusAndLogFiles = False &#039;assume false until tested
	
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	strDownloadsDir = GetTaniumDir(&quot;Downloads&quot;)
	
	If fso.FolderExists(strDownloadsDir) Then
		Set objFolder = fso.GetFolder(strDownloadsDir)
		
		For Each file In objFolder.Files
			If Left(file.Name, 6) = &quot;Action&quot; Then
				arrWords1 = Split(file.Name, &quot;.&quot;)
				strExt = arrWords1(UBound(arrWords1))
				If LCase(strExt) = &quot;log&quot; Or LCase(strExt) = &quot;status&quot; Then
					intAge = GetMinutesOld(file.DateLastModified)
					If intAge &gt;= intThreshold Then
						bHasStaleActionStatusAndLogFiles = True
						Exit For
					End If
				End If
			End If
		Next
	End If
	
	If bHasStaleActionStatusAndLogFiles Then WScript.Echo &quot;Stale Action Status/Log Files&quot;
	HasStaleActionStatusAndLogFiles = bHasStaleActionStatusAndLogFiles
	
End Function &#039;HasStaleActionStatusAndLogFiles

Function HasStaleFilesWantedDownloads(intThreshold)
	&#039; returns true or false
		
	Dim bHasStaleFilesWantedDownloads,fso,strCacheDir,objFolder,objFile
	Dim strFileName, intAge
	bHasStaleFilesWantedDownloads = False &#039;assume false until tested
	
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	strCacheDir = GetTaniumDir(&quot;Downloads\Cache&quot;)
	
	If fso.FolderExists(strCacheDir) And intThreshold &lt;&gt; 0 Then
		Set objFolder = fso.GetFolder(strCacheDir)
		
		For Each objFile In objFolder.Files
			strFileName = objFile.Name
	
			If strFileName &lt;&gt; &quot;Catalog&quot; And _
			   strFileName &lt;&gt; &quot;FullCacheFile&quot; And _
			   strFileName &lt;&gt; &quot;HotCacheFile&quot; And _
			   InStr(strFileName, &quot;-&quot;) &gt; 0 Then 		
				intAge = GetMinutesOld(objFile.DateLastModified)
				If intAge &gt;= intThreshold Then
					bHasStaleFilesWantedDownloads = True
					Exit For
				End If
			End If
		Next
	End If
	
	If bHasStaleFilesWantedDownloads Then WScript.Echo &quot;Stalled Downloads&quot;
	HasStaleFilesWantedDownloads = bHasStaleFilesWantedDownloads
	
End Function &#039;HasStaleFilesWantedDownloads

Function HasStaleActionFolders(intThreshold)
&#039; returns true or false
&#039; threshold value recommended &gt; 2 days for long running actions.
	Dim intCount,fso,strVBDir,intAge,objFolder,folder
	Dim arrWords1,strExt,strDownloadsDir,bHasStaleActionStatusAndLogFiles
	bHasStaleActionStatusAndLogFiles = False &#039;assume false until tested
	
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	strDownloadsDir = GetTaniumDir(&quot;Downloads&quot;)
	
	intCount = 0
	If fso.FolderExists(strDownloadsDir) Then
		Set objFolder = fso.GetFolder(strDownloadsDir)
		For Each folder In objFolder.Subfolders
			If Left(folder.Name, 7) = &quot;Action_&quot; Then
				intAge = GetMinutesOld(folder.DateLastModified)
				If intAge &gt;= intThreshold Then
					bHasStaleActionStatusAndLogFiles = True
					Exit For
				End If
			End If
		Next
	End If
	
	If bHasStaleActionStatusAndLogFiles Then WScript.Echo &quot;Stale Action Folders&quot;
	HasStaleActionFolders = bHasStaleActionStatusAndLogFiles
		
End Function &#039;HasStaleActionFolders

Function HasStaleQNAFiles(intThreshold)
&#039; returns true or false
	Dim intCount,fso,strVBDir,intAge,objFolder,file
	Dim strQNADir,strTaniumDir,bHasStaleQNAFiles
	bHasStaleQNAFiles = False &#039;assume false until tested
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	&#039; Do not point gettaniumdir at tools\qna directly or it would create the folder
	strTaniumDir = GetTaniumDir(&quot;&quot;)
	strQNADir = strTaniumDir&amp;&quot;QNA&quot;
	
	intCount = 0
	If fso.FolderExists(strQNADir) Then
		Set objFolder = fso.GetFolder(strQNADir)
		On Error Resume Next
		For Each file In objFolder.Files
			If Instr(file.name,&quot;.qna&quot;) &gt; 0 Then
				intAge = GetMinutesOld(file.DateLastModified)
				If intAge &gt;= intThreshold Then
					bHasStaleQNAFiles = True
				End If
			End If
		Next
		On Error Goto 0
	End If
	
	If bHasStaleQNAFiles Then WScript.Echo &quot;Stale QNA Files&quot;
	HasStaleQNAFiles = bHasStaleQNAFiles
	
End Function &#039;HasStaleQNAFiles

Function GetAgeInMinutesWMI(strWMI)
	Dim strProcessStart,strYear,strMonth,strDate,strHours,strMin,strSec
	Dim dtmProcessStart
	
	strYear = Left(strWMI, 4)
	strMonth = Mid(strWmi, 5, 2)
	strDate = Mid(strWMI, 7, 2)
	strHours = Mid(strWMI, 9, 2)
	strMin = Mid(strWMI, 11, 2)
	strSec = Mid(strWMI, 13, 2)
	strProcessStart = 	strMonth&amp;&quot;/&quot;&amp;strDate&amp;&quot;/&quot;&amp;strYear&amp;&quot; &quot; &amp; _
	strhours&amp;&quot;:&quot;&amp;strMin&amp;&quot;:&quot;&amp;strSec
	On Error Resume Next
	dtmProcessStart = FormatDateTime(strProcessStart, 0)
	If Err.Number &lt;&gt; 0 Then
		GetAgeInMinutesWMI = False
		On Error Goto 0
		Exit Function
	End If
	On Error Goto 0
	GetAgeInMinutesWMI = DateDiff(&quot;n&quot;, dtmProcessStart, Now())
End Function &#039;GetAgeInMinutesWMI

Function GetOffset
	Dim objSWbemServices,colTimeZone,objTimeZone
	
	Set objSWbemServices = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objSWbemServices.ExecQuery(&quot;SELECT * FROM Win32_TimeZone&quot;)
	For Each objTimeZone In colTimeZone
		GetOffset = objTimeZone.Bias
	Next	
End Function

Function GetMinutesOld(strDate)
	Dim patternDate
	On Error Resume Next
	patternDate = CDate( strDate )
	If Err.Number &lt;&gt; 0 Then
		GetMinutesOld = False
		On Error Goto 0
		Exit Function
	End If
	On Error Goto 0		
	GetMinutesOld = Abs(DateDiff(&quot;n&quot;, patternDate, Now()))
End Function &#039;GetMinutesOld


Function GetTaniumDir(strSubDir)
	&#039;GetTaniumDir with GeneratePath, works in x64 or x32
	&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
	
	&#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
	On Error Resume Next
	strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
	On Error Goto 0
	
	If strPath = &quot;&quot; Then
		&#039; Could not find 32-bit mode path, checking Wow6432Node
		On Error Resume Next
		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
		On Error Goto 0
	End If
	
	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If  
		
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False
	
	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function ClientRAMThresholdHitNoRestart(intMaxClientRAMInMB)
&#039; Checks the Client RAM and will restart the client

	If intMaxClientRAMInMB = 0 Then
		ClientRAMThresholdHitNoRestart = False
		Exit Function
	End If
	
	Dim objWMIService,colItems,objItem,strProcess,intClientRAMUsedInMB
	Dim strClientExeName,strMem,strProcessMem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	strClientExeName = &quot;taniumclient.exe&quot;

	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process where Caption=&#039;&quot;&amp;strClientExeName&amp;&quot;&#039;&quot;,,48)
	strMem = 0
	On Error Resume Next
	For Each objItem in colItems
		strProcessMem = objItem.WorkingSetSize
		If Err.Number = 0 Then
			If IsInteger(strProcessMem) Then
				strMem = strProcessMem + strMem
			End If
		End If
		Err.Clear()
	Next
	On Error Goto 0
	intClientRAMUsedInMB = 0
	strMem = CLng(strMem)
	intClientRAMUsedInMB = Int(strMem / (1024 * 1024))
	If intClientRAMUsedInMB &gt; intMaxClientRAMInMB And intClientRAMUsedInMB &gt; MIN_CLIENT_STRING_NODE_THRESHOLD Then
		WScript.Echo &quot;Stale String/Node Data&quot;
		ClientRAMThresholdHitNoRestart = True
	Else
		ClientRAMThresholdHitNoRestart = False
	End If
	
End Function &#039;ClientRAMThresholdHitNoRestart",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,8,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
174,Unmanaged Assets,2015-01-05T20:22:03,",","Determines whether a machine has the unmanaged asset tools.  A ""No"" answer will prompt a tools distribution job to the endpoint.
Example: Yes",1,1434351235,0,345,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Unmanaged Asset Scanner Exists,,,,,,,,,Windows,"&#039;========================================
&#039; Unmanaged Asset Scanner Exists
&#039;========================================

Option Explicit

&#039;--------------------
&#039; Set These Variables
Dim strDesiredVersion, strDesiredPortTesterVersion
&#039; a string value which is a verison like
&#039; 4.2.314.7111
&#039; which is used to determine whether the files are the correct version
&#039; The top line of each file should read
&#039;Tanium File Version: &lt;version string below&gt;
strDesiredVersion = &quot;6.2.314.8513&quot;
&#039; -------------------
&#039; Treat the PortTester Tool differently, since it&#039;s a build-process item
strDesiredPortTesterVersion = &quot;&quot;  &#039; is not versioned today


Dim objFSO
Dim strToolsDir,objTextFile
Dim bHasAllLatestFiles,arrActionFiles,strFile,strVersionLine,strFileVersion
Dim strPortTesterFile,strPortTesterFileVersion

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

strToolsDir = GetTaniumDir(&quot;Tools&quot;)

arrActionFiles = Array(&quot;run-ua-scan.vbs&quot;)

&#039; PortTester utility is required
strPortTesterFile=strToolsDir&amp;&quot;PortTester.exe&quot;
bHasAllLatestFiles = True
For Each strFile In arrActionFiles
	If Not objFSO.FileExists(strToolsDir&amp;strFile) Then
		WScript.Echo &quot;Missing &quot; &amp; strFile
		bHasAllLatestFiles = False
	End If
	If objFSO.FileExists(strToolsDir&amp;strFile) Then
		Set objTextFile = objFSO.OpenTextFile(strToolsDir&amp;strFile)
		strVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line
		If Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line
			WScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;
			bHasAllLatestFiles = False
		Else &#039; we have a version number, not split to check
			strFileVersion = Trim(Split(strVersionLine,&quot;tanium file version:&quot;)(1))
			If strFileVersion &lt;&gt; strDesiredVersion Then
				WScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion
				bHasAllLatestFiles = False
			End If
		End If
		objTextFile.Close
	End If
Next

&#039; check the PortTester binary
If Not objFSO.FileExists(strPortTesterFile) Then
	WScript.Echo &quot;Missing &quot; &amp; strPortTesterFile
	bHasAllLatestFiles = False
End If
If objFSO.FileExists(strPortTesterFile) Then
	strPortTesterFileVersion = objFSO.GetFileVersion(strPortTesterFile)
	If Not strPortTesterFileVersion = &quot;&quot; Then
		bHasAllLatestFiles = False
		WScript.Echo strPortTesterFile&amp;&quot; version: &quot;&amp;strPortTesterFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredPortTesterVersion
	End If
End If

If bHasAllLatestFiles Then
	WScript.Echo &quot;True&quot;
Else
	WScript.Echo &quot;False&quot;
End If

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,9,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
175,Hardware,2015-01-05T20:22:03,",","The serial number, if available, provided by the computer manufacturer.
Example: 123ABC1",1,102224229,0,347,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:03,Computer Serial Number,,,,,,,,,Windows,select SerialNumber from win32_BIOS,WMIQuery,Linux,"#!/bin/bash
dmidecode -s system-serial-number
",UnixShell,Mac,"#!/bin/bash
system_profiler SPHardwareDataType | awk &#039;/Serial Number/ {print $NF}&#039;
",UnixShell,0,7,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
176,SQL,2015-01-05T20:22:03,",","Returns whether or not the SQL server instance is clustered
Example: True",1,1039470236,0,349,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,SQL Clustered,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Clustered
&#039;========================================

Option Explicit

&#039; Searches for a service called &quot;Cluster Service&quot; and returnes yes if found
&#039; and SQL Server is also found

Dim objWMIService, colServices, objService, strCaption, bSQLServerInstalled, bSQLClusterServiceRunning

Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
For Each objService In colServices
    strCaption = objService.Caption

    If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0) Then    
        &#039; OK -- found SQL Server on this machine
		bSQLServerInstalled = True
    End If  
    
    If (InStr(strCaption,&quot;Cluster Service&quot;) &lt;&gt; 0 And objService.State = &quot;Running&quot;) Then
    	bSQLClusterServiceRunning = True
    End If 
Next  

If bSQLServerInstalled Then
	If bSQLClusterServiceRunning Then
		WScript.Echo &quot;True&quot;
	Else 
		WScript.Echo &quot;False&quot;
	End If
Else 
	WScript.Echo &quot;SQL Server Not Installed&quot;
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
177,Hardware,2015-01-05T20:22:03,",","Returns the virtual platform or technology used for the virtual machine, if it is a virtual machine.
Example: VMware",1,1046354727,0,351,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:03,Virtual Platform,,,,,,,,,Windows,"&#039;========================================
&#039; Virtual Platform
&#039;========================================

&#039; This sensor will determine if a machine is a virtual machine or not
&#039; Comparing values for certain properties against known values.
&#039; It will need to be updated for some current tech and 
&#039; as new technologies come to market.


Option Explicit



WScript.Echo GetVirtualPlatform


Function GetVirtualPlatform
	Dim sVMPlatform, sMake, sModel, sBIOSVersion,bIsVM

    &#039; Check the WMI information against known values

    bIsVM = false
    sVMPlatform = &quot;&quot;

    sMake = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Manufacturer&quot;)
    sModel = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Model&quot;)
    sBIOSVersion = GetWmiPropertyValue(&quot;root\cimv2&quot;, &quot;Win32_BIOS&quot;, &quot;Version&quot;)

    &#039;WScript.Echo &quot;Manufacturer=&quot; &amp; sMake
    &#039;WScript.Echo &quot;Model=&quot; &amp; sModel
    &#039;WScript.Echo &quot;BIOSVersion=&quot; &amp; sBIOSVersion

    If sModel = &quot;Virtual Machine&quot; then

        &#039; Microsoft virtualization technology detected, assign defaults

        sVMPlatform = &quot;Hyper-V&quot;
        bIsVM = true

        &#039; Try to determine more specific values

        Select Case sBIOSVersion
        Case &quot;VRTUAL - 1000831&quot;
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 Beta or RC0&quot;
        Case &quot;VRTUAL - 5000805&quot;, &quot;BIOS Date: 05/05/08 20:35:56  Ver: 08.00.02&quot;
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 RTM&quot;
        Case &quot;VRTUAL - 3000919&quot; 
            bIsVM = true
            sVMPlatform = &quot;Hyper-V 2008 R2&quot;
        Case &quot;A M I  - 2000622&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005R2SP1 or VPC2007&quot;
        Case &quot;A M I  - 9000520&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005R2&quot;
        Case &quot;A M I  - 9000816&quot;, &quot;A M I  - 6000901&quot;
            bIsVM = true
            sVMPlatform = &quot;Windows Virtual PC&quot;
        Case &quot;A M I  - 8000314&quot;
            bIsVM = true
            sVMPlatform = &quot;VS2005 or VPC2004&quot;
        Case &quot;Xen - 0s&quot;
        	bIsVM = True
        	sVMPlatform = &quot;Xen&quot;
        Case &quot;Xen - 0&quot;
            bIsVM = True
            sVMPlatform = &quot;Xen&quot;
        End Select

    ElseIf sModel = &quot;VMware Virtual Platform&quot; then

        &#039; VMware detected

        sVMPlatform = &quot;VMware&quot;
        bIsVM = true

    ElseIf sModel  = &quot;VirtualBox&quot; then

        &#039; VirtualBox detected

        bIsVM = true
        sVMPlatform = &quot;VirtualBox&quot;

    Else 
        sVMPlatform = &quot;Not Virtual&quot;
    End if

    GetVirtualPlatform = sVMPlatform

End Function

Function GetWmiPropertyValue(strNameSpace, strClassName, strPropertyName)
	Dim strPropertyValue, oWMIClass, oWMIProperties, objWMIService, colItems
	Dim objItem, objProperty
	Dim sLine
	
    On Error Resume Next

    strPropertyValue = &quot;&quot;
    set oWmiClass = getobject(&quot;winmgmts:&quot; &amp; strNameSpace).get(strClassName,&amp;h20000) &#039;amended
    set oWmiProperties = oWmiClass.Properties_

    Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; &quot;.&quot; &amp; &quot;\&quot; &amp; strNameSpace)
    Set colItems = objWMIService.ExecQuery(&quot;Select * from &quot; &amp; strClassName,,48)

    For Each objItem in colItems
        For Each objProperty in oWmiProperties
            sLine = &quot;&quot;
            &#039;WScript.Echo &quot;- &quot; &amp; objProperty.name &amp; &quot;: &quot; &amp; strPropertyName

            If objProperty.Name = strPropertyName Then
                If objProperty.IsArray = True Then
                    sLine = &quot;str&quot; &amp; objProperty.Name &amp; &quot; = Join(objItem.&quot; &amp; objProperty.Name &amp; &quot;, &quot; &amp; Chr(34) &amp; &quot;,&quot; &amp; Chr(34) &amp; &quot;)&quot; &amp; vbCrLf
                    sLine = sLine &amp; &quot;strPropertyValue =  str&quot; &amp; objProperty.Name
                &#039;ElseIf objProperty.CIMTYPE = 101 Then
                &#039;    bHasDates = True
                &#039;    sLine =  &quot;strPropertyValue =  WMIDateStringToDate(objItem.&quot; &amp; objProperty.Name &amp; &quot;)&quot;
                Else
                    sLine =  &quot;strPropertyValue =  objItem.&quot; &amp; objProperty.Name
                End If

                &#039;WScript.Echo sLine
                Execute sLine
            End If

        Next
    Next

    GetWmiPropertyValue = strPropertyValue
    
    &#039;Cleanup!
    set oWmiClass = Nothing
    set oWmiProperties = Nothing

    Set objWMIService = Nothing
    Set colItems = Nothing

End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
178,File System,2015-01-05T20:22:03,",","Returns the version of the file specified.
Example: 1.0",1,112406691,0,353,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,File Version,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the full drive letter, folder path and file name of the file."",""value"":"""",""promptText"":""c:\\windows\\test.txt"",""defaultValue"":"""",""label"":""File path and name"",""maxChars"":0,""key"":""file"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; File Version
&#039;========================================

&#039; TAG: REDIRECTION

filePath = unescape(&quot;||file||&quot;)

filePath = FixFileSystemRedirectionForPath(filePath)

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

If fso.FileExists(filePath) Then 
	strVersion = fso.GetFileVersion(filePath)

	If strVersion = &quot;&quot; Then
		WScript.Echo &quot;Version not found&quot;
	Else
		WScript.Echo strVersion
	End If	
&#039;	If strVersion
Else 
	WScript.Echo &quot;File not found&quot;
End If

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
    
    Dim objFSO, strSystem32Location,objShell
    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
    
    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
        If InStr(strFilePath,strSystem32Location) = 1 Then
            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
            strFilePath = strNewSystem32Location&amp;strRestOfPath
        End If
    End If
    FixFileSystemRedirectionForPath = strFilePath
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

    Dim objFSO,strSystem32Location,strNewSystem32Location
    
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    
    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
    
    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File path and name&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||file||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File path and name&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||file||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
179,Operating System,2015-01-05T20:22:03,",","Hard disk device that the operating system uses to boot from.
Example: \\Device\\HarddiskVolume1",1,1125023461,0,355,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:03,Boot Device,,,,,,,,,Windows,select BootDevice from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
180,Operating System,2015-01-05T20:22:03,",","Returns information about shares on a PC.
Example: SHARENAME",1,1132013379,0,357,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Open Shares,,,,,,,,,Windows,select name from win32_share where caption != &#039;Default Share&#039; AND caption != &#039;Remote Admin&#039; AND caption != &#039;Remote IPC&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
sharing -l | awk &#039;BEGIN {i=0} /smb:/ { while (i &lt; 1) { getline; print $0; i++ } i=0}&#039; | awk -F &quot;:\t&quot; &#039;{print $2}&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
181,McAfee,2015-01-05T20:22:03,",","Returns error conditions that would indicate an unhealthy VirusScan Enterprise state on an endpoint.
example: Unhealthy",1,115043288,0,359,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,VirusScan Enterprise Health,,,,,,,,,Windows,"&#039; Sensor: VirusScan Enterprise Health
&#039; Returns any error conditions for VirusScan Enterprise 8.7 or 8.8

Option Explicit

Dim strServiceState
&#039; First get the state of the service
strServiceState = ServiceState(&quot;McShield&quot;)
If strServiceState = &quot;Not Installed&quot; Then
	&#039;No further tests are necessary
	WScript.Echo &quot;VirusScan Enterprise Not Installed&quot;
	WScript.Quit
End If

SetLocale(1033) &#039; this sensor uses date math, setting to us/english

&#039; Hold whether to report a final error state
Dim bGlobalError : bGlobalError = False

&#039; Global objects the functions may use
Const HKLM = &amp;h80000002
Dim objFSO,objReg

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set objReg = Getx64RegistryProvider()


&#039; Pass the global error flag down each of the functions
&#039; which will flip it and report their own errors

&#039; do not use parentheses or will not pass ByRef.
&#039; could use parentheses and use the Call keyword, however

DatTooOld 1, bGlobalError
ServiceIsRunning strServiceState, bGlobalError
ServiceIsNotAuto strServiceState, bGlobalError
AccessProtectionDisabled bGlobalError
OnAccessScannerDisabled bGlobalError

If bGlobalError Then
	WScript.Echo &quot;Unhealthy&quot;
Else
	WScript.Echo &quot;Healthy&quot;
End If

&#039; --- Health Check Functions --- &#039;

Sub DatTooOld(intThresholdDays,ByRef bHasError)
	Dim strDatDate,dtmDatDate,arrDatDateBits
	Dim strRegPath, intDaysOld
	strRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetStringValue HKLM,strRegPath,&quot;AVDatDate&quot;,strDatDate
		
		&#039;Date is in YYYY/MM/DD format, move to US/English
		If InStr(strDatDate,&quot;/&quot;) &gt; 0 Then &#039;valid value
			arrDatDateBits = Split(strDatDate,&quot;/&quot;)
			strDatDate = arrDatDateBits(1)&amp;&quot;/&quot;&amp;arrDatDateBits(2)&amp;&quot;/&quot;&amp;arrDatDateBits(0)
			If IsDate(strDatDate) Then
				intDaysOld = CInt(GetDaysOld(strDatDate))
				If intDaysOld &gt; CInt(intThresholdDays) Then
					WScript.Echo &quot;Error: VirusScan Enterprise DAT file greater than &quot; &amp; intThresholdDays &amp; &quot; days old&quot;
					bHasError = True
				End If
			Else
				WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Dat date&quot;
				bHasError = True
			End If
		Else &#039; Dat Date has no &quot;/&quot; in it and cannot be parsed or compared
			WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT date&quot;
			bHasError = True
		End If
	Else
		WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT date&quot;
		bHasError = True
	End If
End Sub &#039;DatTooOld

Sub AccessProtectionDisabled(ByRef bHasError)
&#039; This function determines whether Access Protection feature is disabled
	Dim intAPEnabled
	Dim strRegPath
	strRegPath = GetMcAfeeProductRegRootKey(&quot;SYSTEMCORE&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetDWORDValue HKLM,strRegPath&amp;&quot;\VSCore\On Access Scanner\BehaviourBlocking&quot;,&quot;APEnabled&quot;,intAPEnabled
		If Not (IsNull(intAPEnabled) Or intAPEnabled = &quot;&quot; ) And IsNumeric(intAPEnabled) Then
			If CInt(intAPEnabled) = 0 Then
				WScript.Echo &quot;Fixable: VirusScan Enterprise Access Protection is Disabled&quot;
				bHasError = True
			End If
		Else
			WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Access Protection Status&quot;
			bHasError = True
		End If
	Else
		WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Access Protection Status&quot;
		bHasError = True
	End If
End Sub &#039;AccessProtectionDisabled

Sub OnAccessScannerDisabled(ByRef bHasError)
&#039; This function determines whether On Access Scanner feature is disabled
	Dim intOASEnabled
	Dim strRegPath
	strRegPath = GetMcAfeeProductRegRootKey(&quot;SYSTEMCORE&quot;)
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetDWORDValue HKLM,strRegPath&amp;&quot;\VSCore\On Access Scanner\McShield\Configuration&quot;,&quot;OASEnabled&quot;,intOASEnabled
		If Not (IsNull(intOASEnabled) Or intOASEnabled = &quot;&quot; ) And IsNumeric(intOASEnabled) Then
			If CInt(intOASEnabled) &lt;&gt; 3 Then
				WScript.Echo &quot;Fixable: VirusScan Enterprise On-Access Scanner is Disabled&quot;
				bHasError = True
			End If
		Else
			WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise On-Access Scanner Status&quot;
			bHasError = True
		End If
	Else
		WScript.Echo &quot;Error: Cannot determine VirusScan Enterprise On-Access Scanner Status&quot;
		bHasError = True
	End If
End Sub &#039;OnAccessScannerDisabled

Sub ServiceIsRunning(strServiceState, ByRef bHasError)
	If InStr(strServiceState,&quot;Stopped&quot;) &gt; 0 Or InStr(strServiceState,&quot;Paused&quot;) &gt; 0 Then
		WScript.Echo &quot;Fixable: VirusScan Enterprise On-Access Scan Service not Running&quot;
		bHasError = True
	End If
End Sub &#039;ServiceIsRunning

Sub ServiceIsNotAuto(strServiceState, ByRef bHasError)
	If InStr(strServiceState,&quot;Manual&quot;) &gt; 0 Or InStr(strServiceState,&quot;Disabled&quot;) &gt; 0 Then
		WScript.Echo &quot;Fixable: VirusScan Enterprise On-Access Scan Service start mode not Automatic&quot;
		bHasError = True
	End If
End Sub &#039;ServiceIsNotAuto

&#039; ---- Support Functions ---- &#039;
Function ServiceState(strServiceName)
&#039; This function determines if a service is in a bad state and returns
&#039; values indicating the state.  Examples: 
&#039; &quot;Stopped&quot;
&#039; &quot;Stopped Manual&quot;
&#039; &quot;Running Disabled&quot;
&#039; &quot;Not Installed&quot;

	Dim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState

	strWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;

	strState = &quot;&quot;
	strStartMode = &quot;&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
		&amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(strWMIQuery)
	
	If colItems.Count = 0 Then
		ServiceState = &quot;Not Installed&quot;
	Else
		For Each objItem In colItems
			If objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then
				strState = objItem.State
			End If
			If objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then
				strStartMode = objItem.StartMode
			End If
			ServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)
		Next
	End If

End Function &#039;ServiceState

Function RegKeyExists(sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function &#039;RegKeyExists

Function GetMinutesOld(strDate)
&#039;date format is MM/DD/YYYY 
	SetLocale(1033)
	Dim patternDate, today
	patternDate = CDate( strDate )
	today = CDate( now )
	GetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)
End Function &#039;GetMinutesOld

Function GetDaysOld(strDate)
&#039;date format is MM/DD/YYYY 
	SetLocale(1033)
	Dim patternDate, today
	patternDate = CDate( strDate )
	today = CDate( now )
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function &#039;GetDaysOld

Function GetSystemDir 
	Dim strWinDir,strSysDir
	
	&#039;Check for 64-bit sysnative directory to avoid win redirect
	strWinDir = objFSO.GetSpecialFolder(0)
	strSysDir = strWinDir &amp; &quot;\sysnative&quot;
	
	If Not objFSO.FolderExists(strSysDir) Then
		strSysDir = objFSO.GetSpecialFolder(1)
	End If
	GetSystemDir = strSysDir
End Function &#039; GetSystemDir

Function GetMcAfeeProductRegRootKey(strProductString)
&#039; Retrieves McAfee key for a product
&#039; products are passed in and defined in the function

	Dim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey
	Dim strProductKeyPath

	&#039; select on input
	strProductString = UCase(strProductString)
	Select Case strProductString
		Case &quot;AGENT&quot;
			strProductSubKey = &quot;McAfee\Agent&quot;	
		Case &quot;AVENGINE&quot;
			strProductSubKey = &quot;McAfee\AVEngine&quot;
		Case &quot;DESKTOPPROTECTION&quot;
			strProductSubKey = &quot;McAfee\DesktopProtection&quot;
		Case &quot;EPO&quot;
			strProductSubKey = &quot;McAfee\ePolicy Orchestrator&quot;
		Case &quot;HIPS&quot;
			strProductSubKey = &quot;McAfee\HIP&quot;
		Case &quot;HIPSCORE&quot;
			strProductSubKey = &quot;McAfee\HIPSCore&quot;
		Case &quot;MCTRAY&quot;
			strProductSubKey = &quot;McAfee\McTray&quot;					
		Case &quot;SITEADVISOR&quot;
			strProductSubKey = &quot;McAfee\SiteAdvisor Enterprise Plus&quot;
		Case &quot;SYSTEMCORE&quot;
			strProductSubKey = &quot;McAfee\SystemCore&quot;
		Case &quot;VSCORE&quot;
			strProductSubKey = &quot;McAfee\VSCore&quot;
		Case &quot;NAIEPO&quot;
			strProductSubKey = &quot;Network Associates\ePolicy Orchestrator&quot;
		Case &quot;NAITVD&quot;
			strProductSubKey = &quot;Network Associates\TVD&quot;
		Case Else
			strProductSubKey = False
	End Select
			
	Const HKLM = &amp;h80000002
	
    
	strRootSoftwareKeyNative = &quot;Software&quot;
	strRootSoftwareKeyWow64 = &quot;Software\Wow6432Node&quot;
    If Not strProductSubKey = False Then
	    &#039; Assume not in both places on a 64-bit machine
		If RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey
		ElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey
		End If
	Else
		strProductKeyPath = False		
	End If
	
	GetMcAfeeProductRegRootKey = strProductKeyPath

End Function &#039;GetMcAfeeProductRegRootKey

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
182,Active Directory,2015-01-05T20:22:03,",","Returns the SYSVOL size on Domain Controllers
Example: 2.2 GB",1,1155294592,0,361,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Domain Controller SYSVOL Size,,,,,,,,,Windows,"&#039;========================================
&#039; Domain Controller SYSVOL Size
&#039;========================================

Option Explicit

Dim strSharePath

strSharePath = GetPathForShare(&quot;sysvol&quot;)
If strSharePath = &quot;&quot; Then WScript.Quit

Dim objFSO,objFolder
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

Set objFolder = objFSO.GetFolder(strSharePath)

WScript.Echo GetPrettyFileSize(objFolder.Size)

Function GetPathForShare(strShareName)

	Dim objWMIService,colItems,objItem,strReturn
	
	On Error Resume Next &#039; could be permissions issues
	strReturn = &quot;&quot;
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Share&quot;,,48)

	For Each objItem in colItems
		If LCase(objItem.Name) = LCase(strShareName) Then
			strReturn = objItem.Path
		End If
	Next
	
	On Error Goto 0
	
	GetPathForShare = strReturn
	
End Function &#039;GetPathForShare	


Function GetPrettyFileSize(strSize)
Dim dblSize
	dblSize = CDbl(strSize)

	If dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB
		strSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;	
	ElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB
		strSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;
	ElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB
		strSize = CStr(Round(dblSize / 1024)) &amp; &quot; kB&quot;
	Else
		strSize = CStr(dblSize) &amp; &quot; B&quot;	
	End If	
	GetPrettyFileSize = strSize
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
183,Operating System,2015-01-05T20:22:03,",","Returns the current total number of disk IOPS currently occurring
Example: 86",1,1156943497,0,363,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Disk IOPS,,,,,,,,,Windows,"Option Explicit

Dim strComputer, objWMIService, objRefresher, objDiskDrive, colDiskDrives, driveName, sampleCount, counter, total

sampleCount = 6 &#039;number of datapoints to use for averaging result

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)

set objRefresher = CreateObject(&quot;WbemScripting.SWbemRefresher&quot;)
Set colDiskDrives = objRefresher.AddEnum _
    (objWMIService, &quot;Win32_PerfFormattedData_PerfDisk_LogicalDisk&quot;).objectSet
objRefresher.Refresh

total = 0
For Each objDiskDrive in colDiskDrives
	driveName = objDiskDrive.Name
	If driveName = &quot;_Total&quot; Then
		For counter = 1 To sampleCount
			objRefresher.Refresh
	    	total = total + objDiskDrive.DiskTransfersPerSec
	    	Wscript.Sleep 500
	    Next
	    WScript.Echo FormatNumber(total/sampleCount,0)
    End If 
Next

WScript.Quit",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
184,Network,2015-01-05T20:22:03,|,"Returns the names and speeds of all network connections.
Example: WAN Miniport (IP) | 10000",1,1206550580,0,365,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:03,Network Link Speed,,,,,,,,,Windows,"&#039;========================================
&#039; Network Link Speed
&#039;========================================

Option Explicit

Const cWMINameSpace = &quot;root/wmi&quot;
Const cWMIInstance = &quot;MSNdis_LinkSpeed&quot;
Const strComputerName = &quot;.&quot;

Dim strWinMgmts, objWMI, listAdapters, objAdapter,intLinkSpeed,strSep
strSep = &quot;|&quot;

strWinMgMts = &quot;winmgmts:{impersonationLevel=impersonate}!//&quot; &amp; strComputerName &amp; &quot;/&quot; &amp; cWMINameSpace
Set objWMI = GetObject(strWinMgMts)

If Err.Number &lt;&gt; 0 Then
WScript.Echo &quot;ERROR: Unable to connect to the WMI namespace.&quot;
Else
Set listAdapters = objWMI.InstancesOf(cWMIInstance)
If (listAdapters.count &gt; 0) Then
For Each objAdapter in listAdapters
If CDbl(objAdapter.NdisLinkSpeed) &lt; 0 Then
	intLinkSpeed = Abs(CDbl(objAdapter.NdislinkSpeed))
Else
	intLinkSpeed = CDbl(objAdapter.NdisLinkSpeed)
End If
WScript.Echo objAdapter.InstanceName &amp; strSep &amp; intLinkSpeed/10000
Next
Else
WScript.Echo &quot;WARNING: No adapters found.&quot;
End If
End IF",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Adapter Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Speed (Mbps),Numeric,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
185,Applications,2015-01-05T20:22:03,",","Returns the version of the Managed Applications DAT package received from Tanium.
Example:20121107.01",1,1211382204,0,367,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Managed Applications DAT Version,,,,,,,,,Windows,"&#039;========================================
&#039; Managed Applications DAT Version
&#039;========================================

Option Explicit
Dim strSep
strSep = &quot;|&quot;
Dim objFso, strXml, objFile
Const ForReading = 1
Set objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

Dim strDatPath, strCurrentDir, oShell
strDatPath = GetTaniumDir(&quot;Tools\Managed Applications&quot;) &amp; &quot;tanium.dat&quot;

Dim isDebug
isDebug = False 
If isDebug Then
	Set oShell = CreateObject(&quot;WScript.Shell&quot;)
	strCurrentDir = objFso.GetParentFolderName(Wscript.ScriptFullName)
	strDatPath = strCurrentDir &amp; &quot;\tanium.dat&quot;
	WScript.Echo strDatPath
End If 

If Not objFso.FileExists(strDatPath) Then
	WScript.Echo &quot;Cannot find DAT file&quot;
	WScript.Quit
End If
Set objFile = objFSO.OpenTextFile(strDatPath, ForReading)
strXml = objFile.ReadAll
objFile.Close

Dim xmlDoc

Set xmlDoc = CreateObject(&quot;Msxml2.DOMDocument&quot;)
xmlDoc.loadXml(strXml)

Dim strVersion
WScript.echo GetVersion(xmlDoc)

WScript.Quit


Function GetVersion(xmlDoc)
	Dim objList
	Set objList = xmlDoc.getElementsByTagName(&quot;dat-version&quot;)

	If objList.length &gt; 0 Then
		Dim objNode, strType
	
		&#039;Find first DAT version definition
		For Each objNode In objList
			GetVersion = objNode.text
		Next
	End If
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
186,Hardware,2015-01-05T20:22:03,",","Indicates the free RAM available to the operating system.
Example: 1024MB",1,1260624634,0,369,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Free Memory,,,,,,,,,Windows,"&#039;========================================
&#039; Free Memory
&#039;========================================

Option Explicit

Dim objWMIService, colItems, objItem, strLineAvailableMemory

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
 
&#039;Gets MEMORY Usage
Set colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)
For Each objItem In colItems  
 strLineAvailableMemory = objItem.AvailableMBytes
 wscript.echo strLineAvailableMemory &amp; &quot; MB&quot;
Next",VBScript,Linux,"#!/bin/bash
memLine=$(free -m | grep &quot;Mem&quot;)
set -- $memLine
echo $4 MB
",UnixShell,Mac,"#!/bin/bash

FREE_BLOCKS=$(vm_stat | grep free | awk &#039;{ print $3 }&#039; | sed &#039;s/\.//&#039;)
FREE=$((($FREE_BLOCKS+SPECULATIVE_BLOCKS)*4096/1048576))
echo $FREE MB
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
187,Operating System,2015-01-05T20:22:03,",","A list of accounts under which services are configured to run.  This list will not include the default accounts, including LocalSystem, LocalService, and NetworkService.
Example: .\\servuser",1,1271450145,0,371,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Service Login Names,,,,,,,,,Windows,select Startname from win32_service where (Startname &lt;&gt; &#039;LocalSystem&#039; AND Startname &lt;&gt; &#039;NT AUTHORITY\\LocalService&#039; AND Startname &lt;&gt; &#039;NT AUTHORITY\\NetworkService&#039; AND Startname &lt;&gt;  &#039;NT AUTHORITY\\LOCAL SERVICE&#039; AND Startname &lt;&gt; &#039;NT AUTHORITY\\NETWORK SERVICE&#039;),WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
188,Windows Event Logs,2015-01-05T20:22:03,",","Event identifier code for Security log events as shown in the Windows NT Event Viewer tool.
Example: 4648",1,1314534715,0,373,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Security Event Log IDs,,,,,,,,,Windows,select EventCode from Win32_NTLogEvent where LogFile = &#039;Security&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
189,Hardware,2015-01-05T20:22:03,",","Memory in use in MB from client machine.
Example: 6348 MB",1,1315630323,0,375,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Used Memory,,,,,,,,,Windows,"&#039;========================================
&#039; Used Memory
&#039;========================================

Option Explicit

Dim objWMIService, colItems, objItem, intTotalMemory, intAvailableMemory

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
 
&#039;Gets total memory
Set colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_Computersystem &quot;)
For Each objItem In colItems  
 intTotalMemory = Int(objItem.TotalPhysicalMemory / 1024 / 1024)
Next 
&#039;Gets available memory
Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)
For Each objItem In colItems  
 intAvailableMemory = objItem.AvailableMBytes
Next

&#039; We didn&#039;t use committed bytes here, because that is often bigger than total - available

WScript.Echo intTotalMemory - intAvailableMemory &amp; &quot; MB&quot;",VBScript,Linux,"#!/bin/bash
memLine=$(free -m | grep &quot;Mem&quot;)
set -- $memLine
echo $3 MB
",UnixShell,Mac,"#!/bin/bash

ACTIVE_BLOCKS=$(vm_stat | grep &quot;Pages active&quot; | awk &#039;{ print $3 }&#039; | sed &#039;s/\.//&#039;)
ACTIVE=$((($ACTIVE_BLOCKS+SPECULATIVE_BLOCKS)*4096/1048576))
echo $ACTIVE MB
",UnixShell,0,10,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
190,Hardware,2015-01-05T20:22:03,",","Returns printers connected to a system.
Example:HP LaserJet 4400c",1,1348043492,0,377,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Printers,,,,,,,,,Windows,Select DriverName from Win32_Printer,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
191,Operating System,2015-01-05T20:22:03,",","Name of the domain of the most recently logged in user.
Example: CORP",1,1348161929,0,379,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Default Login Domain,,,,,,,,,Windows,"&#039;========================================
&#039; Default Login Domain
&#039;========================================

Dim reg , strComputer
strComputer = &quot;.&quot;
Set reg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

strKeyPath = GetKeyPath()
&#039;strKeyPath = &quot;Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot;
strValueName = &quot;DefaultDomainName&quot; 

const HKEY_CURRENT_USER = &amp;H80000001
const HKEY_LOCAL_MACHINE = &amp;H80000002

On Error Resume Next
reg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue
If strValue &lt;&gt; &quot;&quot; Then
	Wscript.Echo strValue
Else
	Wscript.Echo &quot;Default Domain Not Set&quot;
End If

Function GetKeyPath()
	
	Dim key32path, key64path, keyPath
	key32Path = &quot;Software\Microsoft\Windows NT\CurrentVersion\Winlogon&quot;
	key64Path = &quot;Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Winlogon&quot;

	If RegKeyExists(reg , HKEY_LOCAL_MACHINE, key64Path) Then
		keyPath = key64Path
	ElseIf RegKeyExists(reg , HKEY_LOCAL_MACHINE, key32Path) Then
		keyPath = key32Path
	End If
	GetKeyPath = keyPath
End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
192,File System,2015-01-05T20:22:03,",","Finds the specified folder and provides the full path if the folder exists on the client machine. Takes regular expression to match.
Example: C:\WINDOWS\System32",1,1374547302,0,381,1,Jim Olsen,600,0,defined,McAfee,2015-01-05T20:22:03,Folder Name Search with RegEx Match,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the folder name to search for"",""value"":"""",""promptText"":""e.g Program Files"",""defaultValue"":"""",""label"":""Search for Folder Name"",""maxChars"":0,""key"":""dirname"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the regular expression to search for."",""value"":"""",""promptText"":""e.g. test*.exe"",""defaultValue"":"""",""label"":""Regular Expression"",""maxChars"":0,""key"":""regexp"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""helpString"":""Enter Yes/No for case sensitivity of search."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Case sensitive?"",""key"":""casesensitive"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""},{""helpString"":""Enter Yes/No whether the search is global."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Global"",""key"":""global"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Folder Name Search with RegEx Match
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit

SensorRandomize()

Dim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg
Dim bGlobal,bCaseSensitive

Pattern = unescape(&quot;||dirname||&quot;)
strRegExp = Trim(Unescape(&quot;||regexp||&quot;))
strGlobalArg = Trim(Unescape(&quot;||global||&quot;))
strCaseSensitiveArg = Trim(Unescape(&quot;||casesensitive||&quot;))

bGlobal = GetTrueFalseArg(&quot;global&quot;,strGlobalArg)
bCaseSensitive = GetTrueFalseArg(&quot;casesensitive&quot;,strCaseSensitiveArg)

Const SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1

Dim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine

Set FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set WshShell = CreateObject(&quot;WScript.Shell&quot;)

OutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir

&#039; Go through file system, refresh output file for filename
If Not FSO.FileExists(OutputFilename) Then
	
	If FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename

	&#039; Get the collection of local drives.
	Set Drives = FSO.Drives
	For Each Drive in Drives
		If Drive.DriveType = 2 Then &#039; 2 = Fixed drive
			&#039; Run the Dir command that looks for the filename pattern.
			RunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:D /B /S&quot;, OutputFilename, true
		End If
	Next
End If

&#039; Open the output file, echo each line, and then close and delete it.
Set TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)
Do While Not TextStream.AtEndOfStream
	strLine = TextStream.ReadLine()
	If RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then
		WScript.Echo strLine
	End If
Loop


TextStream.Close()
 
If FSO.FileExists(OutputFileName) Then
	On Error Resume Next
	FSO.DeleteFile OutputFileName, True
	On Error Goto 0
End If

Function RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)

	Dim re
	Set re = New RegExp
	With re
	  .Pattern = strPattern
	  .Global = bGlobal
	  .IgnoreCase = Not bIsCaseSensitive
	End With
	
	RegExpMatch = re.Test(strToMatch)

End Function &#039;RegExpMatch


Function GetTrueFalseArg(strArgName,strArgValue)
	&#039; Checks for valid values, will fail with error message
	
	Dim bArgVal
	bArgVal = False
	Select Case LCase(strArgValue)
		Case &quot;true&quot;
			bArgVal = True
		Case &quot;yes&quot;
			bArgVal = True
		Case &quot;false&quot;
			bArgVal = False
		Case &quot;no&quot;
			bArgVal = False
		Case Else
			WScript.Echo &quot;Error: Argument &#039;&quot;&amp;strArgName&amp;&quot;&#039; must be True or False, quitting&quot;
			PrintUsage
	End Select
	GetTrueFalseArg = bArgVal

End Function &#039;GetTrueFalseArg


&#039; Returns the name of a temporary file in the Temp directory.
Function TempName()
	Dim Result
	Do
 		Result = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())
		WScript.Sleep 200 &#039;avoid potential busy loop
	Loop While FSO.FileExists(Result)
	
	TempName = Result
End Function &#039;TempName

&#039; Runs a command with Cmd.exe and redirects its output to a temporary
&#039; file. The function returns the name of the temporary file that holds
&#039; the command&#039;s output.
Function RunCommand(Command, OutputFilename, b64BitNecessary)
	&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32
	Dim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set WshShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strDOSCall = &quot;%ComSpec% /C &quot;
	
	&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection
	strProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)
	If objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64
		strDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))
	End If
		
	CommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)
	WshShell.Run CommandLine, 0, True
End Function &#039;RunCommand

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
			strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
			strFilePath = strNewSystem32Location&amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/bash
#||dirname||||regexp||||casesensitive||||global||
echo Windows Only
",UnixShell,Mac,"#!/bin/bash
#||dirname||||regexp||||casesensitive||||global||
echo Windows Only
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
193,Operating System,2015-01-05T20:22:03,|,"A list of programs configured to automatically run on the client machine.  Also includes the command line entry to run the program.
Example: Windows Mobile Device Center | C:\Windows\WindowsMobile\wmdc.exe",1,1404374135,0,383,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Startup Programs,,,,,,,,,Windows,"&#039;========================================
&#039; Startup Programs
&#039;========================================

&#039; This sensor will return values from the 32-bit and 64-bit areas of the
&#039; registry that defines auto-run programs.
&#039; This is a multi-column sensor that has output that looks like:
&#039; Name|Command Line

Option Explicit

Dim strSep

strSep = &quot;|&quot;

GetAutoRunPrograms strSep

Function GetAutoRunPrograms(strSep)
&#039; This function will output the two values

	Const HKLM = &amp;h80000002
	
	Dim strComputer, strStartupRegPath, strStartupWow64RegPath
	Dim objRegistry, strFinalOutputString
	
	strStartupRegPath = &quot;Software\Microsoft\Windows\CurrentVersion\Run&quot;
	strStartupWow64RegPath = &quot;Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run&quot;
	
	strFinalOutputString = &quot;&quot;
	Set objRegistry = Getx64RegistryProvider()
	If RegKeyExists(HKLM, strStartupRegPath, objRegistry) Then	
		strFinalOutputString = GetValues(objRegistry, HKLM, strStartupRegPath)
	End If
	If Not strFinalOutputString = &quot;&quot; Then
		strFinalOutputString = strFinalOutputString &amp; vbCrLf
	End If
	If RegKeyExists(HKLM, strStartupWow64RegPath, objRegistry) Then
		strFinalOutputString = strFinalOutputString _ 
			&amp; GetValues(objRegistry, HKLM, strStartupWow64RegPath)
	End If
	
	WScript.Echo strFinalOutputString
End Function &#039;GetAutoRunPrograms

Function GetValues(objRegistry, hiveConst, keyPath)

	Dim arrKeyNames, arrTypes, arrValueNames, strValueName
	Dim strValueData, i, strOutputString
		
	objRegistry.EnumValues hiveConst, keyPath, arrValueNames, arrTypes
	
	If Not IsArray(arrValueNames) Then
		arrValueNames = Array(&quot;&quot;)
		arrTypes = Array(1)
	End If
	
	strOutputString = &quot;&quot;
	For i = LBound(arrValueNames) To UBound(arrValueNames)
		strValueName = arrValueNames(i)
		strValueData = GetRegValue(objRegistry, hiveConst, keyPath, strValueName, arrTypes(i))
		If Not ( IsNull(strValueName) Or IsNull(strValueData) ) Then
			If i = UBound(arrValueNames) Then
				strOutputString = strOutputString &amp; strValueName &amp; strSep &amp; strValueData
			Else
				strOutputString = strOutputString &amp; strValueName &amp; strSep &amp; strValueData &amp; vbCrLf
			End If
		End If
	Next	
	GetValues = strOutputString
End Function &#039;GetValues

Function GetRegValue(objRegistry, hiveConst, keyPath, strValueName, constType)

	Const REG_SZ        = 1
	Const REG_EXPAND_SZ = 2
	Const REG_BINARY    = 3
	Const REG_DWORD     = 4
	Const REG_MULTI_SZ  = 7
	Const REG_QWORD     = 11

	Dim strValue, arrBytes, uValue, arrValues

	Select Case constType
		Case REG_SZ  
			objRegistry.GetStringValue hiveConst, keyPath, strValueName, strValue
			GetRegValue =  strValue
			Exit Function
		Case REG_EXPAND_SZ
			objRegistry.GetExpandedStringValue hiveConst, keyPath, strValueName, strValue
			GetRegValue =  strValue
			Exit Function
		Case REG_BINARY
			objRegistry.GetBinaryValue hiveConst, keyPath, strValueName, arrBytes
			strBytes = &quot;&quot;
			For Each uByte in arrBytes
				strBytes = strBytes &amp; Hex(uByte) &amp; &quot; &quot;
			Next
			GetRegValue =  strBytes
			Exit Function
		Case REG_DWORD
			objRegistry.GetDWORDValue hiveConst, keyPath, strValueName, uValue
			GetRegValue =  CStr(uValue)				  
			Exit Function
		Case REG_QWORD
			objRegistry.GetQWORDValue hiveConst, keyPath, strValueName, uValue
			GetRegValue =  CStr(uValue)				  
			Exit Function
		Case REG_MULTI_SZ
			objRegistry.GetMultiStringValue hiveConst, keyPath, strValueName, arrValues				  				
			For Each strValue in arrValues
				GetRegValue =  strValue 
			Next
			Exit Function
	End Select
End Function &#039;GetRegValue

Function RegKeyExists(sHive, sRegKey, objReg)
	Dim aValueNames, aValueTypes
	If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Command Line,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
194,McAfee,2015-01-05T20:22:03,",","This sensor will return the version of an activated McAfee Endpoint Encryption install
Example: 7.0",1,1450323545,0,385,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,McAfee Endpoint Encryption Activated Version,,,,,,,,,Windows,"&#039;========================================
&#039; McAfee Endpoint Encryption Activated Version
&#039;========================================

&#039; This sensor will return the version of an
&#039; activated McAfee Endpoint Encryption install
&#039; This is a numeric value, a version number

Option Explicit

Dim objRegistry,keyPath,key64Path,strSep
strSep = &quot;|&quot; &#039; column delimiter

Set objRegistry = Getx64RegistryProvider()

Const HKLM = &amp;H80000002

keyPath = &quot;SOFTWARE\McAfee Endpoint Encryption\MfeEpePC\Status&quot;
key64Path = &quot;SOFTWARE\Wow6432Node\McAfee Endpoint Encryption\MfeEpePC\Status&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If

If RegKeyExists(HKLM, keyPath) Then
	Dim strReturn
	strReturn = ReturnStringValueOrEchoError _
		(objRegistry,HKLM,keyPath,&quot;ActivatedVersion&quot;,&quot;McAfee Endpoint Encryption Activation Version Not Found&quot;)
	If VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error
		WScript.Echo strReturn
	Else
		WScript.Quit
	End If
Else
	WScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;
	WScript.Quit
End If

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)
&#039; Return a value or fatal error message and error result
	Dim intReturn,strValueData
	intReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)
	If intReturn = 0 Then
		ReturnStringValueOrEchoError = strValueData
	Else
		ReturnStringValueOrEchoError = -1
		WScript.Echo strErrorMessage
	End If
End Function 

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
195,Network,2015-01-05T20:22:03,",","The addresses of the configured DHCP servers, If a machine is on DHCP.
Example: 192.168.1.1",1,1471370561,0,387,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,DHCP Server,,,,,,,,,Windows,select DHCPServer from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
196,Applications,2015-01-05T20:22:03,",",Returns the full versions numbers of all installed .NET.,1,1496471156,0,389,1,Jim Olsen,7200,,,,2015-01-05T20:22:03,NET Version,,,,,,,,,Windows,"&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;
&#039;  .NET Version
&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;
&#039; This sensor returns the highest .NET Version installed on the endpoint

Option Explicit

Dim strComputer, strKeyPath10, strKeyPath11, strkeyPath20, strKeyPath30, strKeyPath35, strKeyPath40, strkeyPath4c, strKeyPath45, objRegistry, strValueName, strValue, strNoNET, strValue10, strValue11, strValue20, strValue30, strValue35, strValue40, strValue4C, strValue45, byPass4c, byPass40
Const HKEY_LOCAL_MACHINE = &amp;H80000002
strComputer = &quot;.&quot;

strKeyPath10 = &quot;SOFTWARE\Microsoft\NET Framework Setup\NDP\v1.0.3705\&quot;
strKeyPath11 = &quot;SOFTWARE\Microsoft\NET Framework Setup\NDP\v1.1.4322\&quot;
strKeyPath20 = &quot;SOFTWARE\Microsoft\NET Framework Setup\NDP\v2.0.50727\&quot;
strKeyPath30 = &quot;SOFTWARE\Microsoft\NET Framework Setup\NDP\v3.0\&quot;
strKeyPath35 = &quot;SOFTWARE\Microsoft\NET Framework Setup\NDP\v3.5\&quot;
strKeyPath40 = &quot;SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full\&quot;
strKeyPath4C = &quot;SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Client\&quot;
strKeyPath45 = &quot;Software\Microsoft\NET Framework Setup\NDP\v4\Full\&quot;

Set objRegistry = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

strValue = NULL

&#039;Find existence of .NET1.0
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath10, strValueName, strValue10
If IsNull(strValue10) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	strValue = strValue10
End If

&#039;Find existence of .NET1.1
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath11, strValueName, strValue11
If IsNull(strValue11) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	strValue = strValue11
End If

&#039;Find existence of .NET2.0
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath20, strValueName, strValue20
If IsNull(strValue20) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	strValue = strValue20
End If

&#039;Find existence of .NET3.0
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath30, strValueName, strValue30
If IsNull(strValue30) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	strValue = strValue30
End If

&#039;Find existence of .NET3.5
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath35, strValueName, strValue35
If IsNull(strValue35) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	strValue = strValue35
End If

&#039;Find existence of .NET4.0 Client Version - but only if .NET4.0 Full Version Not Found
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath4C, strValueName, strValue4C
If IsNull(strValue4C) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	strValue = strValue4C
End If

&#039;Find existence of .NET4.0 and Bypass test for .NET4.0 Client if Found
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath40, strValueName, strValue40
If IsNull(strValue40) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	strValue = strValue40
End If

&#039;Find existence of .NET4.5 Client Version
strValueName = &quot;Version&quot;
objRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath45, strValueName, strValue45
If IsNull(strValue45) Then
	strNoNet = &quot;.NET not installed&quot;
Else
	If InStr(strValue45, &quot;4.5.&quot;) &gt; 0 Then
		strValue = strValue45
	End If
End If

If IsNull(strValue)Then
	WScript.Echo strNoNet
Else
	WScript.Echo strValue
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
197,Hardware,2015-01-05T20:22:03,",","Returns the name of any device which is built into the motherboard.
Example: ES1371",1,151176619,0,391,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Onboard Devices,,,,,,,,,Windows,select Description from Win32_OnBoardDevice,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
198,Registry,2015-01-05T20:22:03,",","Returns True if the Registry Value exists, False if not.",1,1512811088,0,393,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,Registry Key Value Exists,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{5}"",""helpString"":""Value must be at least 5 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the key path to query"",""value"":"""",""promptText"":""e.g. HKEY_LOCAL_MACHINE\\Software\\Microsoft"",""defaultValue"":"""",""label"":""Registry Key"",""maxChars"":0,""key"":""strKey"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the key value to query"",""value"":"""",""promptText"":""e.g. Version"",""defaultValue"":"""",""label"":""Registry Value"",""maxChars"":0,""key"":""strValue"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Registry Value Exists
&#039;========================================

&#039;Columns:
&#039; User | Data | Type | Architecture | KeyPath | Value

&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)

strKey = unescape(&quot;||strKey||&quot;)
strValue = unescape(&quot;||strValue||&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client&quot;
&#039;strValue = &quot;ServerPort&quot;

&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;
&#039;strValue = &quot;Emailname&quot;
strSep = &quot;~~&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = ValueExists(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = ValueExists(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If


If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = ValueExists(objReg, objCTX, constHive, strKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive
		hasValues64 = ValueExists(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True
	End If
End If

If (hasAnyResult) Then
	WScript.Echo &quot;True&quot;
Else
	WScript.Echo &quot;False&quot;
End If

&#039;Goes through all values in a key, returns True if strValue is found
Function ValueExists(objReg, objCtx, constHive, strKey, strValue, intBit)

	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames
	arrTypes = Outparams.Types

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			
			&#039;if strValue is found, echo
			If LCase(strValueName) = LCase(strValue) Then
				ValueExists = True
				Exit Function
			End If
		Next
	End If
	ValueExists = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit)
	If intBit = 64 Then
		strArch = &quot;64-bit&quot;
	Else
		strArch = &quot;32-bit&quot;
	End If
			
	GetDisplayString = _
		strValue &amp; strSep &amp; _
		strType &amp; strSep &amp; _
		strArch
End Function

Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\Software\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  ||strValue||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\Software\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  ||strValue||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
199,Patch,2015-01-05T20:22:03,",","Gives the last install time of any patch applied via Tanium.
Example: 09/18/2012",1,151391351,0,395,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Last Tanium Patch Install Time,,,,,,,,,Windows,"&#039;========================================
&#039; Last Tanium Patch Install Time
&#039;========================================

&#039; sensor - Last Tanium Patch Install Time
&#039; This sensor will output the date modified for installresultsreadable.txt

Option Explicit

SetLocale(1033) &#039; Required for RFC822
Dim strBias : strBias = GetRFC822Bias

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, dtmDateModified
strSep = &quot;|&quot;

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\installedresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	On Error Resume Next
	dtmDateModified = CDate(objFSO.GetFile(fn).DateLastModified)
	WScript.Echo vbTimeToRFC822(CStr(dtmDateModified), strBias)
	If Err.Number &lt;&gt; 0 Then
		WScript.Echo &quot;Error: Could not interpret date format of file&quot;
	End If
Else
   Wscript.echo &quot;Tanium patch install history output not found&quot;
End If

WScript.Quit()

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

&#039; --- Begin Time Functions --- &#039;
Function vbTimeToRFC822(myDate, offset)
&#039;SetLocale outside of function in global scope
&#039; must be set so that month is displayed with US/English abbreviations
&#039; as per the standard

	If Not GetLocale = 1033 Then
		WScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;
		WScript.Quit
	End If
   Dim myDay, myDays, myMonth, myYear
   Dim myHours, myMinutes, myMonths, mySeconds

   myDate = CDate(myDate)
   myDay = WeekdayName(Weekday(myDate),true)
   myDays = zeroPad(Day(myDate), 2)
   myMonth = MonthName(Month(myDate), true)
   myYear = Year(myDate)
   myHours = zeroPad(Hour(myDate), 2)
   myMinutes = zeroPad(Minute(myDate), 2)
   mySeconds = zeroPad(Second(myDate), 2)

   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _
                                  myDays&amp;&quot; &quot;&amp; _
                                  myMonth&amp;&quot; &quot;&amp; _ 
                                  myYear&amp;&quot; &quot;&amp; _
                                  myHours&amp;&quot;:&quot;&amp; _
                                  myMinutes&amp;&quot;:&quot;&amp; _
                                  mySeconds&amp;&quot; &quot;&amp; _ 
                                  offset
End Function &#039;vbTimeToRFC822


Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function

Function GetRFC822Bias
&#039; This function returns a string which is a 
&#039; timezone bias for RFC822 format
&#039; considers daylight savings
&#039; we choose 4 digits and a sign (+ or -)

	Dim objWMIService,colTimeZone,objTimeZone
	
	Dim intTZBiasInMinutes,strSign,strReturnString

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
	 
	For Each objTimeZone in colTimeZone
	    intTZBiasInMinutes = objTimeZone.CurrentTimeZone
	Next

	&#039; The offset is explicitly signed
	If intTZBiasInMinutes &lt; 0 Then
		strSign = &quot;-&quot;
	Else
		strSign = &quot;+&quot;
	End If
	
	strReturnString = CStr(Abs(intTZBiasInMinutes))
	&#039; no offset is greater than three digits but RFC822 bias seems to
	&#039; usually take the form of 1 alpha / 4 digit as described as 
	&#039; valid in ANSI X3.51-1975

	strReturnString = zeroPad(strReturnString,4)

	GetRFC822Bias = strSign&amp;strReturnString
	
	&#039;Cleanup
	Set colTimeZone = Nothing
	Set objWMIService = Nothing
	
End Function &#039;GetRFC822Bias

&#039; --- End Time Functions --- &#039;",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,BESDate
200,Patch,2015-01-05T20:22:03,",","Gives the last Tanium patch scan time.
Example: 09/18/2012",1,3708414887,0,397,1,Jim Olsen,60,0,defined,Tanium,2015-01-05T20:22:03,Last Tanium Patch Scan Time,,,,,,,,,Windows,"&#039;========================================
&#039; Last Tanium Patch Scan Time
&#039;========================================

&#039; sensor - Last Tanium Patch Scan Time
&#039; This sensor will output the date modified for Scanresultsreadable.txt

Option Explicit

SetLocale(1033) &#039; Required for RFC822
Dim strBias : strBias = GetRFC822Bias

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, dtmDateModified
strSep = &quot;|&quot;

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\patchresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	On Error Resume Next
	dtmDateModified = CDate(objFSO.GetFile(fn).DateLastModified)
	WScript.Echo vbTimeToRFC822(CStr(dtmDateModified), strBias)
	If Err.Number &lt;&gt; 0 Then
		WScript.Echo &quot;Error: Could not interpret date format of file&quot;
	End If
Else
   Wscript.echo &quot;Tanium patch scan output not found&quot;
End If

WScript.Quit()

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

&#039; --- Begin Time Functions --- &#039;
Function vbTimeToRFC822(myDate, offset)
&#039;SetLocale outside of function in global scope
&#039; must be set so that month is displayed with US/English abbreviations
&#039; as per the standard

	If Not GetLocale = 1033 Then
		WScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;
		WScript.Quit
	End If
   Dim myDay, myDays, myMonth, myYear
   Dim myHours, myMinutes, myMonths, mySeconds

   myDate = CDate(myDate)
   myDay = WeekdayName(Weekday(myDate),true)
   myDays = zeroPad(Day(myDate), 2)
   myMonth = MonthName(Month(myDate), true)
   myYear = Year(myDate)
   myHours = zeroPad(Hour(myDate), 2)
   myMinutes = zeroPad(Minute(myDate), 2)
   mySeconds = zeroPad(Second(myDate), 2)

   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _
                                  myDays&amp;&quot; &quot;&amp; _
                                  myMonth&amp;&quot; &quot;&amp; _ 
                                  myYear&amp;&quot; &quot;&amp; _
                                  myHours&amp;&quot;:&quot;&amp; _
                                  myMinutes&amp;&quot;:&quot;&amp; _
                                  mySeconds&amp;&quot; &quot;&amp; _ 
                                  offset
End Function &#039;vbTimeToRFC822


Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function

Function GetRFC822Bias
&#039; This function returns a string which is a 
&#039; timezone bias for RFC822 format
&#039; considers daylight savings
&#039; we choose 4 digits and a sign (+ or -)

	Dim objWMIService,colTimeZone,objTimeZone
	
	Dim intTZBiasInMinutes,strSign,strReturnString

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
	 
	For Each objTimeZone in colTimeZone
	    intTZBiasInMinutes = objTimeZone.CurrentTimeZone
	Next

	&#039; The offset is explicitly signed
	If intTZBiasInMinutes &lt; 0 Then
		strSign = &quot;-&quot;
	Else
		strSign = &quot;+&quot;
	End If
	
	strReturnString = CStr(Abs(intTZBiasInMinutes))
	&#039; no offset is greater than three digits but RFC822 bias seems to
	&#039; usually take the form of 1 alpha / 4 digit as described as 
	&#039; valid in ANSI X3.51-1975

	strReturnString = zeroPad(strReturnString,4)

	GetRFC822Bias = strSign&amp;strReturnString
	
	&#039;Cleanup
	Set colTimeZone = Nothing
	Set objWMIService = Nothing
	
End Function &#039;GetRFC822Bias

&#039; --- End Time Functions --- &#039;",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,BESDate
201,Operating System,2015-01-05T20:22:03,",","Indicates whether a screen saver is enabled on the client machine.
Example: True",1,1526750078,0,399,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Screen Saver Active,,,,,,,,,Windows,"&#039;========================================
&#039; Screen Saver Active
&#039;========================================

&#039; This sensor will report on whether the screen saver is active

Option Explicit

WScript.Echo GetScreenSaverActive

Function GetScreenSaverActive
	
	Dim objWMIService, colDesktops
	Dim strComputer, objDesktop, bIsActive
	
	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
		&amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;) 

	Set colDesktops = objWMIService.ExecQuery _ 
		(&quot;Select ScreenSaverActive from Win32_Desktop&quot;) 
	If Not IsNull(colDesktops) Then
		For Each objDesktop In colDesktops	
			bIsActive = objDesktop.ScreenSaverActive
		Next
		If bIsActive Then
			GetScreenSaverActive = &quot;True&quot;
		Else
			GetScreenSaverActive = &quot;False&quot;
		End If
	Else
		GetScreenSaverActive = &quot;WMI Error&quot;
	End If
	
	&#039;Cleanup
	Set colDesktops = Nothing
	Set objWMIService = Nothing
End Function &#039;GetScreenSaverActive",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
202,Network,2015-01-05T20:22:03,|,"Any established connections currently being made.  This multi-column Sensor displays the process responsible for the connection, the display name of the process (if available), and the target IP Address and port.  Processes and IP ranges can be excluded in the Sensor definition.
Example: chrome.exe | Google Chrome | 173.194.79.99:80",1,1528412180,0,401,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:03,Established Connections,,,,,,,,,Windows,"&#039;========================================
&#039; Established Connections
&#039;========================================

showProcess = True
showPort = True
showDNSName = False

Dim strcommand, results, excludeProcesses, excludeSubnets, taniumDebug
Dim strSep : strSep = &quot;|&quot;
&#039; This is a multi-column sensor that looks like:
&#039;Process|Name|Target IP

excludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;
&#039;excludeProcesses = &quot;chrome.exe&quot;
&#039;excludeProcesses = &quot;iexplore.exe&quot;
&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;
&#039;excludeProcesses = &quot;trillian.exe&quot;

excludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;
&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;

taniumDebug = False


excludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)
excludeSubnets = Split(excludeSubnets, &quot;,&quot;)

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
query = &quot;select name, executablepath, processId from win32_process&quot;
Set colResults = objWMIService.ExecQuery(query)

&#039;dictionary for process-app pairs
Set processes = CreateObject(&quot;Scripting.Dictionary&quot;)

For Each result In colResults 
	processId = CStr(result.ProcessId)
	processPath = result.ExecutablePath
	processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later
Next

strcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; Chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find &quot; &amp; Chr(34) &amp; &quot;ESTABLISHED&quot; &amp; Chr(34)

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strPingResults = LCase(objScriptExec.StdOut.ReadAll)

results = Split(strPingResults, vbCrLf)
j = 0

For Each line In results
	line = cleanWhitespace(Trim(line))
	
	If line &lt;&gt; &quot;&quot; Then 
		lineResults = Split(line)
		i = 0
		Dim strPort, strPid, strConnectionType, strForeignIp, strApp
		For Each word In lineResults
			If i = 1 Then
				strPort = word
			ElseIf i = 2 Then
				strForeignIp = word
			ElseIf i = 3 Then
				strConnectionType = word
			ElseIf i = 4 Then
				strPid = word
			End If
			
			i = i + 1
		Next
		
		&#039;DO NOT INCLUDE EXCLUDED APPS
		strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path
		arrAppEntry = Split(strAppEntry,&quot;,&quot;)
		strAppExe = arrAppEntry(0)
		strAppPath = arrAppEntry(1)
		
		isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))
		
		&#039;DO NOT INCLUDE EXCLUDED SUBNETS
		isNotExcludedSubnet = Not(ContainedInSubnet(strForeignIp, excludeSubnets))
		
		If Not(IsEmpty(strAppExe)) _
			And isNotExcludedApp _ 
			And isNotExcludedSubnet Then
			
			If Not showPort Then 
				arrTemp = Split(strForeignIp, &quot;:&quot;)
				strForeignIp = arrTemp(0)
			End If
			
			If showDNSName Then
				arrTemp = Split(strForeignIp, &quot;:&quot;)
				strForeignIp = ReverseDNSLookup(arrTemp(0))
				If UBound(arrTemp) &gt;=1 Then 
					strForeignIp = strForeignIp &amp; &quot;:&quot; &amp; arrTemp(1)
				End If
			End If 
			
			If showProcess Then
				results(j) = strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIp
			Else
				results(j) = strSep &amp; strSep &amp; strForeignIp
			End If	
		Else
			If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp
			results(j) = &quot;&quot;   
		End If 
		
		j = j + 1
	End If
Next

results = RemDups(results)

If UBound(results) &lt; 1 Then
	If GetLocale() &lt;&gt; 1033 Then
		WScript.Echo &quot;English Language OS Required&quot;
	End If
End If
 
For Each result In results 
	WScript.Echo result
Next

WScript.Quit

Function ReverseDNSLookup(strIPAddress)
	ReverseDNSLookup = strIPAddress	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	Set objExecCommand = objShell.Exec(&quot;%comspec% /c nslookup &quot; &amp; strIPAddress)
	
	strResults = objExecCommand.StdOut.ReadAll
	
	If InStr(strResults, &quot;Name:&quot;) Then
		arrNameTemp = Split(strResults, &quot;Name:&quot;)
		arrName = Split(Trim(arrNameTemp(1)), Chr(13))
		
		ReverseDNSLookup = arrName(0)
	End If	
End Function

Function ContainedInSubnet(str, arr)
	Dim strIp, strSubnet, strMask
	temp = Split(str, &quot;:&quot;)
	strIp = temp(0)
	
	For Each item In arr
		If InStr(item, &quot;-&quot;) Then &#039;Subnet range
			temp = Split(item, &quot;-&quot;)
			lower = Split(temp(0), &quot;:&quot;)
			upper = Split(temp(1), &quot;:&quot;)
			lowerSubnet = Trim(lower(0))
			lowerMask = Trim(lower(1))
			upperSubnet = Trim(upper(0))
			upperMask = Trim(upper(1))
			
			If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _
				And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then
				ContainedInSubnet = True
				Exit Function
			End If 
		Else &#039;Single subnet
			parts = Split(item, &quot;:&quot;)
			strSubnet = Trim(parts(0))
			strMask = Trim(parts(1))
			If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then
				ContainedInSubnet = True
				Exit Function
			End If
		End If 
	Next
	ContainedInSubnet = False
End Function

Function ContainedInArray(str, arr)
	For Each item In arr 
		If str = Trim(item) Then
			ContainedInArray = True
			Exit Function
		End If   
	Next
	ContainedInArray = False
End Function

Function cleanWhitespace(strStarter)
	intStarter = Len(strStarter)
	For i = intStarter To 2 Step -1
		strChars = Space(i)
		strStarter = Replace(strStarter, strChars, &quot; &quot;)
	Next
	cleanWhitespace = strStarter
End Function

Function RemDups(ByVal anArray)
	Dim d, item, thekeys
	Set d = CreateObject(&quot;Scripting.Dictionary&quot;)
	d.removeall
	d.CompareMode = 0
	For Each item In anArray
		If Len(item) &gt; 0 Then
			If Not d.Exists(item) Then d.Add item, item
		End If
	Next
	thekeys = d.keys
	Set d = Nothing
	RemDups = thekeys
End Function

Function Subnet(strAddress, strMask)
	intSubnetLength = SubnetLength(strMask)
	Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))
End Function

Function SubnetLength(strMask)
	strMaskBinary = StringToBinary(strMask)
	SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))
End Function

Function BinaryToString(strBinary)
	For intOctetPos = 1 To 4
		strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)
		intOctet = 0
		intValue = 1
		For intBinaryPos = 1 To Len(strOctetBinary)
			If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue
			intValue = intValue * 2
		Next
		If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)
	Next
End Function

Function StringToBinary(strAddress)
	objAddress = Split(strAddress, &quot;.&quot;, -1)
	For Each strOctet In objAddress
		intOctet = CInt(strOctet)
		strOctetBinary = &quot;&quot;
		For x = 1 To 8
			If intOctet Mod 2 &gt; 0 Then
				strOctetBinary = &quot;1&quot; &amp; strOctetBinary
			Else
				strOctetBinary = &quot;0&quot; &amp; strOctetBinary
			End If
			intOctet = Int(intOctet / 2)
		Next
		StringToBinary = StringToBinary &amp; strOctetBinary
	Next
End Function

Function ProcessNameToApplicationName(strExecutablePath, strExecutableName)
	&#039; This function will return the full application name of a running executable
	
	Dim fso
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	arrPathParts = Split(strExecutablePath,&quot;\&quot;)
	
	If UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process
		ProcessNameToApplicationName = strExecutableName
		Set fso = Nothing
		Exit Function
	End If
	strExecutable = arrPathParts(UBound(arrPathParts))
	
	If fso.FileExists(strExecutablePath) Then
		Dim strOutput, fileVersion, fileVersionOutput, fullName
		
		Set execFile = fso.GetFile(strExecutablePath)
		fullName = GetDescription(execFile.ParentFolder.Path, strExecutable)
		If Not fullName = &quot;&quot; Then
			ProcessNameToApplicationName = fullName
		Else
			ProcessNameToApplicationName = strExecutableName
		End If
	Else &#039; file doesn&#039;t exist or inaccessible
		ProcessNameToApplicationName = strExecutableName
	End If
	
End Function &#039;ProcessNameToApplicationName

Function GetDescription(folderPath, fileName)
	descIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)
	If IsEmpty(descIndex) Then
		descIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)
	End If
	GetDescription = GetFileProperty(folderPath, fileName, descIndex)
End Function

Function GetFileProperty(folderPath, fileName, fileProperty)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	GetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)
End Function

Function GetAttributeIndex(folderPath, attrTarget)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	For i = 0 To 50
		attrName = objFolder.GetDetailsOf(objFolder.Items, i)
		If LCase(attrName) = LCase(attrTarget) Then
			GetAttributeIndex = i
			Exit Function
		End If
	Next
	
End Function",VBScript,Linux,"#!/bin/sh

tmpfile=&quot;/tmp/tanium.$$&quot;
lsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n  &gt; $tmpfile
cat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($0,index($0,&quot;&gt;&quot;)+1,index($0,&quot; (ESTABLISHED)&quot;)-(index($0,&quot;&gt;&quot;)+1))}&#039;
rm -f $tmpfile
",UnixShell,Mac,"#!/bin/sh

tmpfile=&quot;/tmp/tanium.$$&quot;
lsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n  &gt; $tmpfile
cat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($0,index($0,&quot;&gt;&quot;)+1,index($0,&quot; (ESTABLISHED)&quot;)-(index($0,&quot;&gt;&quot;)+1))}&#039;
rm -f $tmpfile
",UnixShell,0,0,0,1,0,Process,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Name,String,0,1,2,Target IP,IPAddress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
203,Operating System,2015-01-05T20:22:03,",","Returns the directory the Operating System boots from.
Example:\\Windows",1,1544486184,0,403,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:03,Operating System Boot Directory,,,,,,,,,Windows,select BootDirectory from win32_BootConfiguration,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
204,Hardware,2015-01-05T20:22:03,",","Returns a list of USB devices currently plugged in to the client machine.
Example: HID Keyboard Device",1,15451865,0,405,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:03,USB Device,,,,,,,,,Windows,select Caption from Win32_PnPEntity where (Status=&#039;OK&#039; and DeviceID like &#039;%HID%&#039;),WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
205,Hardware,2015-01-05T20:22:04,",","Name of sound card in client machine.
Example: SoundMAX Integrated Digital HD Audio",1,1579270802,0,407,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Sound Card,,,,,,,,,Windows,select Name from Win32_SoundDevice,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
206,Hardware,2015-01-05T20:22:04,",","Manufacturer or vendor of the BIOS.
Example: Dell, Inc.",1,1580351176,0,409,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,BIOS Vendor,,,,,,,,,Windows,select Manufacturer from win32_BIOS,WMIQuery,Linux,"#!/bin/bash
dmidecode -s bios-vendor
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
207,Operating System,2015-01-05T20:22:04,",","Returns share names of network shares which are mapped locally.
Example: \\\\server\\share",1,1582126011,0,411,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Mapped Drives,,,,,,,,,Windows,"&#039;========================================
&#039; Mapped Drives
&#039;========================================
&#039;

Option Explicit

Dim dictBlacklist, objWMIService, colItems, objItem, strProviderName, bShouldList, strItem

Set dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; Add one line for each file share that you do not want listed in the sensor output.  
&#039;dictBlacklist.Add LCase(&quot;InsertBlacklistPathHere&quot;), True

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;select ProviderName from WIN32_LogicalDisk&quot;)    
For Each objItem In colItems
	strProviderName = objItem.ProviderName

	If Not IsNull(strProviderName) Then 	
		bShouldList = True
	
		For Each strItem In dictBlacklist.Keys
			If InStr(LCase(strProviderName), strItem) &lt; 0 Then 
				bShouldList = False
			End If
		Next
	
		If bShouldList Then 
			WScript.Echo strProviderName
		End If 
	End If 
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
208,Windows Event Logs,2015-01-05T20:22:04,",","Event codes for Windows event logs of type System and Error.
Example: 8009",1,1591480148,0,413,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,System Event Log IDs,,,,,,,,,Windows,select EventCode from Win32_NTLogEvent where LogFile = &#039;System&#039; and Type = &#039;Error&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
209,Registry,2015-01-05T20:22:04,~~,"Returns the data of a supplied value in a supplied registry key.  If the hive is HKEY_USERS, it will attempt to output the user name associated with the key.  HKEY_CURRENT_USER will only return data for the SYSTEM account which the Tanium Client runs as.
Example: John | 4.1.314.7020 | REG_SZ|32-bit",1,1591958393,0,415,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Registry Value Data,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{5}"",""helpString"":""Value must be at least 5 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the key path to query"",""value"":"""",""promptText"":""e.g. HKEY_LOCAL_MACHINE\\Software\\Microsoft"",""defaultValue"":"""",""label"":""Registry Key"",""maxChars"":0,""key"":""strKey"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the key value to query"",""value"":"""",""promptText"":""e.g. Version"",""defaultValue"":"""",""label"":""Registry Value"",""maxChars"":0,""key"":""strValue"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Registry Value Data
&#039;========================================

&#039;Columns:
&#039; User | Data | Type | Architecture | KeyPath | Value

&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)

strKey = unescape(&quot;||strKey||&quot;)
strValue = unescape(&quot;||strValue||&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client
&#039;strValue = &quot;Version&quot;

&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;
&#039;strValue = &quot;Emailname&quot;
strSep = &quot;~~&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If

&#039; Do not return second value set in different context unnecessarily
Dim strKeyPrefix,bSkipSecondContextCheck
bSkipSecondContextCheck = False
strKeyPrefix = Split(strKey,&quot;\&quot;)(0) &#039; Software, for instance, even for HEKY_USERS

Select Case Ucase(strKeyPrefix)
	Case &quot;SOFTWARE&quot;
		bSkipSecondContextCheck = False
	Case Else
		bSkipSecondContextCheck = True
End Select

If Is64 And Not bSkipSecondContextCheck Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive
		hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True
	End If
End If

If Not (hasAnyResult) Then
	WScript.Echo &quot;Key/Value not found&quot;
End If

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames
	arrTypes = Outparams.Types

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			
			&#039;if strValue is found, echo
			If LCase(strValueName) = LCase(strValue) Then
				EchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit
				CheckValues = True
				Exit Function
			End If
		Next
	End If
	CheckValues = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit)
	If intBit = 64 Then
		strArch = &quot;64-bit&quot;
	Else
		strArch = &quot;32-bit&quot;
	End If

	GetDisplayString = _
		strValue &amp; strSep &amp; _
		strType &amp; strSep &amp; _
		strArch
End Function

Function EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)
	&#039; Note the key that was being searched, will be a hidden column
	strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
	
	Dim objInParams, objOutParams
	Select Case constType
		Case REG_SZ  
			Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit) _
				&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
		Case REG_EXPAND_SZ
			Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)
	
			WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit) _
				&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
		Case REG_BINARY
			Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)

			strBytes = &quot;&quot;
			For Each uByte in objOutParams.uValue
				strTemp = Hex(uByte)
				If Len(strTemp) &lt; 2 Then
					strTemp = &quot;0&quot; &amp; strTemp
				End If	
				strBytes = strBytes &amp; strTemp &amp; &quot; &quot;
			Next
			
			WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit) _
				&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
		Case REG_DWORD
		    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit) _
				&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
		Case REG_QWORD
		    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit) _
				&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
		Case REG_MULTI_SZ
		    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)
		
			arrValues = objOutParams.sValue
			strResponse = &quot;&quot;

			For Each strTemp In arrValues
				WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit) _
					&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
			Next

	End Select
End Function


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\Software\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  ||strValue||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\Software\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  ||strValue||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,User,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Data,String,0,1,2,Type,String,0,1,3,Architecture,String,0,1,4,KeyPath,String,1,1,5,Value,String,,,,,,,,,,,,,,,,,,,,,String
210,Hardware,2015-01-05T20:22:04,|,"Multi-column sensor that returns details on the type, size, and free space of all partitions on the machine.
Example:ST3808110AS ATA Device|C:|250G|120G",1,1652607578,0,417,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Disk Drive Details,,,,,,,,,Windows,"&#039; Sensor:  Disk Drive Details
&#039; disk-drive-details.vbs
&#039;
&#039; Multicolumn sensor that returns all of the drive details on a single line

Option Explicit

Dim objWMIService, objDiskDrives, objDiskDrive, objDiskPartitions, objDiskPartition
Dim objLogicalDisks, objLogicalDisk
Dim strEscapedDeviceID

Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=Impersonate}!//.&quot;)
Set objDiskDrives = objWMIService.ExecQuery(&quot;SELECT Caption, DeviceID FROM Win32_DiskDrive&quot;)
 
For Each objDiskDrive In objDiskDrives
    strEscapedDeviceID = _
        Replace(objDiskDrive.DeviceID, &quot;\&quot;, &quot;\\&quot;, 1, -1, vbTextCompare)
    Set objDiskPartitions = objWMIService.ExecQuery _
        (&quot;ASSOCIATORS OF {Win32_DiskDrive.DeviceID=&quot;&quot;&quot; &amp; _
            strEscapedDeviceID &amp; &quot;&quot;&quot;} WHERE &quot; &amp; _
                &quot;AssocClass = Win32_DiskDriveToDiskPartition&quot;)
 
    For Each objDiskPartition In objDiskPartitions
        Set objLogicalDisks = objWMIService.ExecQuery _
            (&quot;ASSOCIATORS OF {Win32_DiskPartition.DeviceID=&quot;&quot;&quot; &amp; _
                objDiskPartition.DeviceID &amp; &quot;&quot;&quot;} WHERE &quot; &amp; _
                    &quot;AssocClass = Win32_LogicalDiskToPartition&quot;)
 
        For Each objLogicalDisk In objLogicalDisks
            WScript.Echo objDiskDrive.Caption &amp; &quot;|&quot; &amp; objLogicalDisk.DeviceID &amp; &quot;|&quot; &amp; _
            SizeInGB(objLogicalDisk.Size) &amp; &quot;|&quot; &amp; SizeInGB(objLogicalDisk.FreeSpace)
        Next
    Next
Next

Function SizeInGB(orgSize)
	Dim dblSize, intSize, strResult
	strResult = &quot;&quot;
    If Not IsNull(orgSize) Then
	    dblSize = CDbl(orgSize)
	    dblSize = dblSize / 1024 / 1024 / 1024
	    intSize = CInt(dblSize)
		strResult = intSize &amp; &quot; GB&quot;
    End If
    
    SizeInGB = strResult
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Drive Letter,String,0,1,2,Size,String,0,1,3,Free Space,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
211,Operating System,2015-01-05T20:22:04,",","Indicates whether the client machine is currently experiencing high utilization of its CPU.
Example: Under threshold",1,1670489640,0,419,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,High CPU Consumption,,,,,,,,,Windows,"&#039;========================================
&#039; High CPU Consumption
&#039;========================================

Const HKLM = &amp;H80000002 
strComputer = &quot;.&quot;

Set objWMIService = _
  	GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)

Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)
For Each objItem in colProcItems
	N1 = objItem.PercentProcessorTime
	D1 = objItem.TimeStamp_Sys100NS
Next

WScript.sleep(3000)
	
Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)
For Each objItem in colProcItems
	N2 = objItem.PercentProcessorTime
	D2 = objItem.TimeStamp_Sys100NS
Next

numLogicalProcessors = 0

Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) 
For Each objItem in colItems 
	Dim intLogicalProcessors 
	intLogicalProcessors = 1
	
	On Error Resume Next
	intLogicalProcessors = CInt(objItem.NumberOfLogicalProcessors)
	On Error Goto 0

	numLogicalProcessors = numLogicalProcessors + intLogicalProcessors
Next

&#039; CounterType - PERF_100NSEC_TIMER
&#039; Formula = ((N2 - N1) / (D2 - D1)) x 100
If ( 0 = (D2-D1) ) Or D1 &gt; D2 then
	WScript.echo &quot;System Timestamp Error&quot;
ElseIf N1 &gt; N2 Then
	WScript.Echo &quot;Performance Counter Error&quot;
Else
	percentage = Round(100 - ((N2 - N1) / (D2 - D1)) * 100 / numLogicalProcessors, 0)
	If percentage &gt; 80 Then
		WScript.echo percentage &amp; &quot; %&quot;
	Else
		WScript.echo &quot;Under 80% threshold&quot;
	End if
End if

Set wmi_service = nothing",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
212,Patch,2015-01-05T20:22:04,|,This sensor will return all patches uninstalled in the last 7 days,0,1388814144,0,421,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Recently Uninstalled Patches,,,,,,,,,Windows,"&#039;==============================
&#039; Tanium Community Content
&#039; Script ID: 1380
&#039; Last Modified: Fri Mar  7, 2014  9:51 PM
&#039;==============================

&#039;========================================
&#039;Recently Uninstalled Patches
&#039;========================================

&#039; This sensor will return all patches uninstalled in the last 7 days

Option Explicit
Dim strSep : strSep = &quot;|&quot;
Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
Dim strScanDir,strUninstallLog,strLogLine,strUninstallDate,strSplitLine,strDateOnly,strSplitDate
strScanDir = GetTaniumDir(&quot;Tools&quot;) &amp; &quot;Scans\&quot;
strUninstallLog = strScanDir &amp; &quot;uninstalledresultsreadable.txt&quot;
Dim objReadLog : Set objReadLog = fso.OpenTextFile (strUninstallLog,1)
		
Do While Not objReadLog.AtEndOfStream
	strLogLine = objReadLog.ReadLine
	strSplitLine = Split(strLogLine,strSep)
	strUninstallDate = strSplitLine(2)
	strSplitDate = Split(strUninstallDate,&quot; &quot;)
	strDateOnly = strSplitDate(0)
	If DateDiff(&quot;d&quot;,strUninstallDate,Now) &lt; 8 Then
		If UBound(strSplitLine) &gt; 3 Then
			WScript.Echo strSplitLine(0) &amp; strSep &amp; strSplitLine(1) &amp; strSep &amp; strDateOnly &amp; strSep &amp; strSplitLine(3) &amp; strSep &amp; strSplitLine(4)
		Else
			WScript.Echo strSplitLine(0) &amp; strSep &amp; strSplitLine(1) &amp; strSep &amp; strDateOnly &amp; strSep &amp; strSplitLine(3)
		End If
	End If
Loop


&#039;_____________________________________
Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir
&#039;________________________________________________
Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,1,1,0,Unique ID,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Name,String,0,1,2,Uninstall Date,String,0,1,3,Status,String,0,1,4,Tanium Patch ID,String,,,,,,,,,,,,,,,,,,,,,,,,,,String
213,Operating System,2015-01-05T20:22:04,",","Hard drive location hosting system directory on Windows machines.
Example: C:",1,170942492,0,423,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,System Drive,,,,,,,,,Windows,select SystemDrive from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
214,Hardware,2015-01-05T20:22:04,",","Indicates whether the machine is above an acceptable threshold for memory utilization.
Example: Under threshold",1,1718946935,0,425,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,High Memory Consumption,,,,,,,,,Windows,"&#039;========================================
&#039; High Memory Consumption
&#039;========================================

Set oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)  
Set oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)  
Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)     
&#039;Gets MEMORY Usage  
Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)  
For Each objItem In colItems     
strLinePercentCommittedBytesInUse = strLinePercentCommittedBytesInUse &amp; &quot; &quot; &amp; objItem.PercentCommittedBytesInUse  
Next    
If strLinePercentCommittedBytesInUse &gt; 60 THEN  
wscript.echo strLinePercentCommittedBytesInUse &amp; &quot; percent&quot;  
Else   
wscript.echo &quot;Under Threshold&quot;  
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
215,Security,2015-01-05T20:22:04,|,"Returns the last time the password was set for each user account.
Example:  taniumuser|2013-10-31",1,1723627713,0,427,1,Jim Olsen,60,0,defined,Tanium,2015-01-05T20:22:04,Local User Password Change Dates,,,,,,,,,Windows,"Set objNetwork = CreateObject(&quot;Wscript.Network&quot;)
strComputer = objNetwork.ComputerName
Set colAccounts = GetObject(&quot;WinNT://&quot; &amp; strComputer &amp; &quot;&quot;)
colAccounts.Filter = Array(&quot;user&quot;)
For Each objUser In colAccounts
  intPasswordAge = objUser.PasswordAge
  intPasswordAge = intPasswordAge * -1 
  dtmChangeDate = DateAdd(&quot;s&quot;, intPasswordAge, Now)
  strChangeDate = Year(dtmChangeDate)
  strChangeDate = strChangeDate &amp; &quot;-&quot; &amp; Right(&quot;0&quot; &amp; Month(dtmChangeDate), 2)
  strChangeDate = strChangeDate &amp; &quot;-&quot; &amp; Right(&quot;0&quot; &amp; Day(dtmChangeDate), 2)
  Wscript.Echo objUser.Name &amp; &quot;|&quot; &amp; strChangeDate
Next",VBScript,Linux,"#!/bin/bash

for TUSER in $( grep -v &quot;/bin/false&quot; /etc/passwd | awk -F &#039;:&#039; &#039;{ print $1 }&#039; ); do
  TLAST=&quot;$( chage -l &quot;$TUSER&quot; | grep &quot;Last password change&quot; | awk -F &#039;: &#039; &#039;{ print $2 }&#039; )&quot;
  TDATE=&quot;$( date -d &quot;$TLAST&quot; &quot;+%Y-%m-%d&quot; )&quot;
  echo &quot;$TUSER|$TDATE&quot;
done
",UnixShell,Mac,"#!/bin/bash

for TUSER in $( dscl . list /Users | grep -v &quot;^_.*&quot; ); do
  # exclude daemon, nobody, and root because everything segfaults on them
  if [ &quot;$TUSER&quot; != &quot;daemon&quot; ] &amp;&amp; [ &quot;$TUSER&quot; != &quot;nobody&quot; ] &amp;&amp; [ &quot;$TUSER&quot; != &quot;root&quot; ]; then
    dscl . read &quot;/Users/$TUSER&quot; PasswordPolicyOptions | grep -v &quot;PasswordPolicyOptions:&quot; &gt; temp.plist
    TLAST=&quot;$( /usr/libexec/PlistBuddy -c &#039;print passwordLastSetTime&#039; temp.plist )&quot;
    TDATE=&quot;$( date -j -f &quot;%a %b %d %T %Z %Y&quot; &quot;$TLAST&quot; &quot;+%Y-%m-%d&quot; )&quot;
    echo &quot;$TUSER|$TDATE&quot;
  fi
done
",UnixShell,0,0,0,1,0,User,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Last Password Set Time,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
216,Network,2015-01-05T20:22:04,",","Returns the current output throughput, in KB/Sec, of the network interface used to connect to the tanium server.
Example: 1024 KB/S",1,1735107559,0,429,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Network Throughput Outbound,,,,,,,,,Windows,"&#039;========================================
&#039; Network Throughput Outbound
&#039;========================================

&#039; This sensor will use windows performance counters
&#039; and attempt to retrieve network traffic information
&#039; only for the interface being used to connect to the tanium server
&#039; results are in kilobytes per second

Option Explicit

Dim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress
Dim strComputer: strComputer = &quot;.&quot;


Dim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString
Dim objWMIService, colItems, objItem

&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address
&#039; out of WMI.  Because Name is the closest thing to match the Description
&#039; field in the performance counter, but it&#039;s not exact due to how some
&#039; characters are displayed, we will remove troublesome characters
&#039; and attempt to match on that

&#039; Since the entire sensor&#039;s output depends on if the two strings match, we
&#039; can set the one string to something it won&#039;t match on (because _) to be safe
strDescriptionToMatch = &quot;_ImpossibleToMatch&quot;

Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)
For Each objItem In colItems
	For Each strIPAddress In objItem.IPAddress
		If strIPAddress = strTaniumIPAddress Then
			&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress
			strDescriptionToMatch = CleanString(objItem.Description)
			&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch
		End If
	Next
Next

Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)

For Each objItem in colItems
	strNameToMatch = CleanString(objItem.Name)
	&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch
	If LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then
		&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch
		&#039; We can now report bandwidth
		strFinalOutputString = FormatNumber(objItem.BytesSentPersec / 1024,0,-1) &amp; &quot; KB/S&quot;
	End If
Next

If strFinalOutputString = &quot;&quot; Then
	&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client
	WScript.Echo &quot;Cannot determine which adapter to measure&quot;
Else 
	WScript.Echo strFinalOutputString
End If


&#039; Cleanup
Set objWMIService = Nothing
Set colItems = Nothing 
Set objItem = Nothing

&#039;&#039; End Main Line

&#039;&#039; Helper Functions
Function CleanString(strInput)
&#039; This function will remove non-alphanumeric characters
	Dim objRegEx
	
	Set objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)
	
	objRegEx.Global = True   
	objRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;
	CleanString = objRegEx.Replace(strInput, &quot;&quot;)
	
	Set objRegEx = Nothing
End Function &#039;CleanString

Function GetTaniumIPAddress
&#039; Modified from the ua-scan code to remove the subnet and last octet calculations
&#039; which are irrelevant for these purposes.
&#039; Returns the IP address that the client uses for Tanium activity
&#039; (talking to server and other clients)

	Dim strComputer, objReg, strCommand, objShell, objScriptExec
	Dim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords
	Dim strIPAddress, strTaniumPath, strClientAddress
	Dim strServerName
	
	strComputer = &quot;.&quot;
	Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	Const HKLM = &amp;h80000002
	
		
	&#039;&#039;###########Get Tanium Key on 64/32bit computers##########
	
	strTaniumPath = GetTaniumRegistryPath()
	
	
	&#039; if we can pull this from the registry (newer client version), just use that
	objReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\Status&quot;, &quot;ClientAddress&quot;, strClientAddress
	If strClientAddress &lt;&gt; &quot;&quot; Then
		strClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)
		strClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))
		&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;
		GetTaniumIPAddress = strClientAddress
		&#039;Cleanup
		Set objReg = Nothing
		Exit Function
	End If
	
	&#039;Otherwise use PathPing to determine client IP used by Tanium

	&#039;&#039;# Read the ServerName value

	objReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName

	strCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	strResults = objScriptExec.StdOut.ReadAll
	
	arrPathPingLines = Split(strResults, vbCrLf)
	For Each strPathPingLine In arrPathPingLines
		arrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)
		If UBound(arrPathPingWords) &gt; 0 Then
			If arrPathPingWords(0) = &quot;0&quot; Then
				strIPAddress = arrPathPingWords(1)
				Exit For
			End If
		End If	
	Next
	
	Set objShell = Nothing
	Set objScriptExec = Nothing
	Set objReg = Nothing

	If Not IsNull(strIPAddress) Then
		GetTaniumIPAddress = strIPAddress
	Else
		GetTaniumIPAddress = False
	End If
End Function &#039;GetTaniumIPAddress

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function CleanWhitespace(strStarter)
	Dim intStarter, i, strChars
	intStarter = Len(strStarter)
	For i = intStarter to 2 Step -1
		strChars = Space(i)
		strStarter = Replace(strStarter, strChars, &quot; &quot;)
	Next
	CleanWhitespace = strStarter
End Function &#039;CleanWhiteSpace",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
217,Hardware,2015-01-05T20:22:04,",","Returns the number of empty, unused RAM slots.
Example:2",1,1785623864,0,431,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Ram Slots Unused,,,,,,,,,Windows,"&#039;========================================
&#039; RAM Slots Unused
&#039;========================================

&#039; This sensor will return the number of free RAM slots

Option Explicit

FreeRAMSlots

Function FreeRAMSlots
&#039; This function returns the number of free RAM slots
	Dim strComputer
	Dim objWMIService, colPMAs, objPMA
	Dim colPMs, objPM
	
	&#039; How many slots exist
	Dim intSlots: intSlots = 0
	&#039; How many MemoryDevices are present
	Dim intMemorySticks: intMemorySticks = 0
		
	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
	&#039;Use = 3 is system RAM
	&#039; This is the number of slots in the system.
	Set colPMAs = objWMIService.ExecQuery(&quot;Select MemoryDevices from Win32_PhysicalMemoryArray where use=&#039;3&#039;&quot;,,48)
	
	For Each objPMA In colPMAs
		&#039; There should be only one
		&#039; but just in case
		intSlots = intSlots + objPMA.MemoryDevices
		&#039; WScript.Echo &quot;objPMA.MemoryDevices is total slots: &quot; &amp; objPMA.MemoryDevices
	Next
	
	&#039; Cleanup
	Set colPMAs = Nothing
	
	&#039; A new query - asking for DeviceLocator where memory type does not 
	&#039; equal 11 (Flash RAM)
	&#039; DeviceLocator is the label of the socket that holds the memory
	&#039; So this is the number of sockets in the system
	Set colPMs = objWMIService.ExecQuery(&quot;Select DeviceLocator from Win32_PhysicalMemory where MemoryType!=&#039;11&#039;&quot;)
	
	For Each objPM In colPMs
		&#039;Each loop through indicates another slot
		intMemorySticks = intMemorySticks + 1
	Next
	
	&#039; output is total slots minus memory sticks in use
	WScript.Echo intSlots - intMemorySticks
	
	&#039;Cleanup
	Set colPMs = Nothing
	Set objWMIService = Nothing
End Function &#039;FreeRAMSlots",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
218,Hardware,2015-01-05T20:22:04,",","Returns printers which are connected via Network
Example: HP LaserJet 4400c",1,1806420230,0,433,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Network Printers,,,,,,,,,Windows,Select DriverName from Win32_Printer where Network = True,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
219,Network,2015-01-05T20:22:04,",","Parameterized Sensor that shows which addresses the process is connecting to and over what local port.
Example: 0.0.0.0:17500",1,1810333216,0,435,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Established Ports by Application,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{2}"",""helpString"":""Value must be at least 2 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the process name to query"",""value"":"""",""promptText"":""e.g. svchost.exe"",""defaultValue"":"""",""label"":""Process Name to examine"",""maxChars"":0,""key"":""app"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Established Ports by Application
&#039;========================================

Dim strcommand,bHasOutput

check = Trim(Unescape(&quot;||app||&quot;))

strComputer = &quot;.&quot;    
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
query = &quot;select name, processId from win32_process where name = &#039;&quot; &amp; check &amp; &quot;&#039;&quot;
Set colResults = objWMIService.ExecQuery(query)

Set processes = CreateObject(&quot;Scripting.Dictionary&quot;)

For Each result In colResults 
   processId = CStr(result.ProcessId)
   processes.Add processId, result.Name
Next

strcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34)

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strPingResults = LCase(objScriptExec.StdOut.ReadAll)

results = Split(strPingResults, vbCrLf)
bHasOutput = False
for Each line in results
   line = cleanWhitespace(Trim(line))
   lineResults = Split(line)
   i = 0
   Dim strPort, strPid, strConnectionType
   For Each word In lineResults
      If i = 1 Then
         strPort = word
      ElseIf i = 3 Then
         strConnectionType = word
      ElseIf i = 4 Then
         strPid = word
      End If
      
      i = i + 1
   Next
   If processes.Exists(strPid) And (strConnectionType = &quot;listening&quot; Or strConnectionType = &quot;established&quot;) Then
		WScript.echo strPort &amp; &quot; &quot; &amp; processes.Item(strPid)
		bHasOutput = True
   End If   
Next

If Not bHasOutput Then
	If GetLocale() &lt;&gt; 1033 Then
		WScript.Echo &quot;English Language OS Required&quot;
	End If
End If


Function cleanWhitespace(strStarter)
   intStarter = Len(strStarter)
   For i = intStarter to 2 Step -1
      strChars = Space(i)
      strStarter = Replace(strStarter, strChars, &quot; &quot;)
   Next
   cleanWhitespace = strStarter
End Function",VBScript,Linux,"#!/bin/bash

tmpfile=/tmp/tanium.$$

urldecode() {
        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\+/ /g&#039; -e &#039;s/%/\\x/g&#039;)
        printf &#039;%b&#039; &quot;$data&quot;
}

lsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n &gt; $tmpfile 
application=$(urldecode &quot;||app||&quot;)
cat $tmpfile | awk -v app=$application &#039;tolower($1)==tolower(app) {print substr($0,index($0,$9),index($0,&quot;&gt;&quot;)-index($0,$9)-1)}&#039;
rm -f $tmpfile
",UnixShell,Mac,"#!/bin/bash

tmpfile=/tmp/tanium.$$

urldecode() {
        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\+/ /g&#039; -e &#039;s/%/\\x/g&#039;)
        printf &#039;%b&#039; &quot;$data&quot;
}

lsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n &gt; $tmpfile 
application=$(urldecode &quot;||app||&quot;)
cat $tmpfile | awk -v app=$application &#039;tolower($1)==tolower(app) {print substr($0,index($0,$9),index($0,&quot;&gt;&quot;)-index($0,$9)-1)}&#039;
rm -f $tmpfile
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
220,McAfee,2015-01-05T20:22:04,",","Returns the McAfee Agent Version
Example: 4.6.0.2292",0,1815624605,0,437,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:04,McAfee Agent Version,,,,,,,,,Windows,"&#039; sensor - McAfee Agent Version

Option Explicit

Dim strMcAfeeFrameworkServiceState
&#039; First get the state of the service
strMcAfeeFrameworkServiceState = ServiceState(&quot;McAfeeFramework&quot;)
If strMcAfeeFrameworkServiceState = &quot;Not Installed&quot; Then
	&#039;No further tests are necessary
	WScript.Echo &quot;McAfee Agent Not Installed&quot;
	WScript.Quit
End If


Const HKLM = &amp;h80000002
Dim objReg	
Set objReg = Getx64RegistryProvider()	

WScript.Echo GetMcAfeeAgentVersion

Function GetMcAfeeAgentVersion

	Dim intIPSState,intMajorVersion
	Dim strRegPath,strVersion

	strRegPath = GetMcAfeeProductRegRootKey(&quot;NAITVD&quot;)	
	If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then
		objReg.GetStringValue HKLM,strRegPath&amp;&quot;\Shared Components\Framework&quot;,&quot;Version&quot;,strVersion
		If Not (IsNull(strVersion) Or strVersion = &quot;&quot; ) Then
			GetMcAfeeAgentVersion = strVersion
		Else &#039; no version
			WScript.Echo &quot;Error: Cannot determine McAfee Agent version&quot;
		End If
	Else &#039; no way to get to root registry key
		WScript.Echo &quot;Error: Cannot determine McAfee Agent version&quot;
	End If

End Function &#039;GetMcAfeeAgentVersion



Function GetMcAfeeProductRegRootKey(strProductString)
&#039; Retrieves McAfee key for a product
&#039; products are passed in and defined in the function

	Dim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey
	Dim strProductKeyPath

	&#039; select on input
	strProductString = UCase(strProductString)
	Select Case strProductString
		Case &quot;AGENT&quot;
			strProductSubKey = &quot;McAfee\Agent&quot;	
		Case &quot;AVENGINE&quot;
			strProductSubKey = &quot;McAfee\AVEngine&quot;
		Case &quot;DESKTOPPROTECTION&quot;
			strProductSubKey = &quot;McAfee\DesktopProtection&quot;
		Case &quot;EPO&quot;
			strProductSubKey = &quot;McAfee\ePolicy Orchestrator&quot;
		Case &quot;HIPS&quot;
			strProductSubKey = &quot;McAfee\HIP&quot;
		Case &quot;HIPSCORE&quot;
			strProductSubKey = &quot;McAfee\HIPSCore&quot;
		Case &quot;MCTRAY&quot;
			strProductSubKey = &quot;McAfee\McTray&quot;					
		Case &quot;SITEADVISOR&quot;
			strProductSubKey = &quot;McAfee\SiteAdvisor Enterprise Plus&quot;
		Case &quot;SYSTEMCORE&quot;
			strProductSubKey = &quot;McAfee\SystemCore&quot;
		Case &quot;VSCORE&quot;
			strProductSubKey = &quot;McAfee\VSCore&quot;
		Case &quot;NAIEPO&quot;
			strProductSubKey = &quot;Network Associates\ePolicy Orchestrator&quot;
		Case &quot;NAITVD&quot;
			strProductSubKey = &quot;Network Associates\TVD&quot;
		Case Else
			strProductSubKey = False
	End Select
			
	Const HKLM = &amp;h80000002
	
    
	strRootSoftwareKeyNative = &quot;Software&quot;
	strRootSoftwareKeyWow64 = &quot;Software\Wow6432Node&quot;
    If Not strProductSubKey = False Then
	    &#039; Assume not in both places on a 64-bit machine
		If RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\&quot;&amp;strProductSubKey
		ElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey) Then
			strProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\&quot;&amp;strProductSubKey
		End If
	Else
		strProductKeyPath = False		
	End If
	
	GetMcAfeeProductRegRootKey = strProductKeyPath

End Function &#039;GetMcAfeeProductRegRootKey

Function RegKeyExists(sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function &#039;RegKeyExists

Function ServiceState(strServiceName)
&#039; This function determines if a service is in a bad state and returns
&#039; values indicating the state.  Examples: 
&#039; &quot;Stopped&quot;
&#039; &quot;Stopped Manual&quot;
&#039; &quot;Running Disabled&quot;
&#039; &quot;Not Installed&quot;

	Dim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState

	strWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;

	strState = &quot;&quot;
	strStartMode = &quot;&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
		&amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(strWMIQuery)
	
	If colItems.Count = 0 Then
		ServiceState = &quot;Not Installed&quot;
	Else
		For Each objItem In colItems
			If objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then
				strState = objItem.State
			End If
			If objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then
				strStartMode = objItem.StartMode
			End If
			ServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)
		Next
	End If

End Function &#039;ServiceState

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
221,Network,2015-01-05T20:22:04,",","Returns the current throughput, as a percentage of total possible, of the network interface used to connect to the tanium server.
Example: 50%",1,1819649983,0,439,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Network Throughput Percentage,,,,,,,,,Windows,"&#039;========================================
&#039; Network Throughput Percentage
&#039;========================================

&#039; This sensor will use windows performance counters
&#039; and attempt to retrieve network traffic information
&#039; only for the interface being used to connect to the tanium server
&#039; to show the total througput (in and out) as a percentage of capability

Option Explicit

Dim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress
Dim strComputer: strComputer = &quot;.&quot;

Dim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString
Dim objWMIService, colItems, objItem, colNAItems, objNAItem, strMaxSpeed
Dim strRawDescription

&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address
&#039; out of WMI.  Because Name is the closest thing to match the Description
&#039; field in the performance counter, but it&#039;s not exact due to how some
&#039; characters are displayed, we will remove troublesome characters
&#039; and attempt to match on that

&#039; Since the entire sensor&#039;s output depends on if the two strings match, we
&#039; can set the one string to something it won&#039;t match on (because _) to be safe
strDescriptionToMatch = &quot;_ImpossibleToMatch&quot;

Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)
For Each objItem In colItems
	For Each strIPAddress In objItem.IPAddress
		If strIPAddress = strTaniumIPAddress Then
			&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress
			strDescriptionToMatch = CleanString(objItem.Description)
			strRawDescription = objItem.Description
			&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch
		End If
	Next
Next

Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)

For Each objItem in colItems
	strNameToMatch = CleanString(objItem.Name)
	&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch
	If LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then
		&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch

		If Not IsNull(strMaxSpeed) Then &#039; must have this value
			strFinalOutputString = FormatNumber(objItem.BytesTotalPersec / objItem.CurrentBandwidth * 100,0,-1) &amp; &quot;%&quot;
		End If
	End If
Next

If strFinalOutputString = &quot;&quot; Then
	&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client
	WScript.Echo &quot;Cannot determine which adapter to measure&quot;
Else 
	WScript.Echo strFinalOutputString
End If


&#039; Cleanup
Set objWMIService = Nothing
Set colItems = Nothing 
Set objItem = Nothing

&#039;&#039; End Main Line

&#039;&#039; Helper Functions
Function CleanString(strInput)
&#039; This function will remove non-alphanumeric characters
	Dim objRegEx
	
	Set objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)
	
	objRegEx.Global = True   
	objRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;
	CleanString = objRegEx.Replace(strInput, &quot;&quot;)
	
	Set objRegEx = Nothing
End Function &#039;CleanString

Function GetTaniumIPAddress
&#039; Modified from the ua-scan code to remove the subnet and last octet calculations
&#039; which are irrelevant for these purposes.
&#039; Returns the IP address that the client uses for Tanium activity
&#039; (talking to server and other clients)

	Dim strComputer, objReg, strCommand, objShell, objScriptExec
	Dim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords
	Dim strIPAddress, strTaniumPath, strClientAddress
	Dim strServerName
	
	strComputer = &quot;.&quot;
	Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	Const HKLM = &amp;h80000002
	
		
	&#039;&#039;###########Get Tanium Key on 64/32bit computers##########
	
	strTaniumPath = GetTaniumRegistryPath()
	
	
	&#039; if we can pull this from the registry (newer client version), just use that
	objReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\Status&quot;, &quot;ClientAddress&quot;, strClientAddress
	If strClientAddress &lt;&gt; &quot;&quot; Then
		strClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)
		strClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))
		&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;
		GetTaniumIPAddress = strClientAddress
		&#039;Cleanup
		Set objReg = Nothing
		Exit Function
	End If
	
	&#039;Otherwise use PathPing to determine client IP used by Tanium

	&#039;&#039;# Read the ServerName value

	objReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName

	strCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	strResults = objScriptExec.StdOut.ReadAll
	
	arrPathPingLines = Split(strResults, vbCrLf)
	For Each strPathPingLine In arrPathPingLines
		arrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)
		If UBound(arrPathPingWords) &gt; 0 Then
			If arrPathPingWords(0) = &quot;0&quot; Then
				strIPAddress = arrPathPingWords(1)
				Exit For
			End If
		End If	
	Next
	
	Set objShell = Nothing
	Set objScriptExec = Nothing
	Set objReg = Nothing

	If Not IsNull(strIPAddress) Then
		GetTaniumIPAddress = strIPAddress
	Else
		GetTaniumIPAddress = False
	End If
End Function &#039;GetTaniumIPAddress

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function CleanWhitespace(strStarter)
	Dim intStarter, i, strChars
	intStarter = Len(strStarter)
	For i = intStarter to 2 Step -1
		strChars = Space(i)
		strStarter = Replace(strStarter, strChars, &quot; &quot;)
	Next
	CleanWhitespace = strStarter
End Function &#039;CleanWhiteSpace",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
222,Software,2015-01-05T20:22:04,|,"Returns the names and dates of the last users to log in.
Example: John.Doe 7/25/2012",1,182214159,0,441,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Local User Login Dates,,,,,,,,,Windows,"&#039;========================================
&#039; Local User Login Dates
&#039;========================================

Option Explicit  

&#039;Uses date math - set locale

SetLocale(GetTaniumLocale)
Dim strSep: strSep = &quot;|&quot;
Dim objNetwork : Set objNetwork = CreateObject(&quot;WScript.Network&quot;) 
Dim objGroup : Set objGroup = GetObject(&quot;WinNT://.&quot;) 
objGroup.Filter = Array(&quot;user&quot;) 
Dim objUser 
For Each objUser In objGroup     
On Error Resume Next         
WScript.Echo objUser.name &amp; strSep &amp; left(GetObject(objUser.adsPath).LastLogin,Instr(GetObject(objUser.adsPath).LastLogin,&quot; &quot;))     
On Error GoTo 0 
Next


Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Date,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
223,Operating System,2015-01-05T20:22:04,|,"Returns the run once keys that define which programs will be started when a user logs in.
Example:  System|GlobalProtect|""C:\Program Files\Palo Alto Networks\GlobalProtect\PanGPA.exe""",1,1832324705,0,443,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Run Once Keys,,,,,,,,,Windows,"&#039;========================================
&#039; Run Once Keys
&#039;========================================

&#039; returns the system and user keys for a given key

Option Explicit

Const strSep = &quot;|&quot;

Dim strKeyPath, strKeyPath32, dictResults, strValue

strKeyPath = &quot;Software\Microsoft\Windows\CurrentVersion\RunOnce&quot;
strKeyPath32 = &quot;Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce&quot;
    
Set dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)

AddValuesForKey dictResults, strKeyPath
AddValuesForKey dictResults, strKeyPath32

For Each strValue In dictResults.Keys
    WScript.Echo strValue
Next

Sub AddValuesForKey(dictResults, strKey)
&#039; This function will output the two values

    Const HKLM = &amp;h80000002
    Const HKEY_USERS = &amp;H80000003
    
    Dim objRegistry
    Dim arrUserKeys,strUserKey, strUserKeyPath
    
    &#039; get System Keys
    Set objRegistry = Getx64RegistryProvider()
    If RegKeyExists(HKLM, strKey, objRegistry) Then  
        GetValues objRegistry, HKLM, strKey, dictResults, &quot;System&quot;
    End If
    
    &#039; get User Keys
    objRegistry.EnumKey HKEY_USERS, &quot;&quot;,arrUserKeys
    For Each strUserKey In arrUserKeys
        If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
            strUserKeyPath = strUserKey &amp; &quot;\&quot; &amp; strKey
            If RegKeyExists(HKEY_USERS,strUserKeyPath, objRegistry) Then
                GetValues objRegistry, HKEY_USERS, strUserKeyPath, dictResults, &quot;User&quot;
            End If
         End If 
    Next 
End Sub &#039;AddValuesForKey

Sub GetValues(objRegistry, hiveConst, keyPath, dictValues, strPrefix)
    Dim arrKeyNames, arrTypes, arrValueNames, strValueName
    Dim strValueData, i, strEntry
        
    objRegistry.EnumValues hiveConst, keyPath, arrValueNames, arrTypes
    
    If Not IsArray(arrValueNames) Then
        arrValueNames = Array(&quot;&quot;)
        arrTypes = Array(1)
    End If
    
    For i = LBound(arrValueNames) To UBound(arrValueNames)
        strValueName = arrValueNames(i)
        strValueData = GetRegValue(objRegistry, hiveConst, keyPath, strValueName, arrTypes(i))
        If Not ( IsNull(strValueName) Or IsNull(strValueData) ) Then
            strEntry = strPrefix &amp; strSep &amp; strValueName &amp; strSep &amp; strValueData
            If Not dictValues.Exists(strEntry) Then 
                dictValues.Add strEntry, True
            End If 
        End If
    Next    
End Sub &#039;GetValues

Function GetRegValue(objRegistry, hiveConst, keyPath, strValueName, constType)

    Const REG_SZ        = 1
    Const REG_EXPAND_SZ = 2
    Const REG_BINARY    = 3
    Const REG_DWORD     = 4
    Const REG_MULTI_SZ  = 7
    Const REG_QWORD     = 11

    Dim strValue, arrBytes, uValue, arrValues

    Select Case constType
        Case REG_SZ  
            objRegistry.GetStringValue hiveConst, keyPath, strValueName, strValue
            GetRegValue =  strValue
            Exit Function
        Case REG_EXPAND_SZ
            objRegistry.GetExpandedStringValue hiveConst, keyPath, strValueName, strValue
            GetRegValue =  strValue
            Exit Function
        Case REG_BINARY
            objRegistry.GetBinaryValue hiveConst, keyPath, strValueName, arrBytes
            strBytes = &quot;&quot;
            For Each uByte in arrBytes
                strBytes = strBytes &amp; Hex(uByte) &amp; &quot; &quot;
            Next
            GetRegValue =  strBytes
            Exit Function
        Case REG_DWORD
            objRegistry.GetDWORDValue hiveConst, keyPath, strValueName, uValue
            GetRegValue =  CStr(uValue)               
            Exit Function
        Case REG_QWORD
            objRegistry.GetQWORDValue hiveConst, keyPath, strValueName, uValue
            GetRegValue =  CStr(uValue)               
            Exit Function
        Case REG_MULTI_SZ
            objRegistry.GetMultiStringValue hiveConst, keyPath, strValueName, arrValues                             
            For Each strValue in arrValues
                GetRegValue =  strValue 
            Next
            Exit Function
    End Select
End Function &#039;GetRegValue

Function RegKeyExists(sHive, sRegKey, objReg)
    Dim aValueNames, aValueTypes
    If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
        RegKeyExists = True
    Else
        RegKeyExists = False
    End If
End Function &#039; RegKeyExists


Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Type,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Name,String,0,1,2,Command Line,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
224,SQL,2015-01-05T20:22:04,",","Current CPU utilization percentage by SQL Server process on client machine.
Example: 8%",1,1845399463,0,445,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,SQL Server CPU Consumption,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Server CPU Consumption
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit

Dim dictInstances, strInstance, Process

Set dictInstances = GetMSSQLInstances()

If dictInstances.Count &gt; 0 Then 
	For Each Process In GetObject(&quot;winmgmts:&quot;).ExecQuery(&quot;Select * from Win32_Process where Name = &#039;sqlservr.exe&#039;&quot;)   
		WScript.echo CPUUSage(Process.Handle) &amp; &quot;%&quot;  
	Next  
End If

Function CPUUSage( ProcID ) 
	Dim objService, objInstance1, objInstance2, N1, N2, D1, D2, Nd, Dd, PercentProcessorTime  
	On Error Resume Next   
	Set objService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)     
	For Each objInstance1 In objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;sqlservr&#039;&quot;)        
		N1 = objInstance1.PercentProcessorTime        
		D1 = objInstance1.TimeStamp_Sys100NS      
		Exit For    
	Next  
	WScript.Sleep(2000)     
	For Each objInstance2 In objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;sqlservr&#039;&quot;)        
		N2 = objInstance2.PercentProcessorTime        
		D2 = objInstance2.TimeStamp_Sys100NS      
		Exit For    
	Next    
	On Error Goto 0
	
	&#039; CounterType - PERF_100NSEC_TIMER_INV   
	&#039; Formula - (1- ((N2 - N1) / (D2 - D1))) x 100     
	Nd = (N2 - N1)     
	Dd = (D2 - D1)     
	PercentProcessorTime = ( (Nd/Dd))  * 100    
	CPUUSage = Round(PercentProcessorTime, 0) 
End Function 

&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
225,McAfee,2015-01-05T20:22:04,|,"This sensor will return the encryption status of volumes encrypted with McAfee Endpoint Encryption
Example: C:|Encrypted",1,1849288420,0,447,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,McAfee Endpoint Encryption Status,,,,,,,,,Windows,"&#039;========================================
&#039; McAfee Endpoint Encryption Status
&#039;========================================

&#039; This sensor will return the encryption status
&#039; of volumes encrypted with McAfee Endpoint Encryption

Option Explicit

Dim objRegistry,keyPath,key64Path,strSep
strSep = &quot;|&quot; &#039; column delimiter

Set objRegistry = Getx64RegistryProvider()

Const HKLM = &amp;H80000002 

keyPath = &quot;SOFTWARE\McAfee Endpoint Encryption\MfeEpePC\Status&quot;
key64Path = &quot;SOFTWARE\Wow6432Node\McAfee Endpoint Encryption\MfeEpePC\Status&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If 

If RegKeyExists(HKLM, keyPath) Then
	Dim strReturn
	strReturn = ReturnStringValueOrEchoError _
		(objRegistry,HKLM,keyPath,&quot;CryptState&quot;,&quot;McAfee Endpoint Encryption State Not Found&quot;)
	If VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error
		ReturnEEPCEncryptionStatus strReturn
	Else
		WScript.Quit
	End If
Else
	WScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;
	WScript.Quit
End If

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function ReturnEEPCEncryptionStatus(strStatus)
&#039; output looks like Volume=C:,State=Encrypted;Volume=D:,State=Encrypted;
	Dim arrInput,strVolumes,strWord,strVolume,strVolumeName,strVolumeState
	Dim bBadVolume
	
	arrInput = Split(strStatus,&quot;;&quot;)
	
	For Each strVolume In arrInput
		bBadVolume = False
		If InStr(1,strVolume,&quot;volume=&quot;,1) &gt; 0 And InStr(1,strVolume,&quot;state=&quot;,1) &gt; 0 Then	
			On Error Resume Next
			strVolumeName = Split(Split(strVolume,&quot;volume=&quot;,-1,1)(1),&quot;,&quot;)(0)
			strVolumeState = Split(Split(strVolume,&quot;state=&quot;,-1,1)(1),&quot;,&quot;)(0)
			On Error Goto 0
			If strVolumeName = &quot;&quot; Or strVolumeState = &quot;&quot; Then
				bBadVolume = True
			Else
				WScript.Echo strVolumeName&amp;strSep&amp;strVolumeState
			End If
		End If
		If bBadVolume Then WScript.Echo &quot;Invalid Volume Information: &quot; &amp; strVolume
	Next
End Function &#039;ReturnEEPCEncryptionStatus

Function ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)
&#039; Return a value or fatal error message and error result
	Dim intReturn,strValueData
	intReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)
	If intReturn = 0 Then
		ReturnStringValueOrEchoError = strValueData
	Else
		ReturnStringValueOrEchoError = -1
		WScript.Echo strErrorMessage
	End If
End Function 

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Volume Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Encryption Status,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
226,Tanium Diagnostics,2015-01-05T20:22:04,",","Retrieves the Tanium Server Name List from the Client's Registry
Example: server.domain.com,server1.domain.com",1,1865193433,0,449,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Tanium Server Name List,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Server Name List
&#039;========================================


Option Explicit

Const HKLM = &amp;h80000002

Dim objReg
Dim strTaniumRegPath, strCurrentTaniumServerNameListValue
Dim strComputer

strComputer = &quot;.&quot;

Set objReg = _ 
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

strTaniumRegPath = GetTaniumRegistryPath()
&#039;retrieve current server name value
objReg.GetStringValue HKLM, strTaniumRegPath, &quot;ServerNameList&quot;, strCurrentTaniumServerNameListValue

If Not IsNull(strCurrentTaniumServerNameListValue) Then 
	WScript.Echo strCurrentTaniumServerNameListValue
Else 
	WScript.Echo &quot;Not Set&quot;
End If 

&#039;Cleanup
Set objReg = Nothing

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
227,Hardware,2015-01-05T20:22:04,",","Description of the onboard audio controller for the computer.
Example: Intel(R) High Definition Audio Controller",1,189860887,0,451,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Audio Controller,,,,,,,,,Windows,select Description from win32_onboarddevice where DeviceType=7,WMIQuery,Linux,"#!/bin/sh
lspci | grep &#039;audio controller&#039; | awk -F&#039;audio controller: &#039; &#039;{print $2}&#039;
",UnixShell,Mac,"#!/bin/bash
system_profiler SPAudioDataType | grep -w -A2 &quot;^Audio:&quot; | tail -1 | sed -e &#039;s/^ *//&#039; -e &#039;s/:$//&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
228,Tanium Diagnostics,2015-01-05T20:22:04,",","The number of buffered messages currently queued to be processed by the Tanium client on each client machine.
Example: 2",1,191451006,0,453,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Tanium Buffer Count,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Buffer Count 
&#039;========================================

strKeyPath = &quot;SOFTWARE\Tanium\Tanium Client\Status&quot;
strValueName = &quot;BufferCount&quot; 

const HKEY_CURRENT_USER = &amp;H80000001
const HKEY_LOCAL_MACHINE = &amp;H80000002
strComputer = &quot;.&quot;

Set oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp;_
 strComputer &amp; &quot;\root\default:StdRegProv&quot;) 

On Error Resume Next

  oReg.GetDWORDValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue

  Wscript.Echo strValue

On Error Goto 0",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
229,Hardware,2015-01-05T20:22:04,",","All hardware devices currently in use by a computer.
Example: Microsoft PS/2 Mouse",1,1927765752,0,455,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Active Devices,,,,,,,,,Windows,"&#039;========================================
&#039; Active Devices
&#039;========================================

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PnPEntity where status = &#039;OK&#039; and service is not null and service &lt;&gt; &#039;pci&#039;&quot;,,48)
For Each objItem in colItems
	If Not Left(objItem.PNPDeviceId, Len(&quot;ROOT&quot;)) = &quot;ROOT&quot; Then
	    Wscript.Echo objItem.Caption
	End If 
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
230,Applications,2015-01-05T20:22:04,|,"Returns the date that each application was last launched on.
Example: Notepad | 9/18/2012",1,1927941770,0,457,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Last Application Launch Date,,,,,,,,,Windows,"&#039;========================================
&#039; Last Application Launch Date
&#039;========================================

strComputer = &quot;.&quot;
Const HKLM = &amp;h80000002
Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

strKeyPath = GetTaniumRegistryPath() &amp; &quot;\Sensor Data\Applications&quot;

If RegKeyExists(reg, HKLM, strKeyPath) Then
	reg.EnumKey HKLM, strKeyPath, arrSubKeys
	If IsArray(arrSubKeys) Then
		For Each Subkey In arrSubKeys
			&#039;Wscript.Echo Subkey
			newKeyPath = strKeyPath &amp; &quot;\&quot; &amp; Subkey
			
			reg.GetStringValue HKLM, newKeyPath, &quot;Last Start&quot;, strLastStart
			reg.GetStringValue HKLM, newKeyPath, &quot;Description&quot;, strDescription
			WScript.Echo strDescription &amp; &quot;|&quot; &amp; strLastStart
		Next
	Else	
		WScript.Echo &quot;Application data not initialized&quot;
	End If
Else	
	WScript.Echo &quot;Application data not initialized&quot;
End If

Function GetTaniumRegistryPath
	&#039;GetTaniumRegistryPath works in x64 or x32
	&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
	
	&#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
	On Error Resume Next
	strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
	On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
	
	If strPath = &quot;&quot; Then
		&#039; Could not find 32-bit mode path, checking Wow6432Node
		On Error Resume Next
		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
	End If
	
	If Not strPath = &quot;&quot; Then
		GetTaniumRegistryPath = strFoundTaniumRegistryPath
	Else
		GetTaniumRegistryPath = False
		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
	End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Application Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Date,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
231,Operating System,2015-01-05T20:22:04,",","Returns the currently defined system variables
Example:  windir=c:\Windows",1,1978207968,0,459,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,System Environment Variables,,,,,,,,,Windows,"&#039;========================================
&#039; System Environment Variables
&#039;========================================

Option Explicit

Const EXPAND_VARS = False

Dim wshShell, wshSysEnv, strItem

Set wshShell = CreateObject( &quot;WScript.Shell&quot; )
Set wshSysEnv = wshShell.Environment( &quot;SYSTEM&quot; )
For Each strItem In wshSysEnv
	If EXPAND_VARS Then 
		WScript.Echo wshShell.ExpandEnvironmentStrings( strItem )
	Else 
		WScript.Echo strItem
	End If
Next
Set wshSysEnv = Nothing
Set wshShell = Nothing",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
232,User,2015-01-05T20:22:04,",","List of user accounts on a linux client machine.
Example: webadmin",1,1988427982,0,461,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:04,User Accounts,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
cat /etc/passwd | grep -v &quot;sbin/nologin&quot; | cut -d: -f1
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
233,Operating System,2015-01-05T20:22:04,",","The currently specified time zone for the client machine.
Example: (UTC-08:00) Pacific Time (US & Canada)",1,2006202074,0,463,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Time Zone,,,,,,,,,Windows,Select Description from Win32_TimeZone,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
234,File System,2015-01-05T20:22:04,",","Finds the specified file and provides the full path if the file exists on the client machine.
Example: C:\WINDOWS\System32\Notepad.exe",1,2054092310,0,465,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,File Name Search,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the file name only to search for."",""value"":"""",""promptText"":""e.g. test.txt"",""defaultValue"":"""",""label"":""File name to search for"",""maxChars"":0,""key"":""filename"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; File Name Search
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit

SensorRandomize()

Dim Pattern

Pattern = Trim(unescape(&quot;||filename||&quot;))

Const SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1

Dim FSO, WshShell, Drives, Drive, TextStream, OutputFilename

Set FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set WshShell = CreateObject(&quot;WScript.Shell&quot;)

OutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir

&#039; Go through file system, refresh output file for filename
If Not FSO.FileExists(OutputFilename) Then
	
	If FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename

	&#039; Get the collection of local drives.
	Set Drives = FSO.Drives
	For Each Drive in Drives
		If Drive.DriveType = 2 Then &#039; 2 = Fixed drive
			&#039; Run the Dir command that looks for the filename pattern.
			RunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:-d /b /s&quot;, OutputFilename, true
		End If
	Next
End If

&#039; Open the output file, echo each line, and then close and delete it.
Set TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)
Do While Not TextStream.AtEndOfStream
	WScript.Echo TextStream.ReadLine()
Loop

TextStream.Close()
 
If FSO.FileExists(OutputFileName) Then
	On Error Resume Next
	FSO.DeleteFile OutputFileName, True
	On Error Goto 0
End If

&#039; Returns the name of a temporary file in the Temp directory.
Function TempName()
	Dim Result
	Do
 		Result = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())
		WScript.Sleep 200 &#039;avoid potential busy loop
	Loop While FSO.FileExists(Result)
	
	TempName = Result
End Function &#039;TempName

&#039; Runs a command with Cmd.exe and redirects its output to a temporary
&#039; file. The function returns the name of the temporary file that holds
&#039; the command&#039;s output.
Function RunCommand(Command, OutputFilename, b64BitNecessary)
	&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32
	Dim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set WshShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strDOSCall = &quot;%ComSpec% /C &quot;
	
	&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection
	strProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)
	If objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64
		strDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))
	End If
		
	CommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)
	WshShell.Run CommandLine, 0, True
End Function &#039;RunCommand

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
			strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
			strFilePath = strNewSystem32Location&amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
235,Operating System,2015-01-05T20:22:04,",","Returns users (but not groups) who are members of the Local Administrators group on Windows.  Will not list the individual members of groups in the Local Administrators group.
Example: Administrator",1,2060254274,0,467,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Local Administrators Without Groups,,,,,,,,,Windows,"&#039;========================================
&#039; Local Administrators Without Groups
&#039;========================================

&#039; output of membership (individual users but no groups) of Local Administrators
&#039; will not list members of sub-groups

Option Explicit

Dim strMember

For Each strMember In GetLocalAdminAccountsMinusGroups
	WScript.Echo strMember
Next

Function GetLocalAdminAccountsMinusGroups
    Dim objWMIService,strLocalAdminQuery,colItems,objItem,strMembers,strComputerName,arrReturn,i
    Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
    
	&#039; Get Computer Name
    Set colItems = objWMIService.ExecQuery( &quot;Select * from Win32_ComputerSystem&quot;, , 48 )
    For Each objItem in colItems
        strComputerName = objItem.Name
    Next	    
    
    strLocalAdminQuery = &quot;select * from Win32_GroupUser where GroupComponent = &quot; &amp; chr(34) &amp; &quot;Win32_Group.Domain=&#039;&quot; &amp; strComputerName &amp; &quot;&#039;,Name=&#039;Administrators&#039;&quot; &amp; Chr(34)
    
    Set ColItems = objWMIService.ExecQuery(strLocalAdminQuery)
    strMembers = &quot;&quot;
    arrReturn = Array() &#039; set up return array
    i = 0
    For Each objItem In colItems
    	i = i + 1
    	If Not InStr(LCase(objItem.PartComponent),&quot;win32_group.domain&quot;) &gt; 0 Then			
	        Dim strMemberName, NamesArray, strDomainName, DomainNameArray
	        NamesArray = Split(objItem.PartComponent,&quot;,&quot;)
	        strMemberName = Replace(Replace(NamesArray(1),Chr(34),&quot;&quot;),&quot;Name=&quot;,&quot;&quot;)
	        DomainNameArray = Split(NamesArray(0),&quot;=&quot;)
	        strDomainName = Replace(DomainNameArray(1),Chr(34),&quot;&quot;)
	        If strDomainName &lt;&gt; strComputerName Then
	            strMemberName = strDomainName &amp; &quot;\&quot; &amp; strMemberName
	        End If
	        ReDim Preserve arrReturn(UBound(arrReturn) + 1) &#039; increase array by one
	        arrReturn(UBound(arrReturn)) = strMemberName
		End If
    Next
    
    GetLocalAdminAccountsMinusGroups = arrReturn
End Function &#039;GetLocalAdminAccountsMinusGroups",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
236,Network,2015-01-05T20:22:04,|,"Returns any recently closed connection, ie those connection currently in CLOSED_WAIT or TIME_WAIT.  If the process that owned the connection can be determined, it will be included.
Example: Google Chrome | 173.194.79.99:80",1,2074877994,0,469,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Recently Closed Connections,,,,,,,,,Windows,"&#039;========================================
&#039; Recently Closed Connections
&#039;========================================

&#039; Returns all of the connections which are currently in timewait or closewait

Option Explicit

Dim showPort : showPort = True
Dim taniumDebug : taniumDebug = False
Dim strSep : strSep = &quot;|&quot;

Dim excludeProcesses, excludePorts, excludeSubnets

Dim strcommand, results, objWMIService, query, colResults, processes, result, processId
Dim processPath, objShell, objScriptExec, strNetStatResults, line, lineResults, j, i, word
Dim strAppEntry, arrAppEntry, strAppExe, strAppPath, Item

excludeProcesses = Array(&quot;taniumclient.exe&quot;,&quot;taniumreceiver.exe&quot;)
excludePorts = Array(&quot;17472&quot;)
excludeSubnets = Array(&quot;127.0.0.0:255.255.255.0&quot;)


Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
query = &quot;select name, executablepath, processId from win32_process&quot;
Set colResults = objWMIService.ExecQuery(query)

&#039;dictionary for process-app pairs
Set processes = CreateObject(&quot;Scripting.Dictionary&quot;)

For Each result In colResults 
   processId = CStr(result.ProcessId)
   processPath = result.ExecutablePath
   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later
Next

strcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find /V &quot; &amp; Chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34) &amp; &quot; | find /V &quot; &amp; Chr(34) &amp; &quot;ESTABLISHED&quot; &amp; Chr(34)

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strNetStatResults = LCase(objScriptExec.StdOut.ReadAll)

results = Split(strNetStatResults, vbCrLf)

j = 0
For Each line in results
   line = cleanWhitespace(Trim(line))
   
   lineResults = Split(line)
   i = 0
   Dim strPort, strPid, strConnectionType, strForeignIp, arrForeignIp, strIp, strApp
   Dim strLocalIp, arrLocalIp, strLocalPort
   Dim isNotExcludedApp, isNotExcludedSubnet,isNotClientPortUsage
   For Each word In lineResults
      If i = 1 Then
         strLocalIp = word
      ElseIf i = 2 Then
         strForeignIp = word
      ElseIf i = 3 Then
         strConnectionType = word
      ElseIf i = 4 Then
         strPid = word
      End If
      
      i = i + 1
   Next
   
   &#039;DO NOT INCLUDE EXCLUDED APPS
   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path
   arrAppEntry = Split(strAppEntry,&quot;,&quot;)
   strAppExe = arrAppEntry(0)
   strAppPath = arrAppEntry(1)
   
   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))
   
   &#039;DO NOT INCLUDE EXCLUDED SUBNETS
   arrForeignIp = Split(strForeignIp, &quot;:&quot;)
   strIp = arrForeignIp(0)
   strPort = arrForeignIp(1)

   isNotExcludedSubnet = Not(ContainedInSubnet(strIp, excludeSubnets))

   arrLocalIp = Split(strLocalIp, &quot;:&quot;)
   strLocalPort = arrLocalIp(1)

   isNotClientPortUsage = Not(ContainedInArray(strLocalPort, excludePorts)) And Not(ContainedInArray(strPort, excludePorts))
   
   If Not(IsEmpty(strAppExe)) _
      And isNotExcludedApp _ 
      And isNotExcludedSubnet _
      And isNotClientPortUsage Then
	  If Not showPort Then 
		strForeignIp = strIp
	  End If

	  If strPid = &quot;0&quot; Then 
      	  results(j) = &quot;Unknown&quot; &amp; strSep &amp; strForeignIp
      Else 
      	  results(j) = ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIp
      End If 
   Else
      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp
      results(j) = &quot;&quot;   
   End If 
   
   j = j + 1
Next

results = RemDups(results)

If UBound(results) &lt; 1 Then
	If GetLocale() &lt;&gt; 1033 Then
		WScript.Echo &quot;English Language OS Required&quot;
	End If
End If

For Each result In results 
   WScript.Echo result
Next

WScript.Quit

Function ContainedInSubnet(strIp, arr)
   Dim strSubnet, strMask, temp, parts

   For Each item In arr
      If InStr(item, &quot;-&quot;) Then &#039;Subnet range
         temp = Split(item, &quot;-&quot;)
         lower = Split(temp(0), &quot;:&quot;)
         upper = Split(temp(1), &quot;:&quot;)
         lowerSubnet = Trim(lower(0))
         lowerMask = Trim(lower(1))
         upperSubnet = Trim(upper(0))
         upperMask = Trim(upper(1))
         
         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _
            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then
            ContainedInSubnet = True
            Exit Function
         End If 
      Else &#039;Single subnet
         parts = Split(item, &quot;:&quot;)
         strSubnet = Trim(parts(0))
         strMask = Trim(parts(1))
         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then
            ContainedInSubnet = True
            Exit Function
         End If
      End If 
   Next
   ContainedInSubnet = False
End Function

Function ContainedInArray(str, arr)
	Dim strItem
   	For Each strItem In arr 
      If str = strItem Then
         ContainedInArray = True
         Exit Function
      End If   
   Next
   ContainedInArray = False
End Function

Function ContainedInDict(str, dict)
	ContainedInDict = dict.Exists(str)
End Function

Function cleanWhitespace(strStarter)
	Dim intStarter, i, strChars
   	intStarter = Len(strStarter)
   	For i = intStarter to 2 Step -1
      	strChars = Space(i)
      	strStarter = Replace(strStarter, strChars, &quot; &quot;)
   	Next
   	cleanWhitespace = strStarter
End Function

Function RemDups(ByVal anArray)
   Dim d, item, thekeys
   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)
   d.removeall
   d.CompareMode = 0
   For Each item In anArray
      If Len(item) &gt; 0 Then
         If Not d.Exists(item) Then d.Add item, item
      End If
   Next
   thekeys = d.keys
   Set d = Nothing
   RemDups = thekeys
End Function

Function Subnet(strAddress, strMask)
	Dim intSubnetLength
   	intSubnetLength = SubnetLength(strMask)
   	Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))
End Function

Function SubnetLength(strMask)
	Dim strMaskBinary
   	strMaskBinary = StringToBinary(strMask)
   	SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))
End Function

Function BinaryToString(strBinary)
	Dim intOctetPos, strOctetBinary, intOctet, intValue, intBinaryPos
   For intOctetPos = 1 To 4
      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)
      intOctet = 0
      intValue = 1
      For intBinaryPos = 1 To Len(strOctetBinary)
         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue
         intValue = intValue * 2
      Next
      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)
   Next
End Function

Function StringToBinary(strAddress)
	Dim objAddress, strOctet, intOctet, strOctetBinary, x
   	objAddress = Split(strAddress, &quot;.&quot;, -1)
   	For Each strOctet In objAddress
      	intOctet = CInt(strOctet)
      	strOctetBinary = &quot;&quot;
      	For x = 1 To 8
         	If intOctet Mod 2 &gt; 0 Then
            	strOctetBinary = &quot;1&quot; &amp; strOctetBinary
         	Else
            	strOctetBinary = &quot;0&quot; &amp; strOctetBinary
         	End If
         	intOctet = Int(intOctet / 2)
      	Next
      	StringToBinary = StringToBinary &amp; strOctetBinary
   	Next
End Function

Function ProcessNameToApplicationName(strExecutablePath, strExecutableName)
&#039; This function will return the full application name of a running executable

		Dim fso, arrPathParts, strExecutable
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		
		arrPathParts = Split(strExecutablePath,&quot;\&quot;)

		If UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process
			ProcessNameToApplicationName = strExecutableName
			Set fso = Nothing
			Exit Function
		End If
		strExecutable = arrPathParts(UBound(arrPathParts))
		
		If fso.FileExists(strExecutablePath) Then
			Dim execFile, strOutput, fileVersion, fileVersionOutput, fullName
		
			Set execFile = fso.GetFile(strExecutablePath)
			fullName = GetDescription(execFile.ParentFolder.Path, strExecutable)
			If Not fullName = &quot;&quot; Then
				ProcessNameToApplicationName = fullName
			Else
				ProcessNameToApplicationName = strExecutableName
			End If
		Else &#039; file doesn&#039;t exist or inaccessible
			ProcessNameToApplicationName = strExecutableName
		End If

End Function &#039;ProcessNameToApplicationName

Function GetDescription(folderPath, fileName)
	Dim descIndex
	descIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)
	If IsEmpty(descIndex) Then
		descIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)
	End If
	GetDescription = GetFileProperty(folderPath, fileName, descIndex)
End Function

Function GetFileProperty(folderPath, fileName, fileProperty)
	Dim objShell, objFolder
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	GetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)
End Function

Function GetAttributeIndex(folderPath, attrTarget)
	Dim objShell, objFolder, i, attrName
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	For i = 0 to 50
		attrName = objFolder.GetDetailsOf(objFolder.Items, i)
		If LCase(attrName) = LCase(attrTarget) Then
			GetAttributeIndex = i
			Exit Function
		End If
	Next
End Function

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		GetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		GetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;GetTaniumRegistryPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Target IP,IPAddress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
237,Operating System,2015-01-05T20:22:04,",","Last user name entered in the ""Log On to Windows"" dialog box.
Example: tanium_admin",1,2095666087,0,471,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Default Login UserID,,,,,,,,,Windows,"&#039;========================================
&#039; Default Login UserID
&#039;========================================

Dim reg , strComputer
strComputer = &quot;.&quot;
Set reg = Getx64RegistryProvider()

strKeyPath = &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon&quot;
strValueName = &quot;DefaultUserName&quot; 

const HKEY_CURRENT_USER = &amp;H80000001
const HKEY_LOCAL_MACHINE = &amp;H80000002
strComputer = &quot;.&quot;

reg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue
If strValue &lt;&gt; &quot;&quot; Then
	Wscript.Echo strValue
Else
	Wscript.Echo &quot;Default Login User Not Set&quot;
End If
  
Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
238,User,2015-01-05T20:22:04,|,"Provides various properties for users which are currently logged into the machine.
Example: CORP\john.doe | John Doe | john.doe@organization.com",1,2106396979,0,473,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Logged in User Details,,,,,,,,,Windows,"&#039;========================================
&#039; Logged In User Details
&#039;========================================

&#039; This sensor will retrieve various properties of all users which are currently logged in

Option Explicit

Dim intRandomWaitInMilliseconds
intRandomWaitInMilliseconds = 10000
&#039; each client will wait up to 10 seconds to retrieve information from AD to stagger the load

RandomWait(intRandomWaitInMilliseconds)

Dim strSep : strSep = &quot;|&quot;

Dim strReturnedAttribute1 : strReturnedAttribute1 = Trim(Unescape(&quot;givenName&quot;)) &#039; first name
Dim strReturnedAttribute2 : strReturnedAttribute2 = Trim(Unescape(&quot;sn&quot;)) &#039; last name
Dim strReturnedAttribute3 : strReturnedAttribute3 = Trim(Unescape(&quot;proxyAddresses&quot;)) &#039; email addresses as array

&#039;Get the NETBIOS name of the domain
Dim objSystemInfo,strDomain
Set objSystemInfo = CREATEOBJECT(&quot;ADSystemInfo&quot;)

On Error Resume Next
strDomain = objSystemInfo.DomainShortName
On Error Goto 0


&#039; List all users currently logged in

Dim objWMIService,colItems,objItem,strUser,strUserDomain,i

Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;) 
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process Where Name=&#039;explorer.exe&#039;&quot;,,48)

i = 0
For Each objItem in colItems
    objItem.GetOwner strUser, strUserDomain
    i = i + 1
    GetDetails strUser,strUserDomain
Next

If i = 0 Then
    Wscript.Echo &quot;No users logged in&quot;
End If


&#039;&#039; --- helper functions --- &#039;&#039;

Sub GetDetails(strUser,strUserDomain)
&#039; Echo output with attributes
    Dim strDN,emails,strEmail,strPrimaryEmail,strBackupEmail,strOutEmail
    Dim strProperty1,strProperty2
    strDN = getUserDN(strUser,strUserDomain)
    emails = GetAttribute(strDN,strReturnedAttribute3)
    If IsArray(emails) Then &#039; loop through all entries, try to pick primary
        strPrimaryEmail = &quot;&quot;
        strBackupEmail = &quot;&quot;
        strOutEmail = &quot;&quot;
        For Each strEmail In emails
            &#039; primary has SMTP in capital letters
            strBackupEmail = Mid(strEmail,6,Len(strEmail))
            If InStr(strEmail,&quot;SMTP&quot;) = 1 Then
                strPrimaryEmail = Mid(strEmail,6,Len(strEmail))
            End If
        Next
        If strPrimaryEmail &lt;&gt; &quot;&quot; Then
            strOutEmail = strPrimaryEmail
        Else
            strOutEmail = strBackupEmail
        End If
    Else &#039;single entry
        strOutEmail = GetAttribute(strDN,strReturnedAttribute3)
    End If
    
    If strOutEmail = &quot;&quot; Then strOutEmail = &quot;Unknown or Local User&quot;
    strProperty1 = &quot;&quot;
    strProperty2 = &quot;&quot;
    strProperty1 = GetAttribute(strDN,strReturnedAttribute1)
    
    If strProperty1 = &quot;&quot; Then 
        strProperty1 = &quot;Unknown or Local&quot;
        strProperty2 = &quot;User&quot;
    Else
        strProperty2 = GetAttribute(strDN,strReturnedAttribute2)
    End If
        
    WScript.Echo strUserDomain&amp;&quot;\&quot;&amp;strUser&amp;strSep&amp;strProperty1 _
        &amp;&quot; &quot;&amp;strProperty2&amp;strSep&amp;strOutEmail
        
End Sub &#039;GetDetails

Function RandomWait(intWaitTimeInMilliseconds)
&#039; waits a random amount of time
    
    Randomize(TaniumRandomSeed)
    intWaitTimeInMilliseconds = Int( ( intWaitTimeInMilliseconds + 1 ) * Rnd )
    WScript.Sleep(intWaitTimeInMilliseconds)
    
End Function &#039;RandomWait

Function GetAttribute(strDn,strAttribute)
&#039; Returns the AD attribute of a DN
    
    Const E_ADS_PROPERTY_NOT_FOUND  = &amp;h8000500D
    Dim objADObj,attribute
    
    On Error Resume Next
    Set objADObj = GetObject _
        (&quot;LDAP://&quot; &amp; strDn)
    If Err.Number &lt;&gt; 0 Then
        &#039; WScript.Echo &quot;Error: &quot; &amp; Err.Description &amp; &quot; - cannot bind to AD&quot;
    End If
    
    attribute = objADObj.Get(strAttribute)
     
    If Err.Number = E_ADS_PROPERTY_NOT_FOUND Then
        &#039; WScript.Echo &quot;The &quot; &amp; strAttribute &amp; &quot; attribute is not set in AD.&quot;
    Else
        GetAttribute = attribute
    End If
    
    On Error Goto 0
    
End Function &#039;GetAttribute

Function getUserDN(BYVAL strUser,BYVAL strUserDomain)
   &#039; Function to get the distinguished name of a user
   &#039; from the older domain format (domain\user) using
   &#039; name translate
   
    On Error Resume Next
    CONST ADS_NAME_INITTYPE_GC = 3
    CONST ADS_NAME_TYPE_NT4 = 3
    Const ADS_NAME_TYPE_1779 = 1
   
    Dim objTrans
    
    SET objTrans = CREATEOBJECT(&quot;NameTranslate&quot;)
    &#039; Initialize name translate using global catalog
    objTrans.Init ADS_NAME_INITTYPE_GC, &quot;&quot;
    &#039; Input computer name (NT Format)
    objTrans.SET ADS_NAME_TYPE_NT4, strUserDomain &amp; &quot;\&quot; &amp; strUser
    &#039; Get Distinguished Name.
    getUserDN = objTrans.GET(ADS_NAME_TYPE_1779)
    On Error Goto 0
End Function &#039;GetUserDN

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function TaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
    Dim timerNum
    timerNum = Timer()
    If timerNum &lt; 1 Then
        TaniumRandomSeed = (GetTaniumComputerID / Timer() * 10 )
    Else
        TaniumRandomSeed = GetTaniumComputerID / Timer
    End If
End Function &#039;TaniumRandomSeed

Function GetTaniumComputerID
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

    Const HKEY_LOCAL_MACHINE = &amp;H80000002
    
    Dim objReg
    Dim intClientID,strID,strKeyPath,strValueName,dwValue
    
    
    Set objReg=GetObject( _
        &quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp;_ 
        &quot;.\root\default:StdRegProv&quot;)
    strKeyPath = GetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    
    objReg.GetDWORDValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,dwValue
    GetTaniumComputerID = ReinterpretSignedAsUnsigned(dwValue)
    
End Function &#039;GetTaniumComputerID

Function ReinterpretSignedAsUnsigned(ByVal x)
      If x &lt; 0 Then x = x + 2^32
      ReinterpretSignedAsUnsigned = x
End Function &#039;ReinterpretSignedAsUnsigned",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Userid,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Full Name,String,0,1,2,Email Address,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
239,Network,2015-01-05T20:22:04,",","Returns the share path of network shares the host is connected to.
Example: \\\\server\\share",1,2114351169,0,475,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Network Drives Accessed,,,,,,,,,Windows,select RemotePath from Win32_NetworkConnection,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
240,Hardware,2015-01-05T20:22:04,",","The manufacturer of the CPU.
Example: GenuineIntel",1,2130080578,0,477,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,CPU Manufacturer,,,,,,,,,Windows,Select Manufacturer from Win32_Processor,WMIQuery,Linux,"#!/bin/bash
grep -m 1 -i &quot;vendor_id&quot; /proc/cpuinfo | awk -F&quot;: &quot; &#039;{print $2}&#039;
",UnixShell,Mac,"#!/bin/bash
cpu=$(system_profiler SPHardwareDataType | grep &#039;Processor Name&#039; | awk -F&#039;:&#039;  &#039;{split($2,a,&quot; &quot;); print a[1]}&#039;)
if [ &quot;&quot; = &quot;$cpu&quot; ]
then
	echo &quot;Unknown&quot;
else
	echo &quot;$cpu&quot;
fi
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
241,File System,2015-01-05T20:22:04,",","Finds the specified folder and provides the full path if the folder exists on the client machine.
Example: C:\WINDOWS\System32",1,214691664,0,479,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Folder Name Search,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the folder name only to search for."",""value"":"""",""promptText"":""e.g. Program Files"",""defaultValue"":"""",""label"":""Folder name to search for"",""maxChars"":0,""key"":""dirname"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Folder Name Search
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit

SensorRandomize()

Dim Pattern

Pattern = unescape(&quot;||dirname||&quot;)

Const SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1

Dim FSO, WshShell, Drives, Drive, TextStream, OutputFilename

Set FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set WshShell = CreateObject(&quot;WScript.Shell&quot;)

OutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir

&#039; Go through file system, refresh output file for filename
If Not FSO.FileExists(OutputFilename) Then
	
	If FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename

	&#039; Get the collection of local drives.
	Set Drives = FSO.Drives
	For Each Drive in Drives
		If Drive.DriveType = 2 Then &#039; 2 = Fixed drive
			&#039; Run the Dir command that looks for the filename pattern.
			RunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:D /B /S&quot;, OutputFilename,true
		End If
	Next
End If

&#039; Open the output file, echo each line, and then close and delete it.
Set TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)
Do While Not TextStream.AtEndOfStream
	WScript.Echo TextStream.ReadLine()
Loop

TextStream.Close()
 
If FSO.FileExists(OutputFileName) Then
	On Error Resume Next
	FSO.DeleteFile OutputFileName, True
	On Error Goto 0
End If

&#039; Returns the name of a temporary file in the Temp directory.
Function TempName()
	Dim Result
	Do
 		Result = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())
		WScript.Sleep 200 &#039;avoid potential busy loop
	Loop While FSO.FileExists(Result)
	
	TempName = Result
End Function &#039;TempName

&#039; Runs a command with Cmd.exe and redirects its output to a temporary
&#039; file. The function returns the name of the temporary file that holds
&#039; the command&#039;s output.
Function RunCommand(Command, OutputFilename, b64BitNecessary)
	&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32
	Dim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set WshShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strDOSCall = &quot;%ComSpec% /C &quot;
	
	&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection
	strProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)
	If objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64
		strDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))
	End If
		
	CommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)
	WshShell.Run CommandLine, 0, True
End Function &#039;RunCommand

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
			strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
			strFilePath = strNewSystem32Location&amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;dirname&quot;,&quot;promptText&quot;:&quot;e.g. Program Files&quot;,&quot;label&quot;:&quot;Folder name to search for&quot;,&quot;helpString&quot;:&quot;Enter the folder name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||dirname||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;dirname&quot;,&quot;promptText&quot;:&quot;e.g. Program Files&quot;,&quot;label&quot;:&quot;Folder name to search for&quot;,&quot;helpString&quot;:&quot;Enter the folder name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||dirname||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
242,Office,2015-01-05T20:22:04,",","Returns the version of Microsoft Office Outlook installed.
Example: Outlook 2003, Version: 11.0",1,2154864096,0,481,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Outlook Version,,,,,,,,,Windows,"&#039;========================================
&#039; Outlook Version
&#039;========================================

strExe = &quot;outlook.exe&quot;

EchoOutlookVersion(&quot;Software\Microsoft\Office&quot;)

WScript.Echo &quot;Outlook not found&quot;

Function PrintVersionString(strVersion)
	Select Case (Left(strVersion,4))
		Case &quot;10.0&quot;
			WScript.echo &quot;Outlook 2002, Version:&quot; &amp; strVersion
			Exit Function
		Case &quot;11.0&quot;
			WScript.echo &quot;Outlook 2003, Version:&quot; &amp; strVersion
			Exit Function
		Case &quot;12.0&quot; 
			WScript.echo &quot;Outlook 2007, Version:&quot; &amp; strVersion
			Exit Function
		Case &quot;14.0&quot; 
			wscript.echo &quot;Outlook 2010, Version:&quot; &amp; strVersion
			Exit Function
		Case &quot;15.0&quot; 
			wscript.echo &quot;Outlook 2013, Version:&quot; &amp; strVersion
			Exit Function			
	End Select
	WScript.Echo &quot;Unknown Outlook, Version: &quot; &amp; strVersion
End Function

Function EchoOutlookVersion(strKey)
	Dim fso
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	Const HKLM = &amp;h80000002
	strComputer = &quot;.&quot;
	Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	
	If RegKeyExists(reg, HKLM, strKey) Then
&#039;		WScript.Echo &quot;Office Found, attempt to get path&quot;
		
		reg.enumKey HKLM, strKey, subKeys
		
		For Each subKey In subKeys
			If RegKeyExists(reg, HKLM, strKey &amp; &quot;\&quot; &amp; subKey &amp; &quot;\Common\InstallRoot&quot;) Then
				reg.getStringValue HKLM, strKey &amp; &quot;\&quot; &amp; subKey &amp; &quot;\Common\InstallRoot&quot;, &quot;Path&quot;, strPath
				If Not IsNull(strPath) Then
					If fso.FolderExists(strPath) Then
						If fso.FileExists(strPath &amp; &quot;outlook.exe&quot;) Then
							PrintVersionString(fso.GetFileVersion(strPath&amp;&quot;outlook.exe&quot;))
							WScript.Quit
						End If	
					End If
				End If
			End If
		Next
	End If
End Function


Function RegKeyExists(objRegistry, sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
243,User,2015-01-05T20:22:04,",","Returns details about last logins on systems.
Example: user.name      pts/1    192.168.1.2  Thu Nov  8 22:07:30 -0800 2012",1,2177412849,0,483,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Last Logins,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
lastlog | tail -n +2 | grep -v &quot;**Never&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
244,Operating System,2015-01-05T20:22:04,",","Returns the gobal temp directory of the Operating System.
Example: C:\Temp",1,2222730558,0,485,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Operating System Temp Directory,,,,,,,,,Windows,select TempDirectory from win32_BootConfiguration,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
245,Hardware,2015-01-05T20:22:04,",","Returns details about connected displays.
Example:1024 by 768 pixels, True Color, 60 Hertz",1,2265461905,0,487,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:04,Monitor Resolution,,,,,,,,,Windows,select VideoMode from win32_DisplayControllerConfiguration,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Resolution,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Color Mode,String,0,1,2,Refresh Rate,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
246,Active Directory,2015-01-05T20:22:04,",","Returns the short, NetBIOS name of a machine's domain.
Example: CORP",1,2322714946,0,489,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,AD Short Domain,,,,,,,,,Windows,"&#039;========================================
&#039; AD Short Domain
&#039;========================================

Option Explicit
On Error Resume Next 
Dim objSysInfo
Set objSysInfo = CreateObject(&quot;ADSystemInfo&quot;) 

If IsNull(objSysInfo.DomainShortName) Then
	WScript.Echo &quot;N/A&quot;
Else
	WScript.Echo objSysInfo.DomainShortName
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
247,Software,2015-01-05T20:22:04,",","List of database names from SQL Server on client machines.
Example: tanium",1,2344747808,0,491,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,SQL Server Databases,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Server Databases
&#039;========================================

Const adOpenStatic = 3
 Const adLockOptimistic = 3
 Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) 
 Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  
 objConnection.Open _     
 &quot;Provider=SQLOLEDB;Data Source=.;&quot; &amp; _         
 &quot;Trusted_Connection=Yes;Initial Catalog=master;&quot;  
 objRecordSet.Open &quot;select name from master..sysdatabases&quot;, _         
 objConnection, adOpenStatic, adLockOptimistic  
 ObjRecordSet.MoveFirst  
 for each Record in objRecordSet.Properties    
 strValue = objRecordSet(&quot;name&quot;)    
 wscript.echo strValue    
 ObjRecordSet.MoveNext    
 If (ObjRecordset.EOF = True) THEN       
 objRecordset.Close       
 Exit For    
End If 
next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
248,Hardware,2015-01-05T20:22:04,|,"Returns drives and the S.M.A.R.T. status of the drives on machines which have a failing drive reporting through S.M.A.R.T.
Example: Drive | SMART Report",1,2357545787,0,493,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Predicted Disk Failures,,,,,,,,,Windows,"&#039;========================================
&#039; Predicted Disk Failures
&#039;========================================

Option Explicit

Dim strSep

strSep = &quot;|&quot;
&#039; Output is 
&#039; Drive | S.M.A.R.T. Report


ShowSmartAlerts(strSep)

&#039;----------End Main-------------&#039;
Function ShowSmartAlerts(strSep)
	Dim strComputer
    dim objWMI, objInstance, objStatus, strStatus
    
    &#039;Because this could bomb out
    On Error Resume Next

	strComputer = &quot;.&quot;
    Set objWMI = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\WMI&quot;)

    Set objStatus = objWMI.InstancesOf(&quot;MSStorageDriver_FailurePredictStatus&quot;,48)
        For Each objDriveReport in objStatus
        	If objDriveReport.PredictFailure Then
                   WScript.Echo objDriveReport.InstanceName &amp; strSep &amp; objDriveReport.Reason
            End If
        Next

    On Error Goto 0
    
    &#039;Cleanup
    Set objStatus = Nothing
    Set objWMI = Nothing
End Function &#039;ShowSmartAlerts",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Drive,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,S.M.A.R.T. Report,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
249,Operating System,2015-01-05T20:22:04,",","Returns the average CPU load on a Mac or Linux system 
Example: 0.00 0.03 0.10",1,2361722934,0,495,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Load Average,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
line=$(cat /proc/loadavg)
set -- $line
echo $1 $2 $3
",UnixShell,Mac,"#!/bin/bash
uptime | awk -F&#039;: &#039; &#039; /load averages:/ { print $2 } &#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
250,Miscellaneous,2015-01-05T20:22:04,",","The local time on the managed client.
Example: 5:17:44 PM",1,2370758491,0,497,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Client Time,,,,,,,,,Windows,"&#039;========================================
&#039; Client Time
&#039;========================================

&#039; This sensor will return the Time the client thinks it is

Option Explicit

SetLocale(GetTaniumLocale())

WScript.Echo FormatDateTime((Time), 3)

Function GetTaniumLocale() 
    Dim objWshShell, intLocaleID
    
    intLocaleID = &quot;&quot;
    
    Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intLocaleID = objWshShell.RegRead(&quot;HKLM\&quot; &amp; GetTaniumRegistryPath() &amp; &quot;\LocaleID&quot;)
    On Error Goto 0
    If intLocaleID = &quot;&quot; Then
        GetTaniumLocale = 1033 &#039; default to us/English
    Else
        GetTaniumLocale = intLocaleID
    End If

    Set objWshShell = Nothing
End Function &#039; GetTaniumLocale

&#039; get-tanium-regpath.vbs

&#039; Updated to always generate path so that GetTaniumDir can take multiple folder arguments
&#039; Updated to always look for the Path string value and not assume a bogus entry
&#039; in the wrong area is valid.  A valid entry will always have a Path string value
&#039; uses objshell registry reads which should be faster and more reliable

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath",VBScript,Linux,"#!/bin/bash

date &quot;+%r&quot;
",UnixShell,Mac,"#!/bin/bash

date &quot;+%r&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
251,Applications,2015-01-05T20:22:04,",","The version string of applications which match the parameter given.
Example:  11.5.502.146",1,2387001299,0,499,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Installed Application Version,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the application name to search for"",""value"":"""",""promptText"":""e.g. Adobe Flash Player"",""defaultValue"":"""",""label"":""Application Name"",""maxChars"":0,""key"":""application"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Installed Application Version
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039; This sensor will return information in the uninstall areas of the registry.
&#039; it is parameterized and will output the version string for an application that
&#039; matches

SensorRandomize()

strApplicationMatchString = LCase(Trim(Unescape(&quot;||application||&quot;)))

Set objRegistry = Getx64RegistryProvider()
keyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall&quot;
key64Path = &quot;SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall&quot;

Const HKLM = &amp;H80000002
Const HKEY_USERS = &amp;H80000003

&#039; list out 32-bit applications on a 64-bit system
If RegKeyExists(HKLM, key64Path) Then
	objRegistry.EnumKey HKLM, key64Path, arrSubKeys
	GetApplications HKLM,key64path,arrSubKeys
End If

&#039; list out 32-bit applications on a 32-bit system, or 64-bit applications
&#039; on a 64-bit system.
If RegKeyExists(HKLM, keyPath) Then
	objRegistry.EnumKey HKLM, keypath, arrSubKeys
	GetApplications HKLM,keypath,arrSubKeys
End If

&#039; Also list out applications installed to HKEY_Users areas
&#039; which will be appended to the arrSubKeys

objRegistry.EnumKey HKEY_USERS, &quot;&quot;, arrUserKeys
For Each strSIDkey In arrUserKeys
	If RegKeyExists(HKEY_USERS, strSIDKEY&amp;&quot;\&quot;&amp;keyPath) Then
		objRegistry.EnumKey HKEY_USERS, strSIDkey&amp;&quot;\&quot;&amp;keyPath, arrSubKeys
		GetApplications HKEY_USERS,strSIDKey&amp;&quot;\&quot;&amp;keyPath,arrSubKeys
	End If
Next


Function GetApplications(HIVE, keypath,arrSubKeys)
	Set applications = CreateObject(&quot;Scripting.Dictionary&quot;)
	On Error Resume Next
	For Each key in arrSubKeys
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;DisplayName&quot;, displayName
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;DisplayVersion&quot;, version
		objRegistry.GetDWORDValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;SystemComponent&quot;, systemComponent	
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;UninstallString&quot;, uninstallString	
		objRegistry.GetStringValue HIVE,keyPath &amp; &quot;\&quot; &amp; key,&quot;ParentKeyName&quot;, parentKey	
	
		&#039; assume it&#039;s not uninstallable
		bUninstallable = &quot;Not Uninstallable&quot;
				
		If displayName &lt;&gt; &quot;&quot; _
			And Not IsNull(uninstallString) _ 
			And IsNull(parentKey) _
			And InStr(displayName, &quot;Hotfix&quot;) = 0 _
			And InStr(displayName, &quot;Update for&quot;) = 0 _
	 		And InStr(displayName, &quot;Security Update for&quot;) = 0 _
	 	Then 
	 		If InStr(LCase(uninstallString), &quot;msiexec&quot;) Then
	 			&#039; replace any /I with /X and add silent flags
	 			uninstallString = Replace(uninstallString,&quot;/I&quot;,&quot;/X&quot;) &amp; &quot; /qn /noreboot&quot; 
	  			bUninstallable = &quot;Is Uninstallable&quot;
	  		End If
	 		If IsNull(systemComponent) Or systemComponent = 0 Then
				If IsNull(version) Then
					version = GetVersionInString(displayName)
				End If
				&#039; This is a multi-column sensor.  Last two columns are hidden.
				If InStr(LCase(displayName),strApplicationMatchString) &gt; 0 Then
					displayString = version
					If Not applications.Exists(displayString) Then
						applications.Add displayString, &quot;&quot;
					End If 						
				End If
			End If 	
		End If 
	Next
	On Error Goto 0
	
	SortDictionary applications, 1 &#039; This calls a sorting function specific to dictionaries
	arrApplicationsKeys = applications.Keys
	For Each application In arrApplicationsKeys
		&#039; final output of the sensor
		WScript.Echo application
	Next
End Function &#039;GetApplications

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function SortDictionary(objDict, intSort)
 &#039;   objDict - the dictionary to sort
 &#039;   intSort - the field to sort (1=key, 2=item)
 
   &#039; declare constants
   Const dictKey  = 1
   Const dictItem = 2
 
   &#039; declare our variables
   Dim strDict()
   Dim objKey
   Dim strKey,strItem
   Dim X,Y,Z
 
   &#039; get the dictionary count
   Z = objDict.Count
 
   &#039; we need more than one item to warrant sorting
   If Z &gt; 1 Then
     &#039; create an array to store dictionary information
     ReDim strDict(Z,2)
     X = 0
     &#039; populate the string array
     For Each objKey In objDict
         strDict(X,dictKey)  = CStr(objKey)
         strDict(X,dictItem) = CStr(objDict(objKey))
         X = X + 1
     Next
 
     &#039; perform a a shell sort of the string array
     For X = 0 To (Z - 2)
       For Y = X To (Z - 1)
         If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) &gt; 0 Then
             strKey  = strDict(X,dictKey)
             strItem = strDict(X,dictItem)
             strDict(X,dictKey)  = strDict(Y,dictKey)
             strDict(X,dictItem) = strDict(Y,dictItem)
             strDict(Y,dictKey)  = strKey
             strDict(Y,dictItem) = strItem
         End If
       Next
     Next
 
     &#039; erase the contents of the dictionary object
     objDict.RemoveAll
 
     &#039; repopulate the dictionary with the sorted information
     For X = 0 To (Z - 1)
       objDict.Add strDict(X,dictKey), strDict(X,dictItem)
     Next
 
   End If
 End Function &#039;SortDictionary

Function GetVersionInString(ByVal strTemp)
&#039; examines a string and returns a version string at the end of it
	Dim strOut
	strOut = &quot;&quot;
	If Not IsNull(strTemp) Then
		strTemp = StrReverse(strTemp)
		Dim strLookAtChar,intCurPos
		Dim bNumbersStartMarked : bNumbersStartMarked = False

		For intCurPos = 1 To Len(strTemp)		
			strLookAtChar = Mid(strTemp,intCurPos,1)
			If IsNumeric(strLookAtChar) Or strLookAtChar = &quot;.&quot; Or strLookAtChar = &quot;-&quot; Then
				bNumbersStartMarked = True
				strOut = strOut &amp; strLookAtChar
			End If
		If bNumbersStartMarked And ( (Not IsNumeric(strLookAtChar) And strLookAtChar &lt;&gt; &quot;.&quot; And strLookAtChar &lt;&gt; &quot;-&quot;) ) Then
			Exit For
		End If	
		Next
		strOut = StrReverse(strOut)
	Else
		strOut = &quot;&quot;
	End If
	
	If Len(strOut) = 0 Then strOut = &quot;N/A&quot;
	
	GetVersionInString = strOut
	
End Function &#039;GetVersionInString

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/bash
############################################
## Script Name: application_version.sh	            ##
## Created: 16 MAR 2014			            ##
## Author: James Hoscheit - Tanium                      ##
##              &lt;james.hoscheit@tanium.com&gt;	            ##
##              Egon Rinderer - Tanium                          ##
##              &lt;egon.rinderer@tanium.com&gt;               ##
## Purpose: To query an application version on   ##
##                  a Linux system.	                          ##
############################################


file=&quot;||application||&quot;

#if [ &quot;$#&quot; -eq &quot;0&quot; ]
#then
#	exit 1
#else
#	file=$1
#fi

if [ -f /bin/rpm ] #rpm based solutions
then
	installedPkg=`rpm -q $file`
	if [ `echo $installedPkg | grep -v &#039;not installed&#039; | grep -c $file` -gt 0 ]
	then
		echo $installedPkg | awk -F&#039;el&#039; &#039;{print $1}&#039; | awk -F&#039;-&#039; &#039;{print $2}&#039;
	else
		echo &quot;not installed&quot;
	fi

elif [ -f /usr/bin/apt-get ] #.deb based solutions
then
	installedPkg=`dpkg -l $file 2&gt;/dev/null`
	installedPkg2=`echo $installedPkg | sed &#039;s/^.*=== /ii.*$/&#039;`
	if [ `echo $installedPkg2 | egrep -c &#039;^ii&#039;` -gt 0 ]
	then
		echo $installedPkg2 | egrep &#039;^ii&#039; | awk &#039;{print $3}&#039;
	else
		echo &quot;not installed&quot;
	fi
else
	echo &quot;unknown Linux installed&quot;
fi
",UnixShell,Mac,"#!/bin/bash
############################################
## Script Name: application_version.sh	            ##
## Created: 16 MAR 2014			            ##
## Author: James Hoscheit - Tanium                      ##
##              &lt;james.hoscheit@tanium.com&gt;	            ##
##              Egon Rinderer - Tanium                          ##
##              &lt;egon.rinderer@tanium.com&gt;               ##
## Purpose: To query an application version on   ##
##                  a Mac system.	                          ##
############################################

version=`system_profiler SPApplicationsDataType | grep -i -A2 &quot;||application||&quot; | grep &quot;^ *Version&quot; | awk -F&#039;: &#039; &#039;{print $2}&#039;`

if [ ${#version} -eq 0 ]
then
     echo &quot;Not installed&quot;
else
     echo $version
fi
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
252,Hardware,2015-01-05T20:22:04,",","Describes the architecture of the CPU/processor.
Example: i386, X86-based PC",1,2463256440,0,501,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,CPU Architecture,,,,,,,,,Windows,Select SystemType from Win32_ComputerSystem,WMIQuery,Linux,"#!/bin/bash
arch
",UnixShell,Mac,"#!/bin/bash
arch
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
253,Registry,2015-01-05T20:22:04,",","Returns True if the Registry Key exists, False if not.",1,2490353155,0,503,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Registry Key Exists,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{5}"",""helpString"":""Value must be at least 5 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the registry key to query"",""value"":"""",""promptText"":""e.g. HKEY_USERS\\Software\\Key"",""defaultValue"":"""",""label"":""Registry Key"",""maxChars"":0,""key"":""strKey"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Registry Key Exists
&#039;========================================

&#039;Columns:
&#039; User | Subkey Name | Architecture | KeyPath

strKey = unescape(&quot;||strKey||&quot;)

&#039;strKey = &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Tanium\Tanium Server&quot;
&#039;strKey = &quot;HKEY_CURRENT_USER\Software\TortoiseSVN&quot;

strSep = &quot;|&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive


&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)
If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = RegKeyExists(objReg, constHive, strFullUserKey)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = RegKeyExists(objReg, constHive, strKey)
	If hasValues32 Then hasAnyResult = True
End If

If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = RegKeyExists(objReg, constHive, strFullUserKey)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive	
		hasValues64 = RegKeyExists(objReg, constHive, strKey)
		If hasValues64 Then hasAnyResult = True	
	End If
End If

If (hasAnyResult) Then
	WScript.Echo &quot;True&quot;
Else
	WScript.Echo &quot;False&quot;
End If

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\Software\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\Software\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
254,Hardware,2015-01-05T20:22:04,",","Name of the default printer.
Example: HP Color LaserJet 3500",1,2505938414,0,505,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Default Printer,,,,,,,,,Windows,Select DriverName from Win32_Printer Where Default = True,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
255,Active Directory,2015-01-05T20:22:04,",","The full Active Directory distinguished name for the computer
Example: CN=Win8-test5,CN=Computers,DC=corp,DC=com",1,2513829483,0,507,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:04,AD Distinguished Name,,,,,,,,,Windows,"&#039;========================================
&#039; AD Distinguished Name
&#039;========================================


&#039; Returns a single column value
&#039; Only checks a single registry context

Const GPKey = &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy&quot;
Dim strSubKey,strValue,strSep,strKey,words,strHive,constHive,hasValues32,hasAnyResult
Dim hasValues64,strUserKey,strFullUserKey,bEchoOnlyValue
Dim objCtx,objReg,bSkipSecondCheckOverride

bEchoOnlyValue = True
bSkipSecondCheckOverride = True &#039; Check in one place
strSubKey = &quot;\DataStore\Machine\0&quot;
strValue = &quot;DNName&quot;
strSep = &quot;~~&quot;

strKey = GPKey&amp;strSubKey

&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
   For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
         strUserName = GetUserForSIDLocal(objReg,strUserKey)
         If strUserName = False Then strUserName = strUserKey
         strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
         hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
         If hasValues32 Then hasAnyResult = True
      End If
   Next
Else &#039; was another hive
   hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
   If hasValues32 Then hasAnyResult = True
End If

&#039; Do not return second value set in different context unnecessarily
Dim strKeyPrefix,bSkipSecondContextCheck
bSkipSecondContextCheck = False
strKeyPrefix = Split(strKey,&quot;\&quot;)(0) &#039; Software, for instance, even for HEKY_USERS

Select Case Ucase(strKeyPrefix)
   Case &quot;SOFTWARE&quot;
      If bSkipSecondCheckOverride Then
         bSkipSecondContextCheck = True
      Else
         bSkipSecondContextCheck = False
      End If
   Case Else
      bSkipSecondContextCheck = True
End Select

If Is64 And Not bSkipSecondContextCheck Then
   Set objCtx = GetObjCtx(64)
   Set objReg = GetObjReg(objCtx)
   If strHive = &quot;HKEY_USERS&quot; Then
   &#039; go through each User&#039;s hive in 64-bit context
      For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
            strUserName = GetUserForSIDLocal(objReg,strUserKey)
            If strUserName = False Then strUserName = strUserKey
            strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
            hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
            If hasValues64 Then hasAnyResult = True   
         End If
      Next
   Else &#039; was another hive
      hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
      If hasValues64 Then hasAnyResult = True
   End If
End If

If Not (hasAnyResult) Then
   WScript.Echo &quot;Key/Value not found&quot;
End If

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

   Dim Inparams, Outparams,arrNames,arrTypes,i,strValueName
   Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
   Inparams.Hdefkey = constHive
   Inparams.sSubkeyname = strKey
   Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
   
   arrNames = Outparams.sNames
   arrTypes = Outparams.Types

   If Not IsNull(arrNames) Then
      For i = LBound(arrNames) To UBound(arrNames)
         strValueName = arrNames(i)
         
         &#039;if strValue is found, echo
         If LCase(strValueName) = LCase(strValue) Then
            EchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit, bEchoOnlyValue
            CheckValues = True
            Exit Function
         End If
      Next
   End If
   CheckValues = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit, bEchoOnlyValue)
   Dim strArch
   If intBit = 64 Then
      strArch = &quot;64-bit&quot;
   Else
      strArch = &quot;32-bit&quot;
   End If
   If bEchoOnlyValue Then
      GetDisplayString = strValue
   Else
      GetDisplayString = _
         strValue &amp; strSep &amp; _
         strType &amp; strSep &amp; _
         strArch
   End If
End Function

Function EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit, bOnlyValueData)
   &#039; Note the key that was being searched, will be a hidden column
   Dim strOutputKey
   strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
   
   Dim objInParams, objOutParams
   Select Case constType
      Case REG_SZ  
         Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters
         objInParams.hDefKey = constHive
         objInParams.sSubKeyName = strKey
         objInParams.sValueName = strValue         
         Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            WScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)
         Else
            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_EXPAND_SZ
         Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters
         objInParams.hDefKey = constHive
         objInParams.sSubKeyName = strKey
         objInParams.sValueName = strValue         
         Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            WScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)
         Else  
            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_BINARY
         Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters
         objInParams.hDefKey = constHive
         objInParams.sSubKeyName = strKey
         objInParams.sValueName = strValue         
         Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)

         strBytes = &quot;&quot;
         For Each uByte in objOutParams.uValue
            strTemp = Hex(uByte)
            If Len(strTemp) &lt; 2 Then
               strTemp = &quot;0&quot; &amp; strTemp
            End If   
            strBytes = strBytes &amp; strTemp &amp; &quot; &quot;
         Next
         If bOnlyValueData Then
            WScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)
         Else
            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit, bOnlyValueData) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If         
      Case REG_DWORD
          Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
          objInParams.hDefKey = constHive
          objInParams.sSubKeyName = strKey
          objInParams.sValueName = strValue
          Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            WScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)
         Else     
            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_QWORD
          Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters
          objInParams.hDefKey = constHive
          objInParams.sSubKeyName = strKey
          objInParams.sValueName = strValue
          Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)
         If bOnlyValueData Then
            WScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)
         Else     
            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit) _
               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
         End If
      Case REG_MULTI_SZ
          Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters
          objInParams.hDefKey = constHive
          objInParams.sSubKeyName = strKey
          objInParams.sValueName = strValue
          Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)
      
         arrValues = objOutParams.sValue
         strResponse = &quot;&quot;

         For Each strTemp In arrValues
            If bOnlyValueData Then
               WScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit, bOnlyValueData)
            Else
               WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit) _
                  &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue
            End If
         Next

   End Select
End Function


Function GetObjCtx(intArch)
   Dim objCtx
   Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
   objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
   objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
   Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
   Dim objLocator, objServices
   Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
   Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
   Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
   Dim Inparams, Outparams
   Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
   Inparams.Hdefkey = constHive
   Inparams.sSubkeyname = strKey
   Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
   GetSubKeys = Outparams.sNames
End Function

Function Is64 
   Dim objWMIService, colItems, objItem
   Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
   Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
   For Each objItem In colItems
      If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
         Is64 = True
      Else
         Is64 = False
      End If      
   Next
End Function


Function GetHiveConst(hive)
   Const HKEY_CLASSES_ROOT   = &amp;H80000000
   Const HKEY_CURRENT_USER   = &amp;H80000001
   Const HKEY_LOCAL_MACHINE  = &amp;H80000002
   Const HKEY_USERS          = &amp;H80000003

   Select Case UCase(hive)
      Case &quot;HKLM&quot;
         GetHiveConst = HKEY_LOCAL_MACHINE
      Case &quot;HKEY_LOCAL_MACHINE&quot;
         GetHiveConst = HKEY_LOCAL_MACHINE
      Case &quot;HKCR&quot;
         GetHiveConst = HKEY_CLASSES_ROOT
      Case &quot;HKEY_CLASSES_ROOT&quot;
         GetHiveConst = HKEY_CLASSES_ROOT
      Case &quot;HKEY_CURRENT_USER&quot;
         GetHiveConst = HKEY_CURRENT_USER
      Case &quot;HKEY_USERS&quot;
         GetHiveConst = HKEY_USERS
   End Select
   
   If IsEmpty(GetHiveConst) Then
      WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
      WScript.Quit
   End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

   Const HKLM = &amp;h80000002
   
   Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
   
   strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
   objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
   If Not IsNull(strUserData) Then
   &#039; strUserData would look like
   &#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
      intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
      &#039; strip off the dat file
      If intDatPos &gt; 0 Then &#039; must be in string
         strUserData = Left(strUserData,intDatPos - 1)
         &#039; find last backslash
         intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
         &#039; get right from that pos
         strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
         GetUserForSIDLocal = strUserData
      Else
         strUserData = False
      End If
   Else
      GetUserForSIDLocal = False
   End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
256,Hardware,2015-01-05T20:22:04,",","Returns System or Motherboard manufacturer (OS Dependent).
Example: Apple",1,2542613392,0,509,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Manufacturer,,,,,,,,,Windows,select Manufacturer from win32_baseboard,WMIQuery,Linux,"#!/bin/bash
dmidecode -s system-manufacturer
",UnixShell,Mac,"#!/bin/bash
echo Apple
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
257,Operating System,2015-01-05T20:22:04,",","Returns a list of hotfixes that have previously been applied to the client machine.
Example: Microsoft National Language Support Downlevel APIs",1,254407409,0,511,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Installed HotFixes,,,,,,,,,Windows,Select Description from Win32_QuickFixEngineering,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
258,Miscellaneous,2015-01-05T20:22:04,",","A parameterized Sensor that allows an operator to search for a particular string in the Windows application event logs.
Example: The Apache service reported the following error: [Tue Jan 01 17:14:24 2010] [warn] PassEnv variable CommonProgramFiles(x86) was undefined",1,2574398281,0,513,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Application Event Log Search,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the event string to search for"",""value"":"""",""promptText"":""e.g. terminated unexpectedly"",""defaultValue"":"""",""label"":""Event string to search for"",""maxChars"":0,""key"":""EVENT"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,select Message from Win32_NTLogEvent where LogFile = &#039;Application&#039; and Message like &#039;%||EVENT||%&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$432000$$&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;EVENT&quot;,&quot;promptText&quot;:&quot;e.g. terminated unexpectedly&quot;,&quot;label&quot;:&quot;Event string to search for&quot;,&quot;helpString&quot;:&quot;Enter the event string to search for&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||EVENT||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;EVENT&quot;,&quot;promptText&quot;:&quot;e.g. terminated unexpectedly&quot;,&quot;label&quot;:&quot;Event string to search for&quot;,&quot;helpString&quot;:&quot;Enter the event string to search for&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||EVENT||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
259,Hardware,2015-01-05T20:22:04,",","Returns the motherboard product name of a system.
Example: 440BX Desktop Reference Platform",1,2595849133,0,515,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Motherboard Name,,,,,,,,,Windows,select Product from win32_baseboard,WMIQuery,Linux,"#!/bin/bash
dmidecode -s baseboard-product-name
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
260,Microsoft Forefront,2015-01-05T20:22:04,",","Indicates the time in days since the last time the Forefront client signatures were checked by Forefront.
Example: 2",1,2606734477,0,517,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Forefront Client Signatures Last Checked Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signatures Last Checked Days Old
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue
	
	If Not IsNull(binValue) Then
		words = Split(BinaryToDate(binValue))
		WScript.Echo GetDaysOld(words(0))
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
End If

&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	patternDate = CDate( strDate )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
261,Hardware,2015-01-05T20:22:04,",","Amount of RAM in the video card in the client machine.
Example: 256MB",1,2607823237,0,519,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Video Graphics Card RAM,,,,,,,,,Windows,"&#039;========================================
&#039; Video Graphics Card RAM
&#039;========================================

&#039; This sensor will return the amount of video RAM a machine 
&#039; has in each card, in Megabytes

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_VideoController&quot;,,48)

For Each objItem in colItems
	If Not isNull(objItem.AdapterRAM) Then
		WScript.Echo CLng((objItem.AdapterRAM /1024)/1024) &amp; &quot;MB&quot;
	End If
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
262,Operating System,2015-01-05T20:22:04,",","Returns Enabled or Disabled based on the status of Windows User Access Control on the client machine.
Example: Enabled",1,2614767778,0,521,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,UAC Status,,,,,,,,,Windows,"&#039;========================================
&#039; UAC Status
&#039;========================================
&#039; This will determine whether UAC is on or off

Option Explicit

WScript.Echo GetUACStatus

Function GetUACStatus
&#039; This function uses the correct way to access 64-bit registry
&#039; in a 32-bit context to query a single registry value and
&#039; Determine if UAC is on
	
	Dim objReg, objCtx
	Dim strUACRegKey, strUACRegVal, strUACStatus
	
	Const HKLM = &amp;H80000002
	
	If Is64 Then
		Set objCtx = GetObjCtx(64)
		Set objReg = GetObjReg(objCtx)
	Else
		Set objCtx = GetObjCtx(32)
		Set objReg = GetObjReg(objCtx)
	End If

	strUACRegKey = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System\&quot;
	strUACRegVal = &quot;EnableLua&quot;
	
		&#039;RegKeyExists Example
	If RegKeyExists(objReg, HKLM, strUACRegKey) Then
		strUACStatus = CStr(GetDwordValue(objReg, HKLM, strUACRegKey, strUACRegVal))
		
		If strUACStatus = &quot;1&quot; Then 
			GetUACStatus = &quot;Enabled&quot;
		ElseIf strUACStatus = &quot;0&quot; Then
			GetUACStatus = &quot;Disabled&quot;
		Else
			GetUACStatus = &quot;UAC Not Applicable to this OS&quot;
		End If		
	Else
		GetUACStatus = &quot;Pre-UAC OS&quot;
	End If
	
	&#039; Cleanup
	Set objReg = Nothing
	Set objCtx = Nothing
End Function &#039;GetUACStatus

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
	&#039; Cleanup
	Set objWMIService = Nothing
	Set colItems = Nothing
End Function &#039;Is64


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function &#039;GetObjCtx

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function &#039;GetObjReg

Function RegKeyExists(objReg, constHive, strKey)
	Dim objNames, objTypes, objValues, Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams)
	
	If Outparams.ReturnValue = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
	&#039; Cleanup
	Set Inparams = Nothing
	Set Outparams = Nothing		
End Function &#039;RegKeyExists

Function GetDWordValue(objReg, constHive, strKey, strValue)
	Dim objInParams, objOutParams
    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
    objInParams.hDefKey = constHive
    objInParams.sSubKeyName = strKey
    objInParams.sValueName = strValue
    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams)
	If Not IsNull(objOutParams) Then
		If Not IsNull(objOutParams.uValue) Then
			GetDWordValue = CStr(objOutParams.uValue)
		End If
	End If
	&#039; Cleanup
	Set objInParams = Nothing
	Set objOutParams = Nothing
End Function &#039;GetDWordValue",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
263,Operating System,2015-01-05T20:22:04,",","Returns true if the machine is part of an Active Directory domain.
Example: TRUE, FALSE",1,2620257697,0,523,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Domain Member,,,,,,,,,Windows,select PartofDomain from win32_ComputerSystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
264,Network,2015-01-05T20:22:04,",","Returns the current total throughput, in KB/Sec, of the network interface used to connect to the tanium server.
Example: 2048 KB/S",1,2623590847,0,525,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Network Throughput Total,,,,,,,,,Windows,"&#039;========================================
&#039; Network Throughput Total
&#039;========================================

&#039; This sensor will use windows performance counters
&#039; and attempt to retrieve network traffic information
&#039; only for the interface being used to connect to the tanium server
&#039; results are in kilobytes per second

Option Explicit

Dim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress
Dim strComputer: strComputer = &quot;.&quot;


Dim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString
Dim objWMIService, colItems, objItem

&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address
&#039; out of WMI.  Because Name is the closest thing to match the Description
&#039; field in the performance counter, but it&#039;s not exact due to how some
&#039; characters are displayed, we will remove troublesome characters
&#039; and attempt to match on that

&#039; Since the entire sensor&#039;s output depends on if the two strings match, we
&#039; can set the one string to something it won&#039;t match on (because _) to be safe
strDescriptionToMatch = &quot;_ImpossibleToMatch&quot;

Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)
For Each objItem In colItems
	For Each strIPAddress In objItem.IPAddress
		If strIPAddress = strTaniumIPAddress Then
			&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress
			strDescriptionToMatch = CleanString(objItem.Description)
			&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch
		End If
	Next
Next

Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)

For Each objItem in colItems
	strNameToMatch = CleanString(objItem.Name)
	&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch
	If LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then
		&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch
		&#039; We can now report bandwidth
		strFinalOutputString = FormatNumber(objItem.BytesTotalPersec / 1024,0,-1) &amp; &quot; KB/S&quot;
	End If
Next

If strFinalOutputString = &quot;&quot; Then
	&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client
	WScript.Echo &quot;Cannot determine which adapter to measure&quot;
Else 
	WScript.Echo strFinalOutputString
End If


&#039; Cleanup
Set objWMIService = Nothing
Set colItems = Nothing 
Set objItem = Nothing

&#039;&#039; End Main Line

&#039;&#039; Helper Functions
Function CleanString(strInput)
&#039; This function will remove non-alphanumeric characters
	Dim objRegEx
	
	Set objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)
	
	objRegEx.Global = True   
	objRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;
	CleanString = objRegEx.Replace(strInput, &quot;&quot;)
	
	Set objRegEx = Nothing
End Function &#039;CleanString

Function GetTaniumIPAddress
&#039; Modified from the ua-scan code to remove the subnet and last octet calculations
&#039; which are irrelevant for these purposes.
&#039; Returns the IP address that the client uses for Tanium activity
&#039; (talking to server and other clients)

	Dim strComputer, objReg, strCommand, objShell, objScriptExec
	Dim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords
	Dim strIPAddress, strTaniumPath, strClientAddress
	Dim strServerName
	
	strComputer = &quot;.&quot;
	Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	Const HKLM = &amp;h80000002
	
		
	&#039;&#039;###########Get Tanium Key on 64/32bit computers##########
	
	strTaniumPath = GetTaniumRegistryPath()
	
	
	&#039; if we can pull this from the registry (newer client version), just use that
	objReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\Status&quot;, &quot;ClientAddress&quot;, strClientAddress
	If strClientAddress &lt;&gt; &quot;&quot; Then
		strClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)
		strClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))
		&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;
		GetTaniumIPAddress = strClientAddress
		&#039;Cleanup
		Set objReg = Nothing
		Exit Function
	End If
	
	&#039;Otherwise use PathPing to determine client IP used by Tanium

	&#039;&#039;# Read the ServerName value

	objReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName

	strCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	strResults = objScriptExec.StdOut.ReadAll
	
	arrPathPingLines = Split(strResults, vbCrLf)
	For Each strPathPingLine In arrPathPingLines
		arrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)
		If UBound(arrPathPingWords) &gt; 0 Then
			If arrPathPingWords(0) = &quot;0&quot; Then
				strIPAddress = arrPathPingWords(1)
				Exit For
			End If
		End If	
	Next
	
	Set objShell = Nothing
	Set objScriptExec = Nothing
	Set objReg = Nothing

	If Not IsNull(strIPAddress) Then
		GetTaniumIPAddress = strIPAddress
	Else
		GetTaniumIPAddress = False
	End If
End Function &#039;GetTaniumIPAddress

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function CleanWhitespace(strStarter)
	Dim intStarter, i, strChars
	intStarter = Len(strStarter)
	For i = intStarter to 2 Step -1
		strChars = Space(i)
		strStarter = Replace(strStarter, strChars, &quot; &quot;)
	Next
	CleanWhitespace = strStarter
End Function &#039;CleanWhiteSpace",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
265,Network,2015-01-05T20:22:04,",","Returns data about percent of packet loss on Windows machines.
Example: 5 %",1,2648511780,0,527,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Packet Loss,,,,,,,,,Windows,"&#039;========================================
&#039; Packet Loss
&#039;========================================

&#039; This sensor looks at TCP-level performance counters and
&#039; does some basic math to determine a packet loss percentage


Option Explicit

Dim objWMIService,colItems
Dim objItem,strFinalOutputString

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_TCPv4&quot;,,48)

For Each objItem in colItems
	If (objItem.SegmentsRetransmittedPersec &gt; 0 AND objItem.SegmentsPerSec &gt; 0) Then
		strFinalOutputString = FormatNumber(objItem.SegmentsRetransmittedPersec / objItem.SegmentsPerSec * 100,0,-1) &amp; &quot; %&quot;
		WScript.Echo strFinalOutputString
	Else
		WScript.Echo &quot;Cannot determine packet loss&quot;
	End If
	
Next

&#039; Cleanup
Set objWMIService = Nothing
Set colItems = Nothing 
Set objItem = Nothing",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
266,User,2015-01-05T20:22:04,|,"Returns local accounts and number of days ago that the password was changed.
Example:
user.name|19",1,2680423840,0,529,1,Jim Olsen,900,,,,2015-01-05T20:22:04,Local Account Last Password Change Days Ago,,,,,,,,,Windows,"&#039;========================================
&#039; Local Account Last Password Change Days Ago
&#039;========================================


Option Explicit

Dim objAccounts,objUser,dtmLastPasswordChangeDate,intDaysSince
Dim strChangeDate,strSep


strSep = &quot;|&quot;
&#039; Multi-column output
&#039; Account Name|Days Since Last Password Change
SetLocale(1033) &#039;Uses RFC822, requires US/English

On Error Resume Next

Set objAccounts = GetObject(&quot;WinNT://.&quot;)
objAccounts.Filter = Array(&quot;User&quot;)

For Each objUser In objAccounts
	On Error Resume Next
	dtmLastPasswordChangeDate = GetObject(&quot;WinNT://./&quot;&amp;objUser.Name).PasswordAge
	If IsNull(objUser.PasswordAge) Then
		Wscript.Echo objUser.Name&amp;strSep&amp;&quot;N/A&quot;
	Else
		dtmLastPasswordChangeDate = DateAdd(&quot;s&quot;, -objUser.PasswordAge, Now())
		intDaysSince = Abs(DateDiff(&quot;d&quot;,Now(),dtmLastPasswordChangeDate))
		strChangeDate = vbTimeToRFC822(dtmLastPasswordChangeDate,GetRFC822Bias)
		On Error Resume Next
		If objUser.PasswordAge = 0 Then
			intDaysSince = &quot;Never&quot;
		End If
		On Error Goto 0
		Wscript.Echo objUser.Name&amp;strSep&amp;intDaysSince
	End If
Next



Function vbTimeToRFC822(myDate, offset)
&#039;SetLocale outside of function in global scope
&#039; must be set so that month is displayed with US/English abbreviations
&#039; as per the standard

	If Not GetLocale = 1033 Then
		WScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;
		WScript.Quit
	End If
   Dim myDay, myDays, myMonth, myYear
   Dim myHours, myMinutes, myMonths, mySeconds

   myDate = CDate(myDate)
   myDay = WeekdayName(Weekday(myDate),true)
   myDays = zeroPad(Day(myDate), 2)
   myMonth = MonthName(Month(myDate), true)
   myYear = Year(myDate)
   myHours = zeroPad(Hour(myDate), 2)
   myMinutes = zeroPad(Minute(myDate), 2)
   mySeconds = zeroPad(Second(myDate), 2)

   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _
                                  myDays&amp;&quot; &quot;&amp; _
                                  myMonth&amp;&quot; &quot;&amp; _ 
                                  myYear&amp;&quot; &quot;&amp; _
                                  myHours&amp;&quot;:&quot;&amp; _
                                  myMinutes&amp;&quot;:&quot;&amp; _
                                  mySeconds&amp;&quot; &quot;&amp; _ 
                                  offset
End Function &#039;vbTimeToRFC822


Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function

Function GetRFC822Bias
&#039; This function returns a string which is a 
&#039; timezone bias for RFC822 format
&#039; considers daylight savings
&#039; we choose 4 digits and a sign (+ or -)

	Dim objWMIService,colTimeZone,objTimeZone
	
	Dim intTZBiasInMinutes,strSign,strReturnString

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
	 
	For Each objTimeZone in colTimeZone
	    intTZBiasInMinutes = objTimeZone.CurrentTimeZone
	Next

	&#039; The offset is explicitly signed
	If intTZBiasInMinutes &lt; 0 Then
		strSign = &quot;-&quot;
	Else
		strSign = &quot;+&quot;
	End If
	
	strReturnString = CStr(Abs(intTZBiasInMinutes))
	&#039; no offset is greater than three digits but RFC822 bias seems to
	&#039; usually take the form of 1 alpha / 4 digit as described as 
	&#039; valid in ANSI X3.51-1975

	strReturnString = zeroPad(strReturnString,4)

	GetRFC822Bias = strSign&amp;strReturnString
	
	&#039;Cleanup
	Set colTimeZone = Nothing
	Set objWMIService = Nothing
	
End Function &#039;GetRFC822Bias",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Account Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Days Since Last Password Change,NumericInteger,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
267,PowerShell,2015-01-05T20:22:04,",","Returns the version(s) of PowerShell installed on a system
Example: 2.0",1,2704923764,0,531,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,PowerShell Version,,,,,,,,,Windows,"&#039;========================================
&#039; PowerShell Version
&#039;========================================

Option Explicit

Const HKEY_LOCAL_MACHINE = &amp;H80000002 
Dim objReg
Dim strKeyPath,arrValueNames,arrValueTypes,i,strValue,strValue3,strKey3Path
Dim bV1orV2NotFound, bV3NotFound

Set objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp;_  
	&quot;.\root\default:StdRegProv&quot;)
strKeyPath = &quot;Software\Microsoft\PowerShell\1\PowerShellEngine&quot;
strKey3Path = &quot;Software\Microsoft\PowerShell\3\PowerShellEngine&quot;

&#039; for powershell 1 or 2
objReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,&quot;PowerShellVersion&quot;,strValue
bV1orV2NotFound = False
If Not IsNull(strValue) Then
	Select Case strValue
		Case &quot;1.0&quot;
			WScript.Echo strValue
		Case &quot;2.0&quot;
			WScript.Echo strValue 
		Case Else
			bV1orV2NotFound = True
	End Select
End If

bV3NotFound = False
&#039; for powershell 3.0
objReg.GetStringValue HKEY_LOCAL_MACHINE,strKey3Path,&quot;PowerShellVersion&quot;,strValue3
If Not IsNull(strValue3) Then
	Select Case strValue3
		Case &quot;3.0&quot;
			WScript.Echo strValue3
		Case Else
			bV3NotFound = True
	End Select
End If
	 
If (bV1orV2NotFound And bV3NotFound) Or ( IsNull(strValue) And IsNull(strValue3) ) Then 
	WScript.Echo &quot;PowerShell Not Installed&quot;
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
268,Hardware,2015-01-05T20:22:04,",","Returns printers which are not connected via Network
Example: HP LaserJet 4400c",1,2706539957,0,533,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Local Printers,,,,,,,,,Windows,Select DriverName from Win32_Printer where Network = False,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
269,Tanium Diagnostics,2015-01-05T20:22:04,|,"Returns the Forward Peers and Backwards Peers returned by the server with which the client should communicate.
Example: 10.0.0.1:17472, 10.0.02:17472 | 10.0.0.10:17472",1,2735360016,0,535,1,Jim Olsen,600,,,,2015-01-05T20:22:04,Tanium Client Neighborhood,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Neighborhood List
&#039;========================================

Option Explicit

Const INCLUDE_PORTS = False

Dim strClientIPAddress, strNeighborhoodList
Dim arrIPs, strIP, strPort, bReachedMe, strBackwards, strForwards

strClientIPAddress = Trim(GetClientIPAddress())
strNeighborhoodList = Trim(GetNeighborhoodList())

If(strClientIPAddress = &quot;&quot;) Then 
	WScript.Echo &quot;Error:  Client IP Address Not Found&quot;
	WScript.Quit
End If

If(strNeighborhoodList = &quot;&quot;) Then 
	WScript.Echo &quot;Error:  Neighborhood List Not Found&quot;
	WScript.Quit
End If

arrIPs = Split(strNeighborhoodList, &quot;,&quot;)
strBackwards = &quot;&quot;
strForwards = &quot;&quot;
bReachedMe = False
For Each strIP In arrIPs
	strIP = Trim(strIP)
	strPort = GetIPPort(strIP)
	If strIP = strClientIPAddress Then 
		bReachedMe = True
	ElseIf strPort &lt;&gt; &quot;0&quot; Then 	
		If Not bReachedMe Then 
			strBackwards = strBackwards &amp; GetReadableIPs(strIP) &amp; &quot; &quot;
		ElseIf bReachedMe Then 
			strForwards = strForwards &amp; GetReadableIPs(strIP) &amp; &quot; &quot;
		End If
	End If
Next

strBackwards = Replace(Trim(strBackwards), &quot; &quot;, &quot;,&quot;)
strForwards = Replace(Trim(strForwards), &quot; &quot; , &quot;,&quot;)


WScript.Echo strBackwards &amp; &quot;|&quot; &amp; strForwards

&#039;----------End Main Line-----------&#039;

Function GetReadableIPs(strIPs)
	Dim arrFront, arrIPInfo, strPort, strResult
	arrFront = Split(strIPs,&quot;_&quot;)
	arrIPInfo = Split(arrFront(0), &quot;:&quot;)
	strPort = arrIPInfo(1)
	
	If INCLUDE_PORTS Then 
		strResult = arrIPInfo(2) &amp; &quot;:&quot; &amp; strPort
	Else 
		strResult = arrIPInfo(2)
	End If 

	GetReadableIPs = strResult
End Function &#039; GetReadableIPs

Function GetIPPort(strIPs)
	Dim arrFront, arrIPInfo, strPort
	arrFront = Split(strIPs,&quot;_&quot;)
	arrIPInfo = Split(arrFront(0), &quot;:&quot;)
	strPort = arrIPInfo(1)
	
	GetIPPort = strPort
End Function &#039; GetIPPort

Function GetClientIPAddress()
	Const HKLM = &amp;h80000002
	
	Dim strTaniumRegistryKey, strComputer, strClientIPAddress
	Dim objReg
	
	&#039; Set up access to registry via WMI
	strComputer = &quot;.&quot;
	
	Set objReg = _
		GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
		&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

	strTaniumRegistryKey = GetTaniumRegistryPath() &amp; &quot;\Status&quot;

	objReg.GetStringValue HKLM, strTaniumRegistryKey, &quot;ClientAddress&quot;, strClientIPAddress
	
	If Not IsNull(strClientIPAddress) Then
		GetClientIPAddress = strClientIPAddress
	Else
		GetClientIPAddress = &quot;&quot;
	End If

	&#039; Cleanup
	Set objReg = Nothing


End Function &#039; GetClientIPAddress

Function GetNeighborhoodList()
	Const HKLM = &amp;h80000002
	
	Dim strTaniumRegistryKey, strComputer, strNeighborhoodList
	Dim objReg
	
	&#039; Set up access to registry via WMI
	strComputer = &quot;.&quot;
	
	Set objReg = _
		GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
		&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

	strTaniumRegistryKey = GetTaniumRegistryPath() &amp; &quot;\Status&quot;

	objReg.GetStringValue HKLM, strTaniumRegistryKey, &quot;NeighborhoodList&quot;, strNeighborhoodList
	
	If Not IsNull(strNeighborhoodList) Then
		GetNeighborhoodList = strNeighborhoodList
	Else
		GetNeighborhoodList = &quot;&quot;
	End If

	&#039; Cleanup
	Set objReg = Nothing
End Function &#039;GetLogLevel

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Backwards,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Forwards,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
270,Operating System,2015-01-05T20:22:04,",","Returns the name of the Primary System Owner on Windows.  This  is set at OS install time.
Example: John Doe",1,2753029185,0,537,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Primary Owner Name,,,,,,,,,Windows,select PrimaryOwnerName from win32_ComputerSystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
271,Hardware,2015-01-05T20:22:04,",","Currently configured language for the BIOS.
Example: en|US|iso8859-1",1,2759217311,0,539,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,BIOS Current Language,,,,,,,,,Windows,select CurrentLanguage from win32_BIOS,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
272,Operating System,2015-01-05T20:22:04,",","Returns the maximum amount of memory, in Kilobytes, that a process can use.  This may be free physical RAM and virtual RAM combined, or may be an arbitrary upper ceiling.
Example: 2097024",1,276664624,0,541,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Maximum Process Memory Size,,,,,,,,,Windows,select MaxProcessMemorySize from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
273,Tanium Diagnostics,2015-01-05T20:22:04,",","The number of seconds it took to download and complete the Action once a Client first sees the Action.
Example: 300 seconds",0,2758038984,0,543,1,Jim Olsen,60,,,,2015-01-05T20:22:04,Tanium Client Action Timing,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\d+"",""helpString"":""Numbers only"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the Action ID number as seen in the Action History"",""value"":"""",""promptText"":""e.g. 1234"",""defaultValue"":"""",""label"":""Action ID number"",""maxChars"":0,""key"":""strId"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Tanium Action Timing
&#039;========================================

strId = unescape(&quot;||strId||&quot;)

strDownloadPath =  GetTaniumDir(&quot;Downloads&quot;)

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

strActionLog = strDownloadPath &amp; &quot;action_&quot; &amp; strId &amp; &quot;.log&quot;

Const ForReading = 1


If fso.FileExists(strActionLog) Then
	Set objReadLog = fso.OpenTextFile(strActionLog, ForReading)

	dim strLine

	Do Until objReadLog.AtEndOfStream
	    strLine = objReadLog.ReadLine
	Loop

	objReadLog.Close

	if instr(strLine, &quot;Command Completed&quot;) &gt; 0 Then
		Set objLog = fso.GetFile(strActionLog)
		dCreated = objLog.DateCreated
		dModified = objLog.DateLastModified
		Wscript.echo DateDiff(&quot;s&quot;, dCreated, dModified) &amp; &quot; seconds&quot;
	else
		Wscript.echo &quot;Action in process&quot;
	End if
Else
	Wscript.echo &quot;Action does not exist&quot;
End If

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;strId&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\d+&quot;,&quot;helpString&quot;:&quot;Numbers only&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter the Action ID number as seen in the Action History&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strId||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;strId&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\d+&quot;,&quot;helpString&quot;:&quot;Numbers only&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter the Action ID number as seen in the Action History&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strId||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
274,Patch,2015-01-05T20:22:04,|,"A sensor to return patch history for a certain number of days prior.
Example: GUID|Operation|Result|Exception|Install Date|Publish Date|Title|First Needed Date|Severity|MS ID|KB|CVE ID|Size",1,2779050471,0,545,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Patch History Details,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to show patch history for."",""value"":""7"",""defaultValue"":""7"",""snapInterval"":1,""label"":""Show past days"",""minimum"":1,""key"":""DaysOldLimit"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""},{""helpString"":""Choose whether to show the patch history in local time or not (UTC time)"",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Show Local Install Time (not UTC)"",""key"":""ShowInLocalTime"",""values"":[""Yes"",""No""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Patch History Details
&#039;========================================

&#039; sensor: patch history details
&#039; this will show the full patch history of a machine
&#039; This is a multi-column sensor whose output looks like:
&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|Tanium Unique ID|Patched By

Option Explicit

Const FORREADING = 1

Dim objFSO,objTextFile
Dim strToolsDir,strScanDir,intDaysOldLimit,strDaysOldLimit
Dim strHistoryTextReadableFilePath,strShowInLocalTime
Dim strSep : strSep = &quot;|&quot;
Dim strSep2 : strSep2 = &quot;&amp;&amp;&quot;
Dim strLine,arrLine,strColumn2,dtmInstallDateLocal,intDaysOld
Dim bShowInLocalTime,bUTCDateTime,bMalformedLines,intLineCount
Dim dictInstalledResultsData,intHoursThresholdToConsiderMatched

SetLocale(GetTaniumLocale) &#039; uses date math

&#039; This value is used to determine whether an entry in the API history matches
&#039; a similar entry in the tanium installed by. If the times are within this range
&#039; we consider the update performed by tanium in this history printout.
intHoursThresholdToConsiderMatched = 2
&#039; days old parameter
strDaysOldLimit=Trim(Unescape(&quot;||DaysOldLimit||&quot;))

If IsNumeric(strDaysOldLimit) Then
	intDaysOldLimit = CInt(strDaysOldLimit)
Else
	WScript.Echo &quot;Error: Days Old Limit parameter must be a number&quot;
	WScript.Quit
End If

&#039; show local time parameter
&#039; a customer may want UTC display
strShowInLocalTime=Trim(Unescape(&quot;||ShowInLocalTime||&quot;))

Select Case LCase(strShowInLocalTime)
	Case &quot;yes&quot;
		bShowInLocalTime = True
	Case &quot;true&quot;
		bShowInLocalTime = True
	Case &quot;no&quot;
		bShowInLocalTime = False
	Case &quot;false&quot;
		bShowInLocalTime = False
	Case &quot;&quot;
		bShowInLocalTime = True
	Case Else
		WScript.Echo &quot;Error: Show Local Time Parameter must be Yes or No&quot;
		WScript.Quit
End Select

bMalformedLines = False
Set objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)
strToolsDir = GetTaniumDir(&quot;Tools&quot;)
strScanDir = GetTaniumDir(&quot;Tools\Scans&quot;)

strHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;

If Not objFSO.FileExists(strHistoryTextReadableFilePath) Then
	WScript.Echo &quot;Cannot find History file&quot;
	Set objFSO = Nothing
	WScript.Quit
End If

Set dictInstalledResultsData = CreateObject(&quot;Scripting.Dictionary&quot;)

GetInstalledResultsData dictInstalledResultsData

intLineCount = 0
&#039; read History into dictionary
Set objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)
While objTextFile.AtEndOfStream = False
	strLine = objTextFile.ReadLine
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
	&#039; 15 History Columns
	&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|Tanium Unique ID|Applied By
	arrLine = Split(strLine,strSep)
		If IsArray(arrLine) Then
			If UBound(arrLine) &gt; 10 Then
				On Error Resume Next
				bUTCDateTime = arrLine(4)
				dtmInstallDateLocal = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)
				If bShowInLocalTime Then			
				&#039; Convert from UTC to Local replace the line						
					strLine = Replace(strLine,arrLine(4),dtmInstallDateLocal)
					On Error Goto 0
				End If
				&#039; Ignore first needed and superseded lines
				strColumn2 = Trim(LCase(arrLine(1)))
				If Not (strColumn2 = &quot;firstneeded&quot; Or strColumn2 = &quot;superseded&quot;) Then
					intLineCount = intLineCount + 1
					&#039; do not echo if the days old is older than the max days on input
					intDaysOld = Abs(DateDiff(&quot;d&quot;,Now(),dtmInstallDateLocal))
					If intDaysOld &lt; intDaysOldLimit Then
						Dim strInstallResultsTime
						&#039; we have a value to write, check if it was our update
						If dictInstalledResultsData.Exists(arrLine(0)) Then
							&#039; GUID on history line matched an install result
							&#039; each guid in the install result may not be unique, so lines
							&#039; are concatenated into the single dictionary entry
							Dim strInstallHistoryEntry,arrInstallHistoryLine
							For Each strInstallHistoryEntry In Split(dictInstalledResultsData.Item(arrLine(0)),strSep2)
								arrInstallHistoryLine = Split(strInstallHistoryEntry,strSep)
								If arrLine(1) = &quot;Installation&quot; Then
									Dim strDateFromInstallHistory
									strDateFromInstallHistory = arrInstallHistoryLine(1)
									If IsDate(strDateFromInstallHistory) And IsDate(arrLine(4)) Then
										If Abs(DateDiff(&quot;h&quot;,strDateFromInstallHistory,arrLine(4))) &lt;= intHoursThresholdToConsiderMatched Then
											bTanium = True
										End If										
									Else
										&#039; WScript.Echo &quot;No possible date match - &quot; &amp; strDateFromInstallHistory &amp;&quot; - &quot; &amp; arrLine(4)
									End If
								End If
							Next
							WScript.Echo strLine&amp;strSep&amp;&quot;Tanium&quot;
							bTanium = False
						Else
							WScript.Echo strLine&amp;strSep&amp;&quot;Unsure&quot;
						End If
					End If
				End If
			Else
				bMalformedLines = True
				&#039;WScript.Echo &quot;History Line malformed - needs 11 fields&quot;
			End If
		Else
			bMalformedLines = True
			&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable
		End If
	End If
Wend
If intLineCount = 0 Then WScript.Echo &quot;No patch actions in history&quot;

&#039; If bMalformedLines Then WScript.Echo &quot;History file had malformed line(s)&quot;

objTextFile.Close

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale

Function GetTZBias
&#039; This functiong returns the number of minutes
&#039; (positive or negative) to add to current time to get UTC
&#039; considers daylight savings

	Dim objLocalTimeZone, intTZBiasInMinutes


	For Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)
		intTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone
	Next

	GetTZBias = intTZBiasInMinutes
		
End Function &#039;GetTZBias

Sub GetInstalledResultsData(ByRef dictInstalledResultsData)
	&#039; build patch install results, by GUID
	Dim strInstalledResultsTextReadablePath,objResultsFile
	Dim strLine,arrLine,objFSO
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	strInstalledResultsTextReadablePath = strScanDir&amp;&quot;installedresultsreadable.txt&quot;
	If objFSO.FileExists(strInstalledResultsTextReadablePath) Then
		Set objResultsFile = objFSO.OpenTextFile(strInstalledResultsTextReadablePath,1,False) &#039; do not create
		Do Until objResultsFile.AtEndOfStream = True
			strLine = objResultsFile.ReadLine
			arrLine = Split(strLine,strSep)
			If IsArray(arrLine) Then
				If UBound(arrLine) &gt; 0 Then
					&#039; GUID is first entry, result is final entry
					If Not dictInstalledResultsData.Exists(arrLine(0)) Then
						dictInstalledResultsData.Add arrLine(0),Replace(strLine,arrLine(0)&amp;strSep,&quot;&quot;)
					Else
						&#039; duplicate entry
						strLine = strLine&amp;strSep2&amp;dictInstalledResultsData.Item(arrLine(0))
					End If
				End If
			End If
		Loop
	End If
	objResultsFile.Close
	
End Sub &#039;GetInstalledResultsData",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;DaysOldLimit&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to show patch history for.&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Show past days&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;key&quot;:&quot;ShowInLocalTime&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Choose whether to show the patch history in local time or not (UTC time)&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Local Install Time (not UTC)&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||ShowInLocalTime||  ||DaysOldLimit||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;DaysOldLimit&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to show patch history for.&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Show past days&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;key&quot;:&quot;ShowInLocalTime&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Choose whether to show the patch history in local time or not (UTC time)&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Local Install Time (not UTC)&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||ShowInLocalTime||  ||DaysOldLimit||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,GUID,String,0,1,10,KB,String,0,1,11,CVE ID,String,0,1,12,Size,DataSize,0,1,13,Tanium Patch ID,String,0,1,14,Patched By,String,0,1,1,Operation,String,0,1,2,Result,String,0,1,3,Exception,String,0,1,4,Install Date,String,0,1,5,Publish Date,String,0,1,6,Title,String,0,1,7,First Needed Date,String,0,1,8,Severity,String,0,1,9,MS ID,String,String
275,Hardware,2015-01-05T20:22:04,",","Returns the names of network adapters that are active.
Example: VMware Accelerated AMD PCNet Adapter",1,2783988057,0,547,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Network Adapter Name,,,,,,,,,Windows,select Name from win32_networkadapter where NetConnectionStatus=2,WMIQuery,Linux,"#!/bin/sh
lspci | grep Ethernet | awk -F&#039;Ethernet controller: &#039; &#039;{print $2}&#039;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
276,Operating System,2015-01-05T20:22:04,",","Returns whether the machine is a Mac.  True if so, False if not.
Example: True",0,2800817874,0,549,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Is Mac,,,,,,,,,Windows,"&#039;========================================
&#039; Is Mac
&#039;========================================

Wscript.echo &quot;False&quot;",VBScript,Linux,"#!/bin/bash
echo False
",UnixShell,Mac,"#!/bin/bash
echo True
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
277,Operating System,2015-01-05T20:22:04,",","Returns the time the last reboot occurred.
Example: 2012-12-11 09:01",1,2811135310,0,551,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Last Reboot,,,,,,,,,Windows,"&#039;========================================
&#039; Last Reboot
&#039; (See also OS Boot Time)
&#039;========================================

&#039; This sensor will return the time the OS booted up

Option Explicit

Dim dateBootTime, strFinalOutputString, strSep
&#039; Force output in a specific time format
SetLocale(1033)

strSep = &quot;|&quot;
dateBootTime = GetBootTime

WScript.Echo Year(dateBootTime) &amp; &quot;-&quot; &amp; zeroPad(Month(dateBootTime),2) &amp; &quot;-&quot; &amp; zeroPad(Day(dateBootTime),2) &amp; &quot; &quot; &amp; FormatDateTime(dateBootTime,vbShortTime)

&#039;-----------End Main-------------&#039;

Function zeroPad(m, t)
	zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function &#039;zeroPad
  
Function GetBootTime
&#039; Retrieves a nicely formatted bootup time
    Dim objSWbemDateTime
    Dim objWMIService
    Dim colOperatingSystems
    Dim objOperatingSystem
    Dim strComputer
    Dim colTimeZone
    Dim objTimeZone
    Dim intTZBiasInMinutes
    Dim dateBootTime
    
    strComputer = &quot;.&quot;
    
    Set objSWbemDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
    Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
    Set colOperatingSystems = objWMIService.ExecQuery (&quot;Select * from Win32_OperatingSystem&quot;)
     
    For Each objOperatingSystem in colOperatingSystems
        objSWbemDateTime.Value = objOperatingSystem.LastBootUpTime
        dateBootTime = CDate(objSWbemDateTime.GetVarDate(False))
    Next

    &#039; Now to correct for time zones 
    Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
     
    For Each objTimeZone in colTimeZone
        intTZBiasInMinutes = objTimeZone.CurrentTimeZone
        dateBootTime = DateAdd(&quot;n&quot;, intTZBiasInMinutes, dateBootTime)
    Next

    
    &#039;return result
    GetBootTime = dateBootTime
    
    &#039;Cleanup
    Set objSWbemDateTime = Nothing
    Set objWMIService = Nothing
    Set colOperatingSystems = Nothing
    Set colTimeZone = Nothing

End Function &#039;GetBootTime",VBScript,Linux,"#!/bin/bash
line=$(who -b)
set -- $line
echo ${line#*&quot;boot&quot;}
",UnixShell,Mac,"#!/bin/bash
temp=$(who -b | awk -F&#039;~ &#039; &#039; /reboot/ { print $2 } &#039;)
echo $temp
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
278,Operating System,2015-01-05T20:22:04,",",Returns the time offset in minutes. Example: -0700,0,2811171321,0,553,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Time Zone Offset,,,,,,,,,Windows,"&#039;========================================
&#039; Time Zone Offset
&#039;========================================

Option Explicit

WScript.Echo GetRFC822Bias

Function GetRFC822Bias
&#039; This function returns a string which is a 
&#039; timezone bias for RFC822 format
&#039; considers daylight savings
&#039; we choose 4 digits and a sign (+ or -)

	Dim objWMIService,colTimeZone,objTimeZone
	
	Dim intTZBiasInMinutes,strSign,strReturnString

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
	 
	For Each objTimeZone in colTimeZone
	    intTZBiasInMinutes = objTimeZone.CurrentTimeZone
	Next

	&#039; The offset is explicitly signed
	If intTZBiasInMinutes &lt; 0 Then
		strSign = &quot;-&quot;
	Else
		strSign = &quot;+&quot;
	End If
	
	strReturnString = CStr(Abs(intTZBiasInMinutes))
	&#039; no offset is greater than three digits but RFC822 bias seems to
	&#039; usually take the form of 1 alpha / 4 digit as described as 
	&#039; valid in ANSI X3.51-1975

	strReturnString = zeroPad(strReturnString,4)

	GetRFC822Bias = strSign&amp;strReturnString
	
	&#039;Cleanup
	Set colTimeZone = Nothing
	Set objWMIService = Nothing
	
End Function &#039;GetRFC822Bias

Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function",VBScript,Linux,"#!/bin/bash
echo `date +%z`
",UnixShell,Mac,"#!/bin/bash
echo `date +%z`
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
279,File System,2015-01-05T20:22:04,",","Returns the creation date of the file specified by the parameter.
Example: 12-12-2014 18:00",1,2812601404,0,555,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,File Creation Date,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the file path and name to search for."",""value"":"""",""promptText"":""e.g. c:\\windows\\test.txt"",""defaultValue"":"""",""label"":""File path and name to search for"",""maxChars"":0,""key"":""filename"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; File Creation Date
&#039;========================================

Option Explicit

SetLocale(1033)

Dim filesys, filename, file, createdate 

filename = unescape(&quot;||filename||&quot;)
&#039;filename = &quot;c:\windows\regedit.exe&quot;

filename = FixFileSystemRedirectionForPath(filename)

Set filesys = CreateObject(&quot;Scripting.FileSystemObject&quot;)

If filesys.FileExists(filename) Then
   Set file = filesys.GetFile(filename)
   createdate = file.DateCreated
   WScript.Echo FormatDateTime(createdate, vbShortDate) &amp; &quot; &quot; &amp; FormatDateTime(createdate, vbShortTime)
Else
   WScript.Echo &quot;File &quot; &amp; filename &amp; &quot; not found.&quot;
End If


Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
    
    Dim objFSO, strSystem32Location,objShell
    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
    
    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
        If InStr(strFilePath,strSystem32Location) = 1 Then
            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
            strFilePath = strNewSystem32Location&amp;strRestOfPath
        End If
    End If
    FixFileSystemRedirectionForPath = strFilePath
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

    Dim objFSO,strSystem32Location,strNewSystem32Location
    
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    
    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
    
    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,BESDate
280,Network,2015-01-05T20:22:04,|,"Returns the protocol, local address / port, process name, application name, remote port, and connection state for all active IP connections on an endpoint.
Example: tcp|192.168.95.186:51866|explorer.exe|Windows Explorer|165.254.58.66:80|established",1,2819106613,0,557,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,IP Connections,,,,,,,,,Windows,"&#039;========================================
&#039; IP Connections
&#039;========================================

&#039;Option Explicit

Dim showProcess, showPort, showRemoteConnection

showProcess = True
showPort = True
showRemoteConnection = True

Dim strcommand, results, excludeProcesses, excludeSubnets, excludeListenPorts, excludeRemotePorts, taniumDebug
Dim strSep : strSep = &quot;|&quot;
&#039; This is a multi-column sensor that looks like:
&#039;Process|Name|Target IP

excludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;
&#039;excludeProcesses = &quot;chrome.exe&quot;
&#039;excludeProcesses = &quot;iexplore.exe&quot;
&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;
&#039;excludeProcesses = &quot;trillian.exe&quot;

excludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;
&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;

excludeListenPorts = &quot;17472&quot;
&#039; excludeListenPorts = &quot;17472,80,443&quot;

excludeRemotePorts = &quot;17472&quot;
&#039; excludeRemotePorts = &quot;17472,80,443&quot;

taniumDebug = False


excludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)
excludeSubnets = Split(excludeSubnets, &quot;,&quot;)
excludeListenPorts = Split(excludeListenPorts, &quot;,&quot;)
excludeRemotePorts = Split(excludeRemotePorts, &quot;,&quot;)

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
query = &quot;select name, executablepath, processId from win32_process&quot;
Set colResults = objWMIService.ExecQuery(query)

&#039;dictionary for process-app pairs
Set processes = CreateObject(&quot;Scripting.Dictionary&quot;)

For Each result In colResults 
   processId = CStr(result.ProcessId)
   processPath = result.ExecutablePath
   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later
Next

&#039; unlike established connections, shows connections in all states
strcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34)

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strNSResults = LCase(objScriptExec.StdOut.ReadAll)

results = Split(strNSResults, vbCrLf)
j = 0

For Each line in results
   line = cleanWhitespace(Trim(line))
   
   lineResults = Split(line)
   i = 0
   Dim strPort, strPid, strConnectionState, strForeignIP, strApp
   For Each word In lineResults
      If i = 0 Then
         strProtocol = word   
      ElseIf i = 1 Then
         strLocalIP = word
      ElseIf i = 2 Then
         strForeignIP = word
      ElseIf i = 3 Then
         strConnectionState = word
      ElseIf i = 4 Then
         strPid = word
      End If
      
      i = i + 1
   Next
   
   &#039;DO NOT INCLUDE EXCLUDED APPS
   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path
   arrAppEntry = Split(strAppEntry,&quot;,&quot;)
   strAppExe = arrAppEntry(0)
   strAppPath = arrAppEntry(1)
   
   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))
   
   &#039;DO NOT INCLUDE EXCLUDED SUBNETS
   isNotExcludedSubnet = Not(ContainedInSubnet(strForeignIP, excludeSubnets))
   
   &#039;DO NOT INCLUDE EXCLUDED LISTEN PORTS
   isNotExcludedListenPort = Not(ContainedInArray(Split(strLocalIP, &quot;:&quot;)(1), excludeListenPorts))
   
   &#039;DO NOT INCLUDE EXCLUDED REMOTE PORTS
   isNotExcludedRemotePort = Not(ContainedInArray(Split(strForeignIP, &quot;:&quot;)(1), excludeRemotePorts))
   
   If Not(IsEmpty(strAppExe)) _
      And isNotExcludedApp _ 
      And isNotExcludedSubnet _
      And isNotExcludedListenPort _
      And IsNotExcludedRemotePort Then

	  If Not showPort Then 
	  	arrTemp = Split(strForeignIP, &quot;:&quot;)
		strForeignIP = arrTemp(0)
	  End If
   
      If showProcess Then
      	results(j) = strProtocol &amp; strSep &amp; strLocalIP &amp; strSep &amp; strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIP &amp; strSep &amp; strConnectionState
      Else
        results(j) = strProtocol &amp; strSep &amp; strLocalIP &amp; strSep &amp; strSep &amp; strForeignIP &amp; strSep &amp; strConnectionState
      End If	
   Else
      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIP
      results(j) = &quot;&quot;   
   End If 
   
   j = j + 1
Next

results = RemDups(results)

If UBound(results) &lt; 1 Then
	If GetLocale() &lt;&gt; 1033 Then
		WScript.Echo &quot;English Language OS Required&quot;
	End If
End If

For Each result In results 
   WScript.Echo result
Next

WScript.Quit

Function ContainedInSubnet(str, arr)
   Dim strIp, strSubnet, strMask
   temp = Split(str, &quot;:&quot;)
   strIp = temp(0)

   For Each item In arr
      If InStr(item, &quot;-&quot;) Then &#039;Subnet range
         temp = Split(item, &quot;-&quot;)
         lower = Split(temp(0), &quot;:&quot;)
         upper = Split(temp(1), &quot;:&quot;)
         lowerSubnet = Trim(lower(0))
         lowerMask = Trim(lower(1))
         upperSubnet = Trim(upper(0))
         upperMask = Trim(upper(1))
         
         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _
            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then
            ContainedInSubnet = True
            Exit Function
         End If 
      Else &#039;Single subnet
         parts = Split(item, &quot;:&quot;)
         strSubnet = Trim(parts(0))
         strMask = Trim(parts(1))
         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then
            ContainedInSubnet = True
            Exit Function
         End If
      End If 
   Next
   ContainedInSubnet = False
End Function

Function ContainedInArray(str, arr)
   For Each item In arr 
      If str = Trim(item) Then
         ContainedInArray = True
         Exit Function
      End If   
   Next
   ContainedInArray = False
End Function

Function cleanWhitespace(strStarter)
   intStarter = Len(strStarter)
   For i = intStarter to 2 Step -1
      strChars = Space(i)
      strStarter = Replace(strStarter, strChars, &quot; &quot;)
   Next
   cleanWhitespace = strStarter
End Function

Function RemDups(ByVal anArray)
   Dim d, item, thekeys
   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)
   d.removeall
   d.CompareMode = 0
   For Each item In anArray
      If Len(item) &gt; 0 Then
         If Not d.Exists(item) Then d.Add item, item
      End If
   Next
   thekeys = d.keys
   Set d = Nothing
   RemDups = thekeys
End Function

Function Subnet(strAddress, strMask)
   intSubnetLength = SubnetLength(strMask)
   Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))
End Function

Function SubnetLength(strMask)
   strMaskBinary = StringToBinary(strMask)
   SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))
End Function

Function BinaryToString(strBinary)
   For intOctetPos = 1 To 4
      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)
      intOctet = 0
      intValue = 1
      For intBinaryPos = 1 To Len(strOctetBinary)
         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue
         intValue = intValue * 2
      Next
      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)
   Next
End Function

Function StringToBinary(strAddress)
   objAddress = Split(strAddress, &quot;.&quot;, -1)
   For Each strOctet In objAddress
      intOctet = CInt(strOctet)
      strOctetBinary = &quot;&quot;
      For x = 1 To 8
         If intOctet Mod 2 &gt; 0 Then
            strOctetBinary = &quot;1&quot; &amp; strOctetBinary
         Else
            strOctetBinary = &quot;0&quot; &amp; strOctetBinary
         End If
         intOctet = Int(intOctet / 2)
      Next
      StringToBinary = StringToBinary &amp; strOctetBinary
   Next
End Function

Function ProcessNameToApplicationName(strExecutablePath, strExecutableName)
&#039; This function will return the full application name of a running executable

		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		
		arrPathParts = Split(strExecutablePath,&quot;\&quot;)

		If UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process
			ProcessNameToApplicationName = strExecutableName
			Set fso = Nothing
			Exit Function
		End If
		strExecutable = arrPathParts(UBound(arrPathParts))
		
		If fso.FileExists(strExecutablePath) Then
			Dim strOutput, fileVersion, fileVersionOutput, fullName
		
			Set execFile = fso.GetFile(strExecutablePath)
			fullName = GetDescription(execFile.ParentFolder.Path, strExecutable)
			If Not fullName = &quot;&quot; Then
				ProcessNameToApplicationName = fullName
			Else
				ProcessNameToApplicationName = strExecutableName
			End If
		Else &#039; file doesn&#039;t exist or inaccessible
			ProcessNameToApplicationName = strExecutableName
		End If

End Function &#039;ProcessNameToApplicationName

Function GetDescription(folderPath, fileName)
	descIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)
	If IsEmpty(descIndex) Then
		descIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)
	End If
	GetDescription = GetFileProperty(folderPath, fileName, descIndex)
End Function

Function GetFileProperty(folderPath, fileName, fileProperty)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	GetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)
End Function

Function GetAttributeIndex(folderPath, attrTarget)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	For i = 0 to 50
		attrName = objFolder.GetDetailsOf(objFolder.Items, i)
		If LCase(attrName) = LCase(attrTarget) Then
			GetAttributeIndex = i
			Exit Function
		End If
	Next
	
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Protocol,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Local IP and Port,String,0,1,2,Process,String,0,1,3,Application,String,0,1,4,Remote IP and Port,String,0,1,5,Connection State,String,,,,,,,,,,,,,,,,,,,,,String
281,Software,2015-01-05T20:22:04,",","Returns True if client machine is a guest VM in VMware.
Example: True",1,2823285829,0,559,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,VMware Guest,,,,,,,,,Windows,"&#039;========================================
&#039; WMware Guest
&#039;========================================
On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;,,48)
For Each objItem in colItems
	If objItem.Model = &quot;VMware Virtual Platform&quot; Then WScript.Echo &quot;True&quot;
	WScript.Quit
Next

Set colItems = objWMIService.ExecQuery _
(&quot;Select * From Win32_NetworkAdapterConfiguration Where IPEnabled = True&quot;)
For Each objItem in colItems
	If Left(objItem.MACAddress, 8) = &quot;00:0C:29&quot; Then WScript.Echo &quot;True&quot;
	WScript.Quit
Next",VBScript,Linux,"#!/bin/bash

commout=&quot;&#039;dmidecode | awk &#039;VMware Virtual Platform/ {print $3,$4,$5}&#039; 2&gt; /dev/null&#039;&quot;

if [[ &quot;$commout&quot; == *&quot;Virtual&quot;* ]]
 then
   echo &quot;True&quot;
else
   echo &quot;False&quot;
fi
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
282,Network,2015-01-05T20:22:04,",","Returns the current inbound throughput, in KB/Sec, of the network interface used to connect to the tanium server.
Example: 1024 KB/S",1,2845896284,0,561,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Network Throughput Inbound,,,,,,,,,Windows,"&#039;========================================
&#039; Network Throughput Inbound
&#039;========================================

&#039; This sensor will use windows performance counters
&#039; and attempt to retrieve network traffic information
&#039; only for the interface being used to connect to the tanium server
&#039; results are in kilobytes per second

Option Explicit

Dim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress
Dim strComputer: strComputer = &quot;.&quot;

Dim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString
Dim objWMIService, colItems, objItem

&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address
&#039; out of WMI.  Because Name is the closest thing to match the Description
&#039; field in the performance counter, but it&#039;s not exact due to how some
&#039; characters are displayed, we will remove troublesome characters
&#039; and attempt to match on that

&#039; Since the entire sensor&#039;s output depends on if the two strings match, we
&#039; can set the one string to something it won&#039;t match on (because _) to be safe
strDescriptionToMatch = &quot;_ImpossibleToMatch&quot;

Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)
For Each objItem In colItems
	For Each strIPAddress In objItem.IPAddress
		If strIPAddress = strTaniumIPAddress Then
			&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress
			strDescriptionToMatch = CleanString(objItem.Description)
			&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch
		End If
	Next
Next

Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)

For Each objItem in colItems
	strNameToMatch = CleanString(objItem.Name)
	&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch
	If LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then
		&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch
		&#039; We can now report bandwidth
		strFinalOutputString = FormatNumber(objItem.BytesReceivedPersec / 1024,0,-1) &amp; &quot; KB/S&quot;
	End If
Next

If strFinalOutputString = &quot;&quot; Then
	&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client
	WScript.Echo &quot;Cannot determine which adapter to measure&quot;
Else 
	WScript.Echo strFinalOutputString
End If


&#039; Cleanup
Set objWMIService = Nothing
Set colItems = Nothing 
Set objItem = Nothing

&#039;&#039; End Main Line

&#039;&#039; Helper Functions
Function CleanString(strInput)
&#039; This function will remove non-alphanumeric characters
	Dim objRegEx
	
	Set objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)
	
	objRegEx.Global = True   
	objRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;
	CleanString = objRegEx.Replace(strInput, &quot;&quot;)
	
	Set objRegEx = Nothing
End Function &#039;CleanString

Function GetTaniumIPAddress
&#039; Modified from the ua-scan code to remove the subnet and last octet calculations
&#039; which are irrelevant for these purposes.
&#039; Returns the IP address that the client uses for Tanium activity
&#039; (talking to server and other clients)

	Dim strComputer, objReg, strCommand, objShell, objScriptExec
	Dim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords
	Dim strIPAddress, strTaniumPath, strClientAddress
	Dim strServerName
	
	strComputer = &quot;.&quot;
	Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	Const HKLM = &amp;h80000002
	
		
	&#039;&#039;###########Get Tanium Key on 64/32bit computers##########
	
	strTaniumPath = GetTaniumRegistryPath()
	
	
	&#039; if we can pull this from the registry (newer client version), just use that
	objReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\Status&quot;, &quot;ClientAddress&quot;, strClientAddress
	If strClientAddress &lt;&gt; &quot;&quot; Then
		strClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)
		strClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))
		&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;
		GetTaniumIPAddress = strClientAddress
		&#039;Cleanup
		Set objReg = Nothing
		Exit Function
	End If
	
	&#039;Otherwise use PathPing to determine client IP used by Tanium

	&#039;&#039;# Read the ServerName value

	objReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName

	strCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objScriptExec = objShell.Exec (strCommand)
	strResults = objScriptExec.StdOut.ReadAll
	
	arrPathPingLines = Split(strResults, vbCrLf)
	For Each strPathPingLine In arrPathPingLines
		arrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)
		If UBound(arrPathPingWords) &gt; 0 Then
			If arrPathPingWords(0) = &quot;0&quot; Then
				strIPAddress = arrPathPingWords(1)
				Exit For
			End If
		End If	
	Next
	
	Set objShell = Nothing
	Set objScriptExec = Nothing
	Set objReg = Nothing

	If Not IsNull(strIPAddress) Then
		GetTaniumIPAddress = strIPAddress
	Else
		GetTaniumIPAddress = False
	End If
End Function &#039;GetTaniumIPAddress

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath


Function CleanWhitespace(strStarter)
	Dim intStarter, i, strChars
	intStarter = Len(strStarter)
	For i = intStarter to 2 Step -1
		strChars = Space(i)
		strStarter = Replace(strStarter, strChars, &quot; &quot;)
	Next
	CleanWhitespace = strStarter
End Function &#039;CleanWhiteSpace",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
283,Hardware,2015-01-05T20:22:04,",","Description of the CPU.
Example: Intel(R) Core(TM) i5-2500 CPU @ 3.30GHz",1,2853143977,0,563,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,CPU,,,,,,,,,Windows,"&#039;========================================
&#039; CPU
&#039;========================================

Option Explicit

Dim objWMIService, colProcessors, objProcessor
Dim strProcessorName, intProcessorSpeed

Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
Set colProcessors = objWMIService.ExecQuery(&quot;select Name,MaxClockSpeed from win32_processor&quot;)

For Each objProcessor in colProcessors
	strProcessorName = objProcessor.Name
	intProcessorSpeed = CInt(objProcessor.MaxClockSpeed)
	If InStr(strProcessorName, &quot;Intel Pentium III&quot;) &gt;0 And _
		Left(GetOSMajorVersion(), 1) = &quot;5&quot; And _
		intProcessorSpeed &gt; 1000 Then 
		&#039; Work around for this problem on Windows XP / Windows 2003 machines, where
		&#039; wrong value is reported for the processor type:
		&#039; http://support.microsoft.com/kb/953955
		
		strProcessorName = &quot;Intel(R) Core(TM)2 Duo CPU&quot;
	End If 
	WScript.Echo Trim(strProcessorName)
Next

Function GetOSMajorVersion
&#039; Returns the OS Major Version
&#039; A different way to examine the OS instead of by name

	Dim objWMIService,colItems,objItem
	Dim strVersion

	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    
	For Each objItem In colItems
		strVersion = objItem.Version &#039; like 6.2.9200
		strVersion = Left(strVersion,Len(strVersion) - 5)
	Next
	
	GetOSMajorVersion = strVersion
	
End Function &#039;GetOSMajorVersion",VBScript,Linux,"#!/bin/bash
line=$(cat /proc/cpuinfo | grep &quot;model name&quot;)
set -- $line
echo ${line#*:}
",UnixShell,Mac,"#!/bin/bash
name=$( system_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Processor Name:/ { print $2 } &#039; )
speed=$( system_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Processor Speed:/ { print $2 } &#039; )

echo $name $speed
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
284,File System,2015-01-05T20:22:04,",","Finds the specified file and provides the full path if the file exists on the client machine. Takes regular expression to match.
Example: C:\WINDOWS\System32\Notepad.exe",1,2884431352,0,565,1,Jim Olsen,600,0,defined,McAfee,2015-01-05T20:22:04,File Name Search with RegEx Match,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the file name only to search for"",""value"":"""",""promptText"":""e.g test.txt"",""defaultValue"":"""",""label"":""File Name"",""maxChars"":0,""key"":""filename"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""restrict"":null,""validationExpressions"":[],""helpString"":""Enter the regular expression to search for."",""value"":"""",""promptText"":""e.g. test*.exe"",""defaultValue"":"""",""label"":""Regular Expression"",""maxChars"":0,""key"":""regexp"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""helpString"":""Enter Yes/No for case sensitivity of search."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Case sensitive?"",""key"":""casesensitive"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""},{""helpString"":""Enter Yes/No whether the search is global."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Global"",""key"":""global"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; File Name Search with RegEx Match
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit

SensorRandomize()

Dim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg
Dim bGlobal,bCaseSensitive

Pattern = unescape(&quot;||filename||&quot;)
strRegExp = Trim(Unescape(&quot;||regexp||&quot;))
strGlobalArg = Trim(Unescape(&quot;||global||&quot;))
strCaseSensitiveArg = Trim(Unescape(&quot;||casesensitive||&quot;))

bGlobal = GetTrueFalseArg(&quot;global&quot;,strGlobalArg)
bCaseSensitive = GetTrueFalseArg(&quot;casesensitive&quot;,strCaseSensitiveArg)

Const SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1

Dim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine

Set FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set WshShell = CreateObject(&quot;WScript.Shell&quot;)

OutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir

&#039; Go through file system, refresh output file for filename
If Not FSO.FileExists(OutputFilename) Then
	
	If FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename

	&#039; Get the collection of local drives.
	Set Drives = FSO.Drives
	For Each Drive in Drives
		If Drive.DriveType = 2 Then &#039; 2 = Fixed drive
			&#039; Run the Dir command that looks for the filename pattern.
			RunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:-d /b /s&quot;, OutputFilename, true
		End If
	Next
End If

&#039; Open the output file, echo each line, and then close and delete it.
Set TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)
Do While Not TextStream.AtEndOfStream
	strLine = TextStream.ReadLine()
	If RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then
		WScript.Echo strLine
	End If
Loop

TextStream.Close()
 
If FSO.FileExists(OutputFileName) Then
	On Error Resume Next
	FSO.DeleteFile OutputFileName, True
	On Error Goto 0
End If

Function RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)

	Dim re
	Set re = New RegExp
	With re
	  .Pattern = strPattern
	  .Global = bGlobal
	  .IgnoreCase = Not bIsCaseSensitive
	End With
	
	RegExpMatch = re.Test(strToMatch)

End Function &#039;RegExpMatch


Function GetTrueFalseArg(strArgName,strArgValue)
	&#039; Checks for valid values, will fail with error message
	
	Dim bArgVal
	bArgVal = False
	Select Case LCase(strArgValue)
		Case &quot;true&quot;
			bArgVal = True
		Case &quot;yes&quot;
			bArgVal = True
		Case &quot;false&quot;
			bArgVal = False
		Case &quot;no&quot;
			bArgVal = False
		Case Else
			WScript.Echo &quot;Error: Argument &#039;&quot;&amp;strArgName&amp;&quot;&#039; must be True or False, quitting&quot;
			PrintUsage
	End Select
	GetTrueFalseArg = bArgVal

End Function &#039;GetTrueFalseArg


&#039; Returns the name of a temporary file in the Temp directory.
Function TempName()
	Dim Result
	Do
 		Result = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())
		WScript.Sleep 200 &#039;avoid potential busy loop
	Loop While FSO.FileExists(Result)
	
	TempName = Result
End Function &#039;TempName

&#039; Runs a command with Cmd.exe and redirects its output to a temporary
&#039; file. The function returns the name of the temporary file that holds
&#039; the command&#039;s output.
Function RunCommand(Command, OutputFilename, b64BitNecessary)
	&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32
	Dim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set WshShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strDOSCall = &quot;%ComSpec% /C &quot;
	
	&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection
	strProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)
	If objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64
		strDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))
	End If
		
	CommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)
	WshShell.Run CommandLine, 0, True
End Function &#039;RunCommand

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
			strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
			strFilePath = strNewSystem32Location&amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/bash
#||filename||||regexp||||casesensitive||||global||
echo Windows Only
",UnixShell,Mac,"#!/bin/bash
#||filename||||regexp||||casesensitive||||global||
echo Windows Only
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
285,Applications,2015-01-05T20:22:04,|,"Default web browser for new users.  Note that this can be changed per user.
Example: Internet Explorer",1,2932384540,0,567,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Default Web Browser,,,,,,,,,Windows,"&#039;========================================
&#039; Default Web Browser
&#039;========================================

&#039; This sensor will return the name and version of the default web browser
&#039; This is a multi-column sensor that looks like:
&#039; Browser|Version
Option Explicit

&#039; TAG: REDIRECTION

Dim strSep
strSep = &quot;|&quot;

GetDefaultWebBrowser strSep

Function GetDefaultWebBrowser(strSep)

	
	Dim objShell, objRE, objFSO
	Dim strComputer, strDefaultBrowserDetectionPath
	Dim strBrowserFolder, strDefaultBrowserExecutable, objMatch
	Dim strPrunedDefaultBrowserExecutable, strBrowserFileName
	Dim strDescription, strVersion, strCleanDefaultBrowserExecutable
	Dim arrBrowserCommand
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	Set objRE = New RegExp

	With objRE
	    .Pattern    = Chr(34)&amp;&quot;([^&quot;&amp;Chr(34)&amp;&quot;\r\n]*)&quot;&amp;Chr(34) &#039; matches anything between first set of quotes
	    .Global     = False
	End With
	&#039; The default browser executable is stored in this location in the registry	
	&#039; Note that this location is the same in 32 and 64 bit registry providers
	strDefaultBrowserExecutable = objShell.RegRead(&quot;HKEY_CLASSES_ROOT\http\shell\open\command\&quot;)
	
	Set objMatch = objRE.Execute(strDefaultBrowserExecutable)
	If objMatch.Count = 1 Then
		strPrunedDefaultBrowserExecutable = objMatch.Item(0)
	End If
	&#039; Catch case where the browser is specified without quotes and with progra~1
	&#039; notation
	&#039; The regex would have failed to produce a valid file.  Check file exists
	&#039; and if not, assume it&#039;s the progra~1 notation without quotes
	 &#039;strDefaultBrowserExecutable = &quot;C:\PROGRA~1\MOZILL~1\FIREFOX.EXE -requestPending -osint -url &quot; &amp; Chr(34) &amp; &quot;%1&quot; &amp; Chr(34)
	If Not Left(strDefaultBrowserExecutable,1) = Chr(34) Then &#039; if it doesn&#039;t start with a quote
		&#039; WScript.Echo &quot;Found an ugly Command: &quot; &amp; strCleanDefaultBrowserExecutable
		arrBrowserCommand = Split(strDefaultBrowserExecutable, &quot; &quot; )
		strCleanDefaultBrowserExecutable = arrBrowserCommand(0)
		&#039; WScript.Echo strCleanDefaultBrowserExecutable &amp; &quot; after split&quot;
	Else
		strCleanDefaultBrowserExecutable = objRE.Replace(strPrunedDefaultBrowserExecutable, &quot;$1&quot;)
	End If
	

		
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	
	&#039; Pass the folder and file name into GetFileDetails to find description and version
	strBrowserFolder = objFSO.GetParentFolderName(strCleanDefaultBrowserExecutable)
	strBrowserFileName = objFSO.GetFileName(strCleanDefaultBrowserExecutable)
&#039; WScript.Echo strBrowserFolder &amp; &quot; Is folder&quot;
&#039; WScript.Echo strBrowserFileName &amp; &quot; Is File Name&quot;
	strDescription = GetFileDescription(strBrowserFolder, strBrowserFileName)
	strVersion = GetFileVersion(strBrowserFolder, strBrowserFileName)
	
	WScript.Echo strDescription &amp; strSep &amp; strVersion
	
End Function &#039;GetDefaultWebBrowser

Function GetFileVersion(folderName,fileName)
        On Error Resume Next
        Dim objShell
        Dim objFolder
        Dim HeaderInfoArray(250), i
        
        Set objShell = CreateObject(&quot;Shell.Application&quot;)
        Set objFolder = objShell.NameSpace(folderName)

        If (not objFolder is nothing) Then
            For i = 0 to 250  
                HeaderInfoArray(i) = objFolder.GetDetailsOf(objFolder.Items, i)
            Next
            Dim objFolderItem

            Set objFolderItem = objFolder.ParseName(fileName)

            If (not objFolderItem Is Nothing) then
                Dim objInfo
                For i = 0 To 250        
                    objInfo = objFolder.GetDetailsOf(objFolderItem, i)
 					&#039; WScript.Echo HeaderInfoArray(i) &amp; &quot; &quot; &amp; objFolder.GetDetailsOf(objFolderItem, i)
                    If LCase(HeaderInfoArray(i)) = &quot;file version&quot; Then
                    	GetFileVersion = objFolder.GetDetailsOf(objFolderItem, i)
                    	Exit Function
                    End If
                Next
            End If
            
            Set objFolderItem = Nothing
        End If
        
        Set objFolder = Nothing
        Set objShell = Nothing
        On Error Goto 0
End Function &#039;GetFileVersion

Function GetFileDescription(folderName,fileName)
        On Error Resume Next
        Dim objShell
        Dim objFolder
        Dim HeaderInfoArray(250), i
        
        Set objShell = CreateObject(&quot;Shell.Application&quot;)
        Set objFolder = objShell.NameSpace(folderName)

        If (not objFolder is nothing) Then
            For i = 0 to 250  
                HeaderInfoArray(i) = objFolder.GetDetailsOf(objFolder.Items, i)
            Next
            Dim objFolderItem

            Set objFolderItem = objFolder.ParseName(fileName)

            If (not objFolderItem Is Nothing) then
                Dim objInfo
                For i = 0 To 250        
                    objInfo = objFolder.GetDetailsOf(objFolderItem, i)
                     &#039; WScript.Echo HeaderInfoArray(i) &amp; &quot; &quot; &amp; objFolder.GetDetailsOf(objFolderItem, i)
                    If LCase(HeaderInfoArray(i)) = &quot;description&quot; Or LCase(HeaderInfoArray(i)) = &quot;file description&quot; Then
                    	GetFileDescription = objFolder.GetDetailsOf(objFolderItem, i)
                    	Exit Function
                    End If
                Next
            End If
            
            Set objFolderItem = Nothing
        End If
        
        Set objFolder = Nothing
        Set objShell = Nothing
        On Error Goto 0
End Function &#039;GetFileDescription

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Browser,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Version,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
286,Operating System,2015-01-05T20:22:04,",","Returns disk drives which have less than 2 gigabytes free.
Example: C:",1,2939169480,0,569,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Low Disk Space,,,,,,,,,Windows,select Caption from Win32_logicaldisk where (FreeSpace &lt; 2000000000 AND Description=&#039;Local Fixed Disk&#039;),WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
287,Operating System,2015-01-05T20:22:04,",","Returns the number of user sessions for which the operating system is storing state.  This may differ from the number of interactively logged in users.
Example:3",1,2950466201,0,571,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Number Of Users,,,,,,,,,Windows,select NumberOfUsers from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
288,Hardware,2015-01-05T20:22:04,",","Returns the Model of a system.
Example: Precision T1600",1,2961425050,0,573,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Model,,,,,,,,,Windows,select Model from win32_ComputerSystem,WMIQuery,Linux,"#!/bin/bash
dmidecode -s system-product-name
",UnixShell,Mac,"#!/bin/bash
system_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Model Name:/ { print $2 } &#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
289,Network,2015-01-05T20:22:04,",","A list of all of the configured subnet masks for the network adapters of the client machine.
Example: 255.255.0.0",1,2977419696,0,575,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Subnet Mask,,,,,,,,,Windows,select IPSubnet from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
290,Operating System,2015-01-05T20:22:04,",","Returns the Language Code (LCID) of the Operating System.  This differs from the Locale Code returned in the Locale Code sensor.
Example: 1033",1,2997757654,0,577,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Operating System Language Code,,,,,,,,,Windows,select OSLanguage from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
291,Software,2015-01-05T20:22:04,",","Returns the currently installed roles on a Windows Server.
Example:  File Server",1,3057103978,0,579,1,Jim Olsen,3600,,,,2015-01-05T20:22:04,Windows Server Installed Roles,,,,,,,,,Windows,"&#039;========================================
&#039; Windows Server Installed Roles
&#039;========================================

Option Explicit

If Not IsWindowsServer() Then
	WScript.Echo &quot;Not Windows Server&quot;
Else
	If Left(GetOSMajorVersion(), 1) = &quot;5&quot; Then
		WScript.Echo &quot;Windows 2003 Server - Roles Not Available&quot;
	Else 
		EchoInstalledRolesUsingWMI()
	End If
End If

Function EchoInstalledRolesUsingWMI()
	Dim objWMIService, colItems, objItem
	
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ServerFeature&quot;,,48)
	For Each objItem in colItems
	    Wscript.Echo objItem.Name
	Next
End Function &#039; EchoInstalledRolesUsingWMI

Function IsWindowsServer()
	Dim bResult
	bResult = False

	Select Case (LCase(GetProductType))
		&#039; Workstations will always output WinNT
		Case &quot;servernt&quot;
			bResult = True
		Case &quot;lanmannt&quot;
			bResult = True		
	End Select
	
	IsWindowsServer = bResult
End Function &#039; IsWindowsServer
	
Function GetProductType

	Dim objShell
	Dim keyPath, strPath, strFoundPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyPath = &quot;SYSTEM\CurrentControlSet\Control\ProductOptions&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyPath&amp;&quot;\ProductType&quot;)
    On Error Goto 0
	strFoundPath = strPath
  	
  	If Not strPath = &quot;&quot; Then
  		GetProductType = strFoundPath
  	Else
  		GetProductType = False
  		WScript.Echo &quot;Error: Cannot determine OS type&quot;
  		WScript.Quit
  	End If
End Function &#039;GetProductType

Function GetOSMajorVersion
&#039; Returns the OS Major Version
&#039; A different way to examine the OS instead of by name

	Dim objWMIService,colItems,objItem
	Dim strVersion

	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    
	For Each objItem In colItems
		strVersion = objItem.Version &#039; like 6.2.9200
		strVersion = Left(strVersion,Len(strVersion) - 5)
	Next
	
	GetOSMajorVersion = strVersion
	
End Function &#039;GetOSMajorVersion",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
292,Hardware,2015-01-05T20:22:04,",","Returns the number of processor cores in all installed processors.  Not supported on all OS patch levels.
Example:2",1,3083322981,0,581,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Number of Processor Cores,,,,,,,,,Windows,"&#039;========================================
&#039; Number of Processor Cores
&#039;========================================

On Error Resume Next

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Processor&quot;,,48)

intNumCores = 0

For Each objItem in colItems
	intNumCores = intNumCores + objItem.NumberOfCores
	If intNumCores = 0 Then &#039; machine does not support counting cores
		strOs = GetOS
		&#039;Windows 2000 isn&#039;t supported for core count, can&#039;t determine hyperthreading
		If InStr(strOs, &quot;2000&quot;) &gt; 0 Then
			WScript.Echo &quot;Windows 2000 - Cannot determine&quot;
		ElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then
			WScript.Echo &quot;XP SP3 Required to determine&quot;
		ElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then
			&#039;For Win Server 2003 SEE KB 932370
			&#039;http://support.microsoft.com/kb/932370/
			WScript.Echo &quot;KB932370 Required to determine&quot;
		Else
			WScript.Echo &quot;N/A&quot;
		End If
	End If
Next

If Not intNumCores = 0 Then
	WScript.Echo intNumCores
End If


Function GetOS
	Set oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    
	Set oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)    
	Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    
	For Each objItem In colItems       
	strStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   
	&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   
	if Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   
	strOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   
	Else   
	strOS = strStrip1
	End IF   
	GetOS = Trim(strOS)
	Next
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
293,Tanium Diagnostics,2015-01-05T20:22:04,",","Returns if sensor execution is randomized on an endpoint, for better distribution on VDI / VM environments.
Example: Yes",1,3103658637,0,583,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Tanium Sensor Randomization Enabled,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Sensor Randomization Enabled
&#039;========================================


Option Explicit

Const HKLM = &amp;h80000002

Dim objReg
Dim strTaniumRegPath, strSensorRandomizationEnabledValue
Dim strComputer

strComputer = &quot;.&quot;

Set objReg = _ 
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

strTaniumRegPath = GetTaniumRegistryPath()
&#039;retrieve registry entry for Sensor Randomization
objReg.GetDWordValue HKLM, strTaniumRegPath, &quot;RandomSensorDelayInSeconds&quot;, strSensorRandomizationEnabledValue

If Not IsNull(strSensorRandomizationEnabledValue) Then
	If strSensorRandomizationEnabledValue &gt; 0 Then
		WScript.Echo &quot;Yes&quot;
		WScript.Echo strSensorRandomizationEnabledValue
	Else
		WScript.Echo &quot;No&quot;
	End If
Else 
	WScript.Echo &quot;No&quot;
End If 

&#039;Cleanup
Set objReg = Nothing

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
294,Applications,2015-01-05T20:22:04,|,"List of add-ons to Internet Explorer and indicates whether they are a Toolbar, Extension, or Browser Helper Objects.
Example: Java(tm) Plug-In SSV Helper|BHO",1,3114455387,0,585,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Internet Explorer Add-Ons,,,,,,,,,Windows,"&#039;========================================
&#039; Internet Explorer Add-Ons
&#039;========================================

Option Explicit

&#039; WSHVersionOK &#039;call if necessary
&#039; SetLocale(GetTaniumLocale) &#039;call if necessary

Dim is64bitmachine

is64bitmachine = Is64

&#039;// BHOs
&#039;HKLM\Software\Microsoft\Windows\CurrentVersion\explorer\Browser Helper Objects 
&#039;// IE toolbars
&#039;HKLM\Software\Microsoft\Internet Explorer\Toolbar
&#039;// IE extensions
&#039;HKLM\Software\Microsoft\Internet Explorer\Extensions
&#039;// ActiveX
&#039;HKCU\Software\Microsoft\Windows\CurrentVersion\Ext\Stats

Dim reg, strComputer, bShowInProcServer
Const HKCR = &amp;H80000000
Const HKLM = &amp;H80000002
Const HKU = &amp;H80000003

strComputer = &quot;.&quot;
Set reg = Getx64RegistryProvider()

ListBHOs
ListToolbars
ListExtensions
ListActiveXControls

Function LookupClassName(clsid)
	Dim strKeyPath, value, inProc, rootErrorCheck, inProcErrorCheck
	strKeyPath = &quot;CLSID\&quot;&amp;clsid
	rootErrorCheck = reg.GetStringValue(HKCR, strKeyPath,&quot;&quot;,value)
	If (rootErrorCheck=0 And Not IsNull(value)) Then
		inProcErrorCheck = reg.GetStringValue(HKCR, strKeyPath&amp;&quot;\InProcServer32&quot;,&quot;&quot;,inProc)
		If inProcErrorCheck = 0 Then 
			value = inProc&amp;&quot;|&quot;&amp;value
		Else
			value = &quot;Unknown&quot;&amp;&quot;|&quot;&amp;value
		End If
        LookupClassName = value
    Else
    	strKeyPath = &quot;Wow6432Node\CLSID\&quot;&amp;clsid
		rootErrorCheck = reg.GetStringValue(HKCR, strKeyPath,&quot;&quot;,value)
		If (rootErrorCheck=0 And Not IsNull(value)) Then
			inProcErrorCheck = reg.GetStringValue(HKCR, strKeyPath&amp;&quot;\InProcServer32&quot;,&quot;&quot;,inProc)
			If inProcErrorCheck = 0 Then 
				value = inProc&amp;&quot;|&quot;&amp;value
			Else
				value = &quot;Unknown&quot;&amp;&quot;|&quot;&amp;value
			End If
        	LookupClassName = value			
        Else &#039; cannot pull registry value, cannot look up class name
   			LookupClassName = &quot;Unknown&quot;&amp;&quot;|&quot;&amp;clsid
    	End If
	End If
End Function

Function LookupExtensionName(clsid)
	Dim strKeyPath, value, rootErrorCheck, inProc, inProcErrorCheck
	strKeyPath = &quot;SOFTWARE\Microsoft\Internet Explorer\Extensions\&quot;&amp;clsid
	rootErrorCheck = reg.GetStringValue(HKLM, strKeyPath,&quot;MenuText&quot;,value)
	If (rootErrorCheck=0 And Not IsNull(value)) Then
		value = &quot;N/A&quot;&amp;&quot;|&quot;&amp;value &#039; no InProcServer file name for an extension
        LookupExtensionName = value
    Else
    	strKeyPath = &quot;SOFTWARE\wow6432node\Microsoft\Internet Explorer\Extensions&quot;&amp;clsid
		rootErrorCheck = reg.GetStringValue(HKLM, strKeyPath,&quot;MenuText&quot;,value)
		If (rootErrorCheck=0 And Not IsNull(value)) Then
			value = &quot;N/A&quot;&amp;&quot;|&quot;&amp;value &#039; no InProcServer file name for an extension
        	LookupExtensionName = value
        Else
    		LookupExtensionName = &quot;N/A&quot;&amp;&quot;|&quot;&amp;clsid &#039; no InProcServer file name for an extension
    	End If
	End If
End Function

Function ListBHOs
	&#039;WScript.Echo &quot;Listing BHOs&quot;
	Dim strKeyPath, arrSubKeys, errorCheck, subkey
	strKeyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\explorer\Browser Helper Objects&quot;
	
	errorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)
	If (errorCheck=0 and IsArray(arrSubKeys)) then
        For Each subkey In arrSubKeys
        	WScript.Echo LookupClassName(subkey) &amp; &quot;|BHO&quot;
        Next
    End If
    
    If is64bitmachine Then
    	strKeyPath = &quot;SOFTWARE\wow6432node\Microsoft\Windows\CurrentVersion\explorer\Browser Helper Objects&quot;
	
		errorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)
		If (errorCheck=0 and IsArray(arrSubKeys)) then
	        For Each subkey In arrSubKeys
	        	WScript.Echo LookupClassName(subkey) &amp; &quot;|BHO&quot;
	        Next
	    End If
    End If
	
End Function

Function ListToolbars
	&#039;WScript.Echo &quot;Listing Toolbars&quot;
	Dim strKeyPath, arrValues, errorCheck, value
	strKeyPath = &quot;SOFTWARE\Microsoft\Internet Explorer\Toolbar&quot;
	
	errorCheck = reg.EnumValues(HKLM, strKeyPath, arrValues)
	If (errorCheck=0 and IsArray(arrValues)) then
        For Each value In arrValues
        	WScript.Echo LookupClassName(value)&amp; &quot;|Toolbar&quot;
        Next
    End If
    
    If is64bitmachine Then
    	strKeyPath = &quot;SOFTWARE\wow6432node\Microsoft\Internet Explorer\Toolbar&quot;
    	
		errorCheck = reg.EnumValues(HKLM, strKeyPath, arrValues)
		If (errorCheck=0 and IsArray(arrValues)) then
	        For Each value In arrValues
	        	WScript.Echo LookupClassName(value)&amp; &quot;|Toolbar&quot;
	        Next
	    End If
    End If
End Function

Function ListExtensions
	&#039;WScript.Echo &quot;Listing Extensions&quot;
	Dim strKeyPath, arrSubKeys, errorCheck, subkey
	strKeyPath = &quot;SOFTWARE\Microsoft\Internet Explorer\Extensions&quot;
	
	errorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)
	If (errorCheck=0 and IsArray(arrSubKeys)) then
        For Each subkey In arrSubKeys
        	WScript.Echo LookupExtensionName(subkey)&amp; &quot;|Extension&quot;
        Next
    End If
    
    If is64bitmachine Then
    	strKeyPath = &quot;SOFTWARE\wow6432node\Microsoft\Internet Explorer\Extensions&quot;
	
		errorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)
		If (errorCheck=0 and IsArray(arrSubKeys)) then
	        For Each subkey In arrSubKeys
	        	WScript.Echo LookupExtensionName(subkey)&amp; &quot;|Extension&quot;
	        Next
	    End If
    End If
End Function

Function ListActiveXControls
	Dim errorCheck, subkey, arrSubKeys, strKeyPath
	
	strKeyPath = &quot;SOFTWARE\Microsoft\Windows\CurrentVersion\Ext&quot;
	errorCheck = reg.EnumKey(HKU, &quot;&quot;, arrSubKeys)
	If (errorCheck=0 and IsArray(arrSubKeys)) then
		For Each subkey In arrSubKeys
			&#039;WScript.Echo &quot;Looking in subkey: &quot;&amp;subkey
			ListActiveXControlsForUser subkey
		Next
	End If
	
End Function

Function ListActiveXControlsForUser(userkey)
	&#039;WScript.Echo &quot;Listing ActiveXControls&quot;
	Dim strKeyPath, arrSubKeys, errorCheck, subkey
	
	strKeyPath = userkey&amp;&quot;\SOFTWARE\Microsoft\Windows\CurrentVersion\Ext\Settings&quot;	
	errorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)
	If (errorCheck=0 and IsArray(arrSubKeys)) then
        For Each subkey In arrSubKeys
        	WScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;
        Next
    End If
    
    If is64bitmachine Then
    	strKeyPath = userkey&amp;&quot;\SOFTWARE\wow6432node\Microsoft\Windows\CurrentVersion\Ext\Settings&quot;
		errorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)
		If (errorCheck=0 and IsArray(arrSubKeys)) then
	        For Each subkey In arrSubKeys
	        	WScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;
	        Next
	    End If
    End If
	
	strKeyPath = userkey&amp;&quot;\SOFTWARE\Microsoft\Windows\CurrentVersion\Ext\Stats&quot;	
	errorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)
	If (errorCheck=0 and IsArray(arrSubKeys)) then
        For Each subkey In arrSubKeys
        	WScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;
        Next
    End If
    
    If is64bitmachine Then	
    	strKeyPath = userkey&amp;&quot;\SOFTWARE\wow6432node\Microsoft\Windows\CurrentVersion\Ext\Stats&quot;
		errorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)
		If (errorCheck=0 and IsArray(arrSubKeys)) then
	        For Each subkey In arrSubKeys
	        	WScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;
	        Next
	    End If
    End If
	
End Function


&#039;&#039; -- standard help functions -- &#039;&#039;
Sub WSHVersionOK
	If Not CDbl(WScript.Version) &gt;= 5.6 Then
		WScript.Echo &quot;Unsupported WSH version: &quot; &amp; WScript.Version
		WScript.Quit
	End If
End Sub &#039;WSHVersionOK

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale
Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Add-On File,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Add-On Name,String,0,1,2,Add-On Type,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
295,Hardware,2015-01-05T20:22:04,",","Returns the Version of a motherboard.
Example:9230",1,3133617106,0,587,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Motherboard Version,,,,,,,,,Windows,"&#039;========================================
&#039; Motherboard Version
&#039;========================================

Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
Set colMB = objWMIService.ExecQuery(&quot;Select * from Win32_BaseBoard&quot;)
For Each mb In colMB
mbVersion = mb.Version
WScript.Echo mbVersion
Next",VBScript,Linux,"#!/bin/bash
dmidecode -s baseboard-version
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
296,Hardware,2015-01-05T20:22:04,",","Returns the revision number of installed CPUs.
Example: 5898",1,3133620839,0,589,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Revision of CPU,,,,,,,,,Windows,select Revision from win32_processor,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
297,Hardware,2015-01-05T20:22:04,|,"Returns of details of attached USB devices, including Description, vendor ID, and product ID.
Example:  Generic USB Hub|VMware, Inc.|Virtual USB Hub",1,314220795,0,591,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,USB Device Details,,,,,,,,,Windows,"&#039;========================================
&#039; USB Device Details
&#039;========================================

Option Explicit

Const HARDWARE_TOOLS = &quot;Tools\Hardware&quot;
Const USB_ID_FILE = &quot;usb.ids&quot;
Const VIEWABLE_NAME = &quot;VIEWABLE_NAME&quot;


Dim objFSO, strToolsDir, strUSBIDs, dictVendors
Dim objWMIService, colItems, objItem

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
strToolsDir = GetTaniumDir(HARDWARE_TOOLS)
strUSBIDs = strToolsDir &amp; USB_ID_FILE

dictVendors = Null

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;) 
Set colItems = objWMIService.ExecQuery( _
    &quot;SELECT * FROM Win32_USBHub&quot;,,48) 
For Each objItem in colItems 
	Dim strDevId, strPid, strVid
	strDevId = &quot;&quot;
	strPid = &quot;&quot;
	strVid = &quot;&quot;
	
	strDevId = objItem.DeviceID
	If(InStr(strDevId,&quot;VID_&quot;)&lt;&gt;0) Then
		strVid = Mid(strDevId,InStr(strDevId,&quot;VID_&quot;)+4,4)
	End If
	If(InStr(strDevId,&quot;PID_&quot;)&lt;&gt;0) Then
		strPid = Mid(strDevId,InStr(strDevId,&quot;PID_&quot;)+4,4)
	End If
	
	If(strDevId&lt;&gt;&quot;&quot; And strPid&lt;&gt;&quot;&quot; And strVid&lt;&gt;&quot;&quot;) Then
		&#039; ok, only take on reading the in the usb.ids file if we have at least one device
		If(objFSO.FileExists(strUSBIDs) And IsNull(dictVendors)) Then 
			Set dictVendors = CreateObject(&quot;Scripting.Dictionary&quot;)
			LoadVendorProductMap dictVendors, strUSBIDs
		End If
	
		WScript.Echo GenOutputString(objItem.Description, strVid, strPid, dictVendors)
	End If
Next

Function GenOutputString(strDescription, strVid, strPid, dictVendors) 
	Dim strVidName, strPidName, dictVendor
	strVidName = strVid
	strPidName = strPid
	
	If Not IsNull(dictVendors) Then 
		If dictVendors.Exists(LCase(strVid)) Then 
			Set dictVendor = dictVendors.Item(LCase(strVid))
			
			strVidName = dictVendor.Item(VIEWABLE_NAME)
			If dictVendor.Exists(LCase(strPid)) Then 
				strPidName = dictVendor.Item(LCase(strPid))
			End If
		End if
	End If

	GenOutputString = strDescription &amp; &quot;|&quot; &amp; strVidName &amp; &quot;|&quot; &amp; strPidName
End Function &#039; GenOutputString


Sub LoadVendorProductMap(dictVendors, strFile)
	Dim objFSO, objReadFile, bStopReading, strLine, dictCurrentVendor
	Dim strWords, strKey, strValue
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

	Set objReadFile = objFSO.OpenTextFile(strFile, 1, False)
	
	bStopReading = False

	Do While Not objReadFile.AtEndOfStream And Not bStopReading
		strLine = objReadFile.ReadLine
		
		If InStr(strLine, &quot;# List of known device classes, subclasses and protocols&quot;) &gt; 0 Then 
			&#039; this is our signal to stop -- after this are no more vendors
			bStopReading = True
		ElseIf Left(strLine, 1) = &quot;#&quot; Or Trim(strLine) = &quot;&quot; Then 
			&#039; do nothing - this is a skip
		ElseIf Left(strLine, 1) = vbTab Then 
			strLine = Right(strLine, Len(strLine) - 1)
			strWords = Split(strLine, &quot; &quot;, 2)
			strKey = strWords(0)
			strValue = Trim(strWords(1))
			dictCurrentVendor.Add LCase(strKey), strValue		
		Else 
			strWords = Split(strLine, &quot; &quot;, 2)
			strKey = strWords(0)
			strValue = Trim(strWords(1))
			Set dictCurrentVendor = CreateObject(&quot;Scripting.Dictionary&quot;)
			If Not dictVendors.Exists(strKey) Then 
				dictVendors.Add LCase(strKey), dictCurrentVendor
			End If 
			dictCurrentVendor.Add VIEWABLE_NAME, strValue
		End If
	Loop
	objReadFile.Close

End Sub &#039; LoadVendorProductMap

	
Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Description,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Vendor ID,String,0,1,2,Product ID,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
298,Hardware,2015-01-05T20:22:04,",","Provides errors codes for hardware devices that failed to load correctly at last boot.
Example: none",1,3145690673,0,593,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Hardware Device Failed to Load,,,,,,,,,Windows,Select * from Win32_PnPEntity WHERE ConfigManagerErrorCode &lt;&gt; 0,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
299,SQL,2015-01-05T20:22:04,",","Returns database name and recovery mode for that database from all databases in SQL Server on client machine.
Example: ReportServer SIMPLE",1,3147407985,0,595,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,SQL Recovery Mode,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Recovery Mode
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit

Dim dictInstances, strInstance, objConnection

Set dictInstances = GetMSSQLInstances()

For Each strInstance In dictInstances.Keys
	Dim objRecordSet, Record, objRecordSet2, strDatabase, strDBRecovery
	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;) 
	Set objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  

	On Error Resume Next
	objConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)
	
	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 
	On Error Goto 0

	objRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  
	For each Record in objRecordSet.Properties    
		strDatabase = objRecordSet(&quot;name&quot;)    
		objRecordSet2.Open &quot;select databasepropertyex([name],&#039;Recovery&#039;) as [Recovery] from dbo.sysdatabases where name=&quot; &amp; &quot;&#039;&quot; &amp; strDatabase &amp; &quot;&#039;&quot;, _         
			objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC        
		strDBRecovery = objRecordSet2(&quot;Recovery&quot;)       
		WScript.echo strDatabase &amp; &quot; &quot; &amp; strDBRecovery &amp; GetMSSQLSensorInstanceStr(strInstance)    
		objRecordset2.Close     
		objRecordSet.MoveNext    
		If (objRecordset.EOF = True) THEN       
			objRecordset.Close       
			Exit For    
		End If     
	Next 
Next
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
300,Operating System,2015-01-05T20:22:04,",","Total swap space configured by client machine.
Example: 4000 MB",1,3147580256,0,597,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Total Swap,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
memLine=$(free -m | grep &quot;Swap&quot;)
set -- $memLine
echo $2 MB
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
301,Tanium,2015-01-05T20:22:04,|,"Returns the path to and size of the Tanium Client ""Downloads"" directory.  This is the directory to which Tanium Package files are downloaded.  It is considered temporary space and will clean itself out periodically.
Example: C:\Program Files (x86)\Tanium\Tanium Client\Downloads|139.4 MB",1,3157180652,0,599,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:04,Tanium Client Downloads Directory Details,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Downloads Directory Details
&#039;========================================

&#039;Script will return path and size of Tanium Downloads directory

Option Explicit

SetLocale(GetTaniumLocale)

Const HKLM = &amp;H80000002
Dim objRegistry,strTaniumClientKey
Dim objFSO,objFolder,strTaniumClientPath,strTaniumClientDownloadsPath
Dim strSize,strSep

strSep = &quot;|&quot;

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

Set objRegistry=GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)

strTaniumClientKey = GetTaniumRegistryPath()
If Not strTaniumClientKey = &quot;&quot; Then
	objRegistry.GetStringValue HKLM,strTaniumClientKey,&quot;Path&quot;,strTaniumClientPath
End If

If ( IsNull(strTaniumClientPath) Or strTaniumClientPath = &quot;&quot;) Or ( Not objFSO.FolderExists(strTaniumClientPath)) Then
	WScript.Echo &quot;Tanium Client Directory Not Found&quot;
Else
	strTaniumClientDownloadsPath = strTaniumClientPath&amp;&quot;\Downloads&quot;
	Set objFolder = objFSO.GetFolder(strTaniumClientDownloadsPath)
	strSize = GetAccessibleFolderSize(strTaniumClientDownloadsPath)
	strSize = GetPrettyFileSize(strSize)
	Wscript.Echo strTaniumClientDownloadsPath &amp; strSep &amp; strSize
End If

&#039; --- end main --- &#039;

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function GetPrettyFileSize(strSize)
Dim dblSize
	dblSize = CDbl(strSize)

	If dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB
		strSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;	
	ElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB
		strSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;
	ElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB
		strSize = CStr(Round(dblSize / 1024)) &amp; &quot; kB&quot;
	Else
		strSize = CStr(dblSize) &amp; &quot; B&quot;	
	End If	
	GetPrettyFileSize = strSize
End Function &#039;GetPrettyFileSize


Function GetAccessibleFolderSize(strFolderPath)
&#039; Gets the folder sizes that it is able to
&#039; and skips those it has no rights to see
    On Error Resume Next &#039; Permissions Errors potentially

	Dim objFSO
    Dim objFolder,objSubfolder,intSize,bHasSubfolders	
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	    
    bHasSubfolders = False

    Set objFolder = objFSO.GetFolder(strFolderPath)
    Err.Clear
    intSize = objFolder.Size
    If Err.Number &lt;&gt; 0 Then
        For Each objSubfolder in objFolder.SubFolders
            intSize = intSize + GetAccessibleFolderSize(objSubfolder.Path)
            bHasSubfolders = True
        Next

        If Not bHasSubfolders Then
            intSize = objFolder.Size
        End If
    End If

    GetAccessibleFolderSize = intSize
    
    On Error Goto 0

End Function &#039;GetAccessibleFolderSize

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Path,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Size,DataSize,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
302,Hardware,2015-01-05T20:22:04,",","The total physical memory installed in the client machine.
Example: 8000 MB",1,316030016,0,601,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Total Memory,,,,,,,,,Windows,"&#039;========================================
&#039; Total Memory
&#039;========================================

Option Explicit

Dim objWMIService, colItems, objItem, strTotalMemory

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
 
&#039;Gets total memory
Set colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_Computersystem &quot;)
For Each objItem In colItems  
 strTotalMemory = Int(objItem.TotalPhysicalMemory / 1024 / 1024)
 wscript.echo strTotalMemory &amp; &quot; MB&quot;
Next",VBScript,Linux,"#!/bin/bash
memLine=$(free -m | grep &quot;Mem&quot;)
set -- $memLine
echo $2 MB
",UnixShell,Mac,"#!/bin/bash
system_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Memory:/ { print $2 } &#039;
",UnixShell,0,6,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
303,Hardware,2015-01-05T20:22:04,",","Returns the names of PCI devices in the system.
Example:Intel(R) 82371AB/EB PCI Bus Master IDE Controller",1,3170446499,0,603,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,PCI Device,,,,,,,,,Windows,select Caption from Win32_PnPEntity where (Status=&#039;OK&#039; and DeviceID like &#039;%PCI%&#039;),WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
304,User,2015-01-05T20:22:04,",","Returns the number of interactively logged in users.  On Windows, this will include Remote Desktop sessions.
Example: 2",1,3170496172,0,605,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Number of Logged In Users,,,,,,,,,Windows,"&#039;========================================
&#039; Number of Logged In Users
&#039;========================================

Option Explicit

Dim objWMIService,colItems,objItem,i

Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;) 
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process Where Name=&#039;explorer.exe&#039;&quot;,,48)

i = 0
For Each objItem in colItems
	i = i + 1
Next

WScript.Echo i",VBScript,Linux,"#!/bin/bash
who -q | grep &quot;users=&quot; | cut -d= -f2
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
305,Operating System,2015-01-05T20:22:04,",","Returns the OS Locale Code from the installed operating system.  This differs from the LCID returned in the OS language sensor.
Example:0409",1,3177804004,0,607,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:04,Locale Code,,,,,,,,,Windows,select Locale from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
306,Applications,2015-01-05T20:22:04,|,"Returns all running processes along with the memory each process uses.  This is the process's working set.
Example: lsass.exe|23 MB",1,319662655,0,609,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:04,Running Processes Memory Usage,,,,,,,,,Windows,"&#039;========================================
&#039; Running Processes Memory Usage
&#039;========================================

Dim objWMIService,colItems,objItem,strSep,strMem,strProcess

strSep = &quot;|&quot;

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process&quot;,,48)

On Error Resume Next
For Each objItem in colItems
	strProcess = objItem.Caption
	If Err.Number &lt;&gt; 0 Then strProcess = &quot;Unknown&quot;
	
	strMem = objItem.WorkingSetSize
	If Err.Number &lt;&gt; 0 Then strMem = &quot;Unknown&quot;
	
	WScript.Echo strProcess &amp; strSep &amp; PrettyFileSize(strMem)
Next
On Error Goto 0

Function PrettyFileSize(strSize)
	
	strSize = CStr(strSize) &#039; convert all input to string
	
	Dim strOut,intKB,intMB,intGB,intSize
	
	If Not IsNumeric(strSize) Then
		strOut = &quot;Unknown&quot;
		PrettyFileSize = strOut
		Exit Function
	Else
		If Not CStr(CLng(strSize)) = strSize Then
			&#039;not an integer
			strOut = &quot;Unknown&quot;
			PrettyFileSize = strOut
			Exit Function
		End If
	End If
	
	intSize = CLng(strSize)
	intKB = 1024
	intMB = 1024*1024
	intGB = 1024*1024*1024
	
	If intSize &gt; intGB Then
		strOut = Int(intSize / intGB) &amp; &quot; GB&quot;
	ElseIf intSize &gt; intMB Then
		strOut = Int(intSize / intMB) &amp; &quot; MB&quot;
	ElseIf intSize &gt; intKB Then
		strOut = Int(intSize / intKB) &amp; &quot; KB&quot;
	Else
		strOut = intSize &amp; &quot; B&quot;
	End If
	
	PrettyFileSize = strOut
End Function &#039;PrettyFileSize",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Process Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Memory Used,DataSize,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
307,Network,2015-01-05T20:22:05,|,"Returns information network-aware processes and the ports they have bound to.
Example: googletalkplugin.exe Google Talk Plugin :60042",1,3200371050,0,611,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Listen Ports,,,,,,,,,Windows,"&#039;========================================
&#039; Listen Ports
&#039;========================================

showProcess = True
showPort = True

Dim strcommand, results, excludeProcesses, excludeSubnets, taniumDebug
Dim strSep : strSep = &quot;|&quot;
&#039; This is a multi-column sensor that looks like:
&#039;Process|Name|Target IP

excludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;
&#039;excludeProcesses = &quot;chrome.exe&quot;
&#039;excludeProcesses = &quot;iexplore.exe&quot;
&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;
&#039;excludeProcesses = &quot;trillian.exe&quot;

excludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;
&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;

taniumDebug = False


excludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)
excludeSubnets = Split(excludeSubnets, &quot;,&quot;)

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
query = &quot;select name, executablepath, processId from win32_process&quot;
Set colResults = objWMIService.ExecQuery(query)

&#039;dictionary for process-app pairs
Set processes = CreateObject(&quot;Scripting.Dictionary&quot;)

For Each result In colResults 
   processId = CStr(result.ProcessId)
   processPath = result.ExecutablePath
   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later
Next

strcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find &quot; &amp; chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34)

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strPingResults = LCase(objScriptExec.StdOut.ReadAll)

results = Split(strPingResults, vbCrLf)
j = 0

For Each line in results
   line = cleanWhitespace(Trim(line))
   
   lineResults = Split(line)
   i = 0
   Dim strPort, strPid, strConnectionType, strForeignIp, strApp
   For Each word In lineResults
      If i = 1 Then
         strPort = word
         strPort = Right(strPort, Len(strPort) - InStr(strPort, &quot;:&quot;) + 1)
      ElseIf i = 2 Then
         strForeignIp = word
      ElseIf i = 3 Then
         strConnectionType = word
      ElseIf i = 4 Then
         strPid = word
      End If
      
      i = i + 1
   Next
   
   &#039;DO NOT INCLUDE EXCLUDED APPS
   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path
   arrAppEntry = Split(strAppEntry,&quot;,&quot;)
   strAppExe = arrAppEntry(0)
   strAppPath = arrAppEntry(1)
   
   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))
   
   &#039;DO NOT INCLUDE EXCLUDED SUBNETS
   isNotExcludedSubnet = Not(ContainedInSubnet(strForeignIp, excludeSubnets))
   
   If Not(IsEmpty(strAppExe)) _
      And isNotExcludedApp _ 
      And isNotExcludedSubnet Then

	  If Not showPort Then 
	  	arrTemp = Split(strForeignIp, &quot;:&quot;)
		strForeignIp = arrTemp(0)
	  End If

      If showProcess Then
      	results(j) = strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strPort
      Else
        results(j) = strSep &amp; strSep &amp; strForeignIp
      End If	
   Else
      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp
      results(j) = &quot;&quot;   
   End If 
   
   j = j + 1
Next

results = RemDups(results)

If UBound(results) &lt; 1 Then
	If GetLocale() &lt;&gt; 1033 Then
		WScript.Echo &quot;English Language OS Required&quot;
	End If
End If

For Each result In results 
   WScript.Echo result
Next

WScript.Quit

Function ContainedInSubnet(str, arr)
   Dim strIp, strSubnet, strMask
   temp = Split(str, &quot;:&quot;)
   strIp = temp(0)

   For Each item In arr
      If InStr(item, &quot;-&quot;) Then &#039;Subnet range
         temp = Split(item, &quot;-&quot;)
         lower = Split(temp(0), &quot;:&quot;)
         upper = Split(temp(1), &quot;:&quot;)
         lowerSubnet = Trim(lower(0))
         lowerMask = Trim(lower(1))
         upperSubnet = Trim(upper(0))
         upperMask = Trim(upper(1))
         
         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _
            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then
            ContainedInSubnet = True
            Exit Function
         End If 
      Else &#039;Single subnet
         parts = Split(item, &quot;:&quot;)
         strSubnet = Trim(parts(0))
         strMask = Trim(parts(1))
         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then
            ContainedInSubnet = True
            Exit Function
         End If
      End If 
   Next
   ContainedInSubnet = False
End Function

Function ContainedInArray(str, arr)
   For Each item In arr 
      If str = Trim(item) Then
         ContainedInArray = True
         Exit Function
      End If   
   Next
   ContainedInArray = False
End Function

Function cleanWhitespace(strStarter)
   intStarter = Len(strStarter)
   For i = intStarter to 2 Step -1
      strChars = Space(i)
      strStarter = Replace(strStarter, strChars, &quot; &quot;)
   Next
   cleanWhitespace = strStarter
End Function

Function RemDups(ByVal anArray)
   Dim d, item, thekeys
   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)
   d.removeall
   d.CompareMode = 0
   For Each item In anArray
      If Len(item) &gt; 0 Then
         If Not d.Exists(item) Then d.Add item, item
      End If
   Next
   thekeys = d.keys
   Set d = Nothing
   RemDups = thekeys
End Function

Function Subnet(strAddress, strMask)
   intSubnetLength = SubnetLength(strMask)
   Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))
End Function

Function SubnetLength(strMask)
   strMaskBinary = StringToBinary(strMask)
   SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))
End Function

Function BinaryToString(strBinary)
   For intOctetPos = 1 To 4
      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)
      intOctet = 0
      intValue = 1
      For intBinaryPos = 1 To Len(strOctetBinary)
         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue
         intValue = intValue * 2
      Next
      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)
   Next
End Function

Function StringToBinary(strAddress)
   objAddress = Split(strAddress, &quot;.&quot;, -1)
   For Each strOctet In objAddress
      intOctet = CInt(strOctet)
      strOctetBinary = &quot;&quot;
      For x = 1 To 8
         If intOctet Mod 2 &gt; 0 Then
            strOctetBinary = &quot;1&quot; &amp; strOctetBinary
         Else
            strOctetBinary = &quot;0&quot; &amp; strOctetBinary
         End If
         intOctet = Int(intOctet / 2)
      Next
      StringToBinary = StringToBinary &amp; strOctetBinary
   Next
End Function

Function ProcessNameToApplicationName(strExecutablePath, strExecutableName)
&#039; This function will return the full application name of a running executable

		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		
		arrPathParts = Split(strExecutablePath,&quot;\&quot;)

		If UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process
			ProcessNameToApplicationName = strExecutableName
			Set fso = Nothing
			Exit Function
		End If
		strExecutable = arrPathParts(UBound(arrPathParts))
		
		If fso.FileExists(strExecutablePath) Then
			Dim strOutput, fileVersion, fileVersionOutput, fullName
		
			Set execFile = fso.GetFile(strExecutablePath)
			fullName = GetDescription(execFile.ParentFolder.Path, strExecutable)
			If Not fullName = &quot;&quot; Then
				ProcessNameToApplicationName = fullName
			Else
				ProcessNameToApplicationName = strExecutableName
			End If
		Else &#039; file doesn&#039;t exist or inaccessible
			ProcessNameToApplicationName = strExecutableName
		End If

End Function &#039;ProcessNameToApplicationName

Function GetDescription(folderPath, fileName)
	descIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)
	If IsEmpty(descIndex) Then
		descIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)
	End If
	GetDescription = GetFileProperty(folderPath, fileName, descIndex)
End Function

Function GetFileProperty(folderPath, fileName, fileProperty)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	GetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)
End Function

Function GetAttributeIndex(folderPath, attrTarget)
	Set objShell = CreateObject(&quot;Shell.Application&quot;)
	Set objFolder = objShell.Namespace(folderPath)
	For i = 0 to 50
		attrName = objFolder.GetDetailsOf(objFolder.Items, i)
		If LCase(attrName) = LCase(attrTarget) Then
			GetAttributeIndex = i
			Exit Function
		End If
	Next
	
End Function",VBScript,Linux,"#!/bin/sh
tmpfile=&quot;/tmp/tanium.$$&quot;
lsof -p ^$PPID -iTCP -sTCP:LISTEN -P +c 15 -n &gt; $tmpfile
cat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($9,index($9,&quot;:&quot;))}&#039;
rm -f $tmpfile
",UnixShell,Mac,"#!/bin/sh
tmpfile=&quot;/tmp/tanium.$$&quot;
lsof -p ^$PPID -iTCP -sTCP:LISTEN -P +c 15 -n &gt; $tmpfile
cat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($9,index($9,&quot;:&quot;))}&#039;
rm -f $tmpfile
",UnixShell,0,0,0,1,0,Process,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Name,String,0,1,2,Local Port,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
308,Operating System,2015-01-05T20:22:05,|,"Returns the Date and Time that the OS last booted.  This is a multi-column sensor.
Example: 12/10/2012 18:41",1,3226581166,0,613,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,OS Boot Time,,,,,,,,,Windows,"&#039;========================================
&#039; OS Boot Time
&#039;========================================

&#039; This sensor will return the time the OS booted up
&#039; it is a multi-column sensor and should have the format
&#039; Date | Time

Dim dateBootTime, strFinalOutputString, strSep
SetLocale(GetTaniumLocale)

strSep = &quot;|&quot;
dateBootTime = GetBootTime

WScript.Echo FormatDateTime(dateBootTime,vbShortDate) &amp; &quot;|&quot; &amp; FormatDateTime(dateBootTime,vbShortTime)

&#039;-----------End Main-------------&#039;
Function GetBootTime
&#039; Retrieves a nicely formatted bootup time
	Dim objSWbemDateTime
	Dim objWMIService
	Dim colOperatingSystems
	Dim strComputer
	Dim dateBootTime
	
	strComputer = &quot;.&quot;
	
	Set objSWbemDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
	Set colOperatingSystems = objWMIService.ExecQuery (&quot;Select * from Win32_OperatingSystem&quot;)
	 
	For Each objOperatingSystem in colOperatingSystems
		objSWbemDateTime.Value = objOperatingSystem.LastBootUpTime
		dateBootTime = CDate(objSWbemDateTime.GetVarDate(False))
	Next

    &#039; Now to correct for time zones 
    Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
     
    For Each objTimeZone in colTimeZone
        intTZBiasInMinutes = objTimeZone.CurrentTimeZone
        dateBootTime = DateAdd(&quot;n&quot;, intTZBiasInMinutes, dateBootTime)
    Next
	
	&#039;return result
	GetBootTime = dateBootTime
	
	&#039;Cleanup
	Set objSWbemDateTime = Nothing
	Set objWMIService = Nothing
	Set colOperatingSystems = Nothing
	Set colTimeZone = Nothing

End Function &#039;GetBootTime

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Date,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Time,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
309,Hardware,2015-01-05T20:22:05,",","Returns the names of the network connections which are active.
Example: Local Area Connection",1,3276808962,0,615,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Network Adapter Type,,,,,,,,,Windows,select NetConnectionID from Win32_NetworkAdapter where (NetConnectionStatus = 2),WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
310,Registry,2015-01-05T20:22:05,|,"Returns all subkeys of a supplied key.  If the hive is HKEY_USERS, it will attempt to output the user name associated with the key.  HKEY_CURRENT_USER will only return data for the SYSTEM account which the Tanium Client runs as.
Example: John |Sensor Data | 32-bit",1,3285711879,0,617,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Registry Key Subkeys,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{5}"",""helpString"":""Value must be at least 5 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the registry key to query"",""value"":"""",""promptText"":""e.g. HKEY_USERS\\Software\\Key"",""defaultValue"":"""",""label"":""Registry Key"",""maxChars"":0,""key"":""strKey"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Registry Key Subkeys
&#039;========================================

&#039;Columns:
&#039; User | Subkey Name | Architecture | KeyPath

strKey = unescape(&quot;||strKey||&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client&quot;
&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;

strSep = &quot;|&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive


&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)
If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If

If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive	
		hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True	
	End If
End If

If Not (hasAnyResult) Then
	WScript.Echo &quot;Key/Value not found&quot;
End If

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

	&#039; Note the key that was being searched, will be a hidden column
	strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
	
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			WScript.Echo strUserName &amp; strSep &amp; strValueName &amp; strSep &amp; intBit &amp; &quot;-bit&quot; _
				&amp; strSep &amp; strOutputKey &amp; &quot;\&quot; &amp; strValueName
		Next
		CheckValues = True

	Else
		CheckValues = False
	End If
End Function


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\Software\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\Software\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,User,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Subkey Name,String,0,1,2,Architecture,String,0,1,3,KeyPath,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
311,Hardware,2015-01-05T20:22:05,",","Returns the number of physical processors on a system.  This may differ from the number of cores or number of logical processors.
Example:1",1,3320877330,0,619,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Number of Processors,,,,,,,,,Windows,select NumberofProcessors from win32_ComputerSystem,WMIQuery,Linux,"#!/bin/bash
cat /proc/cpuinfo | grep processor | wc -l
",UnixShell,Mac,"#!/bin/bash
system_profiler SPHardwareDataType | grep -i &quot;Number of Processors&quot; | awk -F&#039;: &#039; &#039; { print $2 } &#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
312,Operating System,2015-01-05T20:22:05,",","Returns the Organization defined at OS install time.
Example: YourCorp",1,3369713834,0,621,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Organization,,,,,,,,,Windows,select Organization from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
313,Applications,2015-01-05T20:22:05,",","Returns applications that have been launched in the last number of days supplied.
Example: Microsoft Excel",1,341438855,0,623,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Recently Run Applications,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of previous days to search"",""value"":""7"",""defaultValue"":""7"",""snapInterval"":1,""label"":""Number of Previous Days to Search"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""},{""helpString"":""Enter True or False whether to show the date."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Show Date?"",""key"":""showDate"",""values"":[""True"",""False""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Recently Run Applications
&#039;========================================

days = unescape(&quot;||days||&quot;)
If Not IsNumeric(days) Then 
	WScript.Echo &quot;Parameter Not Number&quot;
	WScript.Quit
End If 
days = CInt(days)

showDate = unescape(&quot;||showDate||&quot;)
showDate=LCase(showDate)
If showDate = &quot;yes&quot; Or showDate = &quot;true&quot; Then 
	bShowDate = True
Else 
	bShowDate = False
End If 

strComputer = &quot;.&quot;
Const HKLM = &amp;h80000002
Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

&#039;Uses date math - set locale

SetLocale(1033)

strKeyPath = GetTaniumRegistryPath() &amp; &quot;\Sensor Data\Applications&quot;

If RegKeyExists(reg, HKLM, strKeyPath) Then
	reg.EnumKey HKLM, strKeyPath, arrSubKeys
	If IsArray(arrSubKeys) Then
	For Each Subkey in arrSubKeys
		&#039;Wscript.Echo Subkey
		newKeyPath = strKeyPath &amp; &quot;\&quot; &amp; Subkey
		
		reg.GetStringValue HKLM, newKeyPath, &quot;Last Start&quot;, strLastStart
		reg.GetStringValue HKLM, newKeyPath, &quot;Description&quot;, strDescription

		If Not IsNull(strLastStart) Then
			If GetDaysOld(strLastStart) &lt; days Then
				Dim strOutput
				strOutput = strDescription
				
				If bShowDate Then
					strOutput = strOutput &amp; &quot; - &quot; &amp; strLastStart
				End If
				WScript.Echo strOutput
			End If
		End If	
	Next
	End If
Else	
	WScript.Echo &quot;Application data not initialized&quot;
End If

function GetDaysOld(strDate)
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, strDate, today)
End Function

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of previous days to search&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Number of Previous Days to Search&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;True&quot;,&quot;False&quot;],&quot;key&quot;:&quot;showDate&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Enter True or False whether to show the date.&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Date?&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||showDate||  ||days||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of previous days to search&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Number of Previous Days to Search&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;True&quot;,&quot;False&quot;],&quot;key&quot;:&quot;showDate&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Enter True or False whether to show the date.&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Date?&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||showDate||  ||days||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
314,Tanium,2015-01-05T20:22:05,",","The date on which the currently installed Tanium Client was installed on each client machine.
Example: Wed, 13 Nov 2013 00:00:00 -0480",1,3418227220,0,625,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium Client Installation Date,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Install Date
&#039;========================================

strComputer = &quot;.&quot;
    Set objRegistry = _
       GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _
       &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

&#039;Uses date math - set locale

SetLocale(1033)

    Const HKLM = &amp;H80000002

    keyPath = &quot;Software\Tanium\Tanium Client&quot;
    key64Path = &quot;Software\WOW6432Node\Tanium\Tanium Client&quot;

    If Not RegKeyExists(HKLM, keyPath) Then
       keyPath = key64Path

       If Not RegKeyExists(HKLM, keyPath) Then
          WScript.Echo &quot;Not installed&quot;
          WScript.Quit
       End If
    End If

    objRegistry.GetStringValue HKLM, keyPath, &quot;FirstInstall&quot;, strFirstInstall

	If Not IsNull(strFirstInstall) Then
		strFirstInstall = FormatDateTime(strFirstInstall, 2)
		WScript.Echo VBTimeToRFC822(strFirstInstall,GetRFC822Bias)
		WScript.Quit
	Else   
		WScript.Echo &quot;Not installed&quot;
	End If  

    Function RegKeyExists(sHive, sRegKey)
       Dim aValueNames, aValueTypes
       If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
          RegKeyExists = True
       Else
          RegKeyExists = False
       End If
    End Function
	

Function vbTimeToRFC822(myDate, offset)
&#039;SetLocale outside of function in global scope
&#039; must be set so that month is displayed with US/English abbreviations
&#039; as per the standard

	If Not GetLocale = 1033 Then
		WScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;
		WScript.Quit
	End If
   Dim myDay, myDays, myMonth, myYear
   Dim myHours, myMinutes, myMonths, mySeconds

   myDate = CDate(myDate)
   myDay = WeekdayName(Weekday(myDate),true)
   myDays = zeroPad(Day(myDate), 2)
   myMonth = MonthName(Month(myDate), true)
   myYear = Year(myDate)
   myHours = zeroPad(Hour(myDate), 2)
   myMinutes = zeroPad(Minute(myDate), 2)
   mySeconds = zeroPad(Second(myDate), 2)

   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _
                                  myDays&amp;&quot; &quot;&amp; _
                                  myMonth&amp;&quot; &quot;&amp; _ 
                                  myYear&amp;&quot; &quot;&amp; _
                                  myHours&amp;&quot;:&quot;&amp; _
                                  myMinutes&amp;&quot;:&quot;&amp; _
                                  mySeconds&amp;&quot; &quot;&amp; _ 
                                  offset
End Function &#039;vbTimeToRFC822


Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function

Function GetRFC822Bias
&#039; This function returns a string which is a 
&#039; timezone bias for RFC822 format
&#039; considers daylight savings
&#039; we choose 4 digits and a sign (+ or -)

	Dim objWMIService,colTimeZone,objTimeZone
	
	Dim intTZBiasInMinutes,strSign,strReturnString

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
	 
	For Each objTimeZone in colTimeZone
	    intTZBiasInMinutes = objTimeZone.CurrentTimeZone
	Next

	&#039; The offset is explicitly signed
	If intTZBiasInMinutes &lt; 0 Then
		strSign = &quot;-&quot;
	Else
		strSign = &quot;+&quot;
	End If
	
	strReturnString = CStr(Abs(intTZBiasInMinutes))
	&#039; no offset is greater than three digits but RFC822 bias seems to
	&#039; usually take the form of 1 alpha / 4 digit as described as 
	&#039; valid in ANSI X3.51-1975

	strReturnString = zeroPad(strReturnString,4)

	GetRFC822Bias = strSign&amp;strReturnString
	
	&#039;Cleanup
	Set colTimeZone = Nothing
	Set objWMIService = Nothing
End Function &#039;GetRFC822Bias",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
mdls -name kMDItemFSCreationDate /Library/Tanium/TaniumClient | awk &#039;{print $3}&#039; | awk -F &#039;-&#039;  &#039;{print $2&quot;-&quot;$3&quot;-&quot;$1}&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,BESDate
315,User,2015-01-05T20:22:05,|,"Returns local accounts and days until they expire. Accounts which have no expiration date return ""N/A""
Example:
user.name|19",1,3418263806,0,627,1,Jim Olsen,900,,,,2015-01-05T20:22:05,Local Account Expiration Details,,,,,,,,,Windows,"&#039;========================================
&#039; Local Account Expiration Details
&#039;========================================


Option Explicit

Dim objAccounts,objUser,dtmExpirationDate,intDaysUntil,strSep

strSep = &quot;|&quot;
&#039; Multi-column output
&#039; Account Name|Days Until Expiration
SetLocale(1033) &#039;Uses RFC822, requires US/English

On Error Resume Next

Set objAccounts = GetObject(&quot;WinNT://.&quot;)
objAccounts.Filter = Array(&quot;User&quot;)

For Each objUser In objAccounts
	If IsNull(objUser.AccountExpirationDate) Then
		Wscript.Echo objUser.Name &amp; strSep &amp; &quot;N/A&quot;
	Else
		dtmExpirationDate = objUser.AccountExpirationDate
		intDaysUntil = Abs(DateDiff(&quot;d&quot;,Now(),dtmExpirationDate))
		Wscript.Echo objUser.Name&amp;intDaysUntil
	End If
Next



Function vbTimeToRFC822(myDate, offset)
&#039;SetLocale outside of function in global scope
&#039; must be set so that month is displayed with US/English abbreviations
&#039; as per the standard

	If Not GetLocale = 1033 Then
		WScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;
		WScript.Quit
	End If
   Dim myDay, myDays, myMonth, myYear
   Dim myHours, myMinutes, myMonths, mySeconds

   myDate = CDate(myDate)
   myDay = WeekdayName(Weekday(myDate),true)
   myDays = zeroPad(Day(myDate), 2)
   myMonth = MonthName(Month(myDate), true)
   myYear = Year(myDate)
   myHours = zeroPad(Hour(myDate), 2)
   myMinutes = zeroPad(Minute(myDate), 2)
   mySeconds = zeroPad(Second(myDate), 2)

   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _
                                  myDays&amp;&quot; &quot;&amp; _
                                  myMonth&amp;&quot; &quot;&amp; _ 
                                  myYear&amp;&quot; &quot;&amp; _
                                  myHours&amp;&quot;:&quot;&amp; _
                                  myMinutes&amp;&quot;:&quot;&amp; _
                                  mySeconds&amp;&quot; &quot;&amp; _ 
                                  offset
End Function &#039;vbTimeToRFC822


Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function

Function GetRFC822Bias
&#039; This function returns a string which is a 
&#039; timezone bias for RFC822 format
&#039; considers daylight savings
&#039; we choose 4 digits and a sign (+ or -)

	Dim objWMIService,colTimeZone,objTimeZone
	
	Dim intTZBiasInMinutes,strSign,strReturnString

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
	 
	For Each objTimeZone in colTimeZone
	    intTZBiasInMinutes = objTimeZone.CurrentTimeZone
	Next

	&#039; The offset is explicitly signed
	If intTZBiasInMinutes &lt; 0 Then
		strSign = &quot;-&quot;
	Else
		strSign = &quot;+&quot;
	End If
	
	strReturnString = CStr(Abs(intTZBiasInMinutes))
	&#039; no offset is greater than three digits but RFC822 bias seems to
	&#039; usually take the form of 1 alpha / 4 digit as described as 
	&#039; valid in ANSI X3.51-1975

	strReturnString = zeroPad(strReturnString,4)

	GetRFC822Bias = strSign&amp;strReturnString
	
	&#039;Cleanup
	Set colTimeZone = Nothing
	Set objWMIService = Nothing
	
End Function &#039;GetRFC822Bias",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Account Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Days Until Expiration,NumericInteger,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
316,Tanium,2015-01-05T20:22:05,",","The date and time on which the currently installed Tanium Client was installed on each client machine.
Example: Wed, 13 Nov 2013 08:18:00 -0480",1,3479253433,0,629,1,Jim Olsen,1800,0,defined,Tanium,2015-01-05T20:22:05,Tanium Client Installation Time,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client Installation Time
&#039;========================================

strComputer = &quot;.&quot;
    Set objRegistry = _
       GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _
       &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

&#039;Uses date math - set locale

SetLocale(1033)

    Const HKLM = &amp;H80000002

    keyPath = &quot;Software\Tanium\Tanium Client&quot;
    key64Path = &quot;Software\WOW6432Node\Tanium\Tanium Client&quot;

    If Not RegKeyExists(HKLM, keyPath) Then
       keyPath = key64Path

       If Not RegKeyExists(HKLM, keyPath) Then
          WScript.Echo &quot;Not installed&quot;
          WScript.Quit
       End If
    End If

    objRegistry.GetStringValue HKLM, keyPath, &quot;FirstInstall&quot;, strFirstInstall

	If Not IsNull(strFirstInstall) Then
		WScript.Echo VBTimeToRFC822(strFirstInstall,GetRFC822Bias)
		WScript.Quit
	Else   
		WScript.Echo &quot;Not installed&quot;
	End If  

    Function RegKeyExists(sHive, sRegKey)
       Dim aValueNames, aValueTypes
       If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
          RegKeyExists = True
       Else
          RegKeyExists = False
       End If
    End Function
	

Function vbTimeToRFC822(myDate, offset)
&#039;SetLocale outside of function in global scope
&#039; must be set so that month is displayed with US/English abbreviations
&#039; as per the standard

	If Not GetLocale = 1033 Then
		WScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;
		WScript.Quit
	End If
   Dim myDay, myDays, myMonth, myYear
   Dim myHours, myMinutes, myMonths, mySeconds

   myDate = CDate(myDate)
   myDay = WeekdayName(Weekday(myDate),true)
   myDays = zeroPad(Day(myDate), 2)
   myMonth = MonthName(Month(myDate), true)
   myYear = Year(myDate)
   myHours = zeroPad(Hour(myDate), 2)
   myMinutes = zeroPad(Minute(myDate), 2)
   mySeconds = zeroPad(Second(myDate), 2)

   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _
                                  myDays&amp;&quot; &quot;&amp; _
                                  myMonth&amp;&quot; &quot;&amp; _ 
                                  myYear&amp;&quot; &quot;&amp; _
                                  myHours&amp;&quot;:&quot;&amp; _
                                  myMinutes&amp;&quot;:&quot;&amp; _
                                  mySeconds&amp;&quot; &quot;&amp; _ 
                                  offset
End Function &#039;vbTimeToRFC822


Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function

Function GetRFC822Bias
&#039; This function returns a string which is a 
&#039; timezone bias for RFC822 format
&#039; considers daylight savings
&#039; we choose 4 digits and a sign (+ or -)

	Dim objWMIService,colTimeZone,objTimeZone
	
	Dim intTZBiasInMinutes,strSign,strReturnString

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	    &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
	Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)
	 
	For Each objTimeZone in colTimeZone
	    intTZBiasInMinutes = objTimeZone.CurrentTimeZone
	Next

	&#039; The offset is explicitly signed
	If intTZBiasInMinutes &lt; 0 Then
		strSign = &quot;-&quot;
	Else
		strSign = &quot;+&quot;
	End If
	
	strReturnString = CStr(Abs(intTZBiasInMinutes))
	&#039; no offset is greater than three digits but RFC822 bias seems to
	&#039; usually take the form of 1 alpha / 4 digit as described as 
	&#039; valid in ANSI X3.51-1975

	strReturnString = zeroPad(strReturnString,4)

	GetRFC822Bias = strSign&amp;strReturnString
	
	&#039;Cleanup
	Set colTimeZone = Nothing
	Set objWMIService = Nothing
	
End Function &#039;GetRFC822Bias",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/bash
mdls -name kMDItemFSCreationDate /Library/Tanium/TaniumClient | awk &#039;{print $4}&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,BESDate
317,Operating System,2015-01-05T20:22:05,",","The location of the system directory on Windows machines.
Example: C:\\Windows\\system32",1,3482410175,0,631,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,System Directory,,,,,,,,,Windows,select SystemDirectory from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
318,Patch,2015-01-05T20:22:05,|,"Details on patches which Tanium has installed.
Example: Title | Install date (UTC) | Result",1,3487549512,0,633,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Patches Installed by Tanium,,,,,,,,,Windows,"&#039;========================================
&#039; Patches Installed By Tanium
&#039;========================================

&#039; sensor - Patches Installed by Tanium
&#039; This sensor will list patches that the tanium patch installer logs
&#039; this may differ than the list of installed patches
&#039; which may have been installed through any workable technology

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput
strSep = &quot;|&quot;


&#039;Title|Install Date (UTC)|Result|Tanium Patch ID


path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\installedresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine,words,bBadLine,strOut

	bBadline = False
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine
		words = Split(strLine, strSep)	
		&#039; only output 4 column data
		If UBound(words) = 3 Then 
			strOut = words(1)&amp;strSep&amp;words(2)&amp;strSep&amp;words(3)
		ElseIf UBound(words) = 4 Then
			strOut = words(1)&amp;strSep&amp;words(2)&amp;strSep&amp;words(3)&amp;strSep&amp;words(4)
		Else
			bBadLine = True
		End If
		WScript.Echo strOut
	Loop

	objReadFile.close
Else
   Wscript.echo &quot;Error: Tanium patch install history output not found&quot;
End If

If bBadLine Then WScript.Echo &quot;Error: A Bad Line was detected and not displayed&quot;

WScript.Quit()

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Install Date (UTC),String,0,1,2,Result,String,0,1,3,Tanium Patch ID,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
319,Microsoft Forefront,2015-01-05T20:22:05,",","Indicates how many days ago a new AV signature was applied.
Example: 8",1,3494644520,0,635,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Forefront Client Signature Applied Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signature Applied Days Old
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue
	
	If Not IsNull(binValue) Then
		words = Split(BinaryToDate(binValue))
		WScript.Echo GetDaysOld(words(0))
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
End If

&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	patternDate = CDate( strDate )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)
End Function

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
320,Network,2015-01-05T20:22:05,",","Provides a list of hosts file entries for the local operating system.
Example: myserver.com , 192.168.1.100",0,3518770446,0,637,1,Jim Olsen,300,0,defined,Tanium,2015-01-05T20:22:05,Hosts File Entries,,,,,,,,,Windows,"Option Explicit
Class std_host_file
	Private Sub Class_Initialize()
		Set m_lines = CreateObject(&quot;Scripting.Dictionary&quot;)
		Set m_ip_map = CreateObject(&quot;Scripting.Dictionary&quot;)
		Set m_alias_map = CreateObject(&quot;Scripting.Dictionary&quot;)
		m_alias_map.CompareMode = vbTextCompare
	End Sub
	Private sub Class_Terminate()
		Set m_lines = Nothing
		Set m_ip_map = Nothing
		Set m_alias_map = Nothing
	End Sub
	&#039; Function returns the ip and data
	Private Sub parse_line( ByVal line , ByRef comment , ByRef ip , ByRef aliases  ) 
		Dim rx : Set rx = New RegExp
		Dim r
		rx.Global = False
		rx.IgnoreCase = True
		rx.Pattern = &quot;\s*(#.*)\s*&quot;
		&#039; Parse Comment
		If rx.Test( line ) Then
			Set r = rx.Execute( line )
			comment = r.Item(0).subMatches.Item(0)
			line = rx.Replace( line , &quot;&quot; )
		End If		
		rx.Pattern = &quot;\s*((\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b)|(\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*))\s*&quot;
		&#039; Parse IP
		If rx.Test( line ) Then
			Set r = rx.Execute( line )
			ip = r.Item(0).subMatches.Item(0)
			aliases = rx.Replace( line , &quot;&quot; )
		End If
	End Sub
	&#039; Function returns the ip and data
	Private Function getip( ByRef str , ByRef ip  ) 
		getip = False 
		Dim rx_ip : Set rx_ip = New RegExp
		rx_ip.Global = False
		rx_ip.IgnoreCase = True
		rx_ip.Pattern = &quot;\s*((\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b)|(\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*))\s*&quot;
		If rx_ip.Test( str ) Then
			Dim r : Set r = rx_ip.Execute( str )
			ip = r.Item(0).subMatches.Item(0)
			str = rx_ip.Replace( str , &quot;&quot; )
			getip = True
		End If
	End Function
	&#039; Internal function used to validate IPV4 addresses
	Private Function isipv4( ByVal ip )
		Dim rx_ipv4 : Set rx_ipv4 = New RegExp
		rx_ipv4.Global = false
		rx_ipv4.IgnoreCase = True
		rx_ipv4.Pattern = &quot;^\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b$&quot;
		isipv4 = rx_ipv4.Test( ip )
	End Function
	&#039; Internal function used to validate IPV6 addresses
	Private Function isipv6( ip )
		Dim rx_ipv6 : Set rx_ipv6 = New RegExp
		rx_ipv6.Global = false
		rx_ipv6.IgnoreCase = True
		rx_ipv6.Pattern = &quot;^\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$&quot;			
		IsIPV6 = rx_ipv6.Test( ip )
	End Function
	&#039; Internal function used to generate unique IDs
	Private Function genguid()
		Dim guidgen : Set guidgen = CreateObject(&quot;Scriptlet.TypeLib&quot;) 
		genguid = Mid(guidgen.Guid, 2, 36)
	End Function
	&#039; Function returns true on success, otherwise false if the ip doesn&#039;t exist
	Public Function GetHostEntryAliases( ByVal ip , ByRef aliases )
		GetHostEntryAliases = False
		aliases = Array
		If m_ip_map.Exists( ip ) Then 
			aliases = m_lines.Item( m_ip_map.Item(ip) )(1).Keys
			GetHostEntryAliases = True
		End If
	End Function 
	&#039; Function returns true on success, otherwise false if alias doesn&#039;t exist
	Public Function GetHostEntryAliasAddresses( ByVal alias , ByRef ips )
		GetHostEntryAliasAddresses = False
		ips = Array
		If m_alias_map.Exists( alias ) Then 
			ips = m_alias_map.Item( alias ).Keys
			GetHostEntryAliasAddresses = True
		End If
	End Function 
	&#039; Removes a host entry by IPV4 or IPV6 address, return true
	&#039; on success, otherwise false if the IP is doesn&#039;t exist
	Public Function DeleteHostEntry( ByVal ip )
		DeleteHostEntry = False
		If m_ip_map.Exists( ip ) Then 
			Dim a
			Dim uid : uid = m_ip_map.Item(ip)
			&#039; Remove the ip&#039;s from the associated aliases
			For Each a In m_lines.Item(uid)(1).Keys 
				If m_alias_map.Item( a ).Exists( ip ) Then
					m_alias_map.Item( a ).Remove( ip )
				End If
				&#039; If there are no more assoicated IPs remove the alias
				If m_alias_map.Item(a).Count = 0 Then
					m_alias_map.Remove( a )
				End If 
			Next
			&#039; This *should* exist since we manage the entries and mappings
			m_lines.Remove( uid )
			m_ip_map.Remove( ip )
			DeleteHostEntry = True
		End If
	End Function
	&#039; Removes a host alias by IPV4 or IPV6 address
	Public Function DeleteHostEntryAlias( ByVal ip , ByVal alias )
		DeleteHostEntryAlias = False
		&#039; If the IP is valid
		If m_ip_map.Exists( ip ) Then
			Dim uid : uid = m_ip_map.Item(ip)		
			&#039; If the alias exists remove the ip and if no more ip&#039;s are mapped to the alias remove the alias	
			If m_alias_map.Exists( alias ) Then
				If m_alias_map.Item( alias ).Exists( ip ) Then
					m_alias_map.Item( alias ).Remove( ip )
				End If
				If m_alias_map.Item(alias).Count = 0 Then
					m_alias_map.Remove( alias )
				End If
			End If
			&#039; If IP no longer has aliases associated with it remove it
			Call delalias( uid , alias )
			If m_lines.Item( uid )(1).Count = 0 Then
				m_lines.Remove( uid )
				m_ip_map.Remove( ip )
			End If
			DeleteHostEntryAlias = True
		End If
	End Function
	&#039; Adds a host entry by IPV4 or IPV6 address, alias should be 
	&#039; the text alias for the address. Returns true on success
	Public Function AddHostEntry( ByVal ip , ByVal alias )		
			AddHostEntry = False 		
			Dim rx : Set rx = New RegExp
			rx.Global = true
			rx.IgnoreCase = True
			rx.Pattern = &quot;\s*&quot;
			alias = rx.Replace( alias , &quot;&quot; )
			ip = rx.Replace( ip , &quot;&quot; )
			&#039; Validate IP
			If isipv6( ip ) Or isipv4( ip ) Then 
				&#039; Check for alias in the alias mapping
				If Not m_alias_map.Exists( alias ) Then	Call m_alias_map.Add( alias , CreateObject(&quot;Scripting.Dictionary&quot;) )
				If Not m_alias_map.Item( alias ).Exists( ip ) Then Call m_alias_map.Item( alias ).Add( ip , &quot;&quot; )
				&#039; Map IP -&gt; alias 
				If m_ip_map.Exists( ip ) Then 
					&#039; Lookup the index by ip then add aliases
					Call addalias( m_ip_map.Item(ip) , alias )
				Else
					&#039; Store File Line
					Dim uid : uid = genguid
					Call m_lines.Add( uid , Array( ip , CreateObject(&quot;Scripting.Dictionary&quot;) , vbNullString ) )
					Call addalias( uid , alias )
					Call m_ip_map.Add( ip , uid )
				End If
				AddHostEntry = True
			End If	
	End Function
	&#039; Should be used for debugging the data
	Public Sub DumpData( )
		Dim id, a, ip, a_map
		&#039; Debug dump host file out to text
		
		For Each ip In m_ip_map.Keys
			For Each a In m_lines.Item( m_ip_map.Item(ip) )(1).Keys
&#039;				WScript.Echo &quot;IP [&quot; &amp; ip &amp; &quot;] ID Map {&quot; &amp; m_ip_map.Item(ip)	&amp; &quot;} --&gt; alias [&quot; &amp; a &amp; &quot;]&quot;
				If m_alias_map.Exists( a ) Then 
					For Each a_map In m_alias_map.Item( a ).Keys
						WScript.Echo a &amp; &quot;,&quot; &amp; a_map
					Next
				End If
			Next
		Next	 
	End Sub 
	&#039; Internal formattig function for padding host data
	Private Function lpad ( str , padch , padlen ) 
		If padlen - Len(str) &gt;= 0 Then 
			Lpad = String(padlen - Len(str),padch) &amp; str 
		Else
			Lpad = str	
		End If 	
	End Function
	&#039; Returns all the IP addresses defined in the host file
	&#039; Returns true on success, otherwise false
	Public Function GetAllHostEntryAddresses( ByRef ips )
		GetAllHostEntryAddresses = False
		ips = Array
		If m_ip_map.Count &gt; 0 Then 
			ips = m_ip_map.Keys
			GetAllHostEntryAddresses = True
		End If
	End Function
	&#039; Returns all the aliases defined in the host file
	&#039; Returns true on success, otherwise false
	Public Function GetAllHostEntryAliases( ByRef aliases )
		GetAllHostEntryAliases = False
		aliases = Array
		If m_alias_map.Count &gt; 0 Then 
			aliases = m_alias_map.Keys
			GetAllHostEntryAliases = True
		End If
	End Function
	
	&#039; Write host file returns true if file could be opened for writing
	Public Function Save( ByVal hostfile )		
		On Error Resume Next
		Save = False
		Dim id, a
		Dim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
		Dim oFile : Set oFile = Nothing
		Set oFile = objFSO.OpenTextFile( hostfile , 2 , True )
		If Not oFile Is Nothing Then 
			For Each id In m_lines.Keys
				If TypeName( m_lines.Item(id) ) = &quot;String&quot; Then
					Call oFile.WriteLine( m_lines.Item(id) )
				ElseIf TypeName( m_lines.Item(id) ) = &quot;Variant()&quot; Then
					Call oFile.Write( lpad( m_lines.Item(id)(0) &amp; &quot;&quot; , &quot; &quot; , 16 )  &amp; Space(8) )
					For Each a In m_lines.Item(id)(1).Keys
						Call oFile.Write( a &amp; &quot; &quot; )
					Next
					Call oFile.Write( m_lines.Item(id)(2) &amp; vbCrLf )
				End If 
			Next
			Save = True
		End If
		Set objFSO = Nothing
	End Function
	
	&#039; Write host file returns true if file could be opened for reading
	Public Function Load( ByVal hostfile , ByVal bmergecomments )
		On Error Resume Next		
		Load = False
		m_lines.RemoveAll()
		m_ip_map.RemoveAll()
		m_alias_map.RemoveAll()
		Dim rx : Set rx = New RegExp
		rx.Global = true
		rx.IgnoreCase = True
		rx.Pattern = &quot;\s+&quot;
		Dim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
		Dim oFile : Set oFile=Nothing
		Set oFile = objFSO.OpenTextFile( hostfile , 1 )
		If Not oFile Is Nothing Then 
		While Not oFile.AtEndOfStream
			Dim pos : pos = 0
			&#039; Data will not be modified to preserve the file context
			Dim data : data = Trim(oFile.ReadLine())
			&#039; Remove all the extra whitespace so we have a single spacing	
			&#039; Line will be chopped up to see valid information exists
			Dim line : line = Trim(rx.Replace(data, &quot; &quot;))
			Dim ip : ip = vbNullString
			Dim comment : comment = vbNullString
			Dim aliases : aliases = vbNullString
			&#039; Check if the line is empty
			If line &lt;&gt; vbNullString Then					
				Call parse_line( line , comment , ip , aliases )
				If isipv4( ip ) Or isipv6( ip ) Then 	
					Dim a, uid
					&#039; Map alias -&gt; IPs
					For Each a In Split(aliases)
						If Not m_alias_map.Exists( a ) Then 
							Call m_alias_map.Add( a , CreateObject(&quot;Scripting.Dictionary&quot;) )
						End If
						If Not m_alias_map.Item( a ).Exists( ip ) Then Call m_alias_map.Item( a ).Add( ip , &quot;&quot; )
					Next
					&#039; Map IP -&gt; alias 
					If m_ip_map.Exists( ip ) Then
						uid = m_ip_map.Item(ip)
						&#039; Lookup the index by ip then add aliases
						For Each a In Split(aliases)
							Call addalias( uid , a )
						Next
						If bmergecomments Then 
							&#039; Overkill (should be first # )
							pos = InStr( 1, comment , &quot;#&quot; , vbTextCompare )
							If pos &lt;&gt; 0 Then 
								&#039; Replace leading # from dual comment
								comment = Mid( comment , pos + 1 )
								&#039; Merge comments
								Call setcomment( uid , m_lines.Item( uid )(2) &amp; &quot;,&quot; &amp; comment )
							End If
						End If
					Else
						&#039; Store File Line
						uid = genguid
						Call m_lines.Add( uid , Array( ip , CreateObject(&quot;Scripting.Dictionary&quot;) , comment ) )
						For Each a In Split(aliases)
							Call addalias( uid , a )
						Next
						Call m_ip_map.Add( ip , uid )
					End If
				Else &#039; Unknown IP format or malformed file
					Call m_lines.Add(genguid,data)
				End If
			Else
				Call m_lines.Add(genguid,data)
			End If
		Wend
		Load=True
		End If
		Set objFSO = Nothing
	End Function
	Private Function setip( uid , ip )
		setip = False
		If m_lines.Exists( uid ) Then
			m_lines.Item(uid) = Array( ip , m_lines.Item(uid)(1) , m_lines.Item(uid)(2) ) 
			setip = True
		End If
	End Function
	Private Function setcomment( uid , comment )
		setcomment = False
		If m_lines.Exists( uid ) Then
			Dim a : a = m_lines.Item(uid)
			m_lines.Item(uid) = Array( m_lines.Item(uid)(0) , m_lines.Item(uid)(1) , comment )  
			setcomment = True
		End If
	End Function
	Private Function addalias( uid , alias )
		addalias = False
		If m_lines.Exists( uid ) Then
			If Not m_lines.Item(uid)(1).Exists( alias ) Then 
				Call m_lines.Item(uid)(1).Add( alias , &quot;&quot; )
				addalias = True
			End If
		End If
	End Function
	Private Function delalias( uid , alias )
		delalias = False
		If m_lines.Exists( uid ) Then
			If m_lines.Item(uid)(1).Exists( alias ) Then 
				Call m_lines.Item(uid)(1).Remove( alias )
				delalias = CBool( Not m_lines.Item(uid)(1).Exists( alias ) )
			End If
		End If
	End Function
	Private m_lines
	Private m_ip_map
	Private m_alias_map
End Class


Dim arr, n
Dim o_h : Set o_h = New std_host_file
Call o_h.Load( &quot;C:\Windows\System32\drivers\etc\hosts&quot; , False )

o_h.DumpData",VBScript,Linux,"#!/bin/bash

if [ -f /etc/hosts ]; then

  file=&quot;/etc/hosts&quot;
  line=`cat $file`
  
  while read -r line; do
    line=`echo $line | sed &#039;s/^ *//g&#039; | sed &#039;s/ *$//g&#039;`

    if [[ &quot;$line&quot; =~ ^#.*$ ]]; then
	l=1 #do nothing
    else
      if [ -n &quot;$line&quot; ]; then
        
        COLS=( $line ); # parses columns without executing a subshell
        #RESULT=&quot;${COLS[0]}&quot;; # returns first column (0-based indexes)
        echo &quot;${COLS[1]},${COLS[0]}&quot;

      fi
    fi
  done &lt;&lt;&lt; &quot;$line&quot;


fi
",UnixShell,Mac,"#!/bin/bash

if [ -f /etc/hosts ]; then

  file=&quot;/etc/hosts&quot;
  line=`cat $file`
  
  while read -r line; do
    line=`echo $line | sed &#039;s/^ *//g&#039; | sed &#039;s/ *$//g&#039;`

    if [[ &quot;$line&quot; =~ ^#.*$ ]]; then
	l=1 #do nothing
    else
      if [ -n &quot;$line&quot; ]; then
        
        COLS=( $line ); # parses columns without executing a subshell
        #RESULT=&quot;${COLS[0]}&quot;; # returns first column (0-based indexes)
        echo &quot;${COLS[1]},${COLS[0]}&quot;

      fi
    fi
  done &lt;&lt;&lt; &quot;$line&quot;


fi
",UnixShell,0,0,0,1,0,Alias,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,IP Address,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
321,Microsoft Forefront,2015-01-05T20:22:05,",","Indicates the last time that the client AV signature was updated.
Example: 09/18/2012",1,3551304570,0,639,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Forefront Client Signature Applied Date,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signature Applied Date
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If


If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue
	
	If Not IsNull(binValue) Then
		
		WScript.Echo BinaryToDate(binValue)
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
322,Operating System,2015-01-05T20:22:05,",","Returns whether the machine runs a Linux-based OS.  True if so, False if not.
Example: True",0,3554080383,0,641,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Is Linux,,,,,,,,,Windows,"&#039;========================================
&#039; Is Linux
&#039;========================================

Wscript.echo &quot;False&quot;",VBScript,Linux,"#!/bin/bash
echo True
",UnixShell,Mac,"#!/bin/bash
echo False
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
323,Network,2015-01-05T20:22:05,",","Returns the default gateway for all IP enabled network adapters.
Example: 192.168.10.254",1,3575849436,0,643,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Network IP Gateway,,,,,,,,,Windows,select DefaultIPGateway from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
324,Microsoft Forefront,2015-01-05T20:22:05,",","Indicates the last date that the Forefront client signatures were checked by Forefront.
Example: 09/18/2012",1,3590670635,0,645,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Forefront Client Signatures Last Checked Date,,,,,,,,,Windows,"&#039;========================================
&#039; Forefront Client Signatures Last Checked Date
&#039;========================================

Const HKLM = &amp;h80000002
Set reg=Getx64RegistryProvider()

&#039;Uses date math - set locale

SetLocale(1033)

strKey = &quot;Software\Microsoft\Microsoft Antimalware\Signature Updates&quot;
If Not RegKeyExists(reg, HKLM, strKey) Then
	strKey = &quot;Software\Wow6432Node\Microsoft\Microsoft Antimalware\Signature Updates&quot;
End If

If RegKeyExists(reg, HKLM, strKey) Then
	reg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue
	
	If Not IsNull(binValue) Then
		
		WScript.Echo BinaryToDate(binValue)
	Else
		WScript.Echo &quot;Date not found&quot;	
	End If
Else
	WScript.Echo &quot;Forefront Endpoint Protection not found&quot;
End If

 Function BinaryToDate(Binary)
     Err.Clear
     
     &#039;Define Variants
     Dim lngHigh
     Dim lngLow
     Dim dtmDate
     Dim i
         
     &#039;Populate Variants
     lngHigh = 0
     lngLow = 0
     
     &#039;NOTE: Portions of this code taken from:
     &#039; http://www.visualbasicscript.com/m30907.aspx
     
     for i=7 to 4 step -1
         lngHigh = lngHigh * 256 + Binary(i)
     next
     for i=3 to 0 step -1
         lngLow = lngLow * 256 + Binary(i)
     next
      
     if err.number&lt;&gt;0 then
         dtmDate = #1/1/1601#
         Err.Clear
     else
         If lngLow &lt; 0 Then
             lngHigh = lngHigh + 1
         End If
         If (lngHigh = 0) And (lngLow = 0 ) Then
             dtmDate = #1/1/1601#
         Else
             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _
                 + lngLow)/600000000 - GetTimeBias())/1440
         End If
     End If
     BinaryToDate = dtmDate
 End Function
 
 
 Function GetTimeBias()
     &#039;Define Variants
     Dim lngBiasKey
     Dim lngBias
     
     &#039; Obtain local Time Zone bias from machine registry.
     reg.GetDWORDValue HKLM, &quot;System\CurrentControlSet\Control\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey
     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then
         lngBias = lngBiasKey
     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then
         lngBias = 0
         For k = 0 To UBound(lngBiasKey)
             lngBias = lngBias + (lngBiasKey(k) * 256^k)
         Next
     End If 
     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias
     GetTimeBias = lngBias
 End Function

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
325,Symantec,2015-01-05T20:22:05,",","Returns list of virus discovery events by Symantec AV on the client machine.
Example: Security Risk Found!SecurityRisk.OrphanInf in File: e:\\autorun.inf by: Scheduled scan.  Action: Delete succeeded.  Action Description: The file was deleted successfully.",1,3603227740,0,647,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Symantec Viruses Found,,,,,,,,,Windows,select Message from Win32_NTLogEvent where LogFile = &#039;Application&#039; and SourceName=&#039;Symantec AntiVirus&#039; and Type = &#039;Error&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039; and Message LIKE &#039;%Risk Found%&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
326,Hardware,2015-01-05T20:22:05,",","Indicates any human interface devices connected to the client machine.
Example: HID-compliant mouse",1,3605572245,0,649,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Human Interface Device,,,,,,,,,Windows,select Caption from Win32_PnPEntity where (Status=&#039;OK&#039; and DeviceID like &#039;%HID%&#039;),WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
327,Operating System,2015-01-05T20:22:05,",","Returns users and groups who are members of the Local Administrators group on Windows.  Will not list the individual members of groups in the Local Administrators group.
Example: Administrator",1,3622133010,0,651,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Local Administrators,,,,,,,,,Windows,"&#039;========================================
&#039; Local Administrators
&#039;========================================

&#039; output of membership (individual users and groups) of Local Administrators
&#039; will not list members of sub-groups

Option Explicit

Dim strMember, dictBlacklist
Set dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; Add one line for each admin user that you do not want listed in the sensor output.  
&#039;dictBlacklist.Add LCase(&quot;LocalMgr&quot;), True

For Each strMember In GetLocalAdmins
	Dim bShouldList, strItem
	bShouldList = True

	For Each strItem In dictBlacklist.Keys
		If InStr(LCase(strMember), strItem) &gt; 0 Then 
			bShouldList = False
		End If
	Next

	If bShouldList Then 
		WScript.Echo strMember
	End If 
Next

Function GetLocalAdmins
    Dim objWMIService,strLocalAdminQuery,colItems,objItem,strMembers,strComputerName,arrReturn,i
    Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
    
	&#039; Get Computer Name
    Set colItems = objWMIService.ExecQuery( &quot;Select * from Win32_ComputerSystem&quot;, , 48 )
    For Each objItem in colItems
        strComputerName = objItem.Name
    Next	    
    
    strLocalAdminQuery = &quot;select * from Win32_GroupUser where GroupComponent = &quot; &amp; chr(34) &amp; &quot;Win32_Group.Domain=&#039;&quot; &amp; strComputerName &amp; &quot;&#039;,Name=&#039;Administrators&#039;&quot; &amp; Chr(34)
    
    Set ColItems = objWMIService.ExecQuery(strLocalAdminQuery)
    strMembers = &quot;&quot;
    arrReturn = Array() &#039; set up return array
    i = 0
    For Each objItem In colItems
    	i = i + 1
        Dim strMemberName, NamesArray, strDomainName, DomainNameArray
        NamesArray = Split(objItem.PartComponent,&quot;,&quot;)
        strMemberName = Replace(Replace(NamesArray(1),Chr(34),&quot;&quot;),&quot;Name=&quot;,&quot;&quot;)
        DomainNameArray = Split(NamesArray(0),&quot;=&quot;)
        strDomainName = Replace(DomainNameArray(1),Chr(34),&quot;&quot;)
        If strDomainName &lt;&gt; strComputerName Then
            strMemberName = strDomainName &amp; &quot;\&quot; &amp; strMemberName
        End If
        ReDim Preserve arrReturn(UBound(arrReturn) + 1) &#039; increase array by one
        arrReturn(UBound(arrReturn)) = strMemberName
    Next
    
    GetLocalAdmins = arrReturn
End Function &#039;GetLocalAdmins",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
328,Hardware,2015-01-05T20:22:05,",","CPU cache size in KB.
Example: 1024 KB",1,3646624356,0,653,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,CPU Cache Size,,,,,,,,,Windows,"&#039;========================================
&#039; CPU Cache Size
&#039;========================================

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Processor&quot;)
For Each objItem in colItems

	If objItem.L2CacheSize &lt;&gt; &quot;&quot; Then
		Wscript.Echo objItem.L2CacheSize &amp; &quot; KB&quot;
	Else
		Wscript.Echo &quot;Cannot calculate CPU Cache,Probably a VM&quot;
	End If
Next",VBScript,Linux,"#!/bin/bash
line=$(cat /proc/cpuinfo | grep &quot;cache size&quot;)
set -- $line
echo ${line#*:}
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
329,Operating System,2015-01-05T20:22:05,",","Returns the number of days since a Tanium Reboot Action occurred.
Example: 2",1,3652459872,0,655,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium Reboot Days Ago,,,,,,,,,Windows,"Option Explicit

GetRebootDateTimeDaysOld

Function GetRebootDateTimeDaysOld
&#039;reads a date value in the Tanium Client\RebootManagment key of the registry

	Const HKLM = &amp;h80000002
	
	Dim objReg,strRegPath,dtmNow,dtmLastReboot,intDaysAgo
	
	SetLocale(1033)
	
	dtmNow = Now()
	
	Set objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)	
	strRegPath = GetTaniumRegistryPath()&amp;&quot;\RebootManagement&quot;
	
	If Not RegKeyExists(objReg,HKLM,strRegPath) Then
		objReg.CreateKey HKLM,strRegPath
	End If
	
	objReg.GetStringValue HKLM,strRegPath,&quot;LastReboot&quot;,dtmLastReboot
	
	If IsDate(dtmLastReboot) Then
		intDaysAgo = Round(Abs(DateDiff(&quot;s&quot;,Now(),dtmLastReboot)) / 86400,0)
		WScript.Echo intDaysAgo
	Else
		WScript.Echo &quot;No Previous Reboot Date Found&quot;
	End If

End Function &#039;GetRebootDateTimeDaysOld

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
330,File System,2015-01-05T20:22:05,",","A parameterized Sensor that checks to see if a file exists on a machine.  If it does, it returns back the full path of the file. Will expand environment variables, and will expand %userprofile%/file or ""~/file"" to search all user home directories.
Example: C:\Windows\system32\notepad.exe",1,3662289857,0,657,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,File Exists,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the file path and name to search for."",""value"":"""",""promptText"":""e.g. c:\\windows\\test.txt"",""defaultValue"":"""",""label"":""File path and name to search for"",""maxChars"":0,""key"":""file"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; File Exists
&#039;========================================

Option Explicit

Dim bExamineRemoteFolders &#039; boolean to decide whether to consider non-local dirs
bExamineRemoteFolders = True &#039; attempt to look at remote folders, may fail due to access

Dim strFilePath, objFso, objShell

strFilePath = unescape(&quot;||file||&quot;)

If InStr(LCase(strFilePath),&quot;%userprofile%&quot;) &gt; 0 Then
	CheckForAllUsers strFilePath
Else
	CheckNoUserVars strFilePath
End If

	
Sub CheckNoUserVars(ByVal strFilePath)
&#039; plain check if a file exists
	strFilePath = FixFileSystemRedirectionForPath(strFilePath)
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strFilePath = objShell.ExpandEnvironmentStrings( strFilePath )
	
	Set objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	If objFso.FileExists(strFilePath) Then 
		WScript.Echo &quot;File Exists: &quot; &amp; UnFixFileSystemRedirectionForPath(strFilePath)
	Else 
		WScript.Echo &quot;File does not exist&quot;
	End If
End Sub &#039;CheckNoUserVars

Sub CheckForAllUsers(ByVal strFilePath)
&#039; checks in every user directory

	&#039; Remove %userprofile% and keep the rest
	strFilePath = Replace(LCase(strFilePath),&quot;%userprofile%&quot;,&quot;&quot;)	
	
	On Error Resume Next &#039; permissions issues, perhaps
	
	Const HKLM = &amp;H80000002
	Dim objShell,objFso
	Dim objRegistry,strKeyPath,objSubKey,arrSubKeys,strValueName,strSubPath
	Dim strValue,strOut,bFileFound
	bFileFound = False
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strFilePath = objShell.ExpandEnvironmentStrings( strFilePath )
	
	Set objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	Set objRegistry=Getx64RegistryProvider
 
	strKeyPath = &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList&quot;
	objRegistry.EnumKey HKLM, strKeyPath, arrSubkeys
 

	For Each objSubkey In arrSubkeys
	    strValueName = &quot;ProfileImagePath&quot;
	    strSubPath = strKeyPath &amp; &quot;\&quot; &amp; objSubkey
	    objRegistry.GetExpandedStringValue HKLM,strSubPath,strValueName,strValue

	    If Not bExamineRemoteFolders And Not InStr(strValue,&quot;:&quot;) &gt; 0 Then &#039; Not Local, don&#039;t get size of remote dirs
	    	&#039; if user profile is not local and not examining remote profiles, ignore
	    Else 
	    	If objFSO.FileExists(strValue&amp;strFilePath) Then
				bFileFound = True
				WScript.Echo &quot;File Exists: &quot; &amp; strValue&amp;strFilePath
			End If
		End If
	Next
	
	If Not bFileFound Then

		WScript.Echo &quot;File does not exist&quot;
	End If

	On Error Goto 0

End Sub &#039;CheckForAllUsers

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
			strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
			strFilePath = strNewSystem32Location&amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

	Dim objFSO,strSystem32Location,strNewSystem32Location
	
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
	
	UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/bash

urldecode() {
        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\+/ /g&#039; -e &#039;s/%/\\x/g&#039;)
        printf &#039;%b&#039; &quot;$data&quot;
}

file=&quot;$(urldecode &quot;||file||&quot;)&quot;

if [[ &quot;$file&quot; == *~* ]]
then
  # replace home directory with nothing
  file=&quot;${file#~\/}&quot;

  # Read in /etc/passwd to determine home dirs
  awk -F: &#039;$6 ~ /home/ &amp;&amp; $7 ~ /sh/ {print $1, $6}&#039; /etc/passwd |
  while read NAME homedir
  do
     if [ -e &quot;$homedir/$file&quot; ]
     then
        echo &quot;$homedir/$file&quot;
     fi
   done
else
   if [ -e &quot;$file&quot; ]
   then
      echo &quot;$file&quot;
   fi
fi
",UnixShell,Mac,"#!/bin/bash

urldecode() {
        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\+/ /g&#039; -e &#039;s/%/\\x/g&#039;)
        printf &#039;%b&#039; &quot;$data&quot;
}

file=&quot;$(urldecode &quot;||file||&quot;)&quot;

if [[ &quot;$file&quot; == *~* ]]
then
  # replace home directory with nothing
  file=&quot;${file#~\/}&quot;

  for homedir in `find /Users -type d -maxdepth 1`
  do
     if [ -e &quot;$homedir/$file&quot; ]
     then
        echo &quot;$homedir/$file&quot;
     fi
   done
else
   if [ -e &quot;$file&quot; ]
   then
      echo &quot;$file&quot;
   fi
fi
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
331,File System,2015-01-05T20:22:05,",","A parameterized Sensor that checks to see if a folder exists on a machine.  If it does, it returns back the full path of the folder. Will expand environment variables, and will expand %userprofile%/folder or ""~/folder"" to search all user home directories.
Example: C:\Windows\system32",1,1101836903,0,659,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Folder Exists,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the full drive letter and folder path of the folder. Environment variables accepted."",""value"":"""",""promptText"":""e.g. c:\\Program Files\\MyApp"",""defaultValue"":"""",""label"":""Folder path to search for"",""maxChars"":0,""key"":""folder"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Folder Exists
&#039;========================================

Option Explicit

Dim bExamineRemoteFolders &#039; boolean to decide whether to consider non-local dirs
bExamineRemoteFolders = True &#039; attempt to look at remote folders, may fail due to access

Dim strFolderPath, objFso, objShell

strFolderPath = unescape(&quot;||folder||&quot;)

If InStr(LCase(strFolderPath),&quot;%userprofile%&quot;) &gt; 0 Then
	CheckForAllUsers strFolderPath
Else
	CheckNoUserVars strFolderPath
End If

	
Sub CheckNoUserVars(ByVal strFolderPath)
&#039; plain check if a file exists
	strFolderPath = FixFileSystemRedirectionForPath(strFolderPath)
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strFolderPath = objShell.ExpandEnvironmentStrings( strFolderPath )
	
	Set objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	If objFso.FolderExists(strFolderPath) Then 
		WScript.Echo UnFixFileSystemRedirectionForPath(strFolderPath)
	Else 
		WScript.Echo &quot;Folder does not exist&quot;
	End If
End Sub &#039;CheckNoUserVars

Sub CheckForAllUsers(ByVal strFolderPath)
&#039; checks in every user directory

	&#039; Remove %userprofile% and keep the rest
	strFolderPath = Replace(LCase(strFolderPath),&quot;%userprofile%&quot;,&quot;&quot;)	
	
	On Error Resume Next &#039; permissions issues, perhaps
	
	Const HKLM = &amp;H80000002
	Dim objShell,objFso
	Dim objRegistry,strKeyPath,objSubKey,arrSubKeys,strValueName,strSubPath
	Dim strValue,strOut,bFolderFound
	bFolderFound = False
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strFolderPath = objShell.ExpandEnvironmentStrings( strFolderPath )
	
	Set objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	Set objRegistry=Getx64RegistryProvider
 
	strKeyPath = &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList&quot;
	objRegistry.EnumKey HKLM, strKeyPath, arrSubkeys
 

	For Each objSubkey In arrSubkeys
	    strValueName = &quot;ProfileImagePath&quot;
	    strSubPath = strKeyPath &amp; &quot;\&quot; &amp; objSubkey
	    objRegistry.GetExpandedStringValue HKLM,strSubPath,strValueName,strValue

	    If Not bExamineRemoteFolders And Not InStr(strValue,&quot;:&quot;) &gt; 0 Then &#039; Not Local, don&#039;t get size of remote dirs
	    	&#039; if user profile is not local and not examining remote profiles, ignore
	    Else 
	    	If objFSO.FolderExists(strValue&amp;strFolderPath) Then
				bFolderFound = True
				WScript.Echo strValue&amp;strFolderPath
			End If
		End If
	Next
	
	If Not bFolderFound Then

		WScript.Echo &quot;Folder does not exist&quot;
	End If

	On Error Goto 0

End Sub &#039;CheckForAllUsers

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
			strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
			strFilePath = strNewSystem32Location&amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

	Dim objFSO,strSystem32Location,strNewSystem32Location
	
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
	
	UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/bash

urldecode() {
        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\+/ /g&#039; -e &#039;s/%/\\x/g&#039;)
        printf &#039;%b&#039; &quot;$data&quot;
}

file=&quot;$(urldecode &quot;||folder||&quot;)&quot;

if [[ &quot;$file&quot; == *~* ]]
then
  # replace home directory with nothing
  file=&quot;${file#~\/}&quot;

  # Read in /etc/passwd to determine home dirs
  awk -F: &#039;$6 ~ /home/ &amp;&amp; $7 ~ /sh/ {print $1, $6}&#039; /etc/passwd |
  while read NAME homedir
  do
     if [ -e &quot;$homedir/$file&quot; ]
     then
        echo &quot;$homedir/$file&quot;
     fi
   done
else
   if [ -e &quot;$file&quot; ]
   then
      echo &quot;$file&quot;
   fi
fi
",UnixShell,Mac,"#!/bin/bash

urldecode() {
        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\+/ /g&#039; -e &#039;s/%/\\x/g&#039;)
        printf &#039;%b&#039; &quot;$data&quot;
}

file=&quot;$(urldecode &quot;||folder||&quot;)&quot;

if [[ &quot;$file&quot; == *~* ]]
then
  # replace home directory with nothing
  file=&quot;${file#~\/}&quot;

  for homedir in `find /Users -type d -maxdepth 1`
  do
     if [ -e &quot;$homedir/$file&quot; ]
     then
        echo &quot;$homedir/$file&quot;
     fi
   done
else
   if [ -e &quot;$file&quot; ]
   then
      echo &quot;$file&quot;
   fi
fi
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
332,Operating System,2015-01-05T20:22:05,",","Lists processes that use a module supplied to the sensor.
Example: explorer.exe",1,3682298314,0,661,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Processes Using Module,"{""parameters"":[{""restrict"":null,""validationExpressions"":[],""helpString"":""Enter the Module to search for"",""value"":"""",""promptText"":""e.g. wbem* or kernel32.dll"",""defaultValue"":"""",""label"":""Module to search for"",""maxChars"":0,""key"":""search"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Processes Using Module
&#039;========================================

strSearch = unescape(&quot;||search||&quot;)
&#039;strSearch = &quot;wbem*&quot;

strCommand = &quot;tasklist /M &quot; &amp; strSearch

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strResults = LCase(objScriptExec.StdOut.ReadAll)

arrLines = Split(strResults, vbCrLf)

isBody = False

strProcess = &quot;&quot;
strPid = &quot;&quot;

Dim moduleDictionary
Set moduleDictionary = CreateObject(&quot;scripting.dictionary&quot;)

Dim pidDictionary
Set pidDictionary = CreateObject(&quot;scripting.dictionary&quot;)

For Each line In arrLines

	If isBody Then
		If Left(line, 4) = &quot;    &quot; Then
			&#039;is list of modules
			arrWords = Split(RemoveMultiSpaces(line), &quot; &quot;)
			For i = 0 To UBound(arrWords)
				PrintModule arrWords(i), strProcess
			Next

		Else
			&#039;is name of process
			If line &lt;&gt; &quot;&quot; And InStr(line, &quot;.&quot;) Then
				arrWords = Split(RemoveMultiSpaces(line), &quot; &quot;)
				strProcess = arrWords(0)
				strPid = arrWords(1)
				&#039;WScript.Echo &quot;found process: &quot; &amp; strProcess &amp; &quot;, pid=&quot;&amp;strPid
				
				For i = 2 To UBound(arrWords)
					PrintModule arrWords(i), strProcess
				Next
				
			End If	
		End If
	End If
	
	If Left(line, 4) = &quot;====&quot; Then
		isBody = True 
	End If

Next

Function PrintModule(strMod, strProc)
	strMod = Replace(strMod, &quot;,&quot;, &quot;&quot;)
	WScript.Echo strProc &amp; &quot;: &quot; &amp; strMod
End Function

Function RemoveMultiSpaces(str)
	Dim regEx
	Set regEx = New RegExp
	regEx.Global = true
	regEx.IgnoreCase = True
	
	regEx.Pattern = &quot;\s{2,}&quot;
	
	RemoveMultiSpaces = Trim(regEx.Replace(str, &quot; &quot;))
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;search&quot;,&quot;validationExpressions&quot;:[],&quot;promptText&quot;:&quot;e.g. wbem* or kernel32.dll&quot;,&quot;helpString&quot;:&quot;Enter the Module to search for&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Module to search for&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||search||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;search&quot;,&quot;validationExpressions&quot;:[],&quot;promptText&quot;:&quot;e.g. wbem* or kernel32.dll&quot;,&quot;helpString&quot;:&quot;Enter the Module to search for&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Module to search for&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||search||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
333,Operating System,2015-01-05T20:22:05,",","Returns Yes or No depending on whether a Windows machine is a Terminal Server
Example: Yes",0,3685017662,0,663,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Is Terminal Server,,,,,,,,,Windows,"&#039;========================================
&#039; Is Terminal Server
&#039;========================================

Option Explicit

Dim strOS
 
strOS = GetOSFamily()
If UCase(strOS) = &quot;W2K3&quot; Then
  If isTerminalServer2k3RegRead Then
    WScript.Echo &quot;Yes&quot;
  Else
    WScript.Echo &quot;No&quot;
  End If
Else
	If isTerminalServer(strOS) Then
	  WScript.Echo &quot;Yes&quot;
	Else
	  WScript.Echo &quot;No&quot;
	End If
End If

WScript.Quit(0)

Function GetOSFamily()
  Dim strComputer, oWMIService, colOSInfo, oOSProperty, strCaption, strOSFamily
  Set oWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
  Set colOSInfo = oWMIService.ExecQuery(&quot;Select * from Win32_OperatingSystem&quot;)
  For Each oOSProperty in colOSInfo
    strCaption = oOSProperty.Caption
  Next
  If InStr(1,strCaption, &quot;2008&quot;, vbTextCompare) Then strOSFamily = &quot;W2K8&quot;
  If InStr(1,strCaption, &quot;2003&quot;, vbTextCompare) Then strOSFamily = &quot;W2K3&quot;
  If InStr(1,strCaption, &quot;2012&quot;, vbTextCompare) Then strOSFamily = &quot;W2K12&quot;  
  GetOSFamily = strOSFamily
  Set oWMIService = Nothing
  Set colOSInfo = Nothing
End Function
 
Function isTerminalServer(strOS)
  Dim strComputer, strNameSpace, objWMIService, colItems, objItem  
  If ucase(strOS) = &quot;W2K3&quot; Then
    strNameSpace = &quot;\root\cimv2&quot;
  Else
    strNameSpace = &quot;\root\cimv2\TerminalServices&quot;
  End If
  On Error Resume Next
  Set objWMIService = GetObject(&quot;winmgmts:&quot; _  
    &amp; &quot;{impersonationLevel=impersonate}!\\.&quot; &amp; strNameSpace) 
  If Err.Number &lt;&gt; 0 Then
  	isTerminalServer = False
  	Exit Function
  End If
  Set colItems = objWMIService.ExecQuery _ 
    (&quot;Select * from Win32_TerminalServiceSetting&quot;) 
  For Each objItem in colItems 
    Select Case objItem.LicensingType 
      Case &quot;1&quot; &#039; Remote Administration
        isTerminalServer = False
      Case &quot;2&quot; &#039; Per Device
        isTerminalServer = True
      Case &quot;4&quot; &#039; Per User
        isTerminalServer = True
      Case &quot;5&quot; &#039; Not configured yet
        isTerminalServer = True
      Case Else
        isTerminalServer = False 
    End Select
  Next 
  Set objWMIService = Nothing 
  Set colItems = Nothing 
End Function
 
Function isTerminalServer2k3RegRead
  Dim objShell, strValue, strValueData
  strValue = &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\TSAppCompat&quot;
  Set objShell = CreateObject(&quot;WScript.Shell&quot;)
  On Error Resume Next
  strValueData = objShell.RegRead(strValue)
  If Err.Number &lt;&gt; 0 Then
  	strValueData = 0
  End If
  On Error Goto 0
  If strValueData = &quot;1&quot; Then
    isTerminalServer2k3RegRead = True
  Else
    isTerminalServer2k3RegRead = False
  End If
  Set objShell = Nothing
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
334,Miscellaneous,2015-01-05T20:22:05,",","The calendar date on the managed client.
Example: 01/30/2012",1,3727949854,0,665,1,Jim Olsen,1800,0,defined,Tanium,2015-01-05T20:22:05,Client Date,,,,,,,,,Windows,"&#039;========================================
&#039; Client Date
&#039;========================================

&#039; This sensor will return the Date the client thinks it is

Option Explicit

SetLocale(GetTaniumLocale())

WScript.Echo FormatDateTime((Date), 2)

Function GetTaniumLocale() 
	Dim objWshShell, intLocaleID
	
	intLocaleID = &quot;&quot;
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\&quot; &amp; GetTaniumRegistryPath() &amp; &quot;\LocaleID&quot;)
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	Set objWshShell = Nothing
End Function &#039; GetTaniumLocale

&#039; get-tanium-regpath.vbs

&#039; Updated to always generate path so that GetTaniumDir can take multiple folder arguments
&#039; Updated to always look for the Path string value and not assume a bogus entry
&#039; in the wrong area is valid.  A valid entry will always have a Path string value
&#039; uses objshell registry reads which should be faster and more reliable

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		GetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		GetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;GetTaniumRegistryPath",VBScript,Linux,"#!/bin/sh
date +%-d/%-m/%Y
",UnixShell,Mac,"#!/bin/sh
date +%-d/%-m/%Y
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
335,Tanium,2015-01-05T20:22:05,",","The current cpu utilization being used by the Tanium Client process on each client machine.  The reported value will be higher than average since the Tanium Client is actively in use while evaluating this Sensor.
Example: 1%",1,3734316770,0,667,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Tanium Client CPU,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client CPU
&#039;========================================

strComputer = &quot;.&quot;  
Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
Set colService = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
For Each objService in colService      
StrSQL = &quot;present&quot;    
Next  
if StrSQL = &quot;present&quot; THEN 
for each Process in GetObject(&quot;winmgmts:&quot;).ExecQuery(&quot;Select * from Win32_Process where Name = &#039;taniumclient.exe&#039;&quot;)   
WScript.echo CPUUSage(Process.Handle) &amp; &quot;%&quot;  
Next  
Function CPUUSage( ProcID )   
On Error Resume Next   
Set objService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)     
For Each objInstance1 in objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;taniumclient&#039;&quot;)        
N1 = objInstance1.PercentProcessorTime        
D1 = objInstance1.TimeStamp_Sys100NS      
Exit For    
Next  
WScript.Sleep(5000)     
For Each perf_instance2 in objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;taniumclient&#039;&quot;)        
N2 = perf_instance2.PercentProcessorTime        
D2 = perf_instance2.TimeStamp_Sys100NS      
Exit For    
Next    
&#039; CounterType - PERF_100NSEC_TIMER_INV   
&#039; Formula - (1- ((N2 - N1) / (D2 - D1))) x 100     
Nd = (N2 - N1)     
Dd = (D2-D1)     
PercentProcessorTime = ( (Nd/Dd))  * 100    
CPUUSage = Round(PercentProcessorTime ,0) 
End Function 
END IF",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
336,Hardware,2015-01-05T20:22:05,",","The family of the processor or CPU (Windows provides a family ID).
Example: Xeon, Family 198",1,3763483691,0,669,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,CPU Family,,,,,,,,,Windows,"&#039;========================================
&#039; CPU Family
&#039;========================================

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Processor&quot;)
For Each objItem in colItems
 	Wscript.Echo objItem.Family &amp; &quot; Processor Family&quot;
Next",VBScript,Linux,"#!/bin/bash
#dmidecode -s processor-family | grep -v &quot;Unknown&quot;
line=$(grep -m 1 -i &quot;cpu family&quot; /proc/cpuinfo)
set -- $line
echo ${line#*:}
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
337,Operating System,2015-01-05T20:22:05,",","Name for SCSI Controller Driver as provided by the manufacturer.
Example: VClone",1,3764526140,0,671,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,SCSI Controller Driver Name,,,,,,,,,Windows,select DriverName from win32_SCSIController,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
338,Operating System,2015-01-05T20:22:05,",","Swap space in use in MB by the client machine.
Example: 2164 MB",1,3868118771,0,673,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Used Swap,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
memLine=$(free -m | grep &quot;Swap&quot;)
set -- $memLine
echo $3 MB
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
339,File System,2015-01-05T20:22:05,",","Returns the contents of the specified folder.
Example: 0.log",1,3881863289,0,675,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Folder Contents,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the full drive letter and folder path of the folder"",""value"":"""",""promptText"":""e.g. c:\\Program Files\\MyApp"",""defaultValue"":"""",""label"":""Folder path to search for"",""maxChars"":0,""key"":""folderPath"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Folder Contents
&#039;========================================

strFolderPath = unescape(&quot;||folderPath||&quot;)
strFolderPath = FixFileSystemRedirectionForPath(strFolderPath)

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

If fso.FolderExists(strFolderpath) Then
	Set objFolder = fso.GetFolder(strFolderPath)
	
	Set objSubDir = objFolder.SubFolders

	Set objFiles = objFolder.Files
	
	If objSubDir.Count = 0 AND objFiles.Count = 0 Then
		
		WScript.Echo &quot;Folder is Empty&quot;

		WScript.quit()

	End If


	If objSubDir.Count &gt; 0 Then

		For Each ObjSubFolder In objSubDir
			WScript.Echo (&quot;Folder : &quot; &amp; ObjSubFolder.Name)

		Next

	End If

	If objFiles.Count &gt; 0 Then
		For Each objFile In objFiles 
			WScript.Echo objFile.Name
		Next
	End If

Else
	WScript.Echo &quot;Folder does not exist&quot;

End If


Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
    
    Dim objFSO, strSystem32Location,objShell
    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
    
    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
        If InStr(strFilePath,strSystem32Location) = 1 Then
            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
            strFilePath = strNewSystem32Location&amp;strRestOfPath
        End If
    End If
    FixFileSystemRedirectionForPath = strFilePath
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

    Dim objFSO,strSystem32Location,strNewSystem32Location
    
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    
    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
    
    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;folderPath&quot;,&quot;promptText&quot;:&quot;e.g. c:\Program Files\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||folderPath||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;folderPath&quot;,&quot;promptText&quot;:&quot;e.g. c:\Program Files\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||folderPath||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
340,Operating System,2015-01-05T20:22:05,",","System unique identifier UUID on Mac or Linux machines.
Example: 3e6be9de-8139-11d1-9106-a43f08d823a6",1,3891170751,0,677,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,System UUID,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
dmidecode -s system-uuid
",UnixShell,Mac,"#!/bin/bash
system_profiler SPHardwareDataType | awk &#039;/Hardware UUID/ {print $NF}&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
341,Tanium Diagnostics,2015-01-05T20:22:05,",","The IP address the Tanium Client is communicating to the server with.  This can be a public IP, or IP of a NAT device, for example.
Example: 65.128.25.253",1,3898138660,0,679,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium Client NAT IP Address,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Client NAT IP Address
&#039;========================================


Dim strTaniumPath, strStatusPath
Dim strClientAddress, arrClientAddress, strIPAddress
Dim objReg


Set objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)

Const HKLM = &amp;h80000002

&#039;Tanium registry key paths
strTaniumPath = GetTaniumRegistryPath()
strStatusPath = strTaniumPath &amp; &quot;\Status&quot;

&#039;Pull the registry value out
objReg.GetStringValue HKLM, strStatusPath, &quot;ClientAddress&quot;, strClientAddress

arrClientAddress = Split(strClientAddress,&quot;0:&quot;)

&#039; Final output
strIPAddress = arrClientAddress(1)

WScript.Echo strIPAddress

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function
	
Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function ParseTaniumIPEntry(strIPEntry)
&#039; This function will parse a Tanium IP address entry in the registry
	
	Dim strLeftSplit
	
	strLeftSplit = Left(strIPEntry,InStr(strIPEntry,&quot;_&quot;)-1)
	ParseTaniumIPEntry = Right(strLeftSplit,len(strLeftSplit)-InStrRev(strLeftSplit,&quot;:&quot;))

End Function &#039;ParseTaniumIPEntry",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
342,SQL,2015-01-05T20:22:05,",","Returns a list of long running SQL Server jobs on the client machine.  Details include job name, start date, and duration.
Example: backupjob | 22-july-12 12:00 Am | 00:01:00:00",1,391368340,0,681,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,SQL Server Agent Long Running Jobs,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Server Agent Log Running Jobs
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit

Dim dictInstances, strInstance, objConnection

Set dictInstances = GetMSSQLInstances()

For Each strInstance In dictInstances.Keys
	
	Dim objRecordSet, Record, strJob, strDate, strDur
	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;)   
	Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)    
	
	On Error Resume Next
	objConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)
	
	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 
	On Error Goto 0
	
	objRecordSet.Open &quot;select job_name, run_datetime, run_duration from (select job_name, run_datetime,SUBSTRING(run_duration, 1, 2) + &#039;:&#039; + SUBSTRING(run_duration, 3, 2) + &#039;:&#039; +SUBSTRING(run_duration, 5, 2) AS run_duration from(select DISTINCT j.name as job_name, run_datetime = CONVERT(DATETIME, RTRIM(run_date)) +  (run_time * 9 + run_time % 10000 * 6 + run_time % 100 * 10) / 216e4, run_duration = RIGHT(&#039;000000&#039; + CONVERT(varchar(6), run_duration), 6) from msdb..sysjobhistory h inner join msdb..sysjobs j on h.job_id = j.job_id) t) t where (run_datetime &gt; (GETDATE()-10) and run_duration &gt; &#039;00:01:00&#039;) order by job_name, run_datetime &quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC    
	
	If (objRecordset.EOF = True) Then
		WScript.Echo &quot;None&quot; &amp; GetMSSQLSensorInstanceStr(strInstance) 
	Else 
		objRecordSet.MoveFirst    
		For Each Record In objRecordSet.Properties      
			strJob = objRecordSet(&quot;job_name&quot;)     
			strDate = objRecordSet(&quot;run_datetime&quot;)     
			strDur = objRecordSet(&quot;run_duration&quot;)      
			WScript.echo strJob &amp; &quot; at: &quot; &amp; strDate &amp; &quot;, duration:&quot; &amp; strDur &amp; GetMSSQLSensorInstanceStr(strInstance)    
			objRecordSet.MoveNext      
			If (objRecordset.EOF = True) Then         
				objRecordSet.Close         
				Exit For      
			End If  
		Next   
	End If
Next
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
343,Hardware,2015-01-05T20:22:05,",","Checks if CD-ROM/DVD-ROM drive is loaded.
Example:  True or False",1,3914171274,0,683,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,CD-ROM Drive Loaded,,,,,,,,,Windows,"&#039;========================================
&#039; CD-ROM Drive Loaded
&#039;========================================

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_CDROMDrive&quot;)

hasDisc = False
For Each objItem in colItems
	If objItem.MediaLoaded Then
		hasDisc = True
	End If
Next

If hasDisc Then
	WScript.Echo &quot;True&quot;
Else
	WScript.Echo &quot;False&quot;	
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
344,Hardware,2015-01-05T20:22:05,",","Device name for any attached batteries for a machine, commonly found in laptops.
Example: DELL V57XN24",1,3963156324,0,685,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Attached Battery,,,,,,,,,Windows,Select Name from Win32_Battery where availability &gt; 0,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
345,User,2015-01-05T20:22:05,|,"Returns the location of all user profiles and their sizes
Example:C:\Users\John.Doe 28.2 GB",1,3999173666,0,687,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,User Profile Directory Details,,,,,,,,,Windows,"&#039;========================================
&#039; User Profile Directory Details
&#039;========================================
Option Explicit
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs

SensorRandomize()

SetLocale(GetTaniumLocale)

On Error Resume Next &#039; permissions issues, perhaps

Const HKLM = &amp;H80000002
Dim objRegistry,strKeyPath,objSubKey,arrSubKeys,strValueName,strSubPath
Dim objFSO,objFolder,strValue,strSize,strSep

strSep = &quot;|&quot;

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)

Set objRegistry=GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)
 
strKeyPath = &quot;SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList&quot;
objRegistry.EnumKey HKLM, strKeyPath, arrSubkeys
 
For Each objSubkey In arrSubkeys
    strValueName = &quot;ProfileImagePath&quot;
    strSubPath = strKeyPath &amp; &quot;\&quot; &amp; objSubkey
    objRegistry.GetExpandedStringValue HKLM,strSubPath,strValueName,strValue
    
    If Not InStr(strValue,&quot;:&quot;) &gt; 0 Then &#039; Not Local, don&#039;t get size of remote dirs
    	strSize = &quot;Unknown&quot;
    ElseIf Not objFSO.FolderExists(strValue) Then
    	strSize = &quot;Folder not found&quot;
    Else
    	Set objFolder = objFSO.GetFolder(strValue)
  		strSize = GetAccessibleFolderSize(strValue)
  		strSize = GetPrettyFileSize(strSize)
	End If
    Wscript.Echo strValue &amp; strSep &amp; strSize
Next
On Error Goto 0


&#039; --- end main --- &#039;
Function GetPrettyFileSize(strSize)
Dim dblSize
	dblSize = CDbl(strSize)

	If dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB
		strSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;	
	ElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB
		strSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;
	ElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB
		strSize = CStr(Round(dblSize / 1024)) &amp; &quot; kB&quot;
	Else
		strSize = CStr(dblSize) &amp; &quot; B&quot;	
	End If	
	GetPrettyFileSize = strSize
End Function &#039;GetPrettyFileSize


Function GetAccessibleFolderSize(strFolderPath)
&#039; Gets the folder sizes that it is able to
&#039; and skips those it has no rights to see
    On Error Resume Next &#039; Permissions Errors potentially

	Dim objFSO
    Dim objFolder,objSubfolder,intSize,bHasSubfolders	
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	    
    bHasSubfolders = False

    Set objFolder = objFSO.GetFolder(strFolderPath)
    Err.Clear
    intSize = objFolder.Size
    If Err.Number &lt;&gt; 0 Then
        For Each objSubfolder in objFolder.SubFolders
            intSize = intSize + GetAccessibleFolderSize(objSubfolder.Path)
            bHasSubfolders = True
        Next

        If Not bHasSubfolders Then
            intSize = objFolder.Size
        End If
    End If

    GetAccessibleFolderSize = intSize
    
    On Error Goto 0

End Function &#039;GetAccessibleFolderSize

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,6,0,1,0,Profile Location,DataSize,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Size,DataSize,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
346,Network,2015-01-05T20:22:05,",","Returns the primary WINS server of a machine.
Example: WINS1",1,4018912755,0,689,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Primary WINS Server,,,,,,,,,Windows,select WINSPrimaryServer from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
347,Operating System,2015-01-05T20:22:05,|,"Returns the run keys that define which programs will be started when a user logs in.
Example:  System|GlobalProtect|""C:\Program Files\Palo Alto Networks\GlobalProtect\PanGPA.exe""",1,4058321794,0,691,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Run Keys,,,,,,,,,Windows,"&#039;========================================
&#039; Run Keys
&#039;========================================

&#039; returns the system and user keys for a given key

Option Explicit

Const strSep = &quot;|&quot;

Dim dictBlacklist, strKeyPath, strKeyPath32, dictResults, strValue, bShouldList, strItem

Set dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; Add one line for each admin user that you do not want listed in the sensor output.  
&#039; dictBlacklist.Add LCase(&quot;VMWare User Process&quot;), True


strKeyPath = &quot;Software\Microsoft\Windows\CurrentVersion\Run&quot;
strKeyPath32 = &quot;Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run&quot;
    
Set dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)

AddValuesForKey dictResults, strKeyPath
AddValuesForKey dictResults, strKeyPath32

For Each strValue In dictResults.Keys
	bShouldList = True
    For Each strItem In dictBlacklist.Keys
        If InStr(LCase(strValue), strItem) &gt; 0 Then 
            bShouldList = False
        End If
    Next

    If bShouldList Then 
        WScript.Echo strValue
    End If 
Next

Sub AddValuesForKey(dictResults, strKey)
&#039; This function will output the two values

    Const HKLM = &amp;h80000002
	Const HKEY_USERS = &amp;H80000003
    
    Dim objRegistry
    Dim arrUserKeys,strUserKey, strUserKeyPath
    
    &#039; get System Keys
    Set objRegistry = Getx64RegistryProvider()
    If RegKeyExists(HKLM, strKey, objRegistry) Then  
        GetValues objRegistry, HKLM, strKey, dictResults, &quot;System&quot;
    End If
    
    &#039; get User Keys
    objRegistry.EnumKey HKEY_USERS, &quot;&quot;,arrUserKeys
	For Each strUserKey In arrUserKeys
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserKeyPath = strUserKey &amp; &quot;\&quot; &amp; strKey
			If RegKeyExists(HKEY_USERS,strUserKeyPath, objRegistry) Then
		        GetValues objRegistry, HKEY_USERS, strUserKeyPath, dictResults, &quot;User&quot;
		 	End If
		 End If 
	Next 
End Sub &#039;AddValuesForKey

Sub GetValues(objRegistry, hiveConst, keyPath, dictValues, strPrefix)
    Dim arrKeyNames, arrTypes, arrValueNames, strValueName
    Dim strValueData, i, strEntry
        
    objRegistry.EnumValues hiveConst, keyPath, arrValueNames, arrTypes
    
    If Not IsArray(arrValueNames) Then
        arrValueNames = Array(&quot;&quot;)
        arrTypes = Array(1)
    End If
    
    For i = LBound(arrValueNames) To UBound(arrValueNames)
        strValueName = arrValueNames(i)
        strValueData = GetRegValue(objRegistry, hiveConst, keyPath, strValueName, arrTypes(i))
        If Not ( IsNull(strValueName) Or IsNull(strValueData) ) Then
        	strEntry = strPrefix &amp; strSep &amp; strValueName &amp; strSep &amp; strValueData
        	If Not dictValues.Exists(strEntry) Then 
        		dictValues.Add strEntry, True
        	End If 
        End If
    Next    
End Sub &#039;GetValues

Function GetRegValue(objRegistry, hiveConst, keyPath, strValueName, constType)

    Const REG_SZ        = 1
    Const REG_EXPAND_SZ = 2
    Const REG_BINARY    = 3
    Const REG_DWORD     = 4
    Const REG_MULTI_SZ  = 7
    Const REG_QWORD     = 11

    Dim strValue, arrBytes, uValue, arrValues

    Select Case constType
        Case REG_SZ  
            objRegistry.GetStringValue hiveConst, keyPath, strValueName, strValue
            GetRegValue =  strValue
            Exit Function
        Case REG_EXPAND_SZ
            objRegistry.GetExpandedStringValue hiveConst, keyPath, strValueName, strValue
            GetRegValue =  strValue
            Exit Function
        Case REG_BINARY
            objRegistry.GetBinaryValue hiveConst, keyPath, strValueName, arrBytes
            strBytes = &quot;&quot;
            For Each uByte in arrBytes
                strBytes = strBytes &amp; Hex(uByte) &amp; &quot; &quot;
            Next
            GetRegValue =  strBytes
            Exit Function
        Case REG_DWORD
            objRegistry.GetDWORDValue hiveConst, keyPath, strValueName, uValue
            GetRegValue =  CStr(uValue)               
            Exit Function
        Case REG_QWORD
            objRegistry.GetQWORDValue hiveConst, keyPath, strValueName, uValue
            GetRegValue =  CStr(uValue)               
            Exit Function
        Case REG_MULTI_SZ
            objRegistry.GetMultiStringValue hiveConst, keyPath, strValueName, arrValues                             
            For Each strValue in arrValues
                GetRegValue =  strValue 
            Next
            Exit Function
    End Select
End Function &#039;GetRegValue

Function RegKeyExists(sHive, sRegKey, objReg)
    Dim aValueNames, aValueTypes
    If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
        RegKeyExists = True
    Else
        RegKeyExists = False
    End If
End Function &#039; RegKeyExists


Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Type,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Name,String,0,1,2,Command Line,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
348,Tanium Diagnostics,2015-01-05T20:22:05,",","Provided with a parameter indicating the path to a file in the Tanium current directory, this sensor will return the contents of that file.
Example: <arbitrary file output>",1,4070262781,0,693,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Tanium File Contents,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Starting from the Client installation directory, complete the file path to get contents for."",""value"":"""",""promptText"":""e.g. Tools\\MyTool\\MyLog.txt"",""defaultValue"":"""",""label"":""Relative file path from <Tanium Client Installation Dir>"",""maxChars"":0,""key"":""filePath"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Tanium File Contents
&#039;========================================

Option Explicit

Dim fso, strFilePath, strClientPath, strAbsoluteFilePath, objTextFile

strFilePath = unescape(&quot;||filePath||&quot;)
strFilePath =  GetTaniumDir(&quot;&quot;) &amp; strFilePath
strClientPath = GetTaniumDir(&quot;&quot;)

Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

If fso.FileExists(strFilePath) Then
	strAbsoluteFilePath = fso.GetAbsolutePathName(strFilePath)
	
	If LCase(Left(strAbsoluteFilePath, Len(strClientPath))) = LCase(strClientPath) Then 
		Set objTextFile = fso.OpenTextFile(strFilePath, 1)
		WScript.Echo Replace(objTextFile.Read(4096),vbLf,&quot;&quot;)
		objTextFile.Close
	Else
		WScript.Echo &quot;Not Within Client Directory&quot;
	End If
Else
	WScript.Echo &quot;File does not exist&quot;
End If


Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filePath&quot;,&quot;promptText&quot;:&quot;e.g. Tools\MyTool\MyLog.txt&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filePath||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filePath&quot;,&quot;promptText&quot;:&quot;e.g. Tools\MyTool\MyLog.txt&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filePath||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
349,Tanium Diagnostics,2015-01-05T20:22:05,",","Retrieves the Tanium Server Name from the Client's Registry
Example: server.domain.com",1,4076878703,0,695,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium Server Name,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Server Name
&#039;========================================


Option Explicit

Const HKLM = &amp;h80000002

Dim objReg
Dim strTaniumRegPath, strCurrentTaniumServerValue
Dim strComputer

strComputer = &quot;.&quot;

Set objReg = _ 
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

strTaniumRegPath = GetTaniumRegistryPath()
&#039;retrieve current server name value
objReg.GetStringValue HKLM, strTaniumRegPath, &quot;ServerName&quot;, strCurrentTaniumServerValue

WScript.Echo strCurrentTaniumServerValue

&#039;Cleanup
Set objReg = Nothing

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists",VBScript,Linux,"#!/bin/sh

grep ^ServerName TaniumClient.ini  | awk -F= &#039;{print $2}&#039;
",UnixShell,Mac,"#!/bin/sh

grep ^ServerName TaniumClient.ini  | awk -F= &#039;{print $2}&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
350,File System,2015-01-05T20:22:05,",","Returns the modification date of the file specified by the parameter.
Example: 12/12/2014 18:00",1,4080631087,0,697,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,File Modification Date,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the file path and name to search for."",""value"":"""",""promptText"":""e.g. c:\\windows\\test.txt"",""defaultValue"":"""",""label"":""File path and name to search for"",""maxChars"":0,""key"":""filename"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; File Modification Date
&#039;========================================

Option Explicit

SetLocale(1033)

Dim filesys, filename, file, modificationdate 

filename = unescape(&quot;||filename||&quot;)
&#039;filename = &quot;c:\windows\regedit.exe&quot;

filename = FixFileSystemRedirectionForPath(filename)

Set filesys = CreateObject(&quot;Scripting.FileSystemObject&quot;)

If filesys.FileExists(filename) Then
   Set file = filesys.GetFile(filename)
   modificationdate = file.DateLastModified
   WScript.Echo FormatDateTime(modificationdate, vbShortDate) &amp; &quot; &quot; &amp; FormatDateTime(modificationdate, vbShortTime)
Else
   WScript.Echo &quot;File &quot; &amp; filename &amp; &quot; not found.&quot;
End If


Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
    
    Dim objFSO, strSystem32Location,objShell
    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
    
    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
        If InStr(strFilePath,strSystem32Location) = 1 Then
            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
            strFilePath = strNewSystem32Location&amp;strRestOfPath
        End If
    End If
    FixFileSystemRedirectionForPath = strFilePath
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

    Dim objFSO,strSystem32Location,strNewSystem32Location
    
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    
    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
    
    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,BESDate
351,Miscellaneous,2015-01-05T20:22:05,|,"Returns the number of used and unused RAM slots.
Example:2 6",1,4086041268,0,699,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,RAM Slots Used and Unused,,,,,,,,,Windows,"&#039;========================================
&#039; RAM Slots Used and Unused
&#039;========================================

&#039; This sensor will return the number of free RAM slots

Option Explicit

Dim strSep: strSep = &quot;|&quot;
&#039; This is a multi-column sensor
&#039; The output is 
&#039; Slots Used | Slots Unused

RAM_SlotsUsedAndUnused(strSep)

Function RAM_SlotsUsedAndUnused(strSep)
&#039; This function returns the number of used and unused RAM slots
	Dim strComputer
	Dim objWMIService, colPMAs, objPMA
	Dim colPMs, objPM

	&#039; How many slots exist
	Dim intSlots: intSlots = 0
	&#039; How many MemoryDevices are present
	Dim intMemorySticks: intMemorySticks = 0
	&#039; How many slots are free
	Dim intFreeSlots: intFreeSlots = 0
	
	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
	&#039;Use = 3 is system RAM
	&#039; This is the number of slots in the system.
	Set colPMAs = objWMIService.ExecQuery(&quot;Select MemoryDevices from Win32_PhysicalMemoryArray where use=&#039;3&#039;&quot;,,48)
	
	For Each objPMA In colPMAs
		&#039; There should be only one
		&#039; but just in case
		intSlots = intSlots + objPMA.MemoryDevices
		&#039; WScript.Echo &quot;objPMA.MemoryDevices is total slots: &quot; &amp; objPMA.MemoryDevices
	Next
	
	&#039; Cleanup
	Set colPMAs = Nothing
	
	&#039; A new query - asking for DeviceLocator where memory type does not 
	&#039; equal 11 (Flash RAM)
	&#039; DeviceLocator is the label of the socket that holds the memory
	&#039; So this is the number of sockets in the system
	Set colPMs = objWMIService.ExecQuery(&quot;Select DeviceLocator from Win32_PhysicalMemory where MemoryType!=&#039;11&#039;&quot;)
	
	For Each objPM In colPMs
		&#039;Each loop through indicates another slot
		intMemorySticks = intMemorySticks + 1
	Next
	
	&#039; output is number of used slots, separator, and number of free slots
	intFreeSlots = intSlots - intMemorySticks
	
	WScript.Echo intMemorySticks &amp; strSep &amp; intFreeSlots
	
	&#039;Cleanup
	Set colPMs = Nothing
	Set objWMIService = Nothing
End Function &#039;RAM_SlotsUsedAndUnused",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Slots Used,NumericInteger,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Slots Unused,NumericInteger,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
352,Operating System,2015-01-05T20:22:05,",","A short description of the SCSI Controller as provided by the manufacturer.
Example: Dell PERC S100 S300 Controller",1,4105783647,0,701,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,SCSI Controller Caption,,,,,,,,,Windows,select Caption from win32_SCSIController,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
353,Symantec,2015-01-05T20:22:05,",","Version of virus definition DAT file on client machine if Symantec AV is installed.
Example: 20120103",1,4117529004,0,703,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Symantec DAT Version,,,,,,,,,Windows,"&#039;========================================
&#039; Symantec DAT Version
&#039;========================================

Option Explicit

&#039; Force correct date handling
SetLocale(1033)

Const HKLM = &amp;H80000002 
Const keyPath = &quot;Software\Symantec\SharedDefs&quot;
Const keyPath12 = &quot;Software\Symantec\Symantec Endpoint Protection\CurrentVersion\SharedDefs&quot;

Dim objRegistry, strResult, strValue

Set objRegistry = Getx32RegistryProvider()

If Not RegKeyExists(HKLM, keyPath) Then
	strResult = &quot;Not Installed&quot;
End If

&#039;check for SEP 12, which uses a different location for definitions&#039;
&#039;check NAVCORP_70 value&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath12 ,&quot;NAVCORP_70&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatVersion(strValue)
	End If
End If

&#039;check NAVCORP_70 value&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVCORP_70&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatVersion(strValue)
	End If
End If

&#039;check NAVNO_50_AP1 value&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNO_50_AP1&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatVersion(strValue)
	End If
End If

&#039;check NAVNT_50_AP1 value&#039;
If strResult = &quot;&quot; Then 
	objRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT_50_AP1&quot;, strValue
	If Not IsNull(strValue) Then
		strResult = GetDatVersion(strValue)
	End If
End If 

If strResult = &quot;&quot; Then 
	WScript.Echo &quot;Dat value not found&quot;
Else 
	WScript.Echo strResult
End If


Function GetDatVersion(strValue)
	Dim words, datFile
	words = Split(strValue, &quot;\&quot;)
	datFile = words(UBound(words))
	words = Split(datFile, &quot;.&quot;)
	GetDatVersion = words(0)
End Function

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function Getx32RegistryProvider
    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems
    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript
    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv
    
    iArchType = 32
   
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx32RegistryProvider = objRegProv
End Function &#039; Getx32RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
354,Active Directory,2015-01-05T20:22:05,",","Returns the name of the Active Directory Forest that a machine is a member of.  This may produce the same value that the Sensor named AD Domain produces.
Example: corp.domain.com",1,4165545489,0,705,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,AD Forest,,,,,,,,,Windows,"&#039;========================================
&#039; AD Forest
&#039;========================================

Option Explicit
On Error Resume Next 
Dim objSysInfo
Set objSysInfo = CreateObject(&quot;ADSystemInfo&quot;) 

If IsNull(objSysInfo.ForestDNSName) Then
	WScript.Echo &quot;N/A&quot;
Else
	WScript.Echo objSysInfo.ForestDNSName
End If",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
355,Operating System,2015-01-05T20:22:05,|,"The amount of free disk space on the main system drive.
Example: C:|4 GB",1,4180356655,0,707,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,System Disk Free Space,,,,,,,,,Windows,"&#039;========================================
&#039; Disk Free Space of System Drive
&#039;========================================

&#039; This sensor uses the Disk Free Space sensor code
&#039; but limits output to the drive that is designated the system
&#039; drive

Set objShell = CreateObject(&quot;WScript.Shell&quot;) 
Set objEnv = objShell.Environment(&quot;PROCESS&quot;) 

strSystemDrive = objEnv(&quot;SystemDrive&quot;)

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; _
    &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colDisks = objWMIService.ExecQuery _
    (&quot;Select * from Win32_LogicalDisk&quot;)

For Each objDisk in colDisks
	If LCase(objDisk.DeviceID) = LCase(strSystemDrive) Then
		FreeMB = objDisk.FreeSpace/1024000
	  	If (FreeMB &lt;&gt; &quot;&quot; and FreeMB &lt;&gt; 0) THEN
	    	FreeGB = FreeMB/1000
	    	WScript.Echo objDisk.DeviceID &amp; &quot;|&quot; &amp; Round(FreeGB) &amp; &quot; GB&quot;
	  	End If
	End If
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,2,0,1,0,Disk,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Free Space,DataSize,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
356,Operating System,2015-01-05T20:22:05,",","Indicates the free swap space available to the operating system.
Example: 640MB",1,4201347922,0,709,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Free Swap,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
memLine=$(free -m | grep &quot;Swap&quot;)
set -- $memLine
echo $4 MB
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
357,Operating System,2015-01-05T20:22:05,",","The amount of total disk space on the main system drive.
Example: C: 100 GB",1,4212162125,0,711,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Disk Total Size of System Drive,,,,,,,,,Windows,"&#039;========================================
&#039; Disk Total Size of System Drive
&#039;========================================

&#039; This sensor uses the Disk Total Space sensor code
&#039; but limits output to the drive that is designated the system
&#039; drive

Set objShell = CreateObject(&quot;WScript.Shell&quot;) 
Set objEnv = objShell.Environment(&quot;PROCESS&quot;) 

strSystemDrive = objEnv(&quot;SystemDrive&quot;)

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; _
    &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colDisks = objWMIService.ExecQuery _
    (&quot;Select * from Win32_LogicalDisk&quot;)
For Each objDisk in colDisks
 &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID
    If LCase(objDisk.DeviceID) = LCase(strSystemDrive) Then
	    If Not IsNull(objDisk.Size) Then
		    dblSize = CDbl(objDisk.Size)
		    dblSize = dblSize / 1024 / 1024 / 1024
		    intSize = CInt(dblSize)
			WScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intSize &amp; &quot; GB&quot;
	    End If
	End If
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
358,Patch,2015-01-05T20:22:05,|,"Allows the retreival of the available patches download URLs
Example:Security Update for Windows Server 2003 (KB2510531) | Critical | URL | Filename",1,4213159728,0,713,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Available Patches URLs,,,,,,,,,Windows,"&#039;========================================
&#039; Available Patches URL
&#039;========================================

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput
strSep = &quot;|&quot;

&#039;title|severity|download|filename

Dim strScansPath, strToolsPath
strToolsPath = GetTaniumDir(&quot;Tools&quot;)
strScansPath = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = strScansPath &amp; &quot;\patchresultsreadable.txt&quot;

&#039;Set up exclusions list
Dim excludeFile
excludeFile = strToolsPath &amp; &quot;\patch-exclude.txt&quot;

Dim objExclusions
Set objExclusions = GetPatchExclusions(excludeFile)

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				WScript.Echo words(0)
			&#039;Else 
&#039;				WScript.Echo &quot;Run upgraded Patch Scan&quot;
&#039;				WScript.Quit
			End If	
&#039;		ElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next

			If Not isComplete Then
				hasOutput = True
				If InStr(strLine, &quot;Already Installed&quot;) Then
					&#039;if InStr(strLine, &quot;(KB&quot;) Then
					&#039;	strLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)
					&#039;End If
					&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				Else
					&#039;Check to see if KB article should be excluded
					If Not IsExclusion(strLine, objExclusions) Then
						EchoLines strLine 
					End If
				End If
			Else
				&#039;If we&#039;re here, update has been queued
				&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				&#039;If InStr(strLine, &quot;Not Installed&quot;) Then
				&#039;	strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
				&#039;	WScript.Echo strLine
				&#039;End If
			End If 
		End If	
	Loop

	If Not hasOutput Then
		WScript.Echo &quot;All available patches queued for installation&quot;
	End If

	objReadFile.close
Else
   Wscript.echo &quot;Patch results output not found&quot;
End if
WScript.Quit()

Sub EchoLines(strLine) 
	Dim arrTokens, strTitle, strSeverity, strDownloads, strFilenames, i
	arrTokens = Split(strLine, &quot;|&quot;)
	strTitle = arrTokens(0)
	strSeverity = arrTokens(1)
	strDownloads = Split(arrTokens(4), &quot;,&quot;)
	strFilenames = Split(arrTokens(5), &quot;,&quot;)

	For i=0 To UBound(strDownloads)
		WScript.Echo strTitle &amp; &quot;|&quot; &amp; strSeverity &amp; &quot;|&quot; &amp; strDownloads(i) &amp; &quot;|&quot; &amp; strFilenames(i)
	Next
End Sub

Function RegKeyExists(reg, sHive, sRegKey)
  Dim aValueNames, aValueTypes
  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
    RegKeyExists = True
  Else
    RegKeyExists = False
  End If
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function IsExclusion(strLine, objDic)
	Dim colKeys, strKey
	colKeys = objDic.Keys
	For Each strKey in colKeys
		If InStr(strLine, strSep &amp; strKey &amp; strSep) &lt;&gt; 0 Then
			IsExclusion = True
			Exit Function
		End If
	Next
	
	IsExclusion = False
End Function

Function GetPatchExclusions(strFile)
	Dim oDic
	Set oDic = CreateObject(&quot;scripting.dictionary&quot;)
	
	Dim fso
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	Const ForReading = 1
	If fso.FileExists(strFile) Then
		Dim objFile
		Set objFile = fso.OpenTextFile(strFile, ForReading)
		
		Dim strLine
		Do While objFile.AtEndOfStream &lt;&gt; True
			strLine = Trim(objFile.ReadLine)
			
			&#039;Ignore lines that start with #
			If Left(strLine, 1) &lt;&gt; &quot;#&quot; Then
				oDic.Item(strLine) = &quot;placeholder&quot;
			End If
		Loop
	End If
	
	Set GetPatchExclusions = oDic
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Severity,String,0,1,2,Download,String,1,1,3,Filename,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
359,Symantec,2015-01-05T20:22:05,",","Age in days of the last scan report by Symantec AV on the client machine if it exists.  This sensor is SEP 12 specific
Example: 9",1,4225944416,0,715,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Symantec SEP 12 Last Report Days Old,,,,,,,,,Windows,"&#039;========================================
&#039; Symantec Last Report Days Old - SEP 12 possible
&#039;========================================

&#039;SEP 12 seems to work differently than previous versions.  This sensor determines the last scan based on&#039;
&#039;a different criteria than previous SEP versions&#039;

strComputer = &quot;.&quot;
Set objRegistry = _
	GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
	&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

keyPath = &quot;SOFTWARE\Symantec\Symantec Endpoint Protection\CurrentVersion\Common Client\PathExpansionMap&quot;
key64Path = &quot;SOFTWARE\WOW6432Node\Symantec\Symantec Endpoint Protection\CurrentVersion\Common Client\PathExpansionMap&quot;

Const HKLM = &amp;H80000002 
If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path
End If 

If Not RegKeyExists(HKLM, keyPath) Then
	WScript.Echo &quot;Not Installed&quot;
	WScript.Quit
End If

strFile = &quot;\Data\IRON\IronState.dat&quot;
set theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)

&#039;check SEP 12 State directory&#039;
objRegistry.GetStringValue HKLM,keyPath ,&quot;APPDATABASE&quot;, strDir
If theFso.FileExists(strDir &amp; strFile) Then
	WScript.Echo GetReportDaysOld(strDir &amp; strFile)
	WScript.Quit
End If

WScript.Echo &quot;Not Installed&quot;

function GetReportDaysOld(theFile)
	dim theFso, theVer
	set theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	reportDate = FormatDateTime(theFso.GetFile(theFile).DateLastModified,2)
	&#039;WScript.Echo (&quot;reportdate: &quot; &amp; reportDate)
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	GetReportDaysOld = DateDiff(&quot;d&quot;, reportDate, today)
End Function

Function GetDatDaysOld(strValue)
End Function


Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
360,Tanium Diagnostics,2015-01-05T20:22:05,",","Installation directory of the Tanium Client on the client machine.
Example: C:\Program Files\Tanium\Tanium Client",1,4225957259,0,717,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium Current Directory,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Current Directory
&#039;========================================

set wshell = createobject(&quot;wscript.shell&quot;)
wscript.echo wshell.currentdirectory",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,4,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
361,Network,2015-01-05T20:22:05,",","A list of the static IP addresses currently held by the client machine.
Example: 192.168.1.1",1,422662332,0,719,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Static IP Addresses,,,,,,,,,Windows,select IPAddress from win32_networkadapterconfiguration where DHCPEnabled = False and IPEnabled=True,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,IPAddress
362,Operating System,2015-01-05T20:22:05,",","Returns the set run level of Linux systems
Example: 3",1,4244179900,0,721,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Run Level,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
line=$(who -r)
set -- $line
echo $2
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
363,Hardware,2015-01-05T20:22:05,",","Returns the number of open slots in the system on Windows client machines.
Example: 3",1,4254566410,0,723,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,System Slots Available,,,,,,,,,Windows,"&#039;========================================
&#039; System Slots Available
&#039;========================================

&#039; This sensor will return the number of slots open in the system

Option Explicit

WScript.Echo GetSystemSlotsAvailable

Function GetSystemSlotsAvailable
	
	Dim objWMIService, colSystemSlots
	Dim strComputer, objSystemSlots

	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
		&amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;) 

	&#039;SlotDesignation is like &quot;PCI-I&quot; and CurrentUsage=3 means available
	Set colSystemSlots = objWMIService.ExecQuery _ 
		(&quot;Select SlotDesignation from Win32_SystemSlot where CurrentUsage=3&quot;) 
	If Not IsNull(colSystemSlots) Then
		GetSystemSlotsAvailable = colSystemSlots.Count
	Else
		GetSystemSlotsInAvailable = &quot;WMI Error&quot;
	End If
	
	&#039;Cleanup
	Set colSystemSlots = Nothing
	Set objWMIService = Nothing
End Function &#039;GetSystemSlotsAvailable",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
364,Tanium Diagnostics,2015-01-05T20:22:05,",","Returns the IP address of the peer specified in th Tanium registry entry at HKLM\SOFTWARE\Tanium\Tanium Client\Status\PeerAddress on windows and TaniumClientStatus.ini on non-windows endpoints.
Example: 192.168.1.123",1,4261354259,0,725,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium Peer Address,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Peer Address
&#039;========================================

Option Explicit

Const HKEY_LOCAL_MACHINE = &amp;H80000002

Dim strKeyPath, strValueName, strValue, strTaniumClientVersion, oReg

strKeyPath = GetTaniumRegistryPath &amp; &quot;\Status&quot;
strValueName = &quot;PeerAddress&quot; 
strTaniumClientVersion = GetTaniumClientVersion()

If InStr(strTaniumClientVersion,&quot;6.0.314.&quot; ) &gt; 0 Then
	&#039; This may seem exactly opposite, but the 6.0 client does not 
	&#039; correctly keep up with these values in status, but does the
	&#039; &quot;reverse&quot; connection.  So to know who is forward, we need to look
	&#039; up the previous back, to know who is backwards, we need the previous
	&#039; peer.  Very confusing
	strValueName = &quot;BackPreviousPeerAddress&quot;
End If

Set oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;) 

oReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue

Wscript.Echo strValue


Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		GetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		GetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;GetTaniumRegistryPath

Function GetTaniumClientVersion

	Dim fso, filePath, objFile
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	If GetTaniumDir(&quot;&quot;) = False Then 
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If 
	
	filePath = GetTaniumDir(&quot;&quot;) &amp; &quot;taniumclient.exe&quot;
	
	If fso.FileExists(filePath) Then
		Set objFile = fso.GetFile(filePath)
		GetTaniumClientVersion = fso.GetFileVersion(objFile)
	Else
		GetTaniumClientVersion &quot;Not installed&quot;
	End If

End Function &#039;GetTaniumClientVersion		

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir",VBScript,Linux,"#!/bin/sh

grep -w &quot;^PeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2
",UnixShell,Mac,"#!/bin/sh

grep -w &quot;^PeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
365,Active Directory,2015-01-05T20:22:05,",","Any Active Directory groups that the currently logged in user is a member of.
Example: CN=Domain Admins,CN=Users,DC=corp,DC=com",1,4264207873,0,727,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:05,AD User Groups,,,,,,,,,Windows,"&#039;========================================
&#039; AD User Groups
&#039;========================================

On Error Resume Next 
ScanUsers
 
Function ScanUsers()
	Dim strComputer, objWMIService, colComputer, objComputer, strId
	strComputer = &quot;.&quot;    
	Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)  
	Set colComputer = objWMIService.ExecQuery (&quot;Select UserName from Win32_ComputerSystem&quot;)    
	If colComputer.Count = 0 Then
		WScript.Echo &quot;No User&quot;
		WScript.quit
	End If
	For Each objComputer in colComputer     
		if objComputer.UserName &lt;&gt; &quot;&quot; Then
			words = Split(objComputer.UserName, &quot;\&quot;)
			
			If UBound(words) &gt; 0 Then
				strId = words(UBound(words))
				dn = GetDN(strId)
				GetGroups(dn)
			End If
		End If  
	Next
End Function

Function GetGroups(strDn)
&#039;	WScript.Echo &quot;looking at: &quot;&amp; strDN
	&#039;	On Error Resume Next
	Const E_ADS_PROPERTY_NOT_FOUND  = &amp;h8000500D
	 
	Set objUser = GetObject _
	    (&quot;LDAP://&quot; &amp; strDn)
	 
	intPrimaryGroupID = objUser.Get(&quot;primaryGroupID&quot;)
	arrMemberOf = objUser.GetEx(&quot;memberOf&quot;)
	 
	If Err.Number = E_ADS_PROPERTY_NOT_FOUND Then
	    WScript.Echo &quot;The memberOf attribute is not set.&quot;
	Else
	    For Each Group in arrMemberOf
	        WScript.Echo Group
	    Next
	End If
End Function

Function GetDN(strUserId)
	Const ADS_SCOPE_SUBTREE = 2
	
	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;)
	Set objCommand =   CreateObject(&quot;ADODB.Command&quot;)
	objConnection.Provider = &quot;ADsDSOObject&quot;
	objConnection.Open &quot;Active Directory Provider&quot;
	Set objCommand.ActiveConnection = objConnection
	
	objCommand.Properties(&quot;Page Size&quot;) = 1000
	objCommand.Properties(&quot;Searchscope&quot;) = ADS_SCOPE_SUBTREE 
	
	Set objRootDSE = GetObject(&quot;LDAP://RootDSE&quot;)
	strDNSDomain = objRootDSE.Get(&quot;defaultNamingContext&quot;)
	
	objCommand.CommandText = _
	    &quot;SELECT distinguishedName FROM &#039;LDAP://&quot;&amp;strDNSDomain&amp;&quot;&#039; WHERE objectCategory=&#039;user&#039; &quot; &amp; _
	        &quot;AND sAMAccountName=&#039;&quot;&amp;strUserId&amp;&quot;&#039;&quot;
	Set objRecordSet = objCommand.Execute
	
	objRecordSet.MoveFirst
	Do Until objRecordSet.EOF
	    &#039;Wscript.Echo objRecordSet.Fields(&quot;distinguishedName&quot;).Value
	    GetDN = objRecordSet.Fields(&quot;distinguishedName&quot;).Value
		Exit Function
	    objRecordSet.MoveNext
	Loop
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
366,Patch,2015-01-05T20:22:05,",","A sensor which counts the number of patch files queued for install.
Example: 2",1,4269230392,0,729,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Number of Queued Patches,,,,,,,,,Windows,"&#039;========================================
&#039; Number of Queued Patches
&#039;========================================

Option Explicit

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput
strSep = &quot;|&quot;

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\patchresultsreadable.txt&quot;

Dim intNumPatches

intNumPatches = 0

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				WScript.Echo words(0)
			&#039;Else 
&#039;				WScript.Echo &quot;Run upgraded Patch Scan&quot;
&#039;				WScript.Quit
			End If	
&#039;		ElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next

			If Not isComplete Then
				hasOutput = True
				If InStr(strLine, &quot;Already Installed&quot;) Then
					if InStr(strLine, &quot;(KB&quot;) Then
						strLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)
					End If
					&#039;Do not echo since we only want to output &quot;Queued&quot; patches
					&#039;WScript.Echo strLine
&#039;				Else
					&#039;Do not echo since we only want to output &quot;Queued&quot; patches
				End If
			Else
				&#039;If we&#039;re here, update has been queued 
				If InStr(strLine, &quot;Not Installed&quot;) Then
					strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
					intNumPatches = intNumPatches + 1
&#039;WScript.Echo strLine
				End If
			End If 
		End If	
	Loop

Wscript.echo intNumPatches

	objReadFile.close
Else
   Wscript.echo &quot;Patch results output not found&quot;
End if
WScript.Quit()

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
367,Registry,2015-01-05T20:22:05,|,"Returns all values contained in a supplied key.  If the hive is HKEY_USERS, it will attempt to output the user name associated with the key.  HKEY_CURRENT_USER will only return data for the SYSTEM account which the Tanium Client runs as.
Example: John | Version | 32-bit",1,4276555360,0,731,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Registry Key Value Names,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{5}"",""helpString"":""Value must be at least 5 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the registry key to query"",""value"":"""",""promptText"":""e.g. HKEY_USERS\\Software\\Key"",""defaultValue"":"""",""label"":""Registry Key"",""maxChars"":0,""key"":""strKey"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Registry Key Value Names
&#039;========================================

&#039;Columns:
&#039; User | Value Name | Architecture | KeyPath

strKey = unescape(&quot;||strKey||&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client&quot;
&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;

strSep = &quot;|&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive


&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)
If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If

If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive	
		hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True	
	End If
End If

If Not (hasAnyResult) Then
	WScript.Echo &quot;Key/Value not found&quot;
End If

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

	&#039; Note the key that was being searched, will be a hidden column
	strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
	
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			WScript.Echo strUserName &amp; strSep &amp; strValueName &amp; strSep &amp; intBit &amp; &quot;-bit&quot; _
				&amp; strSep &amp; strOutputKey &amp; &quot;\&quot; &amp; strValueName
		Next
		CheckValues = True

	Else
		CheckValues = False
	End If
End Function


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\Software\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\Software\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strKey||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,User,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Value Name,String,0,1,2,Architecture,String,0,1,3,KeyPath,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
368,Tanium Diagnostics,2015-01-05T20:22:05,",","Returns the IP address of the back peer specified in th Tanium registry entry at HKLM\SOFTWARE\Tanium\Tanium Client\Status\PeerAddress on windows and TaniumClientStatus.ini on non-windows endpoints.
Example: 192.168.1.123",1,4293389196,0,733,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium Back Peer Address,,,,,,,,,Windows,"&#039;========================================
&#039; Tanium Back Peer Address
&#039;========================================

Option Explicit

Const HKEY_LOCAL_MACHINE = &amp;H80000002

Dim strKeyPath, strValueName, strValue, strTaniumClientVersion, oReg

strKeyPath = GetTaniumRegistryPath &amp; &quot;\Status&quot;
strValueName = &quot;BackPeerAddress&quot; 
strTaniumClientVersion = GetTaniumClientVersion()

If InStr(strTaniumClientVersion,&quot;6.0.314.&quot; ) &gt; 0 Then
	strValueName = &quot;PreviousPeerAddress&quot;
End If

Set oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;) 

oReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue

Wscript.Echo strValue


Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		GetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		GetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;GetTaniumRegistryPath

Function GetTaniumClientVersion

	Dim fso, filePath, objFile
	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	
	If GetTaniumDir(&quot;&quot;) = False Then 
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If 
	
	filePath = GetTaniumDir(&quot;&quot;) &amp; &quot;taniumclient.exe&quot;
	
	If fso.FileExists(filePath) Then
		Set objFile = fso.GetFile(filePath)
		GetTaniumClientVersion = fso.GetFileVersion(objFile)
	Else
		GetTaniumClientVersion &quot;Not installed&quot;
	End If

End Function &#039;GetTaniumClientVersion		

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir",VBScript,Linux,"#!/bin/sh

grep -w &quot;^BackPeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2
",UnixShell,Mac,"#!/bin/sh

grep -w &quot;^BackPeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
369,SQL,2015-01-05T20:22:05,",","Returns the buffer cache hit ratio from SQL Server on the client machine.
Example: .5",1,432766313,0,735,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,SQL Buffer Hit Ratio,,,,,,,,,Windows,"&#039;========================================
&#039; SQL Buffer Hit Ratio
&#039;========================================
&#039;@INCLUDE=sql/mssql_connection_utils.vbs

Option Explicit

Dim dictInstances, strInstance, objConnection

Set dictInstances = GetMSSQLInstances()

For Each strInstance In dictInstances.Keys

	Dim objRecordSet, objRecordSet2, strNumerator, strDenominator, intNum, intDen, result
	Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) 
	Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;) 
	Set objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  
	
	On Error Resume Next
	objConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)
	
	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 
	
	objRecordSet.Open &quot;select cntr_value from master..sysperfinfo where (counter_name=&#039;Buffer cache hit ratio&#039;)&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC 
	objRecordSet2.Open &quot;select cntr_value from master..sysperfinfo where (counter_name=&#039;Buffer cache hit ratio base&#039;)&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  
	strNumerator = objRecordSet(&quot;cntr_value&quot;) 
	strDenominator = objRecordSet2(&quot;cntr_value&quot;) 

	If objConnection.Errors.Count &gt; 0 Then 
		WScript.Echo &quot;SQL Error (&quot; &amp; strInstance &amp; &quot;)&quot;
		Exit For
	End If 

	On Error Goto 0
	
	intNum = CInt(strNumerator) 
	intDen = CInt(StrDenominator) 
	result = intNum/IntDen 
	if result &gt; 1 then 
		result = 1 
	End If 
	WScript.echo result &amp; GetMSSQLSensorInstanceStr(strInstance)
Next

&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: sql/mssql_connection_utils.vbs

&#039; Common constants for MSSQL lookups
Const AD_OPEN_STATIC = 3 
Const AD_LOCK_OPTIMISTIC = 3  


Function GetMSSQLInstances()
    Dim dictResult, objWMIService, colServices, objService
    Dim strCaption, strInstance, intStartIndex, intStopIndex
    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)

    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)  
    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  
    For Each objService In colServices
        strCaption = objService.Caption
    
        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    
            &#039; OK -- found SQL Server on this machien, now we need to find the instance name
            &#039; if this is the correct service
            strInstance = &quot;.&quot;
            intStartIndex = InStr(strCaption, &quot;(&quot;)
            intStopIndex = InStr(strCaption, &quot;)&quot;)
            
            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then 
                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)
                    
                If strInstance = &quot;MSSQLSERVER&quot; Then 
                    strInstance = &quot;.&quot;
                End If 

                If Not dictResult.Exists(strInstance) Then
                    dictResult.Add strInstance, True
                End if
            End If             
        End If  
    Next  
    
    Set GetMSSQLInstances = dictResult

End Function &#039; GetMSSQLInstances

Function GenMSSQLConnectionStr(strInstance, strCatalog) 
    Dim strDataSource, strConnection

    If strInstance = &quot;.&quot; Then 
        strDataSource = strInstance
    Else 
        strDataSource = &quot;.\&quot; &amp; strInstance
    End If 

    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;

    GenMSSQLConnectionStr = strConnection
End Function &#039; OpenMSSQLConnection

Function GetMSSQLSensorInstanceStr(strInstance)
    If strInstance = &quot;.&quot; Then
        GetMSSQLSensorInstanceStr = &quot;&quot;
    Else
        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;
    End If
End Function &#039; GetMSSQLSensorInstanceStr
&#039;- End file: sql/mssql_connection_utils.vbs",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
370,Network,2015-01-05T20:22:05,|,"Returns IPv4 network routes, filtered to exclude noise. With Flags, Metric, Interface columns.
Example:  172.16.0.0|192.168.1.1|255.255.0.0|UG|100|eth0",1,435227963,0,737,1,Jim Olsen,60,0,defined,Tanium,2015-01-05T20:22:05,IP Route Details,,,,,,,,,Windows,"strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)

Set collip = objWMIService.ExecQuery(&quot;select * from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;&quot;)
dim ipaddrs()
ipcount = 0
for each ipItem in collip
    for each ipaddr in ipItem.IPAddress
        ipcount = ipcount + 1
    next
next
redim ipaddrs(ipcount)
ipcount = 0
for each ipItem in collip
    for each ipaddr in ipItem.IPAddress
        ipcount = ipcount + 1
        ipaddrs(ipcount) = ipaddr
    next
next
localhost = &quot;127.0.0.1&quot;

Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_IP4RouteTable&quot;)

For Each objItem in colItems
    dest = objItem.Destination
    gw = objItem.NextHop
    mask = objItem.Mask
    metric = objItem.Metric1
    flags = objItem.Type
    intf = objItem.InterfaceIndex
    For i = 0 to ipcount
        if gw = ipaddrs(i) and gw &lt;&gt; localhost then
            gw = &quot;0.0.0.0&quot;
        end if
    Next
    if gw &lt;&gt; localhost and dest &lt;&gt; &quot;224.0.0.0&quot; and right(dest,3) &lt;&gt; &quot;255&quot; then
        Wscript.Echo dest &amp; &quot;|&quot; &amp; gw &amp; &quot;|&quot; &amp; mask &amp; &quot;|&quot; &amp; &quot;-&quot; &amp; &quot;|&quot; &amp; metric &amp; &quot;|&quot; &amp; &quot;-&quot;
    end if
Next",VBScript,Linux,"route -n | grep -v Kernel | grep -v Destination | awk &#039;{ print $1 &quot;|&quot; $2 &quot;|&quot; $3 &quot;|&quot; $4 &quot;|&quot; $5 &quot;|&quot; $8 }&#039; | grep -v &quot;|127.0.0.1|&quot;
",UnixShell,Mac,"netstat -rn | grep -v &quot;:&quot; | grep -v Destination | grep -v Routing | grep -v -e &quot;^$&quot; | awk &#039;{ print $1 &quot;|&quot; $2 &quot;||&quot; $3 &quot;||&quot; $6 }&#039; | grep -v &quot;|127.0.0.1|&quot;
",UnixShell,0,52,0,1,0,Destination,IPAddress,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Gateway,IPAddress,0,1,2,Mask,String,0,1,3,Flags,String,0,1,4,Metric,NumericInteger,0,1,5,Interface,String,,,,,,,,,,,,,,,,,,,,,String
371,Active Directory,2015-01-05T20:22:05,",","The Active Directory domain name (if any) that the computer is joined to.
Example: intra.company.com",1,462732724,0,739,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,AD Domain,,,,,,,,,Windows,select Domain from win32_ComputerSystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
372,Network,2015-01-05T20:22:05,|,"Returns IPv4 network routes, filtered to exclude noise.
Example:  172.16.0.0|192.168.1.1|255.255.0.0",1,487354270,0,741,1,Jim Olsen,60,0,defined,Tanium,2015-01-05T20:22:05,IP Routes,,,,,,,,,Windows,"strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)

&#039;Build list of local IP addresses
&#039;For identifying locally connected networks
&#039;(which show local IP address as gateway)
Set collip = objWMIService.ExecQuery(&quot;select * from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;&quot;)
dim ipaddrs()
ipcount = 0
for each ipItem in collip
    for each ipaddr in ipItem.IPAddress
        ipcount = ipcount + 1
    next
next
redim ipaddrs(ipcount)
ipcount = 0
for each ipItem in collip
    for each ipaddr in ipItem.IPAddress
        ipcount = ipcount + 1
        ipaddrs(ipcount) = ipaddr
    next
next
localhost = &quot;127.0.0.1&quot;

Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_IP4RouteTable&quot;)

For Each objItem in colItems
    dest = objItem.Destination
    gw = objItem.NextHop
    mask = objItem.Mask
    For i = 0 to ipcount
        if gw = ipaddrs(i) and gw &lt;&gt; localhost then
            &#039;Show single gateway for local networks
            &#039;to allow proper clustering
            gw = &quot;0.0.0.0&quot;
        end if
    Next
    if gw &lt;&gt; localhost and dest &lt;&gt; &quot;224.0.0.0&quot; and right(dest,3) &lt;&gt; &quot;255&quot; then
        &#039;Exclude local, multicast and broadcast
        Wscript.Echo dest &amp; &quot;|&quot; &amp; gw &amp; &quot;|&quot; &amp; mask
    end if
Next",VBScript,Linux,"route -n | grep -v Kernel | grep -v Destination | awk &#039;{ print $1 &quot;|&quot; $2 &quot;|&quot; $3 }&#039; | grep -v &quot;|127.0.0.1|&quot;
",UnixShell,Mac,"netstat -rn | grep -v &quot;:&quot; | grep -v Destination | grep -v Routing | grep -v -e &quot;^$&quot; | awk &#039;{ print $1 &quot;|&quot; $2 &quot;|&quot; &quot;-&quot; }&#039; | grep -v &quot;|127.0.0.1|&quot;
",UnixShell,0,0,0,1,0,Destination,IPAddress,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Gateway,IPAddress,0,1,2,Subnet Mask,IPAddress,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
373,Windows Event Logs,2015-01-05T20:22:05,",","Recent event codes from the application event logs in Windows.
Example: 1001",1,502812713,0,743,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Application Event Log IDs,,,,,,,,,Windows,select EventCode from Win32_NTLogEvent where LogFile = &#039;Application&#039;  and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039;,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
374,Hardware,2015-01-05T20:22:05,",","The amount of used disk space per partition.
Example: C: 40 GB",1,508127351,0,745,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Disk Used Space,,,,,,,,,Windows,"&#039;========================================
&#039; Disk Used Space
&#039;========================================

strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:&quot; _
    &amp; &quot;{impersonationLevel=impersonate}!\\&quot; _
    &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colDisks = objWMIService.ExecQuery _
    (&quot;Select * from Win32_LogicalDisk&quot;)
For Each objDisk in colDisks
 &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID
    
    If Not IsNull(objDisk.Size) And Not IsNull(objDisk.FreeSpace) Then
	    dblSize = CDbl(objDisk.Size) - CDbl(objDisk.FreeSpace)
	    dblSize = dblSize / 1024 / 1024 / 1024
	    intSize = CInt(dblSize)
		WScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intSize &amp; &quot; GB&quot;
    End If
Next",VBScript,Linux,"#!/bin/bash
df -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line
do
	set -- $line
	echo $7: $4
done
",UnixShell,Mac,"#!/bin/bash
df -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\// { print $9&quot;: &quot; $3 }&#039;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
375,Security,2015-01-05T20:22:05,",","A list of all shared folders and the permissions currently enabled for those folders.
Example: Downloads, BUILTIN\Administrators-FULL | \CREATOR OWNER-FULL | NT AUTHORITY\SYSTEM-FULL",1,542266296,0,747,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Share Folder Permissions,,,,,,,,,Windows,"&#039;========================================
&#039; Share Folder Permissions
&#039;========================================

&#039;Script will return permissions on each enabled share

strComputer = &quot;.&quot;
Set objWMI = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMI.ExecQuery(&quot;Select * from win32_share&quot;)

For Each i In colItems
strDir = i.path
strName = i.name
result = Trim (Replace(CollectAceInfo(strDir),&quot;|&quot;,&quot;&quot;, 1 , 1))
wscript.echo strName &amp; &quot;,&quot; &amp; result
Next

Function CollectAceInfo(strDir)
Dim ArrayStrAce()
i=0 
strDir = Replace(strDir,&quot;\&quot;,&quot;\\&quot;)
Set colItems = objWMI.ExecQuery(&quot;Select * from win32_logicalFileSecuritySetting WHERE Path=&#039;&quot; &amp; strDir &amp; &quot;&#039;&quot;,,48)
	for each objItem in colItems
		If objItem.GetSecurityDescriptor(wmiSecurityDescriptor) Then
		CollectAceInfo = &quot;GetSecurityDescriptor failed&quot;
		DisplayFileSecurity = False
		Exit Function
		End if

For each wmiAce in wmiSecurityDescriptor.DACL
strACE = wmiAce.Trustee.Domain &amp; &quot;\&quot; &amp; wmiAce.Trustee.Name
strAceMask = wmiAce.AccessMask

strMask = GetMaskValue(strAceMask)
If strMask &lt;&gt; &quot;1&quot; then
i = i + 1
ReDim Preserve ArrayStrAce(i)
ArrayStrAce(i) = strAce &amp; &quot;-&quot; &amp; strMask
CollectAceInfo = Join(ArrayStrAce,&quot; | &quot;)
end if
next
next
End Function

Function GetMaskValue(StrAceMask)
&#039;Dim MaskArray()
Select Case StrAceMask
Case &quot;1179817&quot;
	GetMaskValue = &quot;READ&quot;
Case &quot;1245631&quot;
	GetMaskValue = &quot;CHANGE&quot;
Case &quot;2032127&quot;
	GetMaskValue = &quot;FULL&quot;
Case Else
	GetMaskValue = &quot;1&quot;
End Select

&#039;i=0
&#039;If StrAceMask AND 16 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Write extended attributes&quot;
&#039;End If
&#039;if StrAceMask AND 1048576 Then
&#039;	i=i + 1
&#039;    ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Synchronize&quot;
&#039;End If
&#039;If StrAceMask AND 524288 Then
&#039;    i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Write owner&quot;
&#039;End If
&#039;If StrAceMask AND 262144 Then
&#039;	i=i + 1
&#039;   ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Write ACL&quot;
&#039;End If
&#039;If StrAceMask AND 131072 Then
&#039;	i=i + 1
&#039;    ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Read security&quot;
&#039;End If
&#039;If StrAceMask AND 65536 Then
&#039;    i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Delete&quot;
&#039;End If
&#039;If StrAceMask AND 256 Then
&#039;    i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Write attributes&quot;
&#039;End If
&#039;If StrAceMask AND 128 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;    MaskArray(i) =  &quot;Read attributes&quot;
&#039;End If
&#039;If StrAceMask AND 64 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;    MaskArray(i) =  &quot;Delete dir&quot;
&#039;End If
&#039;If StrAceMask AND 32 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;    MaskArray(i) =  &quot;Execute&quot;
&#039;End If
&#039;If StrAceMask AND 16 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;    MaskArray(i) =  &quot;Write extended attributes&quot;
&#039;End If
&#039;If StrAceMask AND 8 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;   MaskArray(i) =  &quot;Read extended attributes&quot;
&#039;End If
&#039;If StrAceMask AND 4 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;    MaskArray(i) =  &quot;Append&quot;
&#039;End If
&#039;If StrAceMask AND 2 Then
&#039;    i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;	MaskArray(i) =  &quot;Write&quot;
&#039;End If
&#039;If StrAceMask AND 1 Then
&#039;	i=i + 1
&#039;	ReDim Preserve MaskArray(i)
&#039;    MaskArray(i) =  &quot;Read&quot;
&#039;End If
&#039;GetMaskValue = Join(MaskArray,&quot; : &quot;)
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Share,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Permissions,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
376,Operating System,2015-01-05T20:22:05,|,"Returns the OS language along with any Language Packs installed.
Example: English-United States en-US",1,549503533,0,749,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Operating System Language,,,,,,,,,Windows,"&#039;========================================
&#039; Operating System Language
&#039;========================================

&#039; This sensor will output the language of the installed OS along with
&#039; any language packs installed.
&#039; it is a multi-column sensor that looks like:
&#039; OS Language | Language Packs Installed

Option Explicit

Dim strSep
strSep = &quot;|&quot;

WScript.Echo GetOSLanguage(strSep)

&#039;-----------End Main-------------&#039;
Function GetOSLanguage(strSep)
&#039; Retrieves the OS language and whether there are any MUI packs installed.
&#039; Will only retrieve MUI packs on Vista+

	Const HKLM = &amp;H80000002
	
	Dim strComputer
	Dim strWMILanguageCode, arrLangKeys, strLangKey
	Dim strLanguagesRegPath1, strLanguagesRegPath2
	Dim strLanguagePacksInstalled
	Dim objRegistry, objWMIService, objOperatingSystem
	Dim colOperatingSystems

	
	strComputer = &quot;.&quot;

	Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
	&amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;) 
	Set colOperatingSystems = objWMIService.ExecQuery _ 
		(&quot;Select * from Win32_OperatingSystem&quot;) 
	For Each objOperatingSystem in colOperatingSystems 	
		strWMILanguageCode = objOperatingSystem.OSLanguage
	Next
			
	Set objRegistry = _
		GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; _ 
		&amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
	
	strLanguagePacksInstalled = &quot;&quot;
	strLanguagesRegPath1 = &quot;SYSTEM\CurrentControlSet\Control\MUI\UILanguages&quot;
	strLanguagesRegPath2 = &quot;SYSTEM\CurrentControlSet\Control\Nls\MUILanguages&quot;	
	
	&#039; This works on newer OS&#039;s
	objRegistry.EnumKey HKLM, strLanguagesRegPath1, arrLangKeys
	If Not IsNull(arrLangKeys) Then
		For Each strLangKey In arrLangKeys
			If strLanguagePacksInstalled = &quot;&quot; Then
				strLanguagePacksInstalled = strLangKey
			Else
				strLanguagePacksInstalled = strLanguagePacksInstalled &amp; &quot;,&quot; &amp; strLangKey
			End If
		Next
	End If
	
	If strLanguagePacksInstalled = &quot;&quot; Then strLanguagePacksInstalled = &quot;XP or Earlier OS&quot;
	
	GetOSLanguage = LocaleCodeToLanguage(strWMILanguageCode) &amp; strSep &amp; strLanguagePacksInstalled
	
	&#039; need to : cleanup
	&#039; map language codes to readable english
	&#039;Cleanup

	Set objRegistry = Nothing		
End Function &#039;GetOSLanguage

Function LocaleCodeToLanguage(strCode)
&#039; This function takes an numeric locale code and returns
&#039; a readable language mapping

	Dim arrLangCodes, i

	arrLangCodes = array(&quot;1078&quot;,&quot;Afrikaans&quot;,&quot;1052&quot;,&quot;Albanian&quot;,&quot;14337&quot;,&quot;Arabic - United Arab Emirates&quot;,&quot;15361&quot;,&quot;Arabic - Bahrain&quot;,&quot;5121&quot;,&quot;Arabic - Algeria&quot;,&quot;3073&quot;,_
	&quot;Arabic - Egypt&quot;,&quot;2049&quot;,&quot;Arabic - Iraq&quot;,&quot;11265&quot;,&quot;Arabic - Jordan&quot;,&quot;13313&quot;,&quot;Arabic - Kuwait&quot;,&quot;12289&quot;,&quot;Arabic - Lebanon&quot;,&quot;4097&quot;,&quot;Arabic - Libya&quot;,&quot;6145&quot;,_
	&quot;Arabic - Morocco&quot;,&quot;8193&quot;,&quot;Arabic - Oman&quot;,&quot;16385&quot;,&quot;Arabic - Qatar&quot;,&quot;1025&quot;,&quot;Arabic - Saudi Arabia&quot;,&quot;10241&quot;,&quot;Arabic - Syria&quot;,&quot;7169&quot;,&quot;Arabic - Tunisia&quot;,&quot;9217&quot;,_
	&quot;Arabic - Yemen&quot;,&quot;1067&quot;,&quot;Armenian&quot;,&quot;1068&quot;,&quot;Azeri - Latin&quot;,&quot;2092&quot;,&quot;Azeri - Cyrillic&quot;,&quot;1069&quot;,&quot;Basque&quot;,&quot;1059&quot;,&quot;Belarusian&quot;,&quot;1026&quot;,&quot;Bulgarian&quot;,&quot;1027&quot;,&quot;Catalan&quot;,&quot;2052&quot;,_
	&quot;Chinese - China&quot;,&quot;3076&quot;,&quot;Chinese - Hong Kong S.A.R.&quot;,&quot;5124&quot;,&quot;Chinese - Macau S.A.R&quot;,&quot;4100&quot;,&quot;Chinese - Singapore&quot;,&quot;1028&quot;,&quot;Chinese - Taiwan&quot;,&quot;1050&quot;,&quot;Croatian&quot;,&quot;1029&quot;,_
	&quot;Czech&quot;,&quot;1030&quot;,&quot;Danish&quot;,&quot;1043&quot;,&quot;Dutch - The Netherlands&quot;,&quot;2067&quot;,&quot;Dutch - Belgium&quot;,&quot;3081&quot;,&quot;English - Australia&quot;,&quot;10249&quot;,&quot;English - Belize&quot;,&quot;4105&quot;,&quot;English - Canada&quot;,&quot;9225&quot;,_
	&quot;English - Carribbean&quot;,&quot;6153&quot;,&quot;English - Ireland&quot;,&quot;8201&quot;,&quot;English - Jamaica&quot;,&quot;5129&quot;,&quot;English - New Zealand&quot;,&quot;13321&quot;,&quot;English - Phillippines&quot;,&quot;7177&quot;,_
	&quot;English - South Africa&quot;,&quot;11273&quot;,&quot;English - Trinidad&quot;,&quot;2057&quot;,&quot;English - United Kingdom&quot;,&quot;1033&quot;,&quot;English - United States&quot;,&quot;1061&quot;,&quot;Estonian&quot;,&quot;1065&quot;,&quot;Farsi&quot;,&quot;1035&quot;,_
	&quot;Finnish&quot;,&quot;1080&quot;,&quot;Faroese&quot;,&quot;1036&quot;,&quot;French - France&quot;,&quot;2060&quot;,&quot;French - Belgium&quot;,&quot;3084&quot;,&quot;French - Canada&quot;,&quot;5132&quot;,&quot;French - Luxembourg&quot;,&quot;4108&quot;,&quot;French - Switzerland&quot;,&quot;2108&quot;,_
	&quot;Gaelic - Ireland&quot;,&quot;1084&quot;,&quot;Gaelic - Scotland&quot;,&quot;1031&quot;,&quot;German - Germany&quot;,&quot;3079&quot;,&quot;German - Austria&quot;,&quot;5127&quot;,&quot;German - Liechtenstein&quot;,&quot;4103&quot;,&quot;German - Luxembourg&quot;,&quot;2055&quot;,_
	&quot;German - Switzerland&quot;,&quot;1032&quot;,&quot;Greek&quot;,&quot;1037&quot;,&quot;Hebrew&quot;,&quot;1081&quot;,&quot;Hindi&quot;,&quot;1038&quot;,&quot;Hungarian&quot;,&quot;1039&quot;,&quot;Icelandic&quot;,&quot;1057&quot;,&quot;Indonesian&quot;,&quot;1040&quot;,&quot;Italian - Italy&quot;,&quot;2064&quot;,_
	&quot;Italian - Switzerland&quot;,&quot;1041&quot;,&quot;Japanese&quot;,&quot;1042&quot;,&quot;Korean&quot;,&quot;1062&quot;,&quot;Latvian&quot;,&quot;1063&quot;,&quot;Lithuanian&quot;,&quot;1071&quot;,&quot;FYRO Macedonian&quot;,&quot;1086&quot;,&quot;Malay - Malaysia&quot;,&quot;2110&quot;,_
	&quot;Malay - Brunei&quot;,&quot;1082&quot;,&quot;Maltese&quot;,&quot;1102&quot;,&quot;Marathi&quot;,&quot;1044&quot;,&quot;Norwegian - Bokm-l&quot;,&quot;2068&quot;,&quot;Norwegian - Nynorsk&quot;,&quot;1045&quot;,&quot;Polish&quot;,&quot;2070&quot;,&quot;Portuguese - Portugal&quot;,&quot;1046&quot;,_
	&quot;Portuguese - Brazil&quot;,&quot;1047&quot;,&quot;Raeto-Romance&quot;,&quot;1048&quot;,&quot;Romanian - Romania&quot;,&quot;2072&quot;,&quot;Romanian - Moldova&quot;,&quot;1049&quot;,&quot;Russian&quot;,&quot;2073&quot;,&quot;Russian - Moldova&quot;,&quot;1103&quot;,&quot;Sanskrit&quot;,&quot;3098&quot;,_
	&quot;Serbian - Cyrillic&quot;,&quot;2074&quot;,&quot;Serbian - Latin&quot;,&quot;1074&quot;,&quot;Setsuana&quot;,&quot;1060&quot;,&quot;Slovenian&quot;,&quot;1051&quot;,&quot;Slovak&quot;,&quot;1070&quot;,&quot;Sorbian&quot;,&quot;1034&quot;,&quot;Spanish - Spain&quot;,&quot;11274&quot;,_
	&quot;Spanish - Argentina&quot;,&quot;16394&quot;,&quot;Spanish - Bolivia&quot;,&quot;13322&quot;,&quot;Spanish - Chile&quot;,&quot;9226&quot;,&quot;Spanish - Colombia&quot;,&quot;5130&quot;,&quot;Spanish - Costa Rica&quot;,&quot;7178&quot;,_
	&quot;Spanish - Dominican Republic&quot;,&quot;12298&quot;,&quot;Spanish - Ecuador&quot;,&quot;4106&quot;,&quot;Spanish - Guatemala&quot;,&quot;18442&quot;,&quot;Spanish - Honduras&quot;,&quot;2058&quot;,&quot;Spanish - Mexico&quot;,&quot;19466&quot;,_
	&quot;Spanish - Nicaragua&quot;,&quot;6154&quot;,&quot;Spanish - Panama&quot;,&quot;10250&quot;,&quot;Spanish - Peru&quot;,&quot;20490&quot;,&quot;Spanish - Puerto Rico&quot;,&quot;15370&quot;,&quot;Spanish - Paraguay&quot;,&quot;17418&quot;,&quot;Spanish - El Salvador&quot;,&quot;14346&quot;,_
	&quot;Spanish - Uruguay&quot;,&quot;8202&quot;,&quot;Spanish - Venezuela&quot;,&quot;1072&quot;,&quot;Sutu&quot;,&quot;1089&quot;,&quot;Swahili&quot;,&quot;1053&quot;,&quot;Swedish - Sweden&quot;,&quot;2077&quot;,&quot;Swedish - Finland&quot;,&quot;1097&quot;,&quot;Tamil&quot;,&quot;1092&quot;,&quot;Tatar&quot;,&quot;1054&quot;,_
	&quot;Thai&quot;,&quot;1055&quot;,&quot;Turkish&quot;,&quot;1073&quot;,&quot;Tsonga&quot;,&quot;1058&quot;,&quot;Ukrainian&quot;,&quot;1056&quot;,&quot;Urdu&quot;,&quot;2115&quot;,&quot;Uzbek - Cyrillic&quot;,&quot;1091&quot;,&quot;Uzbek - Latin&quot;,&quot;1066&quot;,&quot;Vietnamese&quot;,&quot;1076&quot;,&quot;Xhosa&quot;,&quot;1085&quot;,&quot;Yiddish&quot;,&quot;1077&quot;,&quot;Zulu&quot;)

	For i = 0 To UBound(arrLangCodes)
		If CStr(arrLangCodes(i)) = CStr(strCode) Then
			&#039;Return the value immediately after the found code
			LocaleCodeToLanguage = arrLangCodes(i+1)
		End If	
	Next
End Function &#039;LocaleCodeToLanguage",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,OS Language,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Language Packs Installed,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
377,Miscellaneous,2015-01-05T20:22:05,",","Returns the number of fixed drives installed in the system.
Example:4",1,590837956,0,751,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Number of Fixed Drives,,,,,,,,,Windows,"&#039;========================================
&#039; Number of Fixed Drives
&#039;========================================

&#039; This sensor will output the number of fixed disk drives

Option Explicit

WScript.Echo GetNumberOfFixedDrives

Function GetNumberOfFixedDrives
	
	Dim objWMIService, colDiskDrives
	Dim strComputer, objDiskDrive, intDriveCount

	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
		&amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;) 

	&#039;SlotDesignation is like &quot;PCI-I&quot; and CurrentUsage=4 means occupied
	Set colDiskDrives = objWMIService.ExecQuery _ 
		(&quot;Select MediaType from Win32_DiskDrive&quot;) 
	If Not IsNull(colDiskDrives) Then
		intDriveCount = 0
		For Each objDiskDrive In colDiskDrives	
			If InStr(LCase(objDiskDrive.MediaType), &quot;fixed&quot; ) &gt; 0 Then	
				intDriveCount = intDriveCount + 1
			End If
		Next
		GetNumberOfFixedDrives = intDriveCount
	Else
		GetNumberOfFixedDrives = &quot;WMI Error&quot;
	End If
	
	&#039;Cleanup
	Set colDiskDrives = Nothing
	Set objWMIService = Nothing
End Function &#039;GetNumberOfFixedDrives",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
378,Operating System,2015-01-05T20:22:05,|,"A multi-column sensor that lists every running process and the amount of CPU usage they are taking up.
Example: svchost | 15",1,600562575,0,753,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,CPU by Process,,,,,,,,,Windows,"&#039;========================================
&#039; CPU by Process
&#039;========================================

&#039; a multi-column sensor whose output looks like:
&#039; Process Name | Percentage

Option Explicit

Dim objWMIService,colItems
Dim objItem,strSep,strName,intPoundPos

Set objWMIService = GetObject(&quot;winmgmts:\\.\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_PerfProc_Process&quot;,,48)

strSep = &quot;|&quot;

For Each objItem in colItems

	strName = LCase(objItem.Name)
	intPoundPos = InStr(strName,&quot;#&quot;)
	If intPoundPos &gt; 0 Then
		&#039; if it&#039;s a duplicate process, the name may put a #x after it
		&#039; as in 
		&#039; chome#9
		&#039; Remove everything after a #
		strName = Left(strName,intPoundPos - 1)
	End If
	&#039; ignore _Total Entry or Idle Entry
	If Not (strName = &quot;_total&quot; Or strName = &quot;idle&quot; Or strName = &quot;taniumclient&quot;)  Then
		WScript.Echo strName &amp; strSep &amp; objItem.PercentProcessorTime
	End If
Next

&#039;Cleanup
Set objWMIService = Nothing
Set colItems = Nothing",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,CPU %,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
379,Network,2015-01-05T20:22:05,",","Returns the ports which are listening on a local machine and the IP address the port is bound to.  0.0.0.0 indicates that the port is bound to all IP addresses.
Example: 0.0.0.0:80",1,601571508,0,755,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Open Port,,,,,,,,,Windows,"&#039;========================================
&#039; Open Port
&#039;========================================

port = &quot;*&quot;

If port = &quot;*&quot; Then
   strcommand = &quot;cmd /c netstat -an | find &quot; &amp; chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34)
Else 
   strcommand = &quot;cmd /c netstat -an | find &quot; &amp; chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34) &amp; _
        &quot;| find &quot; &amp; chr(34) &amp; &quot;:&quot; &amp; port &amp; &quot; &quot; &amp; Chr(34)
End If

Dim bHasOutput : bHasOutput = False

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strPingResults = LCase(objScriptExec.StdOut.ReadAll)

results = Split(strPingResults, vbCrLf)
for Each line in results
    &#039;WScript.Echo &quot;parsing line: &quot; &amp; line
    
    line = cleanWhitespace(Trim(line))
    
    lineResults = Split(line)
    i = 0
    For Each word In lineResults
    &#039;   WScript.Echo &quot;    word &quot;&amp;i&amp; &quot;: &quot; &amp; word
       If i = 1 Then
          WScript.Echo word
          bHasOutput = True
       End If
       i = i + 1
    Next
next

If Not bHasOutput Then
	If GetLocale() &lt;&gt; 1033 Then
		WScript.Echo &quot;English Language OS Required&quot;
	End If
End If

&#039;if len (strPingResults) &gt; 0 then
&#039; WScript.Echo strPingResults
&#039;WScript.Echo &quot;results: &quot; &amp; strPingResults
&#039;End If

Function cleanWhitespace(strStarter)
   intStarter = Len(strStarter)
   For i = intStarter to 2 Step -1
       strChars = Space(i)
       strStarter = Replace(strStarter, strChars, &quot; &quot;)
   Next
   cleanWhitespace = strStarter
End Function",VBScript,Linux,"#!/bin/bash
netstat -tulpn | grep &quot;LISTEN&quot; | grep &quot;0.0.0.0&quot; | grep &quot;tcp&quot; |while read line
do
 set -- $line
	echo $4
done
",UnixShell,Mac,"#!/bin/bash
netstat -a | grep tcp4 | grep LISTEN |while read line
do
 set -- $line
	echo $4
done
",UnixShell,0,50,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
380,File System,2015-01-05T20:22:05,",","Returns the size of the file specified by the parameter.
Example: 69120",1,63201224,0,757,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,File Size,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the full drive letter, folder path and file name of the file."",""value"":"""",""promptText"":""e.g. c:\\windows\\test.txt"",""defaultValue"":"""",""label"":""File name to search for"",""maxChars"":0,""key"":""filename"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; File Size
&#039;========================================

Dim filesys, filename, file, createdate 

filename = unescape(&quot;||filename||&quot;)

filename = FixFileSystemRedirectionForPath(filename)

Set filesys = CreateObject(&quot;Scripting.FileSystemObject&quot;)

If filesys.FileExists(filename) Then
   Set file = filesys.GetFile(filename)
   WScript.Echo file.Size   
Else
   WScript.Echo &quot;File &quot; &amp; filename &amp; &quot; not found.&quot;
End If


Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
    
    Dim objFSO, strSystem32Location,objShell
    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
    
    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
        If InStr(strFilePath,strSystem32Location) = 1 Then
            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
            strFilePath = strNewSystem32Location&amp;strRestOfPath
        End If
    End If
    FixFileSystemRedirectionForPath = strFilePath
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

    Dim objFSO,strSystem32Location,strNewSystem32Location
    
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    
    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
    
    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\windows\test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||filename||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
381,File System,2015-01-05T20:22:05,",","Folder size (in GB, MB, KB, or B)
Example: 62 GB",1,632662206,0,759,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Folder Size,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the full drive letter and folder path of the folder"",""value"":"""",""promptText"":""e.g. c:\\Program Files\\MyApp"",""defaultValue"":"""",""label"":""Folder path to search for"",""maxChars"":0,""key"":""strFolder"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Folder Size
&#039;========================================

&#039; TAG: REDIRECTION

Dim strFolder
strFolder = unescape(&quot;||strFolder||&quot;)

strFolder = FixFileSystemRedirectionForPath(strFolder)

Dim intRound
intRound = 0

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

Dim objFolder

If fso.FolderExists(strFolder) Then
	intSize = GetFolderSize(strFolder)
	
	intKB = 1024
	intMB = 1024*1024
	intGB = 1024*1024*1024
	
	If intSize &gt; intGB Then
		WScript.Echo Int(intSize / intGB) &amp; &quot; GB&quot;
	ElseIf intSize &gt; intMB Then
		WScript.Echo Int(intSize / intMB) &amp; &quot; MB&quot;
	ElseIf intSize &gt; intKB Then
		WScript.Echo Int(intSize / intKB) &amp; &quot; KB&quot;
	Else
		WScript.Echo intSize &amp; &quot; B&quot;
	End If
Else
	WScript.Echo &quot;Folder not found&quot;
End If

Function GetFolderSize(folderName)
	&#039; Some directories have files which are never accessible.  
	&#039; This allows retrieving the values for those type of directories
    On Error Resume Next

    Dim fso, folder, subfolder, size, hasSubfolders

	Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

    size = 0
    hasSubfolders = False

    Set folder = fso.GetFolder(folderName)
    &#039; Try the non-recursive way first (potentially faster?)
    Err.Clear
    size = folder.Size
    If Err.Number &lt;&gt; 0 then     &#039; Did not work; do recursive way:
        For Each subfolder in folder.SubFolders
            size = size + getFolderSize(subfolder.Path)
            hasSubfolders = True
        Next

        If not hasSubfolders then
            size = folder.Size
        End If
    End If

	On Error Goto 0
    GetFolderSize = size
End Function

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
    
    Dim objFSO, strSystem32Location,objShell
    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
    
    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
        If InStr(strFilePath,strSystem32Location) = 1 Then
            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
            strFilePath = strNewSystem32Location&amp;strRestOfPath
        End If
    End If
    FixFileSystemRedirectionForPath = strFilePath
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

    Dim objFSO,strSystem32Location,strNewSystem32Location
    
    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
    
    strFilePath = LCase(strFilePath)
    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
    
    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
    
    &#039;Cleanup
    Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strFolder&quot;,&quot;promptText&quot;:&quot;e.g. c:\Program Files\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strFolder||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strFolder&quot;,&quot;promptText&quot;:&quot;e.g. c:\Program Files\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||strFolder||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
382,Applications,2015-01-05T20:22:05,",","Shows applications that are currently running and how long they have been running for.
Example: Dropbox - 3 days",1,664237249,0,761,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Application Run Time,,,,,,,,,Windows,"&#039;========================================
&#039; Application Run Time
&#039;========================================

&#039;On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select Name, ExecutablePath, CreationDate from Win32_Process&quot;,,48)

&#039;Uses date math - set locale

SetLocale(1033)

Dim nameDictionary, processDictionary
Set nameDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)
Set processDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039;ADD PROCESS NAME IN LOWER CASE
nameDictionary.Add &quot;hppusg.exe&quot;, &quot;Some HP Application&quot;
nameDictionary.Add &quot;taniumclient.exe&quot;, &quot;TANIUM CLIENT&quot;

&#039;array used to print output (no dictionary since we need duplicates)
Dim arrOutput()
intSize = 0
ReDim Preserve arrOutput(intSize)

strComputer = &quot;.&quot;
Const HKLM = &amp;h80000002
Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)

regPath = GetTaniumRegistryPath() &amp; &quot;\Sensor Data\Applications&quot;
If Not RegKeyExists(reg, HKLM, regPath) Then
	reg.createKey HKLM, regPath
End If

For Each objItem in colItems
	If InStr(LCase(objItem.ExecutablePath), &quot;windows\system32\&quot;) = 0 Then
	    Dim fso
	    Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
	    If fso.FileExists(objItem.ExecutablePath) Then
    		Dim strOutput, fullName

	    	Set execFile = fso.GetFile(objItem.ExecutablePath)
	    	
   			fullName = nameDictionary.Item(LCase(objItem.Name))

			If IsEmpty(fullName) Then
	    		fullName = GetProcName(objItem.Name, reg, HKLM, regPath)
    		End If
    					
    		If fullName = &quot;&quot; Then
    			fullName = objItem.Name
    		End If

&#039;			If InStr(LCase(fullName), LCase(appName)) &gt; 0 Then
			lastStart = GetLastStart(objItem.Name, reg, HKLM, regPath)
			If lastStart &lt;&gt; &quot;&quot; Then				
	   			strOutput = fullName &amp; &quot; - &quot; &amp; GetDaysOld(lastStart)
	   		Else
	   			strOutput = fullName &amp; &quot; - Launch date unknown&quot;	
			End If

 			If not ArrayContains(arrOutput, strOutput) Then
				arrOutput(intSize) = strOutput
				intSize = intSize + 1
				ReDim Preserve arrOutput(intSize)
			End If
	    End If
	End If
Next

For Each output In arrOutput 
	If Not IsEmpty(output) Then
		WScript.Echo output
	End If
Next

Function GetLastStart(strProc, objReg, hive, baseRegKey) 
	words = Split(strProc, &quot;.&quot;)	
	regKey = baseRegKey &amp; &quot;\&quot; &amp; words(0)
	If RegKeyExists(objReg, hive, regKey) Then
		objReg.GetStringValue hive, regKey, &quot;Last Start&quot;, GetLastStart
	End If
End Function

Function GetProcName(strProc, objReg, hive, baseRegKey) 
	words = Split(strProc, &quot;.&quot;)	
	regKey = baseRegKey &amp; &quot;\&quot; &amp; words(0)
	If RegKeyExists(objReg, hive, regKey) Then
		objReg.GetStringValue hive, regKey, &quot;Description&quot;, GetProcName
	End If
End Function

Function ArrayContains(arr, str)
	For Each obj In arr 
		If obj = str Then
			ArrayContains = True
			Exit Function
		End If
	Next
	ArrayContains = False
End Function

&#039;date format is MM/DD/YYYY
function GetDaysOld(strDate)
	patternDate = CDate( strDate )
	today = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))
	days = DateDiff(&quot;d&quot;, patternDate, today)
	
	If days = 1 Then
		GetDaysOld = &quot;1 day&quot;
	Else 
		GetDaysOld = days &amp; &quot; days&quot;
	End If
End Function

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
383,Applications,2015-01-05T20:22:05,",","Returns a list of installed RPMs by name on Linux systems.
Example: glibc-2.5-12",1,676468157,0,763,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Installed RPMs,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/sh
rpm -qa
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
384,McAfee,2015-01-05T20:22:05,",","Returns whether McAfee Endpoint Encryption is Activated
Example: Yes",1,732965965,0,765,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,McAfee Endpoint Encryption Activated,,,,,,,,,Windows,"&#039;========================================
&#039; McAfee Endpoint Encryption Activated
&#039;========================================

&#039; This sensor will return whether McAfee Endpoint Encryption is Activated
&#039; This is a Yes or No Value

Option Explicit

Dim objRegistry,keyPath,key64Path,strSep
strSep = &quot;|&quot; &#039; column delimiter

Set objRegistry = Getx64RegistryProvider()

Const HKLM = &amp;H80000002

keyPath = &quot;SOFTWARE\McAfee Endpoint Encryption\MfeEpePC\Status&quot;
key64Path = &quot;SOFTWARE\Wow6432Node\McAfee Endpoint Encryption\MfeEpePC\Status&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If

If RegKeyExists(HKLM, keyPath) Then
	Dim strReturn
	strReturn = ReturnStringValueOrEchoError _
		(objRegistry,HKLM,keyPath,&quot;Activated&quot;,&quot;McAfee Endpoint Encryption Activation Status Not Found&quot;)
	If VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error
		WScript.Echo strReturn
	Else
		WScript.Quit
	End If
Else
	WScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;
	WScript.Quit
End If

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)
&#039; Return a value or fatal error message and error result
	Dim intReturn,strValueData
	intReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)
	If intReturn = 0 Then
		ReturnStringValueOrEchoError = strValueData
	Else
		ReturnStringValueOrEchoError = -1
		WScript.Echo strErrorMessage
	End If
End Function 

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
385,Miscellaneous,2015-01-05T20:22:05,",","Simple sensor that returns the word ""Target"" that is used when targeting actions within Tanium.
Example: Target",1,740857544,0,767,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Target,,,,,,,,,Windows,"&#039;========================================
&#039; Target
&#039;========================================

WScript.Echo &quot;Target&quot;",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
386,Active Directory,2015-01-05T20:22:05,|,"Returns information on AD accounts which are logged in using cached credentials.
Example:john.doe Cached - RDP",1,745447734,0,769,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Cached AD Logins,,,,,,,,,Windows,"&#039;========================================
&#039; Cached AD Logins
&#039;========================================
&#039; This sensor will enumerate the Usernames of all accounts which are
&#039; cached

Option Explicit

Dim strSep : strSep = &quot;|&quot;
&#039; This is a multi-column sensor whose output looks like
&#039; Username|Type
&#039; Where account type is Cached - Interactive or Cached - RDP

ListCachedAccounts

Function ListCachedAccounts

	Dim objWMI, colSessions, colProcesses, objProcess
	Dim objSession, colList, objItem, colOwner, strProcessOwner
	Dim strAccountType, dictProcessOwners, strOwnerUser, strOwnerDomain
	Dim bDisplay, objReg
	
	Set objWMI = GetObject(&quot;winmgmts:&quot; _ 
	              &amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;) 
	Set objReg = GetObject(&quot;winmgmts:\\.\root\default:StdRegProv&quot;)              
	
	&#039; Get owner information for running processes to filter out stale user results
	&#039; because Win32_LogonSession can have days old logins in there.
	
	&#039; store in dictionary object
	Set dictProcessOwners = CreateObject(&quot;Scripting.Dictionary&quot;)
	
	Set colProcesses = objWMI.ExecQuery(&quot;Select * from Win32_Process&quot;,,48)
	On Error Resume Next &#039; some processes may not have owner and domain properties
	For Each objProcess in colProcesses
		colOwner = objProcess.GetOwner(strOwnerUser,strOwnerDomain)
			
		If Not dictProcessOwners.Exists(strOwnerDomain&amp;&quot;\&quot;&amp;strOwnerUser) Then
			dictProcessOwners.Add strOwnerDomain&amp;&quot;\&quot;&amp;strOwnerUser,1 &#039; for uniqueness
		End If
	Next
	On Error Goto 0 &#039;back to normal
	

	Set colSessions = objWMI.ExecQuery(&quot;Select * from Win32_LogonSession&quot;) 
		
	If colSessions.Count = 0 Then 
		&#039; Do Nothing
	Else 
	   For Each objSession in colSessions
	     Set colList = objWMI.ExecQuery(&quot;Associators of &quot; _ 
	         &amp; &quot;{Win32_LogonSession.LogonId=&#039;&quot; &amp; objSession.LogonId &amp; &quot;&#039;} &quot; _ 
	         &amp; &quot;Where AssocClass=Win32_LoggedOnUser Role=Dependent&quot; ) 
	     For Each objItem in colList
	     	Select Case objSession.LogonType
	     		Case 11
	     			strAccountType = &quot;:Cached: :Interactive:&quot;
	     			bDisplay = True
	     		Case 12
	     			strAccountType = &quot;:Cached: :RDP:&quot;
	     			bDisplay = True	     			
	     		Case Else
	     		&#039; There are more cases that we shouldn&#039;t really see
	     			strAccountType = objSession.LogonType
	     	End Select
	     	
 			For Each strProcessOwner In dictProcessOwners.Keys
	      		If bDisplay And InStr(LCase(objItem.Caption),LCase(Split(strProcessOwner,&quot;\&quot;)(0))) &gt; 0 And InStr(LCase(objItem.Caption),LCase(Split(strProcessOwner,&quot;\&quot;)(1))) &gt; 0 Then
		       		WScript.Echo GetUserForSIDLocal(objReg,objItem.SID) &amp; strSep &amp; strAccountType
		       		Exit For
		       	End If
		   bDisplay = False
		   Next
	     	
	     Next
	  Next
	End If
		     	
End Function &#039;ListCachedAccounts


Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		strUserData = Left(strUserData,intDatPos - 1)
		&#039; find last backslash
		intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
		&#039; get right from that pos
		strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
		GetUserForSIDLocal = strUserData
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,User,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Type,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
387,Operating System,2015-01-05T20:22:05,",","Will output ""Windows Server"" or ""Windows Workstation"" depending on the OS type.
Example: Windows Server",1,74624344,0,771,1,Jim Olsen,3600,0,defined,Tanium,2015-01-05T20:22:05,Windows OS Type,,,,,,,,,Windows,"&#039;========================================
&#039; Windows OS Type
&#039;========================================

Option Explicit

Select Case (LCase(GetProductType))
	&#039; Workstations will always output WinNT
	Case &quot;winnt&quot;
		WScript.Echo &quot;Windows Workstation&quot;
	Case &quot;servernt&quot;
		WScript.Echo &quot;Windows Server&quot;
	Case &quot;lanmannt&quot;
		WScript.Echo &quot;Windows Server&quot;		
	Case Else
		WScript.Echo &quot;Error: Cannot determine OS type&quot;
End Select
	
Function GetProductType

	Dim objShell
	Dim keyPath, strPath, strFoundPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyPath = &quot;SYSTEM\CurrentControlSet\Control\ProductOptions&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyPath&amp;&quot;\ProductType&quot;)
    On Error Goto 0
	strFoundPath = strPath
  	
  	If Not strPath = &quot;&quot; Then
  		GetProductType = strFoundPath
  	Else
  		GetProductType = False
  		WScript.Echo &quot;Error: Cannot determine OS type&quot;
  		WScript.Quit
  	End If
End Function &#039;GetProductType",VBScript,Linux,"#!/bin/bash
echo Non-Windows
",UnixShell,Mac,"#!/bin/bash
echo Non-Windows
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
388,Hardware,2015-01-05T20:22:05,",","Returns the number of used slots in the system on Windows client machines.
Example: 1",1,747106243,0,773,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,System Slots In Use,,,,,,,,,Windows,"&#039;========================================
&#039; System Slots in Use
&#039;========================================

&#039; This sensor will return the number of slots in use

Option Explicit

WScript.Echo GetSystemSlotsInUse

Function GetSystemSlotsInUse
	
	Dim objWMIService, colSystemSlots
	Dim strComputer, objSystemSlots

	strComputer = &quot;.&quot;
	Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
		&amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;) 

	&#039;SlotDesignation is like &quot;PCI-I&quot; and CurrentUsage=4 means occupied
	Set colSystemSlots = objWMIService.ExecQuery _ 
		(&quot;Select SlotDesignation from Win32_SystemSlot where CurrentUsage=4&quot;) 
	If Not IsNull(colSystemSlots) Then
		GetSystemSlotsInUse = colSystemSlots.Count
	Else
		GetSystemSlotsInUse = &quot;WMI Error&quot;
	End If
	
	&#039;Cleanup
	Set colSystemSlots = Nothing
	Set objWMIService = Nothing
End Function &#039;GetSystemSlotsInUse",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,NumericInteger
389,Hardware,2015-01-05T20:22:05,",","Returns the size of the maximum amount of RAM a machine can carry.
Example: 8 GB",1,782305667,0,775,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,RAM Max Capacity,,,,,,,,,Windows,"&#039;========================================
&#039; RAM Max Capacity
&#039;========================================

&#039; This sensor will pull the maximum amount of RAM a machine can carry via WMI

Option Explicit
Dim objWMIService, colItems, objItem
Dim strWMIQuery, strItem, strComputer, cap

If Left(GetOSMajorVersion(), 1) = &quot;5&quot; Then 
	&#039; This function does not work on Windows XP or 2003, return Not Available
	WScript.Echo &quot;Not Available&quot;
	WScript.Quit
End If

Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	&amp; &quot;{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)

&#039; 3 is system memory (not video or flash mem)
strWMIQuery = &quot;Select MaxCapacity from Win32_PhysicalMemoryArray where Use=&#039;3&#039;&quot;

Set colItems = objWMIService.ExecQuery(strWMIQuery)
cap = 0
For Each objItem In colItems
	cap = CDbl(objItem.MaxCapacity)
	If cap &gt; 0 Then
		WScript.Echo PrettyFileSize(cap * 1024)
	Else
		WScript.Echo &quot;Error / Unknown&quot;
	End If
Next

Function PrettyFileSize(strBytes)

	Dim size,intKB,intMB,intGB
	
	If IsNumeric(strBytes) Then
		size = CDbl(strBytes)
		
		intKB = 1024
		intMB = 1024*1024
		intGB = 1024*1024*1024
	
		If size &gt; intGB Then
			PrettyFileSize = Int(size / intGB) &amp; &quot; GB&quot;
		ElseIf size &gt; intMB Then
			PrettyFileSize = Int(size / intMB) &amp; &quot; MB&quot;
		ElseIf size &gt; intKB Then
			PrettyFileSize = Int(size / intKB) &amp; &quot; KB&quot;
		Else
			PrettyFileSize = size &amp; &quot; B&quot;
		End If
	Else
		PrettyFileSize = &quot;Error / Unknown&quot;
	End If

End Function &#039;PrettyFileSize

Function GetOSMajorVersion
&#039; Returns the OS Major Version
&#039; A different way to examine the OS instead of by name

	Dim objWMIService,colItems,objItem
	Dim strVersion

	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    
	For Each objItem In colItems
		strVersion = objItem.Version &#039; like 6.2.9200
		strVersion = Left(strVersion,Len(strVersion) - 5)
	Next
	
	GetOSMajorVersion = strVersion
	
End Function &#039;GetOSMajorVersion",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DataSize
390,Hardware,2015-01-05T20:22:05,|,"Indicates whether the machine's harddrive requires defragmentation
Example: Yes",1,801419063,0,777,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Defrag Needed,,,,,,,,,Windows,"&#039;========================================
&#039; Defrag Needed
&#039;========================================

&#039; will output whether a machine needs a defrag for a particular volume
&#039; and some statistics about the volume.
&#039; A defrag has no meaning to an SSD, but there is no way to link
&#039; a volume object property to a disk_drive property
&#039; Not cleanly, anyway.  Perhaps in Windows 8 :)
Option Explicit

Dim strComputer: strComputer = &quot;.&quot;
Dim strSep: strSep = &quot;|&quot;

Dim bRecommended, errResult
Dim objWMIService, colVolumes, objVolume, objReport

&#039; output looks like: Defrag Recommended|DriveLetter|Volume Size|% Fragmented


Set objWMIService = GetObject(&quot;winmgmts:&quot; _
	&amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colVolumes = objWMIService.ExecQuery(&quot;Select * from Win32_Volume&quot;)

For Each objVolume In colVolumes
	errResult = objVolume.DefragAnalysis(bRecommended, objReport)
		If bRecommended = True Then
			WScript.Echo &quot;Yes&quot; &amp; strSep &amp; objVolume.DriveLetter &amp; _
				strSep &amp; objReport.VolumeSize &amp; strSep &amp; _
				objReport.TotalPercentFragmentation
		End If
		If bRecommended = False Then
			&#039; Do nothing.  If you echo No, you get multiple results for each machine.
		End If
Next

&#039; cleanup
Set objWMIService = Nothing
Set colVolumes = Nothing
Set objVolume = Nothing
Set objReport = Nothing",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Recommended,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Drive Letter,String,0,1,2,Volume Size,String,0,1,3,% Fragmented,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
391,User,2015-01-05T20:22:05,|,"Returns a list of local users to the Windows machine and the user's full name.
Example:johndoe|John Doe",1,801908140,0,779,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,User Details,,,,,,,,,Windows,"&#039;=================================
&#039; User Details
&#039; Don&#039;t try this on a domain controller because all domain users are local users on a DC!
&#039;=================================

sComputer = &quot;.&quot;
Function DomainRole(sNode)
	Set oWMI = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\&quot; &amp; sNode &amp; &quot;\root\cimv2&quot;)
	Set colComputer = oWMI.ExecQuery(&quot;Select DomainRole from Win32_ComputerSystem&quot;)
	For Each oComputer in colComputer
		iDR = oComputer.DomainRole
	Next
	Select Case iDR
	Case 0
		&#039; standalone workstation
		DomainRole = &quot;SW&quot;
	Case 1
		&#039; member workstation
		DomainRole = &quot;MW&quot;
	Case 2
		&#039; standalone server
		DomainRole = &quot;SS&quot;
	Case 3
		&#039; member server
		DomainRole = &quot;MS&quot;
	Case 4
		&#039; backup domain controller
		DomainRole = &quot;BDC&quot;
	Case 5
		&#039; primary domain controller
		DomainRole = &quot;PDC&quot;
	Case Else
		&#039;; unknown
		DomainRole = &quot;UNK&quot;
	End Select
End Function
	
If DomainRole(sComputer) = &quot;PDC&quot; Or DomainRole(sComputer) = &quot;BDC&quot; Then
	WScript.Echo &quot;Domain Controller, Can&#039;t Enumerate users&quot;
Else
	Set objNetwork = CreateObject(&quot;Wscript.Network&quot;)
	strComputer = objNetwork.ComputerName
	Set colAccounts = GetObject(&quot;WinNT://&quot; &amp; strComputer &amp; &quot;&quot;)
	colAccounts.Filter = Array(&quot;user&quot;)
	For Each objUser In colAccounts
	    	strFullName = objUser.FullName
    		If strFullName = &quot;&quot; Then
    			strFullName = objUser.Name
    		End If
    		WScript.Echo objUser.Name &amp; &quot;|&quot; &amp; strFullName
	Next
End If",VBScript,Linux,"#!/bin/sh
awk -F: &#039;{print $1&quot;|&quot;$5}&#039; /etc/passwd
",UnixShell,Mac,"#!/bin/sh
awk -F: &#039;{print $1&quot;|&quot;$5}&#039; /etc/passwd
",UnixShell,0,146,0,1,0,User Account,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Full Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
392,Hardware,2015-01-05T20:22:05,",","The version number of the video driver on the client machine.
Example: 6.1.7600.16385",1,8168018,0,781,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Video Driver Version,,,,,,,,,Windows,select DriverVersion from win32_VideoController,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Version
393,Office,2015-01-05T20:22:05,|,"Returns details of PST files that have been mounted by users on a system.
Example: c:\psts\huge.pst 4088 MB",1,856087598,0,783,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,PST Information,,,,,,,,,Windows,"&#039;========================================
&#039; PST Information
&#039;========================================

&#039; This sensor will return data about attached PST files in all profiles.
&#039; This sensor should run in either 32-bit or 64-bit mode without issue
&#039; And will work properly when run in system context of course.
&#039; Times returned are local to the client.

Option Explicit
 &#039;On Error Resume Next 
 Const HKEY_CURRENT_USER = &amp;H80000001 
 Const HKEY_USERS = &amp;H80000003
 Const r_PSTGuidLocation = &quot;01023d00&quot; 
 Const r_MasterConfig = &quot;01023d0e&quot; 
 Const r_PSTCheckFile = &quot;00033009&quot; 
 Const r_PSTFile = &quot;001f6700&quot; 
 Const r_keyMaster = &quot;9207f3e0a3b11019908b08002b2a56c2&quot; 
 Const r_ProfilesRoot = &quot;Software\Microsoft\Windows NT\CurrentVersion\Windows Messaging Subsystem\Profiles&quot; 
 Const r_DefaultOutlookProfile = &quot;Software\Microsoft\Windows NT\CurrentVersion\Windows Messaging Subsystem\Profiles&quot; 
 Const r_DefaultProfileString = &quot;DefaultProfile&quot; 
 Dim oReg        :Set oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)   
 Dim arrSubKeys, subkey, strValue, i, pstFile, arrPSTs, DefaultProfileName, arrUserKeys, strUserKey
 Dim profileName
 Dim strSep: strSep = &quot;|&quot; &#039; This is a multi-column sensor

&#039; This sensor uses dates and should have locale set
SetLocale(GetTaniumLocale) &#039; Default is US/English


&#039; first get all users from HKEY_USERS
oReg.EnumKey HKEY_USERS,&quot;&quot;,arrUserKeys

&#039;And loop through those SIDs
For Each strUserKey In arrUserKeys
	&#039; WScript.Echo userKey &amp; &quot; is current user SID key&quot;
	&#039; return the keys under HKEY_USERS
	&#039; WScript.Echo &quot;We&#039;re in &quot; &amp; strUserKey
	oReg.EnumKey HKEY_USERS,strUserKey &amp; &quot;\&quot; &amp; r_ProfilesRoot,arrSubKeys
	&#039; and loop through those looking for outlook profiles
	&#039; there may be multiple profiles per user.
	If Not IsNull(arrSubKeys) Then
		For Each profileName In arrSubKeys
			&#039;WScript.Echo profileName &amp; &quot; Is profilename&quot;
			&#039;WScript.Echo &quot;We&#039;re going to try to get PSTs for this profile: &quot; &amp; strUserKey &amp; &quot;\&quot; &amp; r_ProfilesRoot &amp; &quot;\&quot; &amp; profileName
			ShowPSTsForProfile strUserKey &amp; &quot;\&quot; &amp; r_ProfilesRoot, profileName
		Next &#039; end inner loop
	End If
Next &#039; end outer loop

&#039;&#039; End Main Line


 &#039;_____________________________________________________________________________________________________________________________ 
 Function ShowPSTsForProfile(profilePath, p_profileName)
 Dim strHexNumber, strPSTGuid
 Dim HexCount    :HexCount = 0
 Dim strPSTFile, arrBinValue 

 &#039; WScript.Echo &quot;ProfilePath is &quot; &amp; profilePath
 &#039; WScript.Echo &quot;And we&#039;re fetching &quot; &amp; profilePath &amp; &quot;\&quot; &amp; p_profileName &amp; &quot;\&quot; &amp; r_keyMaster &amp; &quot;-&quot; &amp; r_MasterConfig
 oReg.GetBinaryValue HKEY_USERS,profilePath &amp; &quot;\&quot; &amp; p_profileName &amp; &quot;\&quot; &amp; r_keyMaster,r_MasterConfig,arrBinValue

     For i = lBound(arrBinValue) to uBound(arrBinValue)     
             If Len(Hex(arrBinValue(i))) = 1 Then  
                 strHexNumber = &quot;0&quot; &amp; Hex(arrBinValue(i)) 
             Else 
                 strHexNumber = Hex(arrBinValue(i)) 
             End If         
         strPSTGuid = strPSTGuid + strHexNumber 
         HexCount = HexCount + 1 
             If HexCount = 16 Then  
                     If IsAPST(profilePath &amp; &quot;\&quot; &amp; p_profileName &amp; &quot;\&quot; &amp; strPSTGuid) Then 
                         &#039; WScript.Echo &quot;It is a PST!!&quot; &amp; profilePath &amp; &quot;\&quot; &amp; p_profileName &amp; &quot;\&quot; &amp; strPSTGuid
                         strPSTFile = PSTFileName(profilePath &amp; &quot;\&quot; &amp; p_profileName &amp; &quot;\&quot; &amp; PSTlocation(profilePath &amp; &quot;\&quot; &amp; p_profileName &amp; &quot;\&quot; &amp; strPSTGuid))
                         WScript.Echo GetFileInfo (strPSTFile, strSep)                         
                     End If     
                 HexCount = 0 
                 strPSTGuid = &quot;&quot; 
             End If             
     Next
 End Function 
 &#039;_____________________________________________________________________________________________________________________________ 
 Function IsAPST(p_PSTGuid) 
 Dim x, P_PSTGuidValue 
 Dim P_PSTCheck:P_PSTCheck=0 
 IsAPST=False 
 oReg.GetBinaryValue HKEY_USERS,p_PSTGuid,r_PSTCheckFile,P_PSTGuidValue 
     For x = lBound(P_PSTGuidValue) to uBound(P_PSTGuidValue)     
         P_PSTCheck = P_PSTCheck + Hex(P_PSTGuidValue(x)) 
     Next     
     If P_PSTCheck=20 Then 
         IsAPST=True 
     End If     
 End Function  
 &#039;_____________________________________________________________________________________________________________________________ 
 Function PSTlocation(p_PSTGuid) 
 Dim y, P_PSTGuidValue, t_strHexNumber 
 oReg.GetBinaryValue HKEY_USERS,p_PSTGuid,r_PSTGuidLocation,P_PSTGuidValue
 	If Not IsNull(P_PSTGuidValue) Then 
     For y = lBound(P_PSTGuidValue) to uBound(P_PSTGuidValue)     
         If Len(Hex(P_PSTGuidValue(y))) = 1 Then 
             PSTlocation = PSTlocation + &quot;0&quot; &amp; Hex(P_PSTGuidValue(y)) 
         Else 
             PSTlocation = PSTlocation + Hex(P_PSTGuidValue(y))     
         End If     
     Next
   End If     
 End Function  
 &#039;_____________________________________________________________________________________________________________________________ 
 Function PSTFileName(p_PSTGuid) 
 Dim z, P_PSTName 
 Dim strString:strString = &quot;&quot; 
 &#039; WScript.Echo &quot;In PSTFileName, p_PSTGUID is : &quot; &amp; p_PSTGuid
 oReg.GetBinaryValue HKEY_USERS,p_PSTGuid,r_PSTFile,P_PSTName 
     For z = lBound(P_PSTName) to uBound(P_PSTName)     
         If P_PSTName(z) &gt; 0 Then 
             strString = strString &amp; Chr(P_PSTName(z)) 
         End If     
     Next     
     PSTFileName = strString 
 Set z = nothing 
 Set P_PSTName = nothing 
 End Function  
 &#039;_________________________________________________________________________________________________________ 
 Function GetFileInfo(strFilePath, strSep)
 &#039; This will return the file name
 &#039; The file size
  
  
 	Dim objFSO
 	Dim file
 
 	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
 	Set file = objFSO.GetFile(strFilePath)
 	&#039; let&#039;s just return a separated string with all kinds of information in it
 	&#039;GetFileInfo = strFilePath &amp; strSep &amp; file.DateCreated &amp; strSep &amp; _ 
 	&#039;	file.DateLastAccessed &amp; strSep &amp; file.DateLastModified _
 	&#039;	&amp; strSep &amp; file.Size &amp; &quot; bytes&quot;
 
  	GetFileInfo = strFilePath &amp; strSep &amp; BytesConvert(file.Size)
 	
 	&#039;cleanup
 	Set file = Nothing
 	Set objFSO = Nothing
 	
 End Function &#039;GetFileInfo
 
Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale

Function BytesConvert(dblSize)

	Dim strSuffix, intCommaSpot
	
	Do While InStr(dblSize,&quot;,&quot;) &#039;Remove commas from dblSize 
	    intCommaSpot = InStr(dblSize,&quot;,&quot;) 
	    dblSize = Mid(dblSize,1,intCommaSpot - 1) &amp; _ 
	        Mid(dblSize,intCommaSpot + 1,Len(dblSize) - intCommaSpot) 
	Loop
	
	On Error Resume Next
	dblSize = CDbl(dblSize)
	If Err.Number &lt;&gt; 0 Then
		BytesConvert = &quot;Invalid input&quot;
		Exit Function
	End If
	On Error Goto 0

	strSuffix = &quot; Bytes&quot; 
	If dblSize &gt;= 1024 Then strSuffix = &quot; KB&quot; 
	If dblSize &gt;= 1048576 Then strSuffix = &quot; MB&quot; 
	If dblSize &gt;= 1073741824 Then strSuffix = &quot; GB&quot; 
	If dblSize &gt;= 1099511627776 Then strSuffix = &quot; TB&quot; 
	
	Select Case strSuffix 
	    Case &quot; KB&quot; dblSize = Round(dblSize / 1024, 1) 
	    Case &quot; MB&quot; dblSize = Round(dblSize / 1048576, 1) 
	    Case &quot; GB&quot; dblSize = Round(dblSize / 1073741824, 1) 
	    Case &quot; TB&quot; dblSize = Round(dblSize / 1099511627776, 1) 
	End Select
	
	BytesConvert = dblSize &amp; strSuffix 
End Function &#039;BytesConvert",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,File,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Size,DataSize,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
394,Hardware,2015-01-05T20:22:05,|,"Details on any shared printers available from the client machine.  Details include printer name, print server, and share name.
Example: \\PRINTSERVER1\PRINTER2 | netserver | \\PRINTSERVER1\PRINTER2",1,861367460,0,785,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Shared Network Printer Details,,,,,,,,,Windows,"&#039;========================================
&#039; Shared Network Printer Details
&#039;========================================

&#039; This is a multi-column sensor that returns details on
&#039; printers that are served by a print server.
&#039; The columns look like:
&#039; Printer|Server|Share Name

strSep = &quot;|&quot;
 
strComputer =&quot;.&quot;

Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\CIMV2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Printer&quot;)

For Each objItem In colItems
	If (objitem.Servername &lt;&gt; &quot;&quot;) Then
		WScript.Echo objItem.name &amp; strSep &amp; objitem.ServerName _
		&amp; strSep &amp; objitem.ShareName
	End If
Next

Set objWMIService = Nothing
Set colItems = Nothing",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Printer,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Server,String,0,1,2,Share Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
395,Operating System,2015-01-05T20:22:05,",","Returns loaded kernel modules on Linux systems.
Example:dcdbas",1,865123401,0,787,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Kernel Modules,,,,,,,,,Windows,WScript.Echo &quot;Not a Windows Sensor&quot;,VBScript,Linux,"#!/bin/bash
cat /proc/modules | while read line
do
        set -- $line
	echo $1
done
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
396,Hardware,2015-01-05T20:22:05,|,"Indicates whether hyperthreading is enabled on the client machine.  This is not supported on all OS patch levels.
Example: Yes",1,867160258,0,789,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Hyperthreading Enabled,,,,,,,,,Windows,"&#039;========================================
&#039; Hyperthreading Enabled
&#039;========================================

&#039; checking if the number of logical processors is greater than
&#039; the number of cores on each physical, socketed processor.
On Error Resume Next

Set objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) 
intNumCores = 0

For Each objItem in colItems
	intNumCores = intNumCores + CInt(objItem.NumberOfCores)
	&#039;decide whether to continue for unsupported OS patch levels
	If intNumCores = 0 Then &#039; machine does not support counting cores
		strOs = GetOS
		&#039;Windows 2000 isn&#039;t supported for core count, can&#039;t determine hyperthreading
		If InStr(strOs, &quot;2000&quot;) &gt; 0 Then
			WScript.Echo &quot;Windows 2000 - Cannot determine&quot;
		ElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then
			WScript.Echo &quot;XP SP3 Required to determine&quot;
		ElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then
			&#039;For Win Server 2003 SEE KB 932370
			&#039;http://support.microsoft.com/kb/932370/
			WScript.Echo &quot;KB932370 Required to determine&quot;
		Else
			WScript.Echo &quot;N/A&quot;
		End If
	ElseIf intNumCores &lt; objItem.NumberOfLogicalProcessors Then
		WScript.Echo &quot;Yes&quot;
	ElseIf intNumCores = objItem.NumberOfLogicalProcessors Then
		WScript.Echo &quot;No&quot;
	Else
		WScript.Echo &quot;Unsure&quot;
	End If
	WScript.Quit &#039;if reported once, it will be the same value across all CPUs
Next

Function GetOS
	Set oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    
	Set oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)    
	Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    
	For Each objItem In colItems       
	strStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   
	&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   
	if Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   
	strOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   
	Else   
	strOS = strStrip1
	End IF   
	GetOS = Trim(strOS)
	Next
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
397,Hardware,2015-01-05T20:22:05,|,"Returns the connected network printers.
Example: printer_name | driver | port",1,876725971,0,791,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Network Printer Details,,,,,,,,,Windows,"&#039;========================================
&#039; Network Printer Details
&#039;========================================

On Error Resume Next
strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\cimv2&quot;)
Set colItems = objWMIService.ExecQuery(&quot;Select PortName,Caption,DriverName from Win32_Printer&quot;,,48)

strSep = &quot;|&quot;

For Each objItem in colItems
	If InStr(objItem.PortName, &quot;.&quot;) Then
	
		WScript.Echo objItem.Caption &amp; strSep &amp; _
			objItem.DriverName &amp; strSep &amp; _
			objItem.PortName
	End If
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Printer,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Driver,String,0,1,2,Port,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
398,Hardware,2015-01-05T20:22:05,",","Returns the Motherboard Manufacturer of a system.
Example:Lenovo",1,885259283,0,793,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Motherboard Manufacturer,,,,,,,,,Windows,"&#039;========================================
&#039; Motherboard Manufacturer
&#039;========================================

Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\cimv2&quot;)
Set colMB = objWMIService.ExecQuery(&quot;Select * from Win32_BaseBoard&quot;)
For Each mb In colMB
mbManufacturer = mb.Manufacturer
WScript.Echo mbManufacturer
Next",VBScript,Linux,"#!/bin/bash
dmidecode -s baseboard-manufacturer
",UnixShell,Mac,"#!/bin/bash
echo Apple
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
399,McAfee,2015-01-05T20:22:05,",","Returns the Product Code of a McAfee Endpoint Encryption install
Example: Enterprise",1,892119042,0,795,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,McAfee Endpoint Encryption Product Code,,,,,,,,,Windows,"&#039;========================================
&#039; McAfee Endpoint Encryption Product Code
&#039;========================================

&#039; This sensor will return the Product Code of a
&#039; McAfee Endpoint Encryption install
&#039; This is a string value such as &quot;Enterprise&quot;

Option Explicit

Dim objRegistry,keyPath,key64Path,strSep
strSep = &quot;|&quot; &#039; column delimiter

Set objRegistry = Getx64RegistryProvider()

Const HKLM = &amp;H80000002

keyPath = &quot;SOFTWARE\McAfee Endpoint Encryption\MfeEpePC\Status&quot;
key64Path = &quot;SOFTWARE\Wow6432Node\McAfee Endpoint Encryption\MfeEpePC\Status&quot;

If Not RegKeyExists(HKLM, keyPath) Then
	keyPath = key64Path

	If Not RegKeyExists(HKLM, keyPath) Then
		WScript.Echo &quot;Not installed&quot;
		WScript.Quit
	End If
End If

If RegKeyExists(HKLM, keyPath) Then
	Dim strReturn
	strReturn = ReturnStringValueOrEchoError _
		(objRegistry,HKLM,keyPath,&quot;ProductCode&quot;,&quot;McAfee Endpoint Encryption Product Code Not Found&quot;)
	If VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error
		WScript.Echo strReturn
	Else
		WScript.Quit
	End If
Else
	WScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;
	WScript.Quit
End If

Function RegKeyExists(sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)
&#039; Return a value or fatal error message and error result
	Dim intReturn,strValueData
	intReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)
	If intReturn = 0 Then
		ReturnStringValueOrEchoError = strValueData
	Else
		ReturnStringValueOrEchoError = -1
		WScript.Echo strErrorMessage
	End If
End Function 

Function Getx64RegistryProvider
    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems
    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv
    Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
    For Each objItem In colItems
        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
            iArchType = 64
        Else
            iArchType = 32
        End If
    Next
    
    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType
    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   
    
    Set Getx64RegistryProvider = objRegProv
End Function &#039; Getx64RegistryProvider",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
400,Operating System,2015-01-05T20:22:05,",","Shows the currently specified country code used by the operating system.
Example: 1    (United States)",1,902205018,0,797,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Country Code,,,,,,,,,Windows,select CountryCode from win32_operatingsystem,WMIQuery,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
401,Operating System,2015-01-05T20:22:05,",","Whether data execution prevention is enabled for 32-bit machines.  If disabled, code can be executed from a non-executable memory region.
Example: TRUE, FALSE",1,916410332,0,799,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Data Execution Prevention Enabled,,,,,,,,,Windows,"&#039;========================================
&#039; Data Execution Prevention Enabled
&#039;========================================

strComputer = &quot;.&quot; 
Set objWMIService = GetObject(&quot;winmgmts:\\&quot; &amp; strComputer &amp; &quot;\root\CIMV2&quot;) 
Set colItems = objWMIService.ExecQuery( _
    &quot;SELECT * FROM Win32_OperatingSystem&quot;,,48) 
For Each objItem in colItems 
    If objItem.DataExecutionPrevention_32BitApplications Then
        Wscript.Echo &quot;True&quot;
    Else
        Wscript.Echo &quot;False&quot;
    End If
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
402,Hardware,2015-01-05T20:22:05,",","Name of any installed CD-ROM or DVD-ROM drives.
Example: SONY DVD-ROM DDU1615 ATA Device",1,923740265,0,801,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,CD-ROM Drive,,,,,,,,,Windows,select Caption from win32_CDROMDRIVE,WMIQuery,Linux,"#!/bin/sh
LINUX=`uname -o | grep -c -i linux`

if [ $LINUX -eq 1 ]
then
lshal | grep -i info.product | grep CD | sed &#039;s/info.product = &#039;\&#039;&#039;\(.*\)&#039;\&#039;&#039;.*/\1/g&#039;
fi
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
403,Applications,2015-01-05T20:22:05,",","Gets a list of all Services on the client machine.
Example: Task Scheduler",1,926119908,0,803,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Service,,,,,,,,,Windows,select Caption from win32_Service,WMIQuery,Linux,"#!/bin/bash
chkconfig --list | while read line
do
        set -- $line
	echo $1
done
",UnixShell,Mac,"#!/bin/bash
first=true
launchctl list | while read line
do
    set -- $line
if ( $first ); 
then
	first=false
else
	echo $3
fi
done
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
404,Tanium,2015-01-05T20:22:05,",","Provided with a parameter indicating the path to a file in the Tanium current directory, returns True or False based on whether that file exists in the specified location.
Example: True",1,95001259,0,805,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Tanium File Exists,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Starting from the Client installation directory, complete the file path to get contents for."",""value"":"""",""promptText"":""e.g. uninst.exe or Tools\\Wsusscn2.cab"",""defaultValue"":"""",""label"":""Relative file path from <Tanium Client Installation Dir>"",""maxChars"":0,""key"":""file"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Tanium File Exists
&#039;========================================

filePath = unescape(&quot;||file||&quot;)
strTaniumDir = GetTaniumDir(&quot;&quot;)

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

filePath = strTaniumDir &amp; filePath

If fso.FileExists(filePath) Then 
	&#039;WScript.Echo filePath
	WScript.Echo &quot;True&quot;
Else 
	WScript.Echo &quot;File does not exist&quot;
End If

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;e.g. uninst.exe or Tools\Wsusscn2.cab&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||file||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;e.g. uninst.exe or Tools\Wsusscn2.cab&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||file||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
405,Hardware,2015-01-05T20:22:05,",","Description of the video card in the client machine.
Example: ATI Radeon HD 2400 Pro",1,953427826,0,807,1,Jim Olsen,86400,0,defined,Tanium,2015-01-05T20:22:05,Video/Graphics Card,,,,,,,,,Windows,select Name from Win32_VideoController,WMIQuery,Linux,"#!/bin/bash
dmidecode | grep -A2 &quot;Type: Video&quot; | awk -F&quot;: &quot; &#039;$1 ~ &quot;Description&quot; {print $2}&#039;
",UnixShell,Mac,"#!/bin/bash
video=$(system_profiler SPDisplaysDataType | grep Chipset | awk -F&#039;: &#039; &#039;{print $2}&#039;)
if [ &quot;&quot; = &quot;$video&quot; ]
then
	echo &quot;Unknown&quot;
else
	echo &quot;$video&quot;
fi
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
406,Patch,2015-01-05T20:22:05,",","Sensor which looks at the patch results file to determine how many security patches are necessary and if that number is above a threshold value (default 20).  Can be edited to determine what severity counts as a security patch.  Threshold can also be adjusted.
Example:Yes",1,956515908,0,809,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Security Patches Needed Above Threshold,,,,,,,,,Windows,"&#039;========================================
&#039; Security Patches Needed Above Threshold
&#039;========================================

&#039; sensor - security patches needed above threshold
&#039; This sensor will Yes or No if the count of security updates needed
&#039; is above a threshold value.


Option Explicit

Dim strHighestSeverityThatCounts
&#039; This sensor is modifiable
&#039; customers can decide how to flag an update as countable in this sensor
&#039; by default, we include all available patches

&#039; This string value will determine what we count.  The valid values here are:
&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS

strHighestSeverityThatCounts = &quot;ALL&quot;

Dim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, intCriticalThreshold
Dim intTotalThreshold
strSep = &quot;|&quot;
intCriticalThreshold = 5
intTotalThreshold = 20

Dim showSingleStatus
showSingleStatus = True

path = GetTaniumDir(&quot;Tools\Scans&quot;)
Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
fn = path &amp; &quot;\patchresultsreadable.txt&quot;

If objFSO.FileExists(fn) Then
	Set objReadFile = objFSO.OpenTextFile(fn, 1, False)

	Dim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete
	
	hasOutput = False

	&#039;note: intNone refers to patches with severity=none
	Dim intCritical, intImportant, intModerate, intLow, intNone, intSecurityBulletin
	
	intCritical = 0
	intImportant = 0
	intModerate = 0
	intLow = 0	
	intNone = 0
	intSecurityBulletin = 0
	
	Do While Not objReadFile.AtEndOfStream
		strLine = objReadFile.ReadLine

		&#039;CHECK FOR MULTI-URL PATCHES
		words = Split(strLine, strSep)
		
		&#039;Ignore old Patch Results format without separator
		If UBound(words) &lt; 4 Then 
			If left(words(0), 4) = &quot;Scan&quot; Then
				hasOutput = True
				&#039;WScript.Echo words(0)
			Else 
				&#039;WScript.Echo &quot;Run upgraded Patch Scan&quot;
				WScript.Quit
			End If	
		Else
			arrFilenames = Split(words(5), &quot;,&quot;)
			&#039;patch filename must be in Tools\Patch directory for queue
			Dim fso
			Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
			
			strPatchDir = GetTaniumDir(&quot;Tools\Patches&quot;)
			
			isComplete = True
			For Each strFilename In arrFilenames
				If Not fso.FileExists(strPatchDir &amp; &quot;\&quot; &amp; strFilename) Then
					isComplete = False
				End If			
			Next


&#039; A previously defined string value will determine what we count.  
&#039; The valid values here are:
&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS

			If Not isComplete Then
				If InStr(strLine, &quot;Already Installed&quot;) Then
					&#039;Do not echo since we only want to output &quot;Available&quot; patches
				Else
					hasOutput = True
					Select Case words(1)
					    Case &quot;Critical&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;CRITICALS&quot; Or _
					    		strHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _
					    		strHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    			intCritical = intCritical + 1
					    	End If
					    Case &quot;Important&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _
					    		strHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    			intImportant = intImportant + 1
					    	End If					    	

					    Case &quot;Moderate&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    		intModerate = intModerate + 1
					    	End If					    						    
					    Case &quot;Low&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    		intLow = intLow + 1
					    	End If									    
					    Case &quot;None&quot;
					    	If strHighestSeverityThatCounts = &quot;ALL&quot; Or _ 
					    		strHighestSeverityThatCounts = &quot;LOWS&quot; Then
					    		intNone = intNone + 1
					    	End If									    
					End Select
					If LCase(words(2)) &lt;&gt; &quot;none&quot; Then &#039; there is an MS Security Bulletin ID associated
						intSecurityBulletin = intSecurityBulletin + 1
					End If
				End If
			Else
				&#039;If we&#039;re here, update has been queued
				&#039;Do not echo since we only want to output &quot;Installed&quot; patches
				&#039;If InStr(strLine, &quot;Not Installed&quot;) Then
				&#039;	strLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)
				&#039;	WScript.Echo strLine
				&#039;End If
			End If 
		End If	
	Loop

	objReadFile.close

	If hasOutput Then &#039; output sum, ignoring the &#039;None&#039; category
		If strHighestSeverityThatCounts = &quot;MS_SECURITY_BULLETINS&quot; Then
			WScript.Echo intSecurityBulletin
		Else
			If intCritical + intImportant + intModerate + intLow + intNone &gt; intTotalThreshold Then
				WScript.Echo &quot;Yes&quot;
			Else
				WScript.Echo &quot;No&quot;
			End If
		End If
	Else
		WScript.Echo &quot;No&quot;
	End If

Else
   Wscript.echo &quot;Patch results output not found&quot;
End If

Function GetTaniumPath
   Dim strComputer, key32path, key64path, keyPath, reg
   strComputer = &quot;.&quot;
   Const HKLM = &amp;h80000002
   
   key32Path = &quot;Software\Tanium\Tanium Client&quot;
   key64Path = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
   
   Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer &amp; &quot;\root\default:StdRegProv&quot;)
   
   If RegKeyExists(reg, HKLM, key64Path) Then
        keyPath = key64Path
   ElseIf RegKeyExists(reg, HKLM, key32Path) Then
      keyPath = key32Path
   End If
   
   reg.GetStringValue HKLM,keyPath,&quot;Path&quot;,GetTaniumPath
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
407,Tanium Diagnostics,2015-01-05T20:22:05,",","Provided with an action number as a parameter, this sensor returns the log from the action from each client machine that executed the action.
Example: 2012-11-02 03:30:17 +0000|Command Completed",1,969736519,0,811,1,Jim Olsen,600,0,defined,Tanium,2015-01-05T20:22:05,Tanium Action Log,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""[0-9]+"",""helpString"":"""",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter a valid Action ID Number from the Action History tab"",""value"":"""",""promptText"":""e.g. 1234"",""defaultValue"":"""",""label"":""Action ID Number"",""maxChars"":0,""key"":""actionNumber"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&#039;========================================
&#039; Tanium Action Log
&#039;========================================

Option Explicit

Const MAX_LINES_TO_RETURN = 100

Dim strAction, strTaniumPath, strFilePath

strAction = &quot;||actionNumber||&quot;
strTaniumPath = GetTaniumDir(&quot;Downloads&quot;)

strFilePath = strTaniumPath &amp; &quot;\Action_&quot;&amp;strAction&amp;&quot;.log&quot;

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

If fso.FileExists(strFilePath) Then
	Dim objTextFile, strLine, intLineNumber
	Set objTextFile = fso.OpenTextFile(strFilePath, 1)
	
	intLineNumber = 1
	Do Until objTextFile.AtEndOfStream
		WScript.Echo zeroPad(intLineNumber,3) &amp; &quot;|&quot; &amp; objTextFile.ReadLine
		intLineNumber = intLineNumber + 1
		
		If(intLineNumber &gt; MAX_LINES_TO_RETURN) Then
			WScript.Echo zeroPad(intLineNumber,3) &amp; &quot;|Max number of lines reached in Action Log Sensor&quot;
			WScript.Quit
		End If
	Loop 
	
Else
	WScript.Echo &quot;File does not exist&quot;
End If

Function zeroPad(m, t)
   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m
End Function

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
    
    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
    End If
    
    If Not strPath = &quot;&quot; Then
        If strSubDir &lt;&gt; &quot;&quot; Then
            strSubDir = &quot;\&quot; &amp; strSubDir
        End If  
    
        Dim fso
        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
        If fso.FolderExists(strPath) Then
            If Not fso.FolderExists(strPath &amp; strSubDir) Then
                &#039;&#039;Need to loop through strSubDir and create all sub directories
                GeneratePath strPath &amp; strSubDir, fso
            End If
            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
        Else
            &#039; Specified Path doesn&#039;t exist on the filesystem
            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
            GetTaniumDir = False
        End If
    Else
        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
        GetTaniumDir = False
    End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
    GeneratePath = False

    If Not fso.FolderExists(pFolderPath) Then
        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
            GeneratePath = True
            Call fso.CreateFolder(pFolderPath)
        End If
    Else
        GeneratePath = True
    End If
End Function &#039;GeneratePath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;actionNumber&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;[0-9]+&quot;,&quot;helpString&quot;:&quot;&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter a valid Action ID Number from the Action History tab&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID Number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||actionNumber||  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;actionNumber&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;[0-9]+&quot;,&quot;helpString&quot;:&quot;&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter a valid Action ID Number from the Action History tab&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID Number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# ||actionNumber||  

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
408,Operating System,2015-01-05T20:22:05,",","The amount of time, in seconds, that the last boot of this machine took.
Example:  100",1,98057726,0,813,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Boot Time,,,,,,,,,Windows,"&#039;========================================
&#039; Boot Time in Minutes
&#039;========================================
&#039;

Option Explicit

Dim strBootTimeInSec

If Left(GetOSMajorVersion(), 1) &lt; 6 Then 
	WScript.Echo &quot;Not Available&quot;
Else
	strBootTimeInSec = GetBootTimeInSec
	WScript.Echo strBootTimeInSec
End If

Function GetBootTimeInSec() 
	Dim objShell, objShellExec, strCmd, strCmdOutput, strBootTime
	Dim xmlDoc, bLoadSuccess, objList, objNode
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strCmd = &quot;wevtutil.exe qe Microsoft-Windows-Diagnostics-Performance/Operational /rd:true /f:xml /c:1 /q:&quot;&quot;*[System[(EventID = 100)]]&quot;&quot; /e:Events&quot;
	
	Set objShellExec = objShell.Exec(strCmd)
	strCmdOutput = objShellExec.StdOut.ReadAll

	&#039; the command gave us back XML -- put the XML into an xml object, then find what we are looking for.
	
	Set xmlDoc = CreateObject(&quot;Msxml2.DOMDocument&quot;)
	bLoadSuccess = xmlDoc.loadXml(strCmdOutput)
	
	If Not bLoadSuccess Then
	    &#039; On Server machines, the above will report that the channel can not be found,
	    &#039; and return nothing.  (that log is only available on clients)  The XML won&#039;t parse,
	    &#039; so return Not Available
		WScript.Echo &quot;Not Available&quot;
		WScript.Quit
	End If
	
	Set objList = xmlDoc.getElementsByTagName(&quot;Data&quot;)
	If objList.length &gt; 0 Then
        For Each objNode In objList
        	Dim strAttribute
        	strAttribute = objNode.getAttribute(&quot;Name&quot;)
        	
        	If strAttribute = &quot;BootTime&quot; Then
        		strBootTime = objNode.text
        	End If
        Next
    End If

	GetBootTimeInSec = Round(strBootTime / 1000)
End Function &#039; GetBootTimeInSec
	
Function GetOSMajorVersion
&#039; Returns the OS Major Version
&#039; A different way to examine the OS instead of by name

	Dim objWMIService,colItems,objItem
	Dim strVersion

	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    
	For Each objItem In colItems
		strVersion = objItem.Version &#039; like 6.2.9200
		strVersion = Left(strVersion,Len(strVersion) - 5)
	Next
	
	GetOSMajorVersion = strVersion
	
End Function &#039;GetOSMajorVersion",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Numeric
409,Network,2015-01-05T20:22:05,",","The configured workgroup or computer domain for each client machine.
Example: mycompanydomain",1,991644931,0,815,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,Workgroup,,,,,,,,,Windows,"&#039;========================================
&#039; Workgroup
&#039;========================================

Set objWMISvc = GetObject( &quot;winmgmts:\\.\root\cimv2&quot; )
Set colItems = objWMISvc.ExecQuery(&quot;Select * From Win32_ComputerSystem&quot;)
For Each objItem in colItems
	strComputerDomain = objItem.Domain
	If Not objItem.PartOfDomain Then
    	&#039; If the machine is not part of a domain, then the &quot;Domain&quot; is the workgroup
    	&#039; Don&#039;t print domain, only workgroup
    	WScript.Echo  strComputerDomain
	End If
Next",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
410,Security,2015-01-05T20:22:05,|,"Returns information on the FileVault status of a machine
Example: If Available | Fully Secure | Status",1,1326015223,0,817,1,Jim Olsen,900,0,defined,Tanium,2015-01-05T20:22:05,FileVault Details,,,,,,,,,Windows,"&#039; THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
&#039; 
&#039; 

WScript.Echo &quot;N/A on Windows&quot;",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh
# 
# Sensor that goes through the current status of the drives via diskutil,
# and outputs the current FileVault status


CORESTORAGESTATUS=&quot;/private/tmp/corestorage.txt&quot;
ENCRYPTSTATUS=&quot;/private/tmp/encrypt_status.txt&quot;
ENCRYPTDIRECTION=&quot;/private/tmp/encrypt_direction.txt&quot;

DEVICE_COUNT=`diskutil cs list | grep -E &quot;^CoreStorage logical volume groups&quot; | awk &#039;{print $5}&#039; | sed -e&#039;s/(//&#039;`

EGREP_STRING=&quot;&quot;
if [ &quot;$DEVICE_COUNT&quot; != &quot;1&quot; ]; then
  EGREP_STRING=&quot;^\| *&quot;
fi

osversionlong=`sw_vers -productVersion`
osvers=${osversionlong:3:1}
CONTEXT=`diskutil cs list | grep -E &quot;$EGREP_STRING\Encryption Context&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $3}&#039;`
ENCRYPTIONEXTENTS=`diskutil cs list | grep -E &quot;$EGREP_STRING\Has Encrypted Extents&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $4}&#039;`
ENCRYPTION=`diskutil cs list | grep -E &quot;$EGREP_STRING\Encryption Type&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $3}&#039;`
CONVERTED=`diskutil cs list | grep -E &quot;$EGREP_STRING\Size \(Converted\)&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $5, $6}&#039;`
SIZE=`diskutil cs list | grep -E &quot;$EGREP_STRING\Size \(Total\)&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $5, $6}&#039;`

# Checks to see if the OS on the Mac is 10.7 or 10.8.
# These older versions of mac OS do not have the ability to encrypt

if [[ ${osvers} -lt 7 ]]; then
  echo &quot;Not Available|No|None&quot;
fi



if [[ ${osvers} -ge 7 ]]; then
  diskutil cs list &gt;&gt; $CORESTORAGESTATUS
  
    # If the Mac is running 10.7 or 10.8, but not does not have
    # any CoreStorage volumes, the status is:
    # Not Enabled
    
    if grep -iE &#039;No CoreStorage&#039; $CORESTORAGESTATUS 1&gt;/dev/null; then
       echo &quot;Available|No|None&quot;
    fi
    
    if grep -iE &#039;Logical Volume Family&#039; $CORESTORAGESTATUS 1&gt;/dev/null; then

    # This section does 10.7-specific checking of the Mac&#039;s
    # FileVault 2 status

      if [ &quot;$CONTEXT&quot; = &quot;Present&quot; ]; then
        if [ &quot;$ENCRYPTION&quot; = &quot;AES-XTS&quot; ]; then
	      diskutil cs list | grep -E &quot;$EGREP_STRING\Conversion Status&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTSTATUS
		    if grep -iE &#039;Complete&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then 
		      echo &quot;Available|Yes|Encrypted&quot;
            else
		      if  grep -iE &#039;Converting&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then
		        diskutil cs list | grep -E &quot;$EGREP_STRING\Conversion Direction&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTDIRECTION
		          if grep -iE &#039;Forward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then
		            echo &quot;Available|No|Encrypting $CONVERTED of $SIZE&quot;
                  else
		            echo &quot;Available|No|Unknown&quot;
	              fi
               fi
             fi
        else
            if [ &quot;$ENCRYPTION&quot; = &quot;None&quot; ]; then
              diskutil cs list | grep -E &quot;$EGREP_STRING\Conversion Direction&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTDIRECTION
                if grep -iE &#039;Backward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then
                  echo &quot;Available|No|Decrypting $CONVERTED of $SIZE&quot;
                elif grep -iE &#039;-none-&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then
                  echo &quot;Available|No|Not Encrypted&quot;
                fi
            fi 
        fi
      fi  
fi
fi
    # This section does 10.8-specific checking of the Mac&#039;s
    # FileVault 2 status

      if [ &quot;$ENCRYPTIONEXTENTS&quot; = &quot;Yes&quot; ]; then
        if [ &quot;$ENCRYPTION&quot; = &quot;AES-XTS&quot; ]; then
	      diskutil cs list | grep -E &quot;$EGREP_STRING\Fully Secure&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTSTATUS
		    if grep -iE &#039;Yes&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then 
		      echo &quot;Available|Yes|Encrypted&quot;
            else
		      if  grep -iE &#039;No&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then
		        diskutil cs list | grep -E &quot;$EGREP_STRING\Conversion Direction&quot; | sed -e&#039;s/\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTDIRECTION
		          if grep -iE &#039;forward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then
		            echo &quot;Available|No|Encrypting $CONVERTED of $SIZE&quot;

                  else
		          if grep -iE &#039;backward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then
                  	    echo &quot;Available|No|Decrypting $CONVERTED of $SIZE&quot;
                          elif grep -iE &#039;-none-&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then
                            echo &quot;Available|No|Not Encrypted&quot;
	              fi
               fi
             fi
      fi  
fi
fi



# Remove the temp files created during the script

if [ -f /private/tmp/corestorage.txt ]; then
   rm /private/tmp/corestorage.txt
fi

if [ -f /private/tmp/encrypt_status.txt ]; then
   rm /private/tmp/encrypt_status.txt
fi

if [ -f /private/tmp/encrypt_direction.txt ]; then
   rm /private/tmp/encrypt_direction.txt
fi
",UnixShell,0,0,0,1,0,Availablity,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Fully Secure,String,0,1,2,Status,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
411,Operating System,2015-01-05T20:22:05,|,"Return details about loaded drivers
Example:
WIMMount|Stopped|C:\Windows\system32\drivers\wimmount.sys|6.3.9600.16384",1,1994896093,0,819,1,Jim Olsen,2700,,,,2015-01-05T20:22:05,Driver Details,,,,,,,,,Windows,"&#039;========================================
&#039; Driver Details
&#039;========================================
&#039; this sensor will return specific data about all drivers in the driver store
&#039; many columns are parsed, but only a few are output
&#039; set hash type to something valid (md5 or sha1) in order to enable hash output
&#039; which would change the column count

Option Explicit

On Error Resume Next
Dim strHashType
&#039; Either MD5 or SHA1. If neither, do not hash
&#039; requires IR tools to hash
&#039;strHashType = &quot;MD5&quot;
&#039;strHashType = &quot;SHA1&quot;
strHashType = &quot;None&quot;

Dim strCommand,objShell,objScriptExec,strDriverResults,results,line
Dim arrFields,strMName,strDName,strDesc,strDType,strStartMode,strState,strStatus,strAccStop
Dim strAccPause,strPP,strCode,strBSS,strLinkDate,strPath,strInit,strFixedPath
Dim strFindChr,strReplaceChr,strSep,bHasOutput,dictOut,strOut,strSystem32Location,objFSO
Dim dictFilesToHash,inputFile,bHashOutput,strHashOfDriver,strFileVersion

Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set dictFilesToHash = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; call the 64-bit driver query on a 64-bit machine when necessary
strSystem32Location = FixFileSystemRedirectionForPath(objFSO.GetSpecialFolder(1))

strCommand = &quot;cmd /c &quot;&amp;strSystem32Location&amp;&quot;\driverquery.exe /V /NH /FO CSV&quot;

Set objShell = CreateObject(&quot;WScript.Shell&quot;)
Set objScriptExec = objShell.Exec (strCommand)
strDriverResults = objScriptExec.StdOut.ReadAll

results = Split(strDriverResults, vbCrLf)

strFindChr = Chr(34)
strReplaceChr = &quot;&quot;

strSep = &quot;|&quot;

Set dictOut = CreateObject(&quot;Scripting.Dictionary&quot;)

bHasOutput = False
For Each line in results
	arrFields = Split(line, Chr(34)&amp;Chr(44))
	If UBound(arrFields) &gt;= 14 Then
		strMName = Replace(Trim(arrFields(0)),strFindChr,strReplaceChr)
		strDName = Replace(Trim(arrFields(1)),strFindChr,strReplaceChr)
		strDesc = Replace(Trim(arrFields(2)),strFindChr,strReplaceChr)
		strDType = Replace(Trim(arrFields(3)),strFindChr,strReplaceChr)
		strStartMode = Replace(Trim(arrFields(4)),strFindChr,strReplaceChr)
		strState = Replace(Trim(arrFields(5)),strFindChr,strReplaceChr)
		strStatus = Replace(Trim(arrFields(6)),strFindChr,strReplaceChr)
		strAccStop = Replace(Trim(arrFields(7)),strFindChr,strReplaceChr)
		strAccPause = Replace(Trim(arrFields(8)),strFindChr,strReplaceChr)
		strPP = Replace(Trim(arrFields(9)),strFindChr,strReplaceChr)
		strCode = Replace(Trim(arrFields(10)),strFindChr,strReplaceChr)
		strBSS = Replace(Trim(arrFields(11)),strFindChr,strReplaceChr)
		strLinkDate = Replace(Trim(arrFields(12)),strFindChr,strReplaceChr)
		strPath = Replace(Trim(arrFields(13)),strFindChr,strReplaceChr)
		strPath = Replace(strPath,&quot;\??\&quot;,&quot;&quot;) &#039;&#039; eliminate strange path chars
		strInit = Replace(Trim(arrFields(14)),strFindChr,strReplaceChr)
		strFixedPath = FixFileSystemRedirectionForPath(strPath)
		strFixedPath = LCase(strFixedPath) &#039; necessary for dict compare later
		strFileVersion = GetFileVersion(objFSO,strFixedPath)
		strOut = strDName &amp; strSep &amp; strState &amp; strSep &amp; strPath &amp; strSep &amp; strFileVersion
		If Not dictOut.Exists(strOut) Then
			dictOut.Add strOut,strFixedPath
			If Not dictFilesToHash.Exists(LCase(strFixedPath)) Then
				&#039; Default message is Cannot Hash if the IR tools are not installed properly or file cannot be hashed
				dictFilesToHash.Add LCase(strFixedPath),&quot;cannot hash&quot;
			End If
			bHasOutput = True
		End If
	End If
Next

strHashType = LCase(strHashType)
If strHashType = &quot;md5&quot; Or strHashType = &quot;sha1&quot; Then
	inputFile = GetTaniumDir(&quot;Tools\IR&quot;) &amp; &quot;driver-details-with-hash-&quot;&amp;strHashType&amp;&quot;.xml&quot;
	&#039;delete potential previous input file on entry
	On Error Resume Next
	If objFSO.FileExists(inputFile) Then
		objFSO.DeleteFile inputFile, True
	End If
	On Error Goto 0
	CreateXmlInputFileByHashType dictFilesToHash,inputFile,strHashType
	&#039; add the hash of the files to the files to hash dictionary
	AddHashToHashesDictFromMD5Output inputFile,dictFilesToHash,strHashType
	On Error Resume Next
	&#039;delete potential previous input file on entry
	If objFSO.FileExists(inputFile) Then
		objFSO.DeleteFile inputFile, True
	End If
	On Error Goto 0
End If

If Not bHasOutput Then
	WScript.echo  &quot;Error: driver data cannot be interpreted&quot;
Else
bHashOutput = False
If strHashType = &quot;md5&quot; Or strHashType = &quot;sha1&quot; Then bHashOutput = True
	For Each strOut In dictOut.Keys
		If bHashOutput Then
			If dictFilesToHash.Exists(dictOut.Item(strOut)) Then
				strHashOfDriver = dictFilesToHash.Item(dictOut.Item(strOut))
			Else
				strHashOfDriver = &quot;unknown&quot;
			End If
			WScript.Echo strOut &amp; strSep &amp; strHashOfDriver
		Else
			WScript.Echo strOut
		End If
	Next
End If


Function GetFileVersion(ByRef fso, strPath)
	Dim strVersion
	If fso.FileExists(strPath) Then
		On Error Resume Next
		strVersion = fso.GetFileVersion(strPath)
		On Error Goto 0
		If strVersion = &quot;&quot; Then
			strVersion = &quot;Version not found&quot;
		End If
	Else 
		strVersion = &quot;File not found&quot;
	End If

	GetFileVersion = strVersion
End Function &#039;GetFileVersion

Function FixFileSystemRedirectionForPath(ByVal strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,strWindowsLocation,objShell
	Dim strProgramFilesx86
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strWindowsLocation = LCase(objFSO.GetSpecialFolder(0))
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strFilePath = Replace(strFilePath,&quot;system32&quot;,&quot;sysnative&quot;)
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath

Function UnFixFileSystemRedirectionForPath(strFilePath)
&#039; This function will undo the changes made to a path by the 
&#039; FixFileSystemRedirectionForPath function
&#039; if a path is passed in with the sysnative string in it
&#039; it will simply change it to system32, regardless of whether
&#039; the OS is 64-bit.  A path will only be changed when it&#039;s
&#039; necessary, so this has no effect when it&#039;s not changed.

	Dim objFSO,strSystem32Location,strNewSystem32Location
	
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	
	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
	
	UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;UnFixFileSystemRedirectionForPath

Function CreateXmlInputFileByHashType(fileStrings, inputFileName, strHashType)
	If Not (strHashType = &quot;md5&quot; Or strHashType = &quot;sha1&quot;) Then
		WScript.Echo &quot;Invalid hash type: &quot; &amp; strHashType&amp; &quot;, Quitting&quot;
		WScript.Quit
	End If
	Dim masterXmlDom
	Set masterXmlDom = CreateObject(&quot;Msxml2.DOMDocument&quot;)
    masterXmlDom.Async = false
	
	Dim oFSO, oExistingTextFile, existingXML
	Set oFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
		
	Dim pi
	Set pi = masterXmlDom.createProcessingInstruction(&quot;xml&quot;, &quot;version=&#039;1.0&#039; encoding=&#039;UTF-8&#039;&quot;)
	masterXmlDom.insertBefore pi, masterXmlDom.firstChild
	
	Dim fcivElement
	Set fcivElement = masterXmlDom.createElement(&quot;FCIV&quot;)
	masterXmlDom.appendChild fcivElement
	
	Dim fPath, fileEntryElement, nameElement, hashtypeElement
	For Each fPath In fileStrings
		fPath = FixFileSystemRedirectionForPath(fPath)
		
		Set fileEntryElement = masterXmlDom.createElement(&quot;FILE_ENTRY&quot;)
		fcivElement.appendChild fileEntryElement
		
		Set nameElement = masterXmlDom.createElement(&quot;name&quot;)
		nameElement.text = fPath
		fileEntryElement.appendChild nameElement
		
		Set hashtypeElement = masterXmlDom.createElement(UCase(strHashType))
		fileEntryElement.appendChild hashtypeElement
	Next	
	&#039;WScript.Echo &quot;Current XML: &quot; &amp; masterXmlDom.xml
	masterXmlDom.save(inputFileName)
	
End Function &#039;CreateXmlInputFileByHashType

Function AddHashToHashesDictFromMD5Output(inputFileName,ByRef dictFilesToHash,strHashType)
&#039; takes a dictionary of files to hash, adds their hash to the file. Carefully consdier
&#039; whether the path is fixed for file system redirection

	Dim objShell, objExec, bErr
	Dim strLine,arrLine,strErrFile,intHashLength,strHasherPath
		
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)

	&#039; Ensure file exists
	If Not objFSO.FileExists(inputFileName) Then
		WScript.Echo &quot;Error: XML input file not written&quot;
		&#039;Cleanup and exit
		Set objShell = Nothing
		Set objFSO = Nothing
		Exit Function
	End If
	
	&#039; Ensure utility exists
	strHasherPath = GetTaniumDir(&quot;Tools\IR&quot;) &amp; &quot;fciv.exe&quot;
	If Not objFSO.FileExists(strHasherPath) Then
		WScript.Echo &quot;Error: Could not locate hash utility, ensure machine has Tanium IR tools&quot;
		&#039;Cleanup and exit
		Set objShell = Nothing
		Set objFSO = Nothing
		Exit Function
	End If
	
	strHashType = LCase(strHashType) &#039; must be md5 or sha1
	Select Case strHashType
		Case &quot;md5&quot;
			intHashLength = 32
		Case &quot;sha1&quot;
			intHashLength = 40
		Case Else
			WScript.Echo &quot;Invalid hash type: &quot; &amp;strHashType&amp;&quot;, quitting&quot;
			WScript.Quit
	End Select

	Set objExec = objShell.Exec(Chr(34)&amp;strHasherPath&amp;Chr(34)&amp; &quot; -v -&quot;&amp;strHashType&amp;&quot; -xml &quot; &amp; Chr(34)&amp;inputFileName&amp;Chr(34))
	&#039; examine output
	Dim fName, fHex
	While objExec.StdOut.AtEndOfStream &lt;&gt; True
		strLine = LCase(Trim(objExec.StdOut.ReadLine))

		If Len(strLine) &gt; 2 Then strLine = Left(strLine, Len(strLine)-2) &#039;adjust for 2 invisible characters at end of line
		
		&#039;Start processesing on lines that are file names
		&#039;This is based on the second character being a :, such as C: or D:
		If Mid(strLine,2,1) = &quot;:&quot; Then
			fName = strLine
			objExec.StdOut.SkipLine
			strLine = LCase(Trim(objExec.StdOut.ReadLine))
			If Len(strLine) &gt; 0 Then strLine = Left(strLine, Len(strLine)-1) &#039;adjust for 1 invisible character at end of line
			fHex = Right(strLine,intHashLength)
			If dictFilesToHash.Exists(fName) Then
				dictFilesToHash.Item(fName) = fHex
				&#039; WScript.Echo fName&amp;strSep&amp;fHex
			End If
		End If
	Wend

	strErrFile = GetTaniumDir(&quot;Tools\IR&quot;) &amp; &quot;fciv.err&quot;
	If objFSO.FileExists(strErrFile) Then
		objFSO.DeleteFile strErrFile, True
	End If
End Function &#039;AddHashToHashesDictFromMD5Output


Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath",VBScript,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# 
# 

echo &quot;N/A on Mac&quot;
",UnixShell,0,0,0,1,0,Display Name,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,State,String,0,1,2,Path,String,0,1,3,Version,Version,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
412,,,",",,1,3478889353,0,4294967295,1,,900,,,,,Number of Application Crashes in Last X Days[5],"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||days||,5,,,,,,Windows,"&#039;========================================
&#039; Number of Application Crashes in Last X Days
&#039;========================================

Option Explicit
Dim strSep
Dim objWMIService, colEvents, objEvent
Dim dtmStart

strSep = &quot;|&quot;

&#039;Uses date math - set locale

SetLocale(1033)


dtmStart = GetTimeWrittenByDaysOld(5)

Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\.\root\cimv2&quot;) 

Set colEvents = objWMIService.ExecQuery _
    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _
        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _
        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)

Dim numCrashes
numCrashes = 0

For Each objEvent In colEvents
    Dim strMessage, arrLines, strLine, strApp, strModule, strTime
    
    strMessage = objEvent.Message
    arrLines = Split(strMessage, vbCrLf)
    
    Dim strIndex, strIndexXp

	&#039;just go through first line of log to grab app name
	strLine = arrLines(0)
	
	&#039;strIndex is for new OSes, strIndexXP for older...
	strIndex = &quot;Faulting application name: &quot;
	strIndexXp = &quot;Faulting application &quot;
	If Left(strLine, Len(strIndex)) = strIndex Then
		strApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)
	ElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then
		strApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)
	End If
	
    strTime = DatetimeToDate(objEvent.TimeWritten)
    	 
	If Not IsNull(strApp) And Not IsEmpty(strApp) Then
		numCrashes = numCrashes + 1
	End If
Next

WScript.Echo numCrashes

Function DatetimeToDate(strDate)
   DatetimeToDate = _
       CDate(Mid(strDate, 5, 2) &amp; _
       &quot;/&quot; &amp; _
       Mid(strDate, 7, 2) &amp; _
       &quot;/&quot; &amp; _
       Left(strDate, 4) &amp; _
       &quot; &quot; &amp; _
       Mid (strDate, 9, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 11, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 13, 2))
End Function

Function GetTimeWrittenByDaysOld(days)
   &#039;subtract &quot;days&quot; days worth of seconds

	Dim epoc, monthAgo   
   	epoc = date2epoch(Now()) - days*24*60*60
   	monthAgo = epoch2date(epoc)
   
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate monthAgo, True
	 
  	GetTimeWrittenByDaysOld = dateTime
End Function

function date2epoch(myDate)
   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)
end Function

function epoch2date(myEpoch)
   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)
end Function",VBScript,,,,,,,175,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
413,,,",",,1,3478888048,0,4294967294,1,,900,,,,,Linux:tempsensor_1,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||days||,5,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,175,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
414,,,|,,1,3478888483,0,4294967293,1,,900,,,,,Application Crashes in Last X Days[5],"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||days||,5,,,,,,Windows,"&#039;========================================
&#039; Application Crashes in Last X Days
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit
Dim strSep
Dim objWMIService, colEvents, objEvent, intCount
Dim dtmStart

strSep = &quot;|&quot;
intCount = 0

&#039;Uses date math - set locale

SetLocale(1033)

dtmStart = GetTimeWrittenByDaysOld(5)
&#039;dtmStart = GetTimeWrittenByDaysOld(7)

Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\.\root\cimv2&quot;) 

Set colEvents = objWMIService.ExecQuery _
    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _
        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _
        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)

For Each objEvent In colEvents
    Dim strMessage, arrLines, strLine, strApp, strModule, strTime
    
    strMessage = objEvent.Message
    arrLines = Split(strMessage, vbCrLf)
    
    Dim strIndex, strIndexXp

	&#039;just go through first line of log to grab app name
	strLine = arrLines(0)
	
	&#039;strIndex is for new OSes, strIndexXP for older...
	strIndex = &quot;Faulting application name: &quot;
	strIndexXp = &quot;Faulting application &quot;
	If Left(strLine, Len(strIndex)) = strIndex Then
		strApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)
	ElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then
		strApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)
	End If
	
    strTime = DatetimeToDate(objEvent.TimeWritten)
    
    Dim strDate, arrTemp
    arrTemp = Split(strTime)
    strDate = arrTemp(0)
	WScript.Echo strApp &amp; strSep &amp; strDate
	intCount = intCount + 1
Next

If intCount = 0 Then
	WScript.Echo &quot;No Application Crashes Found&quot; &amp; strSep
End if

Function DatetimeToDate(strDate)
   DatetimeToDate = _
       CDate(Mid(strDate, 5, 2) &amp; _
       &quot;/&quot; &amp; _
       Mid(strDate, 7, 2) &amp; _
       &quot;/&quot; &amp; _
       Left(strDate, 4) &amp; _
       &quot; &quot; &amp; _
       Mid (strDate, 9, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 11, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 13, 2))
End Function

Function GetTimeWrittenByDaysOld(days)
   &#039;subtract &quot;days&quot; days worth of seconds

	Dim epoc, monthAgo   
   	epoc = date2epoch(Now()) - days*24*60*60
   	monthAgo = epoch2date(epoc)
   
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate monthAgo, True
	 
  	GetTimeWrittenByDaysOld = dateTime
End Function

function date2epoch(myDate)
   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)
end Function

function epoch2date(myEpoch)
   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)
end Function
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,,,,,,,283,0,0,1,0,Process,String,,,,,,,,,,,,,,,,,,,,,,,,,,1,1,1,Date,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
415,,,|,,1,3478890658,0,4294967292,1,,900,,,,,Linux:tempsensor_3,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||days||,5,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,283,0,0,1,0,Process,String,,,,,,,,,,,,,,,,,,,,,,,,,,1,1,1,Date,String,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
416,,,",",,1,3478891093,0,4294967291,1,,900,,,,,Last System Crash in X Days[7],"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query and return system crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""dayThresh"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||dayThresh||,7,,,,,,Windows,"&#039;========================================
&#039; Last System Crash in X Days
&#039;========================================

dayThresh = LCase(Trim(Unescape(&quot;7&quot;)))
&#039;dayThresh = LCase(Trim(Unescape(&quot;1&quot;)))
If Not IsNumeric(dayThresh) Then 
    WScript.Echo &quot;Parameter Not Number&quot;
    WScript.Quit
End If 
dayThresh = Cint(dayThresh)

Dim strValueName, strKey

strValueName = &quot;DumpFile&quot;
strDumpsDirName = &quot;MinidumpDir&quot;

strKey = &quot;SYSTEM\CurrentControlSet\Control\CrashControl&quot;

Set objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv&quot;)
Const HKLM = &amp;h80000002

&#039;Uses date math - set locale

SetLocale(GetTaniumLocale)

Dim fso
Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)

&#039;Get main dump file
Dim mainDumpDate
If RegKeyExists(objReg, HKLM, strKey) Then
	objReg.GetExpandedStringValue HKLM, strKey, strValueName, strValue

	If fso.FileExists(strValue) Then
		
		Set objFile = fso.GetFile(strValue)
		mainDumpDate = objfile.DateLastModified
	End If
Else
	WScript.Echo &quot;Error, Dump key not found: HKLM\SYSTEM\CurrentControlSet\Control\CrashControl&quot;
End If


&#039;Examine minidump folder
Dim newestMini

If RegKeyExists(objReg, HKLM, strKey) Then
	objReg.GetExpandedStringValue HKLM, strKey, strDumpsDirName, strDumpDir

	If fso.FolderExists(strDumpDir) Then
		Set oFolder = fso.GetFolder(strDumpDir)
		For Each sFile In oFolder.Files
		    If newestMini = &quot;&quot; Then
		        Set newestMini = sFile
		    Else
		        If newestMini.DateLastModified &lt; sFile.DateLastModified Then
		          Set newestMini = sFile
		        End If
		    End If
		Next
	End If
End If



If newestMini = &quot;&quot; And mainDumpDate = &quot;&quot; Then
	WScript.Echo &quot;No system crashes found&quot;
	WScript.Quit
End If

Dim responseDate
If newestMini = &quot;&quot; Then	
	responseDate = mainDumpDate
ElseIf mainDumpDate = &quot;&quot; Then
	responseDate = newestMini.DateLastModified
Else
	If newestMini.DateLastModified &lt; mainDumpDate Then
		responseDate = mainDumpDate
	Else
		responseDate = newestMini.DateLastModified	
	End If
End If

current = Now()
dayDiff = DateDiff(&quot;d&quot;, responseDate, current)

Dim arrTemp
If dayDiff &lt;= dayThresh Then
	arrTemp = Split(responseDate)
	responseDate = arrTemp(0)

	WScript.Echo responseDate
Else 
	WScript.Echo &quot;No system crashes in day range&quot;
End If	

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale",VBScript,,,,,,,281,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
417,,,",",,1,3478889788,0,4294967290,1,,900,,,,,Linux:tempsensor_5,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query and return system crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""dayThresh"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||dayThresh||,7,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 7  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 7  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,281,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
418,,,",",,1,3478890223,0,4294967289,1,,600,,,,,High Memory Processes[5],"{""parameters"":[{""maximum"":50,""stepSize"":1,""helpString"":""Enter the number of processes to return"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Processes"",""minimum"":1,""key"":""numOutput"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||numOutput||,5,,,,,,Windows,"&#039;========================================
&#039; High Memory Processes
&#039;========================================

topNum = Trim(Unescape(&quot;5&quot;))
If Not IsNumeric(topNum) Then 
	WScript.Echo &quot;Parameter Not Number&quot;
	WScript.Quit
End If 
topNum = Cint(topNum)

printMemory = false

Dim objWMIService, objItem, colItems, query
Dim strComputer, strList


strComputer = &quot;.&quot;
Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\&quot; &amp; strComputer&amp; &quot;\root\cimv2&quot;)

Const MaxCharacters = 255
Const adBSTR = 8 
Const adDouble = 5
Set DataList = CreateObject(&quot;ADOR.Recordset&quot;)
DataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters
DataList.Fields.Append &quot;ProcessMemory&quot;, adDouble

DataList.Open

Set colProcs = objWMIService.ExecQuery(&quot;Select Name, WorkingSetSize From Win32_Process&quot;)
For Each proc in colProcs
   DataList.AddNew
   DataList(&quot;ProcessName&quot;) = proc.Name
   DataList(&quot;ProcessMemory&quot;) = round(cdbl(proc.WorkingSetSize)/1024/1024, 0)
   DataList.Update
Next
DataList.Sort = &quot;ProcessMemory DESC&quot;
DataList.MoveFirst
i = 1
Do Until DataList.EOF Or i &gt; topNum
   Set field = DataList.Fields
   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))
   If printMemory Then
      strPrint = strPrint &amp; &quot; (&quot; &amp; DataList.Fields.Item(&quot;ProcessMemory&quot;) &amp; &quot; Mb)&quot;
   End if   
   WScript.Echo strPrint
   DataList.MoveNext
   i = i + 1
Loop

WScript.Quit

&#039;removes .exe and process number at end of process
Function CleanString(str)
	words = Split(str, &quot;#&quot;)
	str = words(0)

	If Right(str, 4) = &quot;.exe&quot; Then
		str = Left(str, Len(str) - 4)
	End If 
	CleanString = str
End Function",VBScript,,,,,,,257,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
419,,,",",,1,3478892398,0,4294967288,1,,600,,,,,Linux:tempsensor_7,"{""parameters"":[{""maximum"":50,""stepSize"":1,""helpString"":""Enter the number of processes to return"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Processes"",""minimum"":1,""key"":""numOutput"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||numOutput||,5,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,257,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
420,,,",",,1,3478892833,0,4294967287,1,,600,,,,,High CPU Processes[5],"{""parameters"":[{""maximum"":50,""stepSize"":1,""helpString"":""Enter the number of processes to return"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Processes"",""minimum"":1,""key"":""numOutput"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||numOutput||,5,,,,,,Windows,"&#039;========================================
&#039; High CPU Processes
&#039;========================================

topNum = Trim(Unescape(&quot;5&quot;))
If Not IsNumeric(topNum) Then 
	WScript.Echo &quot;Parameter Not Number&quot;
	WScript.Quit
End If 
topNum = Cint(topNum)

printPercent = false
Const HKLM = &amp;H80000002 
strComputer = &quot;.&quot;

Set objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\Root\Cimv2&quot;)

Const MaxCharacters = 255
Const adBSTR = 8 
Const adDouble = 5

Set DataList = CreateObject(&quot;ADOR.Recordset&quot;)
DataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters
DataList.Fields.Append &quot;ProcessCPU1&quot;, adDouble
DataList.Fields.Append &quot;ProcessCPU2&quot;, adDouble
DataList.Fields.Append &quot;ProcessCPUDiff&quot;, adDouble
DataList.Open

Dim total1, total2, totalDiff

Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   
For Each objItem in colProcItems
   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then
      DataList.AddNew
      DataList(&quot;ProcessName&quot;) = objItem.Name
      DataList(&quot;ProcessCPU1&quot;) = objItem.PercentProcessorTime
      DataList.Update
   ElseIf objItem.Name = &quot;_Total&quot; Then 
      total1 = CDbl(objItem.PercentProcessorTime)
   End If
Next

sleep = 5
WScript.Sleep(sleep * 1000)

Set colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   
For Each objItem in colProcItems
   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then
      
      DataList.MoveFirst
      DataList.Find(&quot;ProcessName = &#039;&quot;&amp; objItem.Name&amp;&quot;&#039;&quot;)

      If DataList.EOF Then
              WScript.Echo &quot;** Not Found **&quot;
      Else
         DataList(&quot;ProcessCPU2&quot;) = objItem.PercentProcessorTime
         DataList(&quot;ProcessCPUDiff&quot;) = DataList(&quot;ProcessCPU2&quot;) - DataList(&quot;ProcessCPU1&quot;)
         DataList.Update
           &#039;WScript.Echo &quot;name: &quot; &amp; DataList.Fields.Item(&quot;ProcessName&quot;) &amp; &quot;, cpu 1: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU1&quot;) &amp; &quot;, cpu 2: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU2&quot;)
      End if
   ElseIf objItem.Name = &quot;_Total&quot; Then 
      total2 = CDbl(objItem.PercentProcessorTime)
      totalDiff = total2 - total1
   End If
Next

DataList.Sort = &quot;ProcessCPUDiff DESC&quot;
DataList.MoveFirst
i = 1
Do Until DataList.EOF  Or i &gt; topNum
   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))
   If printPercent Then
      strPrint = strPrint &amp; &quot; (&quot; &amp; Round(DataList.Fields.Item(&quot;ProcessCPUDiff&quot;) / totalDiff * 100, 0) &amp; &quot;%)&quot;
   End if   
   WScript.Echo strPrint
   DataList.MoveNext
   i = i + 1
Loop

WScript.Quit

&#039;removes .exe and process number at end of 
Function CleanString(str)
	words = Split(str, &quot;#&quot;)
	str = words(0)
	CleanString = str

	If Right(str, 4) = &quot;.exe&quot; Then
		str = Left(str, Len(str) - 4)
	End If 
End Function",VBScript,,,,,,,255,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
421,,,",",,1,1488401243,0,4294967286,1,,600,,,,,Linux:tempsensor_9,"{""parameters"":[{""maximum"":50,""stepSize"":1,""helpString"":""Enter the number of processes to return"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Processes"",""minimum"":1,""key"":""numOutput"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||numOutput||,5,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 5  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,255,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
422,,,|,,1,1488400808,0,4294967285,1,,600,,,,,Patch Failures[Yes],"{""parameters"":[{""helpString"":""Enter Yes, or No, to return failures for applicable patches only"",""value"":"""",""promptText"":""Yes/No"",""defaultValue"":"""",""requireSelection"":true,""label"":""Show failures only for needed patches"",""key"":""ShowOnlyIfApplicable"",""values"":[""Yes"",""No""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||ShowOnlyIfApplicable||,Yes,,,,,,Windows,"&#039;========================================
&#039; Patch Failures
&#039;========================================

&#039; sensor: patch failures
&#039; paramterized sensor which can show failures for all patches
&#039; or only for patches which are failed but necessary

Option Explicit

Const FORREADING = 1

Dim objFSO,objTextFile
Dim dictHistory
Dim strScanDir
Dim strHistoryTextReadableFilePath
Dim strSep : strSep = &quot;|&quot;
Dim strLine,arrLine,strGUID,strCVE
Dim strTitle,strKB,strBulletin,strDate,strException,strSeverity
Dim dictResults,bShowOnlyIfApplicable,strShowOnlyIfApplicable
Dim strResultsReadableFilePath,strInstallStatus,strTaniumPatchID

&#039; take parameter
strShowOnlyIfApplicable=Trim(Unescape(&quot;Yes&quot;))

Select Case LCase(strShowOnlyIfApplicable)
	Case &quot;yes&quot;
		bShowOnlyIfApplicable = True
	Case &quot;true&quot;
		bShowOnlyIfApplicable = True
	Case &quot;no&quot;
		bShowOnlyIfApplicable = False
	Case &quot;false&quot;
		bShowOnlyIfApplicable = False
	Case &quot;&quot;
		bShowOnlyIfApplicable = True
	Case Else
		WScript.Echo &quot;Parameter must be Yes or No, Quitting&quot;
		WScript.Quit
End Select


Set objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)
strScanDir = GetTaniumDir(&quot;Tools\Scans&quot;)

strHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;
strResultsReadableFilePath = strScanDir&amp;&quot;patchresultsreadable.txt&quot;

If Not objFSO.FileExists(strHistoryTextReadableFilePath) Then
	WScript.Echo &quot;Cannot find History file&quot;
	Set objFSO = Nothing
	WScript.Quit
End If

&#039;uses date math, may need locale set
SetLocale(GetTaniumLocale)

Set dictHistory = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; read History into dictionary
Set objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)
While objTextFile.AtEndOfStream = False
	strLine = objTextFile.ReadLine
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
		If UBound(arrLine) &gt; 0 Then
			If Not dictHistory.Exists(strLine) Then
				dictHistory.Add strLine,1
			End If
		Else
			&#039; WScript.Echo &quot;Error parsing results file&quot;
		End If
	Else
		&#039; WScript.Echo &quot;Error parsing results file&quot;
	End If
Wend
objTextFile.Close

Set dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)
If bShowOnlyIfApplicable Then
	&#039; We will tie the GUID in history to the GUID here - if it exists in patch results and if it says
	&#039; not installed, only then will we write it
	&#039; Read results into dictionary
	Set objTextFile = objFSO.OpenTextFile(strResultsReadableFilePath,FORREADING)
	While objTextFile.AtEndOfStream = False
		strLine = objTextFile.ReadLine
		&#039; WScript.Echo strLIne 
		&#039;element 5 must be not installed
		arrLine = Split(strLine,strSep)
		If IsArray(arrLine) Then
			If UBound(arrLine) &gt; 0 Then
				&#039; pull GUID to use as key
				strGUID = arrLine(7)
				If Not (UBound(arrLine) &gt; 4 And dictResults.Exists(strGUID)) Then
					dictResults.Add strGUID,strLine
				End If
			Else
				&#039; WScript.Echo &quot;Error parsing results file&quot;
			End If
		Else
			&#039; WScript.Echo &quot;Error parsing results file&quot;
		End If
	Wend
	objTextFile.Close
End If


Dim strkey

For Each strkey In dictHistory.Keys
	&#039; WScript.Echo dictHistory.Item(strkey)
	strLine = strkey
	&#039; 13 History Columns
	&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|PatchID
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
		If UBound(arrLine) &gt; 11 Then
			If LCase(arrLine(1)) = &quot;installation&quot; And LCase(arrLine(2)) = &quot;failed&quot; Then
				&#039; install failure
				&#039; report title, kb, bulletin, date, and exception
				strGUID = arrLine(0)
				strTitle=arrLine(6)
				strKB=arrLine(10)
				strBulletin=arrLine(9)
				strCVE = arrLine(11)
				On Error Resume Next
				&#039; Convert from UTC to Local and show only the date
				strDate = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)
				If Err.Number &lt;&gt; 0 Then
					strDate = &quot;Unknown&quot;
					Err.Clear
				End If
				On Error Goto 0
				strException=arrLine(3)
				strSeverity=arrLine(8)
				If UBound(arrLine) &gt; 12 Then
					strTaniumPatchID=arrLine(13)
				Else
					strTaniumPatchID=&quot;Unknown&quot;
				End If
				If bShowOnlyIfApplicable Then
					If dictResults.Exists(strGUID) Then
						strInstallStatus = Split(dictResults.Item(strGUID),&quot;|&quot;)(6)
						If LCase(strInstallStatus) = &quot;not installed&quot; Then
							WScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _
								&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _
								&amp;strSep&amp;strTaniumPatchID
						End If
					End If
				Else
					WScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _
						&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _
						&amp;strSep&amp;strTaniumPatchID
				End If
			End If
		Else
			&#039; WScript.Echo &quot;History Line malformed - needs 11 fields&quot;
		End If
	Else
		&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable
	End If
Next

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale

Function GetTZBias
&#039; This functiong returns the number of minutes
&#039; (positive or negative) to add to current time to get UTC
&#039; considers daylight savings

	Dim objLocalTimeZone, intTZBiasInMinutes


	For Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)
		intTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone
	Next

	GetTZBias = intTZBiasInMinutes
		
End Function &#039;GetTZBias",VBScript,,,,,,,233,0,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Error,String,0,1,2,Date,String,0,1,3,KB Article,String,0,1,4,Bulletin ID,String,0,1,5,Severity,String,0,1,6,Tanium Patch ID,String,,,,,,,,,,,,,,,,String
423,,,|,,1,1488402113,0,4294967284,1,,600,,,,,Linux:tempsensor_11,"{""parameters"":[{""helpString"":""Enter Yes, or No, to return failures for applicable patches only"",""value"":"""",""promptText"":""Yes/No"",""defaultValue"":"""",""requireSelection"":true,""label"":""Show failures only for needed patches"",""key"":""ShowOnlyIfApplicable"",""values"":[""Yes"",""No""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||ShowOnlyIfApplicable||,Yes,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# Yes  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# Yes  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,233,91426,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Error,String,0,1,2,Date,String,0,1,3,KB Article,String,0,1,4,Bulletin ID,String,0,1,5,Severity,String,0,1,6,Tanium Patch ID,String,,,,,,,,,,,,,,,,String
424,,,|,,1,1488401678,0,4294967283,1,,600,,,,,Patch Failures[Yes],"{""parameters"":[{""helpString"":""Enter Yes, or No, to return failures for applicable patches only"",""value"":"""",""promptText"":""Yes/No"",""defaultValue"":"""",""requireSelection"":true,""label"":""Show failures only for needed patches"",""key"":""ShowOnlyIfApplicable"",""values"":[""Yes"",""No""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||ShowOnlyIfApplicable||,Yes,,,,,,Windows,"&#039;========================================
&#039; Patch Failures
&#039;========================================

&#039; sensor: patch failures
&#039; paramterized sensor which can show failures for all patches
&#039; or only for patches which are failed but necessary

Option Explicit

Const FORREADING = 1

Dim objFSO,objTextFile
Dim dictHistory
Dim strScanDir
Dim strHistoryTextReadableFilePath
Dim strSep : strSep = &quot;|&quot;
Dim strLine,arrLine,strGUID,strCVE
Dim strTitle,strKB,strBulletin,strDate,strException,strSeverity
Dim dictResults,bShowOnlyIfApplicable,strShowOnlyIfApplicable
Dim strResultsReadableFilePath,strInstallStatus,strTaniumPatchID

&#039; take parameter
strShowOnlyIfApplicable=Trim(Unescape(&quot;Yes&quot;))

Select Case LCase(strShowOnlyIfApplicable)
	Case &quot;yes&quot;
		bShowOnlyIfApplicable = True
	Case &quot;true&quot;
		bShowOnlyIfApplicable = True
	Case &quot;no&quot;
		bShowOnlyIfApplicable = False
	Case &quot;false&quot;
		bShowOnlyIfApplicable = False
	Case &quot;&quot;
		bShowOnlyIfApplicable = True
	Case Else
		WScript.Echo &quot;Parameter must be Yes or No, Quitting&quot;
		WScript.Quit
End Select


Set objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)
strScanDir = GetTaniumDir(&quot;Tools\Scans&quot;)

strHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;
strResultsReadableFilePath = strScanDir&amp;&quot;patchresultsreadable.txt&quot;

If Not objFSO.FileExists(strHistoryTextReadableFilePath) Then
	WScript.Echo &quot;Cannot find History file&quot;
	Set objFSO = Nothing
	WScript.Quit
End If

&#039;uses date math, may need locale set
SetLocale(GetTaniumLocale)

Set dictHistory = CreateObject(&quot;Scripting.Dictionary&quot;)

&#039; read History into dictionary
Set objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)
While objTextFile.AtEndOfStream = False
	strLine = objTextFile.ReadLine
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
		If UBound(arrLine) &gt; 0 Then
			If Not dictHistory.Exists(strLine) Then
				dictHistory.Add strLine,1
			End If
		Else
			&#039; WScript.Echo &quot;Error parsing results file&quot;
		End If
	Else
		&#039; WScript.Echo &quot;Error parsing results file&quot;
	End If
Wend
objTextFile.Close

Set dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)
If bShowOnlyIfApplicable Then
	&#039; We will tie the GUID in history to the GUID here - if it exists in patch results and if it says
	&#039; not installed, only then will we write it
	&#039; Read results into dictionary
	Set objTextFile = objFSO.OpenTextFile(strResultsReadableFilePath,FORREADING)
	While objTextFile.AtEndOfStream = False
		strLine = objTextFile.ReadLine
		&#039; WScript.Echo strLIne 
		&#039;element 5 must be not installed
		arrLine = Split(strLine,strSep)
		If IsArray(arrLine) Then
			If UBound(arrLine) &gt; 0 Then
				&#039; pull GUID to use as key
				strGUID = arrLine(7)
				If Not (UBound(arrLine) &gt; 4 And dictResults.Exists(strGUID)) Then
					dictResults.Add strGUID,strLine
				End If
			Else
				&#039; WScript.Echo &quot;Error parsing results file&quot;
			End If
		Else
			&#039; WScript.Echo &quot;Error parsing results file&quot;
		End If
	Wend
	objTextFile.Close
End If


Dim strkey

For Each strkey In dictHistory.Keys
	&#039; WScript.Echo dictHistory.Item(strkey)
	strLine = strkey
	&#039; 13 History Columns
	&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|PatchID
	arrLine = Split(strLine,strSep)
	If IsArray(arrLine) Then
		If UBound(arrLine) &gt; 11 Then
			If LCase(arrLine(1)) = &quot;installation&quot; And LCase(arrLine(2)) = &quot;failed&quot; Then
				&#039; install failure
				&#039; report title, kb, bulletin, date, and exception
				strGUID = arrLine(0)
				strTitle=arrLine(6)
				strKB=arrLine(10)
				strBulletin=arrLine(9)
				strCVE = arrLine(11)
				On Error Resume Next
				&#039; Convert from UTC to Local and show only the date
				strDate = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)
				If Err.Number &lt;&gt; 0 Then
					strDate = &quot;Unknown&quot;
					Err.Clear
				End If
				On Error Goto 0
				strException=arrLine(3)
				strSeverity=arrLine(8)
				If UBound(arrLine) &gt; 12 Then
					strTaniumPatchID=arrLine(13)
				Else
					strTaniumPatchID=&quot;Unknown&quot;
				End If
				If bShowOnlyIfApplicable Then
					If dictResults.Exists(strGUID) Then
						strInstallStatus = Split(dictResults.Item(strGUID),&quot;|&quot;)(6)
						If LCase(strInstallStatus) = &quot;not installed&quot; Then
							WScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _
								&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _
								&amp;strSep&amp;strTaniumPatchID
						End If
					End If
				Else
					WScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _
						&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _
						&amp;strSep&amp;strTaniumPatchID
				End If
			End If
		Else
			&#039; WScript.Echo &quot;History Line malformed - needs 11 fields&quot;
		End If
	Else
		&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable
	End If
Next

Function GetTaniumDir(strSubDir)
&#039;GetTaniumDir with GeneratePath, works in x64 or x32
&#039;looks for a valid Path value
	
	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;HKLM\Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
  	End If
  	
  	If Not strPath = &quot;&quot; Then
		If strSubDir &lt;&gt; &quot;&quot; Then
			strSubDir = &quot;\&quot; &amp; strSubDir
		End If	
	
		Dim fso
		Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)
		If fso.FolderExists(strPath) Then
			If Not fso.FolderExists(strPath &amp; strSubDir) Then
				&#039;&#039;Need to loop through strSubDir and create all sub directories
				GeneratePath strPath &amp; strSubDir, fso
			End If
			GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\&quot;
		Else
			&#039; Specified Path doesn&#039;t exist on the filesystem
			WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;
			GetTaniumDir = False
		End If
	Else
		WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;
		GetTaniumDir = False
	End If
End Function &#039;GetTaniumDir

Function GeneratePath(pFolderPath, fso)
	GeneratePath = False

	If Not fso.FolderExists(pFolderPath) Then
		If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then
			GeneratePath = True
			Call fso.CreateFolder(pFolderPath)
		End If
	Else
		GeneratePath = True
	End If
End Function &#039;GeneratePath

Function GetTaniumLocale
&#039;&#039; This function will retrieve the locale value
&#039; previously set which governs Tanium content that
&#039; is locale sensitive.

	Dim objWshShell
	Dim intLocaleID
	
	Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Tanium\Tanium Client\LocaleID&quot;)
	If Err.Number &lt;&gt; 0 Then
		intLocaleID = objWshShell.RegRead(&quot;HKLM\Software\Wow6432Node\Tanium\Tanium Client\LocaleID&quot;)
	End If
	On Error Goto 0
	If intLocaleID = &quot;&quot; Then
		GetTaniumLocale = 1033 &#039; default to us/English
	Else
		GetTaniumLocale = intLocaleID
	End If

	&#039; Cleanup
	Set objWshShell = Nothing

End Function &#039;GetTaniumLocale

Function GetTZBias
&#039; This functiong returns the number of minutes
&#039; (positive or negative) to add to current time to get UTC
&#039; considers daylight savings

	Dim objLocalTimeZone, intTZBiasInMinutes


	For Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)
		intTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone
	Next

	GetTZBias = intTZBiasInMinutes
		
End Function &#039;GetTZBias",VBScript,,,,,,,233,3,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Error,String,0,1,2,Date,String,0,1,3,KB Article,String,0,1,4,Bulletin ID,String,0,1,5,Severity,String,0,1,6,Tanium Patch ID,String,,,,,,,,,,,,,,,,String
425,,,|,,1,1488402983,0,4294967282,1,,600,,,,,Linux:tempsensor_13,"{""parameters"":[{""helpString"":""Enter Yes, or No, to return failures for applicable patches only"",""value"":"""",""promptText"":""Yes/No"",""defaultValue"":"""",""requireSelection"":true,""label"":""Show failures only for needed patches"",""key"":""ShowOnlyIfApplicable"",""values"":[""Yes"",""No""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||ShowOnlyIfApplicable||,Yes,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# Yes  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# Yes  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,233,2,0,1,0,Title,String,,,,,,,,,,,,,,,,,,,,,,,,,,0,1,1,Error,String,0,1,2,Date,String,0,1,3,KB Article,String,0,1,4,Bulletin ID,String,0,1,5,Severity,String,0,1,6,Tanium Patch ID,String,,,,,,,,,,,,,,,,String
426,,,",",,1,1488402548,0,4294967281,1,,900,,,,,Number of Application Crashes in Last X Days[7],"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||days||,7,,,,,,Windows,"&#039;========================================
&#039; Number of Application Crashes in Last X Days
&#039;========================================

Option Explicit
Dim strSep
Dim objWMIService, colEvents, objEvent
Dim dtmStart

strSep = &quot;|&quot;

&#039;Uses date math - set locale

SetLocale(1033)


dtmStart = GetTimeWrittenByDaysOld(7)

Set objWMIService = GetObject(&quot;winmgmts:&quot; _ 
    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\.\root\cimv2&quot;) 

Set colEvents = objWMIService.ExecQuery _
    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _
        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _
        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)

Dim numCrashes
numCrashes = 0

For Each objEvent In colEvents
    Dim strMessage, arrLines, strLine, strApp, strModule, strTime
    
    strMessage = objEvent.Message
    arrLines = Split(strMessage, vbCrLf)
    
    Dim strIndex, strIndexXp

	&#039;just go through first line of log to grab app name
	strLine = arrLines(0)
	
	&#039;strIndex is for new OSes, strIndexXP for older...
	strIndex = &quot;Faulting application name: &quot;
	strIndexXp = &quot;Faulting application &quot;
	If Left(strLine, Len(strIndex)) = strIndex Then
		strApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)
	ElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then
		strApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)
	End If
	
    strTime = DatetimeToDate(objEvent.TimeWritten)
    	 
	If Not IsNull(strApp) And Not IsEmpty(strApp) Then
		numCrashes = numCrashes + 1
	End If
Next

WScript.Echo numCrashes

Function DatetimeToDate(strDate)
   DatetimeToDate = _
       CDate(Mid(strDate, 5, 2) &amp; _
       &quot;/&quot; &amp; _
       Mid(strDate, 7, 2) &amp; _
       &quot;/&quot; &amp; _
       Left(strDate, 4) &amp; _
       &quot; &quot; &amp; _
       Mid (strDate, 9, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 11, 2) &amp; _
       &quot;:&quot; &amp; _
       Mid(strDate, 13, 2))
End Function

Function GetTimeWrittenByDaysOld(days)
   &#039;subtract &quot;days&quot; days worth of seconds

	Dim epoc, monthAgo   
   	epoc = date2epoch(Now()) - days*24*60*60
   	monthAgo = epoch2date(epoc)
   
	Dim dateTime
	Set dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)
	dateTime.SetVarDate monthAgo, True
	 
  	GetTimeWrittenByDaysOld = dateTime
End Function

function date2epoch(myDate)
   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)
end Function

function epoch2date(myEpoch)
   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)
end Function",VBScript,,,,,,,175,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
427,,,",",,1,1488403853,0,4294967280,1,,900,,,,,Linux:tempsensor_15,"{""parameters"":[{""maximum"":365,""stepSize"":1,""helpString"":""Enter the number of days to query for Application Crashes"",""value"":""5"",""defaultValue"":""5"",""snapInterval"":1,""label"":""Number of Days"",""minimum"":1,""key"":""days"",""model"":""com.tanium.components.parameters::NumericParameter"",""parameterType"":""com.tanium.components.parameters::NumericParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||days||,7,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 7  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# 7  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,175,2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
428,,,",",,1,1488403418,0,4294967279,1,,900,,,,,Tanium Client Explicit Setting[LogVerbosityLevel],"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)"",""value"":"""",""promptText"":""Enter the Client Setting Name"",""defaultValue"":"""",""label"":""Client Setting Name"",""maxChars"":64,""key"":""setting"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||setting||,LogVerbosityLevel,,,,,,Windows,"&#039;========================================
&#039; Registry Value Data
&#039;========================================

&#039;Columns:
&#039; User | Data | Type | Architecture | KeyPath | Value

&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)

strKey = &quot;HKLM\&quot;&amp;GetTaniumRegistryPath()
strValue = unescape(&quot;LogVerbosityLevel&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client&quot;
&#039;strValue = &quot;Version&quot;

&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;
&#039;strValue = &quot;Emailname&quot;
strSep = &quot;~~&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If


If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive
		hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True
	End If
End If

If Not (hasAnyResult) Then
	WScript.Echo &quot;Key/Value not found&quot;
End If

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames
	arrTypes = Outparams.Types

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			
			&#039;if strValue is found, echo
			If LCase(strValueName) = LCase(strValue) Then
				EchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit
				CheckValues = True
				Exit Function
			End If
		Next
	End If
	CheckValues = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit)
	If intBit = 64 Then
		strArch = &quot;64-bit&quot;
	Else
		strArch = &quot;32-bit&quot;
	End If
			
	GetDisplayString = strValue
End Function

Function EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)
	&#039; Note the key that was being searched, will be a hidden column
	strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
	
	Dim objInParams, objOutParams
	Select Case constType
		Case REG_SZ  
			Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_EXPAND_SZ
			Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_BINARY
			Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)

			strBytes = &quot;&quot;
			For Each uByte in objOutParams.uValue
				strTemp = Hex(uByte)
				If Len(strTemp) &lt; 2 Then
					strTemp = &quot;0&quot; &amp; strTemp
				End If	
				strBytes = strBytes &amp; strTemp &amp; &quot; &quot;
			Next
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)
		Case REG_DWORD
		    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_QWORD
		    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_MULTI_SZ
		    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)
		
			arrValues = objOutParams.sValue
			strResponse = &quot;&quot;

			For Each strTemp In arrValues
				If strResponse = &quot;&quot; Then
					strResponse = strTemp
				Else
					strResponse = strResponse &amp; vbCrLf &amp; strTemp
				End If
			Next
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)
	End Select
End Function


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,,,,,,,31,21244,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
429,,,",",,1,1488397763,0,4294967278,1,,900,,,,,Linux:tempsensor_17,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)"",""value"":"""",""promptText"":""Enter the Client Setting Name"",""defaultValue"":"""",""label"":""Client Setting Name"",""maxChars"":64,""key"":""setting"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||setting||,LogVerbosityLevel,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# LogVerbosityLevel  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# LogVerbosityLevel  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,31,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
430,,,",",,1,1488397328,0,4294967277,1,,900,,,,,Tanium Client Explicit Setting[SaveClientStateIntervalInSeconds],"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)"",""value"":"""",""promptText"":""Enter the Client Setting Name"",""defaultValue"":"""",""label"":""Client Setting Name"",""maxChars"":64,""key"":""setting"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||setting||,SaveClientStateIntervalInSeconds,,,,,,Windows,"&#039;========================================
&#039; Registry Value Data
&#039;========================================

&#039;Columns:
&#039; User | Data | Type | Architecture | KeyPath | Value

&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)

strKey = &quot;HKLM\&quot;&amp;GetTaniumRegistryPath()
strValue = unescape(&quot;SaveClientStateIntervalInSeconds&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client&quot;
&#039;strValue = &quot;Version&quot;

&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;
&#039;strValue = &quot;Emailname&quot;
strSep = &quot;~~&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If


If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive
		hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True
	End If
End If

If Not (hasAnyResult) Then
	WScript.Echo &quot;Key/Value not found&quot;
End If

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames
	arrTypes = Outparams.Types

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			
			&#039;if strValue is found, echo
			If LCase(strValueName) = LCase(strValue) Then
				EchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit
				CheckValues = True
				Exit Function
			End If
		Next
	End If
	CheckValues = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit)
	If intBit = 64 Then
		strArch = &quot;64-bit&quot;
	Else
		strArch = &quot;32-bit&quot;
	End If
			
	GetDisplayString = strValue
End Function

Function EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)
	&#039; Note the key that was being searched, will be a hidden column
	strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
	
	Dim objInParams, objOutParams
	Select Case constType
		Case REG_SZ  
			Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_EXPAND_SZ
			Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_BINARY
			Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)

			strBytes = &quot;&quot;
			For Each uByte in objOutParams.uValue
				strTemp = Hex(uByte)
				If Len(strTemp) &lt; 2 Then
					strTemp = &quot;0&quot; &amp; strTemp
				End If	
				strBytes = strBytes &amp; strTemp &amp; &quot; &quot;
			Next
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)
		Case REG_DWORD
		    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_QWORD
		    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_MULTI_SZ
		    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)
		
			arrValues = objOutParams.sValue
			strResponse = &quot;&quot;

			For Each strTemp In arrValues
				If strResponse = &quot;&quot; Then
					strResponse = strTemp
				Else
					strResponse = strResponse &amp; vbCrLf &amp; strTemp
				End If
			Next
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)
	End Select
End Function


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,,,,,,,31,21244,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
431,,,",",,1,1487791808,0,4294967276,1,,900,,,,,Linux:tempsensor_19,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)"",""value"":"""",""promptText"":""Enter the Client Setting Name"",""defaultValue"":"""",""label"":""Client Setting Name"",""maxChars"":64,""key"":""setting"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||setting||,SaveClientStateIntervalInSeconds,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# SaveClientStateIntervalInSeconds  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# SaveClientStateIntervalInSeconds  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,31,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
432,,,",",,1,1487792243,0,4294967275,1,,900,,,,,Tanium Client Explicit Setting[RandomSensorDelayInSeconds],"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)"",""value"":"""",""promptText"":""Enter the Client Setting Name"",""defaultValue"":"""",""label"":""Client Setting Name"",""maxChars"":64,""key"":""setting"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||setting||,RandomSensorDelayInSeconds,,,,,,Windows,"&#039;========================================
&#039; Registry Value Data
&#039;========================================

&#039;Columns:
&#039; User | Data | Type | Architecture | KeyPath | Value

&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)

strKey = &quot;HKLM\&quot;&amp;GetTaniumRegistryPath()
strValue = unescape(&quot;RandomSensorDelayInSeconds&quot;)

&#039;strKey = &quot;HKLM\Software\Tanium\Tanium Client&quot;
&#039;strValue = &quot;Version&quot;

&#039;strKey = &quot;HKEY_USERS\Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;
&#039;strValue = &quot;Emailname&quot;
strSep = &quot;~~&quot;


&#039;Constants for value types
Const REG_SZ        = 1
Const REG_EXPAND_SZ = 2
Const REG_BINARY    = 3
Const REG_DWORD     = 4
Const REG_MULTI_SZ  = 7
Const REG_QWORD     = 11


&#039;Split up strKey into the hive constant and the registry key
words = Split(strKey, &quot;\&quot;)
strHive = words(0)
constHive = GetHiveConst(strHive)

strKey = Right(strKey, Len(strKey) - Len(strHive) -1)

&#039;Global for Username
Dim strUserName
strUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive

&#039;Set up registry objects for 32-bit, then check value
&#039;Need to check all values of key in order to get type
Set objCtx = GetObjCtx(32)
Set objReg = GetObjReg(objCtx)

If strHive = &quot;HKEY_USERS&quot; Then
&#039; go through each User&#039;s hive
	For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
			strUserName = GetUserForSIDLocal(objReg,strUserKey)
			If strUserName = False Then strUserName = strUserKey
			strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
			hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)
			If hasValues32 Then hasAnyResult = True
		End If
	Next
Else &#039; was another hive
	hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)
	If hasValues32 Then hasAnyResult = True
End If


If Is64 Then
	Set objCtx = GetObjCtx(64)
	Set objReg = GetObjReg(objCtx)
	If strHive = &quot;HKEY_USERS&quot; Then
	&#039; go through each User&#039;s hive in 64-bit context
		For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)
		If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries
				strUserName = GetUserForSIDLocal(objReg,strUserKey)
				If strUserName = False Then strUserName = strUserKey
				strFullUserKey = strUserKey&amp;&quot;\&quot;&amp;strKey
				hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)
				If hasValues64 Then hasAnyResult = True	
			End If
		Next
	Else &#039; was another hive
		hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)
		If hasValues64 Then hasAnyResult = True
	End If
End If

If Not (hasAnyResult) Then
	WScript.Echo &quot;Key/Value not found&quot;
End If

Function GetTaniumRegistryPath
&#039;GetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

    Dim objShell
    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
      
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
    keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
    keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
    strFoundTaniumRegistryPath = keyNativePath
 
    If strPath = &quot;&quot; Then
        &#039; Could not find 32-bit mode path, checking Wow6432Node
        On Error Resume Next
        strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
        On Error Goto 0
        strFoundTaniumRegistryPath = keyWoWPath
    End If
    
    If Not strPath = &quot;&quot; Then
        GetTaniumRegistryPath = strFoundTaniumRegistryPath
    Else
        GetTaniumRegistryPath = False
        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
    End If
End Function &#039;GetTaniumRegistryPath

Function RegKeyExists(objRegistry, sHive, sRegKey)
	Dim aValueNames, aValueTypes
	If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then
		RegKeyExists = True
	Else
		RegKeyExists = False
	End If
End Function &#039;RegKeyExists

&#039;Goes through all values in a key, returns True if strValue is found
Function CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)

	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)
	
	arrNames = Outparams.sNames
	arrTypes = Outparams.Types

	If Not IsNull(arrNames) Then
		For i = LBound(arrNames) To UBound(arrNames)
			strValueName = arrNames(i)
			
			&#039;if strValue is found, echo
			If LCase(strValueName) = LCase(strValue) Then
				EchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit
				CheckValues = True
				Exit Function
			End If
		Next
	End If
	CheckValues = False
End Function

Function GetDisplayString(strKey, strType, strValue, intBit)
	If intBit = 64 Then
		strArch = &quot;64-bit&quot;
	Else
		strArch = &quot;32-bit&quot;
	End If
			
	GetDisplayString = strValue
End Function

Function EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)
	&#039; Note the key that was being searched, will be a hidden column
	strOutputKey = strHive&amp;&quot;\&quot;&amp;strKey
	
	Dim objInParams, objOutParams
	Select Case constType
		Case REG_SZ  
			Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_EXPAND_SZ
			Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)
		Case REG_BINARY
			Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters
			objInParams.hDefKey = constHive
			objInParams.sSubKeyName = strKey
			objInParams.sValueName = strValue			
			Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)

			strBytes = &quot;&quot;
			For Each uByte in objOutParams.uValue
				strTemp = Hex(uByte)
				If Len(strTemp) &lt; 2 Then
					strTemp = &quot;0&quot; &amp; strTemp
				End If	
				strBytes = strBytes &amp; strTemp &amp; &quot; &quot;
			Next
			
			WScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)
		Case REG_DWORD
		    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_QWORD
		    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)
		Case REG_MULTI_SZ
		    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters
		    objInParams.hDefKey = constHive
		    objInParams.sSubKeyName = strKey
		    objInParams.sValueName = strValue
		    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)
		
			arrValues = objOutParams.sValue
			strResponse = &quot;&quot;

			For Each strTemp In arrValues
				If strResponse = &quot;&quot; Then
					strResponse = strTemp
				Else
					strResponse = strResponse &amp; vbCrLf &amp; strTemp
				End If
			Next
		
			WScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)
	End Select
End Function


Function GetObjCtx(intArch)
	Dim objCtx
	Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)
	objCtx.Add &quot;__ProviderArchitecture&quot;, intArch
	objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE
	Set GetObjCtx = objCtx
End Function

Function GetObjReg(objCtx)
	Dim objLocator, objServices
	Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)
	Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)
	Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) 
End Function

Function GetSubKeys(objReg, objCtx, constHive, strKey)
	Dim Inparams, Outparams
	Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters
	Inparams.Hdefkey = constHive
	Inparams.sSubkeyname = strKey
	Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)
	GetSubKeys = Outparams.sNames
End Function

Function Is64 
	Dim objWMIService, colItems, objItem
	Set objWMIService = GetObject(&quot;winmgmts:\\.\root\CIMV2&quot;)
	Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    
	For Each objItem In colItems
		If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then
			Is64 = True
		Else
			Is64 = False
		End If		
	Next
End Function


Function GetHiveConst(hive)
	Const HKEY_CLASSES_ROOT   = &amp;H80000000
	Const HKEY_CURRENT_USER   = &amp;H80000001
	Const HKEY_LOCAL_MACHINE  = &amp;H80000002
	Const HKEY_USERS          = &amp;H80000003

	Select Case UCase(hive)
		Case &quot;HKLM&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKEY_LOCAL_MACHINE&quot;
			GetHiveConst = HKEY_LOCAL_MACHINE
		Case &quot;HKCR&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CLASSES_ROOT&quot;
			GetHiveConst = HKEY_CLASSES_ROOT
		Case &quot;HKEY_CURRENT_USER&quot;
			GetHiveConst = HKEY_CURRENT_USER
		Case &quot;HKEY_USERS&quot;
			GetHiveConst = HKEY_USERS
	End Select
	
	If IsEmpty(GetHiveConst) Then
		WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive
		WScript.Quit
	End If
End Function

Function GetUserForSIDLocal(objReg,strSID)
&#039; This function converts a SID to a user name
&#039; by doing a registry lookup, avoiding an LDAP query
&#039; this will fail in the case where the user&#039;s name was changed in AD
&#039; as they will still have their old home directory name

	Const HKLM = &amp;h80000002
	
	Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos
	
	strHiveListKey = &quot;SYSTEM\CurrentControlSet\Control\hivelist&quot;
	objReg.GetStringValue HKLM,strHiveListKey,&quot;\Registry\User\&quot;&amp;strSID,strUserData
	If Not IsNull(strUserData) Then
	&#039; strUserData would look like
	&#039; \Device\HarddiskVolume2\Users\user.name\NTUSER.DAT
		intDatPos = InStr(UCase(strUserData),&quot;\NTUSER.DAT&quot;)
		&#039; strip off the dat file
		If intDatPos &gt; 0 Then &#039; must be in string
			strUserData = Left(strUserData,intDatPos - 1)
			&#039; find last backslash
			intFinalBackslashPos = InStrRev(strUserData,&quot;\&quot;)
			&#039; get right from that pos
			strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)
			GetUserForSIDLocal = strUserData
		Else
			strUserData = False
		End If
	Else
		GetUserForSIDLocal = False
	End If
End Function &#039;GetUserForSIDLocal",VBScript,,,,,,,31,766,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
433,,,",",,1,1487792678,0,4294967274,1,,900,,,,,Linux:tempsensor_21,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""^\\S"",""helpString"":""Value can not be blank"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)"",""value"":"""",""promptText"":""Enter the Client Setting Name"",""defaultValue"":"""",""label"":""Client Setting Name"",""maxChars"":64,""key"":""setting"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||setting||,RandomSensorDelayInSeconds,,,,,,Linux,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# RandomSensorDelayInSeconds  

echo &quot;N/A on Linux&quot;
",UnixShell,Mac,"#!/bin/sh

# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA
# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}
# RandomSensorDelayInSeconds  

echo &quot;N/A on Mac&quot;
",UnixShell,,,,31,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
434,,,",",,1,1487793113,0,4294967273,1,,600,,,,,"Folder Name Search with RegEx Match[No, Program Files, No, ]","{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the folder name to search for"",""value"":"""",""promptText"":""e.g Program Files"",""defaultValue"":"""",""label"":""Search for Folder Name"",""maxChars"":0,""key"":""dirname"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the regular expression to search for."",""value"":"""",""promptText"":""e.g. test*.exe"",""defaultValue"":"""",""label"":""Regular Expression"",""maxChars"":0,""key"":""regexp"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""helpString"":""Enter Yes/No for case sensitivity of search."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Case sensitive?"",""key"":""casesensitive"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""},{""helpString"":""Enter Yes/No whether the search is global."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Global"",""key"":""global"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||casesensitive||,No,||dirname||,Program Files,||global||,No,||regexp||,Windows,"&#039;========================================
&#039; Folder Name Search with RegEx Match
&#039;========================================
&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit

SensorRandomize()

Dim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg
Dim bGlobal,bCaseSensitive

Pattern = unescape(&quot;Program%20Files&quot;)
strRegExp = Trim(Unescape(&quot;&quot;))
strGlobalArg = Trim(Unescape(&quot;No&quot;))
strCaseSensitiveArg = Trim(Unescape(&quot;No&quot;))

bGlobal = GetTrueFalseArg(&quot;global&quot;,strGlobalArg)
bCaseSensitive = GetTrueFalseArg(&quot;casesensitive&quot;,strCaseSensitiveArg)

Const SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1

Dim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine

Set FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
Set WshShell = CreateObject(&quot;WScript.Shell&quot;)

OutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir

&#039; Go through file system, refresh output file for filename
If Not FSO.FileExists(OutputFilename) Then
	
	If FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename

	&#039; Get the collection of local drives.
	Set Drives = FSO.Drives
	For Each Drive in Drives
		If Drive.DriveType = 2 Then &#039; 2 = Fixed drive
			&#039; Run the Dir command that looks for the filename pattern.
			RunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:D /B /S&quot;, OutputFilename, true
		End If
	Next
End If

&#039; Open the output file, echo each line, and then close and delete it.
Set TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)
Do While Not TextStream.AtEndOfStream
	strLine = TextStream.ReadLine()
	If RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then
		WScript.Echo strLine
	End If
Loop


TextStream.Close()
 
If FSO.FileExists(OutputFileName) Then
	On Error Resume Next
	FSO.DeleteFile OutputFileName, True
	On Error Goto 0
End If

Function RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)

	Dim re
	Set re = New RegExp
	With re
	  .Pattern = strPattern
	  .Global = bGlobal
	  .IgnoreCase = Not bIsCaseSensitive
	End With
	
	RegExpMatch = re.Test(strToMatch)

End Function &#039;RegExpMatch


Function GetTrueFalseArg(strArgName,strArgValue)
	&#039; Checks for valid values, will fail with error message
	
	Dim bArgVal
	bArgVal = False
	Select Case LCase(strArgValue)
		Case &quot;true&quot;
			bArgVal = True
		Case &quot;yes&quot;
			bArgVal = True
		Case &quot;false&quot;
			bArgVal = False
		Case &quot;no&quot;
			bArgVal = False
		Case Else
			WScript.Echo &quot;Error: Argument &#039;&quot;&amp;strArgName&amp;&quot;&#039; must be True or False, quitting&quot;
			PrintUsage
	End Select
	GetTrueFalseArg = bArgVal

End Function &#039;GetTrueFalseArg


&#039; Returns the name of a temporary file in the Temp directory.
Function TempName()
	Dim Result
	Do
 		Result = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())
		WScript.Sleep 200 &#039;avoid potential busy loop
	Loop While FSO.FileExists(Result)
	
	TempName = Result
End Function &#039;TempName

&#039; Runs a command with Cmd.exe and redirects its output to a temporary
&#039; file. The function returns the name of the temporary file that holds
&#039; the command&#039;s output.
Function RunCommand(Command, OutputFilename, b64BitNecessary)
	&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32
	Dim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set WshShell = CreateObject(&quot;WScript.Shell&quot;)
	
	strDOSCall = &quot;%ComSpec% /C &quot;
	
	&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection
	strProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)
	If objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64
		strDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))
	End If
		
	CommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)
	WshShell.Run CommandLine, 0, True
End Function &#039;RunCommand

Function FixFileSystemRedirectionForPath(strFilePath)
&#039; This function will fix a folder location so that
&#039; a 32-bit program can be passed the windows\system32 directory
&#039; as a parameter.
&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&#039; program called in a 64-bit environment cannot access
&#039; the system32 directory - it would be redirected to syswow64.
&#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)
	Set objShell = CreateObject(&quot;Wscript.Shell&quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)
			strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)
			strFilePath = strNewSystem32Location&amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&#039;Cleanup
	Set objFSO = Nothing
End Function &#039;FixFileSystemRedirectionForPath
&#039;------------ INCLUDES after this line. Do not edit past this point -----
&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&#039; sleeps for a random period of time, intSleepTime is in seconds
&#039; if the sensor randomize flag is on
&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\Sensor Data\Random Sleep&quot;
	
	Set objShell = CreateObject(&quot;WScript.Shell&quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeFlag&quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\&quot;&amp;strRandomizeRegPath&amp;&quot;\SensorRandomizeScalingPercentage&quot;)
	On Error Goto 0
	If intRandomizeFlag &gt; 0 Then
		If intRandomizeScalingPercentage &gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ 
				&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds
		&#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;
	Else 
		SensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;
	End If
End Function &#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    
	keyNativePath = &quot;Software\Tanium\Tanium Client&quot;
	keyWoWPath = &quot;Software\Wow6432Node\Tanium\Tanium Client&quot;
    
    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyNativePath&amp;&quot;\Path&quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &quot;&quot; Then
  		&#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&quot;HKLM\&quot;&amp;keyWoWPath&amp;&quot;\Path&quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &quot;&quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;
  	End If
End Function &#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&#039;&#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &quot;ComputerID&quot;
    Set objShell = CreateObject(&quot;WScript.Shell&quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&quot;HKLM\&quot;&amp;strKeyPath&amp;&quot;\&quot;&amp;strValueName)
    If Err.Number &lt;&gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &#039;SensorRandomizeEcho
&#039; -- End Random Sleep Functions --&#039;
&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,,,,,,,381,513,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
435,,,",",,1,1487793548,0,4294967272,1,,600,,,,,Linux:tempsensor_23,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the folder name to search for"",""value"":"""",""promptText"":""e.g Program Files"",""defaultValue"":"""",""label"":""Search for Folder Name"",""maxChars"":0,""key"":""dirname"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the regular expression to search for."",""value"":"""",""promptText"":""e.g. test*.exe"",""defaultValue"":"""",""label"":""Regular Expression"",""maxChars"":0,""key"":""regexp"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""helpString"":""Enter Yes/No for case sensitivity of search."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Case sensitive?"",""key"":""casesensitive"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""},{""helpString"":""Enter Yes/No whether the search is global."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Global"",""key"":""global"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",||casesensitive||,No,||dirname||,Program Files,||global||,No,||regexp||,Linux,"#!/bin/bash
#Program%20FilesNoNo
echo Windows Only
",UnixShell,Mac,"#!/bin/bash
#Program%20FilesNoNo
echo Windows Only
",UnixShell,,,,381,3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
436,File System,2015-01-05T20:29:39,",","Finds the specified folder and provides the full path if the folder exists on the client machine. Takes regular expression to match.
Example: C:\WINDOWS\System32",1,839342978,0,821,1,Tanium User,600,0,defined,McAfee,2015-01-05T20:29:39,Folder Name Search with RegEx Match API TEST,"{""parameters"":[{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the folder name to search for"",""value"":"""",""promptText"":""e.g Program Files"",""defaultValue"":"""",""label"":""Search for Folder Name"",""maxChars"":0,""key"":""dirname"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""restrict"":null,""validationExpressions"":[{""flags"":"""",""expression"":""\\S{3}"",""helpString"":""Value must be at least 3 characters"",""model"":""com.tanium.models::ValidationExpression"",""parameterType"":""com.tanium.models::ValidationExpression""}],""helpString"":""Enter the regular expression to search for."",""value"":"""",""promptText"":""e.g. test*.exe"",""defaultValue"":"""",""label"":""Regular Expression"",""maxChars"":0,""key"":""regexp"",""model"":""com.tanium.components.parameters::TextInputParameter"",""parameterType"":""com.tanium.components.parameters::TextInputParameter""},{""helpString"":""Enter Yes/No for case sensitivity of search."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Case sensitive?"",""key"":""casesensitive"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""},{""helpString"":""Enter Yes/No whether the search is global."",""value"":"""",""promptText"":"""",""defaultValue"":"""",""requireSelection"":true,""label"":""Global"",""key"":""global"",""values"":[""No"",""Yes""],""model"":""com.tanium.components.parameters::DropDownParameter"",""parameterType"":""com.tanium.components.parameters::DropDownParameter""}],""model"":""com.tanium.components.parameters::ParametersArray"",""parameterType"":""com.tanium.components.parameters::ParametersArray""}",,,,,,,,Windows,"&amp;#039;========================================
&amp;#039; Folder Name Search with RegEx Match
&amp;#039;========================================
&amp;#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs
Option Explicit

SensorRandomize()

Dim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg
Dim bGlobal,bCaseSensitive

Pattern = unescape(&amp;quot;||dirname||&amp;quot;)
strRegExp = Trim(Unescape(&amp;quot;||regexp||&amp;quot;))
strGlobalArg = Trim(Unescape(&amp;quot;||global||&amp;quot;))
strCaseSensitiveArg = Trim(Unescape(&amp;quot;||casesensitive||&amp;quot;))

bGlobal = GetTrueFalseArg(&amp;quot;global&amp;quot;,strGlobalArg)
bCaseSensitive = GetTrueFalseArg(&amp;quot;casesensitive&amp;quot;,strCaseSensitiveArg)

Const SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1

Dim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine

Set FSO = CreateObject(&amp;quot;Scripting.FileSystemObject&amp;quot;)
Set WshShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)

OutputFilename = TempName() &amp;#039; a temporary file in system&amp;#039;s temp dir

&amp;#039; Go through file system, refresh output file for filename
If Not FSO.FileExists(OutputFilename) Then
	
	If FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename

	&amp;#039; Get the collection of local drives.
	Set Drives = FSO.Drives
	For Each Drive in Drives
		If Drive.DriveType = 2 Then &amp;#039; 2 = Fixed drive
			&amp;#039; Run the Dir command that looks for the filename pattern.
			RunCommand &amp;quot;dir &amp;quot; &amp;amp;Chr(34)&amp;amp; Drive.DriveLetter &amp;amp; &amp;quot;:\&amp;quot; &amp;amp; Pattern &amp;amp; Chr(34)&amp;amp;&amp;quot; /a:D /B /S&amp;quot;, OutputFilename, true
		End If
	Next
End If

&amp;#039; Open the output file, echo each line, and then close and delete it.
Set TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)
Do While Not TextStream.AtEndOfStream
	strLine = TextStream.ReadLine()
	If RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then
		WScript.Echo strLine
	End If
Loop


TextStream.Close()
 
If FSO.FileExists(OutputFileName) Then
	On Error Resume Next
	FSO.DeleteFile OutputFileName, True
	On Error Goto 0
End If

Function RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)

	Dim re
	Set re = New RegExp
	With re
	  .Pattern = strPattern
	  .Global = bGlobal
	  .IgnoreCase = Not bIsCaseSensitive
	End With
	
	RegExpMatch = re.Test(strToMatch)

End Function &amp;#039;RegExpMatch


Function GetTrueFalseArg(strArgName,strArgValue)
	&amp;#039; Checks for valid values, will fail with error message
	
	Dim bArgVal
	bArgVal = False
	Select Case LCase(strArgValue)
		Case &amp;quot;true&amp;quot;
			bArgVal = True
		Case &amp;quot;yes&amp;quot;
			bArgVal = True
		Case &amp;quot;false&amp;quot;
			bArgVal = False
		Case &amp;quot;no&amp;quot;
			bArgVal = False
		Case Else
			WScript.Echo &amp;quot;Error: Argument &amp;#039;&amp;quot;&amp;amp;strArgName&amp;amp;&amp;quot;&amp;#039; must be True or False, quitting&amp;quot;
			PrintUsage
	End Select
	GetTrueFalseArg = bArgVal

End Function &amp;#039;GetTrueFalseArg


&amp;#039; Returns the name of a temporary file in the Temp directory.
Function TempName()
	Dim Result
	Do
 		Result = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())
		WScript.Sleep 200 &amp;#039;avoid potential busy loop
	Loop While FSO.FileExists(Result)
	
	TempName = Result
End Function &amp;#039;TempName

&amp;#039; Runs a command with Cmd.exe and redirects its output to a temporary
&amp;#039; file. The function returns the name of the temporary file that holds
&amp;#039; the command&amp;#039;s output.
Function RunCommand(Command, OutputFilename, b64BitNecessary)
	&amp;#039; 64BitNecessary true when you need to examine the 64-bit areas like system32
	Dim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO
	Set objFSO = CreateObject(&amp;quot;Scripting.FileSystemObject&amp;quot;)
	Set WshShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)
	
	strDOSCall = &amp;quot;%ComSpec% /C &amp;quot;
	
	&amp;#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection
	strProgramFilesx86=WshShell.ExpandEnvironmentStrings(&amp;quot;%ProgramFiles%&amp;quot;)
	If objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &amp;#039; quick check for x64
		strDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))
	End If
		
	CommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp;amp; Command &amp;amp; &amp;quot; &amp;gt;&amp;gt; &amp;quot;&amp;quot;&amp;quot; &amp;amp; OutputFileName &amp;amp; &amp;quot;&amp;quot;&amp;quot;&amp;quot;)
	WshShell.Run CommandLine, 0, True
End Function &amp;#039;RunCommand

Function FixFileSystemRedirectionForPath(strFilePath)
&amp;#039; This function will fix a folder location so that
&amp;#039; a 32-bit program can be passed the windows\system32 directory
&amp;#039; as a parameter.
&amp;#039; Even if the sensor or action runs in 64-bit mode, a 32-bit
&amp;#039; program called in a 64-bit environment cannot access
&amp;#039; the system32 directory - it would be redirected to syswow64.
&amp;#039; you would not want to do this for 64-bit programs.
	
	Dim objFSO, strSystem32Location,objShell
	Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath
	Set objFSO = CreateObject(&amp;quot;Scripting.FileSystemObject&amp;quot;)
	Set objShell = CreateObject(&amp;quot;Wscript.Shell&amp;quot;)

	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&amp;quot;%ProgramFiles%&amp;quot;)

	strFilePath = LCase(strFilePath)
	strSystem32Location = LCase(objFSO.GetSpecialFolder(1))
	strProgramFilesx86=objShell.ExpandEnvironmentStrings(&amp;quot;%ProgramFiles(x86)%&amp;quot;)
	
	If objFSO.FolderExists(strProgramFilesx86) Then &amp;#039; quick check for x64
		If InStr(strFilePath,strSystem32Location) = 1 Then
			strRestOfPath = Replace(strFilePath,strSystem32Location,&amp;quot;&amp;quot;)
			strNewSystem32Location = Replace(strSystem32Location,&amp;quot;system32&amp;quot;,&amp;quot;sysnative&amp;quot;)
			strFilePath = strNewSystem32Location&amp;amp;strRestOfPath
		End If
	End If
	FixFileSystemRedirectionForPath = strFilePath
	
	&amp;#039;Cleanup
	Set objFSO = Nothing
End Function &amp;#039;FixFileSystemRedirectionForPath
&amp;#039;------------ INCLUDES after this line. Do not edit past this point -----
&amp;#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs
&amp;#039;&amp;#039; -- Begin Random Sleep Functions -- &amp;#039;&amp;#039;

Dim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False

Function SensorRandomizeLow()
    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10
    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)
End Function &amp;#039; SensorRandomizeLow

Function SensorRandomize()
    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20
    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)
End Function &amp;#039; SensorRandomize

Function SensorRandomizeHigh()
    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30
    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)
End Function &amp;#039; SensorRandomize

Function SensorRandomizeRandomSleep(intSleepTime)
&amp;#039; sleeps for a random period of time, intSleepTime is in seconds
&amp;#039; if the sensor randomize flag is on
&amp;#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor
&amp;#039; not typically set but can adjust timings per endpoint, optionally
	Dim intSensorRandomizeWaitTime
	Dim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage
	strRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;amp;&amp;quot;\Sensor Data\Random Sleep&amp;quot;
	
	Set objShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)
	On Error Resume Next
	intRandomizeFlag = objShell.RegRead(&amp;quot;HKLM\&amp;quot;&amp;amp;strRandomizeRegPath&amp;amp;&amp;quot;\SensorRandomizeFlag&amp;quot;)
	intRandomizeScalingPercentage = objShell.RegRead(&amp;quot;HKLM\&amp;quot;&amp;amp;strRandomizeRegPath&amp;amp;&amp;quot;\SensorRandomizeScalingPercentage&amp;quot;)
	On Error Goto 0
	If intRandomizeFlag &amp;gt; 0 Then
		If intRandomizeScalingPercentage &amp;gt; 0 Then
			intSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime
			SensorRandomizeEcho &amp;quot;Randomize scaling percentage of &amp;quot; _ 
				&amp;amp; intRandomizeScalingPercentage &amp;amp; &amp;quot; applied, new sleep time is &amp;quot; &amp;amp; intSleepTime
		End If
		intSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &amp;#039; convert to milliseconds
		&amp;#039; wait random interval between 0 and the max
		Randomize(SensorRandomizeTaniumRandomSeed)
		&amp;#039; assign random value to wait time max value
		intSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )
		SensorRandomizeEcho &amp;quot;Sleeping for &amp;quot; &amp;amp; intSensorRandomizeWaitTime &amp;amp; &amp;quot; milliseconds&amp;quot;
		WScript.Sleep(intSensorRandomizeWaitTime)
		SensorRandomizeEcho &amp;quot;Done sleeping, continuing ...&amp;quot;
	Else 
		SensorRandomizeEcho &amp;quot;SensorRandomize Not Enabled - No Op&amp;quot;
	End If
End Function &amp;#039;SensorRandomizeRandomSleep

Function SensorRandomizeTaniumRandomSeed
&amp;#039; for randomizing sensor code, the default seed is not random enough
	Dim timerNum
	timerNum = Timer()
	If timerNum &amp;lt; 1 Then
		SensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )
	Else
		SensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer
	End If
End Function &amp;#039;SensorRandomizeTaniumRandomSeed

Function SensorRandomizeGetTaniumRegistryPath
&amp;#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32
&amp;#039;looks for a valid Path value

	Dim objShell
	Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath
	  
    Set objShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)
    
	keyNativePath = &amp;quot;Software\Tanium\Tanium Client&amp;quot;
	keyWoWPath = &amp;quot;Software\Wow6432Node\Tanium\Tanium Client&amp;quot;
    
    &amp;#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)
    On Error Resume Next
    strPath = objShell.RegRead(&amp;quot;HKLM\&amp;quot;&amp;amp;keyNativePath&amp;amp;&amp;quot;\Path&amp;quot;)
    On Error Goto 0
	strFoundTaniumRegistryPath = keyNativePath
 
  	If strPath = &amp;quot;&amp;quot; Then
  		&amp;#039; Could not find 32-bit mode path, checking Wow6432Node
  		On Error Resume Next
  		strPath = objShell.RegRead(&amp;quot;HKLM\&amp;quot;&amp;amp;keyWoWPath&amp;amp;&amp;quot;\Path&amp;quot;)
  		On Error Goto 0
		strFoundTaniumRegistryPath = keyWoWPath
  	End If
  	
  	If Not strPath = &amp;quot;&amp;quot; Then
  		SensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath
  	Else
  		SensorRandomizeGetTaniumRegistryPath = False
  		WScript.Echo &amp;quot;Error: Cannot locate Tanium Registry Path&amp;quot;
  	End If
End Function &amp;#039;SensorRandomizeGetTaniumRegistryPath

Function SensorRandomizeGetTaniumComputerID
&amp;#039;&amp;#039; This function gets the Tanium Computer ID
	Dim objShell
	Dim intClientID,strID,strKeyPath,strValueName
	
    strKeyPath = SensorRandomizeGetTaniumRegistryPath
    strValueName = &amp;quot;ComputerID&amp;quot;
    Set objShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)
    On Error Resume Next
    intClientID = objShell.RegRead(&amp;quot;HKLM\&amp;quot;&amp;amp;strKeyPath&amp;amp;&amp;quot;\&amp;quot;&amp;amp;strValueName)
    If Err.Number &amp;lt;&amp;gt; 0 Then
    	SensorRandomizeGetTaniumComputerID = 0
    Else
		SensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)
	End If
	On Error Goto 0
End Function &amp;#039;SensorRandomizeGetTaniumComputerID

Function SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)
	  If x &amp;lt; 0 Then x = x + 2^32
	  SensorRandomizeReinterpretSignedAsUnsigned = x
End Function &amp;#039;SensorRandomizeReinterpretSignedAsUnsigned

Sub SensorRandomizeEcho(str)
	If bSensorRandomizeDebugOutput = true Then WScript.Echo str
End Sub &amp;#039;SensorRandomizeEcho
&amp;#039; -- End Random Sleep Functions --&amp;#039;
&amp;#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs",VBScript,Linux,"#!/bin/bash
#||dirname||||regexp||||casesensitive||||global||
echo Windows Only
",UnixShell,Mac,"#!/bin/bash
#||dirname||||regexp||||casesensitive||||global||
echo Windows Only
",UnixShell,0,0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,String
