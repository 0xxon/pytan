{
  "_type": "sensors", 
  "cache_info": {
    "_type": "cache_info", 
    "cache_id": 913925574, 
    "cache_row_count": 437, 
    "expiration": "2015-01-05T20:37:37", 
    "filtered_row_count": 437, 
    "page_row_count": 437
  }, 
  "sensor": [
    {
      "_type": "sensor", 
      "cache_row_id": 0, 
      "category": "Reserved", 
      "description": "The recorded state of each action a client has taken recently in the form of id:status.\nExample: 1:Completed", 
      "exclude_from_parse_flag": 1, 
      "hash": 1792443391, 
      "hidden_flag": 0, 
      "id": 1, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 3600, 
      "name": "Action Statuses", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Reserved", 
            "script_type": "WMIQuery"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3726, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 1, 
      "category": "Reserved", 
      "description": "A unique identifier of each computer for internal use.\nExample: 4202979704", 
      "exclude_from_parse_flag": 1, 
      "hash": 3556221173, 
      "hidden_flag": 0, 
      "id": 2, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 300, 
      "name": "Computer ID", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Reserved", 
            "script_type": "WMIQuery"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 87, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 2, 
      "category": "Reserved", 
      "description": "The assigned name of the client machine.\nExample: workstation-1.company.com", 
      "exclude_from_parse_flag": 0, 
      "hash": 3409330187, 
      "hidden_flag": 0, 
      "id": 3, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 86400, 
      "name": "Computer Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select CSName from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 7, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 3, 
      "category": "Reserved", 
      "description": "The recorded state of each download a client has made recently in the form of hash:completion percentage.\nExample: 05839407baccdfccfd8e2c1ffc0ff27541cc053d15b52cfd4ed904510e59b428:100", 
      "exclude_from_parse_flag": 0, 
      "hash": 322086833, 
      "hidden_flag": 0, 
      "id": 4, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Download Statuses", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Reserved", 
            "script_type": "WMIQuery"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 331, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 4, 
      "category": "Reserved", 
      "description": "A list of manual group ids for internal use.\nExample: 72", 
      "exclude_from_parse_flag": 1, 
      "hash": 487883112, 
      "hidden_flag": 0, 
      "id": 5, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 300, 
      "name": "Manual Group Membership", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Reserved", 
            "script_type": "WMIQuery"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 5, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Version number of the Tanium Client on the client machine.\nExample: 4.1.314.7020", 
      "exclude_from_parse_flag": 1, 
      "hash": 435957060, 
      "hidden_flag": 0, 
      "id": 7, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium Client Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Version\n&#039;========================================\n\nOption Explicit\n\n\nDim fso, filePath, objFile\n\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nIf GetTaniumDir(&quot;&quot;) = False Then \n\tWScript.Echo &quot;Not installed&quot;\n\tWScript.Quit\nEnd If \n\nfilePath = GetTaniumDir(&quot;&quot;) &amp; &quot;taniumclient.exe&quot;\n\nIf fso.FileExists(filePath) Then\n\tSet objFile = fso.GetFile(filePath)\n\tWScript.Echo fso.GetFileVersion(objFile)\nElse\n\tWScript.Echo &quot;Not installed&quot;\nEnd If\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nfor ini in *Client.ini; do\n  TINI=&quot;$ini&quot;\ndone\nTVER=&quot;`grep -i &quot;Version&quot; &quot;$TINI&quot; | awk -F &#039;=&#039; &#039;{ print $2 }&#039;`&quot;\nif [ &quot;X$TVER&quot; = &quot;X&quot; ]; then\n  echo &quot;Version not specified in $TINI&quot;\nelse\n  echo &quot;$TVER&quot;\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nfor ini in *Client.ini; do\n  TINI=&quot;$ini&quot;\ndone\nTVER=&quot;`grep -i &quot;Version&quot; &quot;$TINI&quot; | awk -F &#039;=&#039; &#039;{ print $2 }&#039;`&quot;\nif [ &quot;X$TVER&quot; = &quot;X&quot; ]; then\n  echo &quot;Version not specified in $TINI&quot;\nelse\n  echo &quot;$TVER&quot;\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 6, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Determines whether the Tanium Client is able to execute the default content set successfully.  Returns any error conditions.\nExample: Error: Windows Script Host version must be at least 5.6", 
      "exclude_from_parse_flag": 1, 
      "hash": 824239263, 
      "hidden_flag": 0, 
      "id": 9, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium Client Core Health", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Core Health\n&#039;========================================\n\nOption Explicit\n\nOn Error Resume Next\n\n&#039; Hold whether to report a final error state\nDim bGlobalError : bGlobalError = False\n\n&#039; Global objects the functions may as well use\nDim objFSO,objReg\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\n\n&#039; First try the very basic access (FSO and registry access)\n\nIf Not TestFSO Then\n\tWScript.Echo &quot;Error: Cannot properly access filesystem&quot;\n\tWScript.Quit\nEnd If\n\nIf Not TestRegistry Then\n\tWScript.Echo &quot;Error: Cannot properly access registry via WMI&quot;\n\tWScript.Quit\nEnd If\n\n\nTestWSHVersionTooLow bGlobalError\nTestWMI bGlobalError\n\nIf bGlobalError Then\n\t&#039; Do not report &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;Healthy&quot;\nEnd If\n\nFunction TestWMI(ByRef bGlobalError)\n&#039; Tests basic WMI\n\tDim locale,objWMIService,colItems,objItem\n\tlocale = &quot;&quot;\n\tOn Error Resume Next\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_OperatingSystem&quot;,,48)\n\n\tFor Each objItem in colItems\n\t\tlocale = objItem.Locale\n\tNext\n\tOn Error Goto 0\n\tIf MyIsNumeric(locale) Then\n\t\t&#039; None\n\tElse\n\t\tWScript.Echo &quot;Error: WMI cannot retrieve a basic property&quot;\n\t\tbGlobalError = True\n\tEnd If\nEnd Function &#039;TestWMI\n\nFunction TestWSHVersionTooLow(ByRef bGlobalError)\n&#039; this function ensures wsh version 5.6\n\tDim WSHVersion\n\tWSHVersion = &quot;&quot;\n\tWSHVersion = WScript.Version\n\tIf Not MyIsNumeric(WSHVersion) Then\n\t\tWScript.Echo &quot;Error: Unknown Windows Script Host version&quot;\n\t\tbGlobalError = True\n\tElse\n\t\tWSHVersion = CDbl(WSHVersion)\n\t\tIf WSHVersion &lt; 5.6 Then\n\t\t\tWScript.Echo &quot;Error: Windows Script Host version must be at least 5.6&quot;\n\t\t\tbGlobalError = True\n\t\tEnd If\n\tEnd If\nEnd Function &#039;TestWSHVersionTooLow\n\nFunction TestRegistry\n&#039; this function will return true if a registry access test via WMI succeeds\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim aValueNames, aValueTypes\n\tOn Error Resume Next\n\tIf objReg.EnumValues(HKLM, &quot;SYSTEM&quot;, aValueNames, aValueTypes) = 0 Then\n\t\tTestRegistry = True\n\tElse\n\t\tTestRegistry = False\n\tEnd If\n\tOn Error Goto 0\n\nEnd Function &#039;TestRegistry\n\nFunction TestFSO\n&#039; this function will return true if an FSO call succeeds\n\n\tDim strWinDir\n\t&#039;Every machine has a windir\n\tOn Error Resume Next\n\tstrWinDir = objFSO.GetSpecialFolder(0)\n\t\n\tIf Not objFSO.FolderExists(strWinDir) Then\n\t\tTestFSO = False\n\tElse\n\t\tTestFSO = True\n\tEnd If\n\tOn Error Goto 0\n\nEnd Function &#039;TestFSO\n\nFunction MyIsNumeric(strTemp)\n\tDim i,d\n\tIf IsNull(strTemp) Then\n\t\tMyIsNumeric = False\n\t\tExit Function\n\tEnd If\n\tIf strTemp = &quot;&quot; Then\n\t\tMyIsNumeric = False\n\t\tExit Function\n\tEnd If\n\t\n    MyIsNumeric = True\n    For i = 1 to Len(strTemp) \n        d = Mid(strTemp, i, 1) \n        If Asc(d) &lt; 48 OR Asc(d) &gt; 57 Then \n            isReallyNumeric = False \n            Exit For \n        End If \n    Next \nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 7, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns, in all cases, the word True.  This sensor is used in many ways, including to find a common target for machines which may have responded to a question with a 'where' clause - get \"online from machines where IP address starts with 192.168.10.\" will allow you to target the respondents with an action or count responses.\nExample:True", 
      "exclude_from_parse_flag": 1, 
      "hash": 131549066, 
      "hidden_flag": 0, 
      "id": 11, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Online", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Online\n&#039;========================================\n\nWscript.echo &quot;True&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\necho &quot;True&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\necho &quot;True&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 8, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the name of the Operating System from all machines.  This name may be localized.\nExample: Windows Server 2008 R2 Enterprise", 
      "exclude_from_parse_flag": 0, 
      "hash": 45421433, 
      "hidden_flag": 0, 
      "id": 13, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Operating System", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Operating System\n&#039;========================================\n\nSet oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    \nSet oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    \nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)    \nSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    \nFor Each objItem In colItems       \nstrStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   \n&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   \nif Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   \nstrOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   \nElse   \nstrOS = strStrip1\nEnd IF   \nwscript.echo Trim(strOS)\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n# Detects which OS and if it is Linux then it will detect which Linux\n# Distribution.\n\nOS=`uname -s`\n\nGetVersionFromFile()\n{\n    VERSION=`cat $1 | tr &quot;\\n&quot; &#039; &#039; | sed s/.*VERSION.*=\\ // `\n}\n\nif [ &quot;${OS}&quot; = &quot;Darwin&quot; ] ; then\n    # Opps, ran on Mac instead of Linux\n    OS=Mac\n    OSSTR=&quot;${OS} incorrect script&quot;\nelif [ &quot;${OS}&quot; = &quot;Linux&quot; ] ; then\n    KERNEL=`uname -r`\n    if [ -f /etc/redhat-release ] ; then\n        DIST=&#039;RedHat&#039;\n        PSUEDONAME=`cat /etc/redhat-release`\n        REV=`cat /etc/redhat-release | sed s/.*release\\ // | sed s/\\ .*//`\n        # just cat of redhat-release, to keep compatibility with old version\n        # of sensor, but could do something different here\n        OSSTR=&quot;${PSUEDONAME}&quot;\n    elif [ -f /etc/SuSE-release ] ; then\n        DIST=`cat /etc/SuSE-release | tr &quot;\\n&quot; &#039; &#039;| sed s/VERSION.*//`\n        REV=`cat /etc/SuSE-release | tr &quot;\\n&quot; &#039; &#039; | sed s/.*=\\ //`\n        OSSTR=&quot;${DIST}&quot;\n    elif [ -f /etc/lsb-release ] ; then\n        # Ubuntu will use the lsb-release, but Debian should be caught by the next\n        # if -- note that Ubuntu also has a /etc/debian_version\n        # some other less popular distros may be caught by this too\n        DIST=`awk -F= &#039;/^DISTRIB_DESCRIPTION/ {print $2}&#039; /etc/lsb-release| tr -d &#039;&quot;&#039;`\n        OSSTR=&quot;${DIST}&quot;\n    elif [ -f /etc/debian_version ] ; then\n        DIST=&quot;Debian `cat /etc/debian_version`&quot;\n        OSSTR=&quot;${DIST}&quot;\n    else \n        # Fall through, some Linux distributions we don&#039;t know or that does not \n        # use lsb style names\n        REV=`uname -r`\n        OSSTR=&quot;Linux $REV&quot;\n    fi\nelse\n   # in case this is run on something else -- like Solaris or BSD ir AIX or HP-UX\n   OSSTR=&quot;${OS}&quot;\nfi\n\necho ${OSSTR}\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nname=$(sw_vers | awk -F&#039;:\\t&#039; &#039; /ProductName/ { print $2 }&#039;)\nversion=$(sw_vers | awk -F&#039;:\\t&#039; &#039; /ProductVersion/ { print $2 }&#039;)\necho $name \\($version\\)\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 8, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 9, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Logging level setting between 1 and 100 of the Tanium Client on the client machine.\nExample: 41", 
      "exclude_from_parse_flag": 1, 
      "hash": 4086596771, 
      "hidden_flag": 0, 
      "id": 15, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium Client Logging Level", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Logging Level\n&#039;========================================\n\nOption Explicit\n\nWScript.Echo GetLogLevel\n\n\n&#039;----------End Main Line-----------&#039;\n\nFunction GetLogLevel()\n&#039; This function sets maintenance window values passed to it\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strTaniumRegistryKey, strComputer, intLogLevel\n\tDim objReg, bLogLevelResult\n\t\n\t&#039; Set up access to registry via WMI\n\tstrComputer = &quot;.&quot;\n\t\n\tSet objReg = _\n\t\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\n\tstrTaniumRegistryKey = GetTaniumRegistryPath()\n\n\tobjReg.GetDWORDValue HKLM, strTaniumRegistryKey, &quot;LogVerbosityLevel&quot;, intLogLevel\n\t\n\tIf Not IsNull(intLogLevel) Then\n\t\tGetLogLevel = intLogLevel\n\tElse\n\t\tGetLogLevel = &quot;Not Set&quot;\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objReg = Nothing\nEnd Function &#039;GetLogLevel\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nlogLevel=$(grep -w &quot;^LogVerbosityLevel&quot; TaniumClient.ini | cut -d= -f2)\n\nif [[ $logLevel == &quot;&quot; ]]\nthen\nlogLevel=&quot;Not set&quot;\nfi\n\necho $logLevel\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nlogLevel=$(grep -w &quot;^LogVerbosityLevel&quot; TaniumClient.ini | cut -d= -f2)\n\nif [[ $logLevel == &quot;&quot; ]]\nthen\nlogLevel=&quot;Not set&quot;\nfi\n\necho $logLevel\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 10, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the combined size of all Action_XXXX subdirectories in the Tanium Client\\Downloads directory.\nExample: 351 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 2290387752, 
      "hidden_flag": 0, 
      "id": 17, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium Client Action Folder Sizes", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Action Folder Sizes\n&#039;========================================\n\nOption Explicit\n\nSetLocale(GetTaniumLocale)\n\nConst HKLM = &amp;H80000002\nDim objRegistry,strTaniumClientKey\nDim objFSO,objFolder,strTaniumClientPath,strDownloadsDir\nDim lngSize,intCount,folder\nDim strSize,strSep\n\nstrSep = &quot;|&quot;\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nSet objRegistry=GetObject(&quot;winmgmts:\\\\.\\root\\default:StdRegProv&quot;)\n\nstrTaniumClientKey = GetTaniumRegistryPath()\nIf Not strTaniumClientKey = &quot;&quot; Then\n\tobjRegistry.GetStringValue HKLM,strTaniumClientKey,&quot;Path&quot;,strTaniumClientPath\nEnd If\n\nIf ( IsNull(strTaniumClientPath) Or strTaniumClientPath = &quot;&quot;) Or ( Not objFSO.FolderExists(strTaniumClientPath)) Then\n\tWScript.Echo &quot;Tanium Client Directory Not Found&quot;\nElse\n\tOn Error Resume Next\n\tstrDownloadsDir = strTaniumClientPath&amp;&quot;\\Downloads&quot;\n\tlngSize = 0\n\tintCount = 0\n\tIf objFso.FolderExists(strDownloadsDir) Then\n\t\tSet objFolder = objFso.GetFolder(strDownloadsDir)\n\n\t\tFor Each folder In objFolder.SubFolders\n\t\t\tIf Left(folder.Name, 7) = &quot;Action_&quot; Then\n\t\t\t\tlngSize = lngSize + GetAccessibleFolderSize(folder.Path)\n\t\t\t\tintCount = intCount + 1\n\t\t\tEnd If\n\t\tNext\n\t\tOn Error Goto 0\n\t\tIf intCount &gt; 0 Then\n\t\t\tWScript.Echo GetPrettyFileSize(CStr(lngSize))\n\t\tElse\n\t\t\tWScript.Echo &quot;No Action Folders Found in Downloads dir&quot;\n\t\tEnd If\n\t\n\tElse\n\t\tWScript.Echo &quot;Tanium Client Downloads Directory Not Found&quot;\n\tEnd If\n\n\nEnd If\n\n&#039; --- end main --- &#039;\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction GetPrettyFileSize(strSize)\nDim dblSize\n\tdblSize = CDbl(strSize)\n\n\tIf dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;\t\n\tElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;\n\tElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB\n\t\tstrSize = CStr(Round(dblSize / 1024)) &amp; &quot; KB&quot;\n\tElse\n\t\tstrSize = CStr(dblSize) &amp; &quot; B&quot;\t\n\tEnd If\t\n\tGetPrettyFileSize = strSize\nEnd Function &#039;GetPrettyFileSize\n\n\nFunction GetAccessibleFolderSize(strFolderPath)\n&#039; Gets the folder sizes that it is able to\n&#039; and skips those it has no rights to see\n    On Error Resume Next &#039; Permissions Errors potentially\n\n\tDim objFSO\n    Dim objFolder,objSubfolder,intSize,bHasSubfolders\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t    \n    bHasSubfolders = False\n\n    Set objFolder = objFSO.GetFolder(strFolderPath)\n    Err.Clear\n    intSize = objFolder.Size\n    If Err.Number &lt;&gt; 0 Then\n        For Each objSubfolder in objFolder.SubFolders\n            intSize = intSize + GetAccessibleFolderSize(objSubfolder.Path)\n            bHasSubfolders = True\n        Next\n\n        If Not bHasSubfolders Then\n            intSize = objFolder.Size\n        End If\n    End If\n\n    GetAccessibleFolderSize = intSize\n    \n    On Error Goto 0\n\nEnd Function &#039;GetAccessibleFolderSize\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 6, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 11, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Provides an indication of whether the Managed Applications definitions file is up to date or out of date.\nExample: Up to Date", 
      "exclude_from_parse_flag": 1, 
      "hash": 2660023085, 
      "hidden_flag": 0, 
      "id": 19, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Managed Applications Status", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Managed Applications Status\n&#039;========================================\n\nOption Explicit\nDim hoursThreshold\nhoursThreshold = 23\n\n&#039; This sensor uses date math which is locale specific\nSetLocale(GetTaniumLocale) &#039;us/english by default\n\n\nConst HKLM = &amp;H80000002\nDim strSep\nstrSep = &quot;|&quot;\nDim objFso, strXml, objFile\nConst ForReading = 1\nSet objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nDim strMAPath\nstrMAPath = GetTaniumDir(&quot;Tools\\Managed Applications&quot;)\n\nDim strDatPath, strScanPath, strCurrentDir, oShell\n\nstrDatPath = strMAPath &amp; &quot;tanium.dat&quot;\nstrScanPath = strMAPath &amp; &quot;run-managed-applications-scan.vbs&quot;\n\nDim isDebug\nisDebug = False \nIf isDebug Then\n\tSet oShell = CreateObject(&quot;WScript.Shell&quot;)\n\tstrCurrentDir = objFso.GetParentFolderName(Wscript.ScriptFullName)\n\tstrDatPath = strCurrentDir &amp; &quot;\\tanium.dat&quot;\n\tWScript.Echo strDatPath\nEnd If \n\n&#039;Check if the scanner vbs exists\nIf Not objFso.FileExists(strScanPath) Then\n\tWScript.Echo &quot;Cannot find scanner&quot;\n\tWScript.Quit\nEnd If\n\n&#039;Check if the DAT file exists\nIf Not objFso.FileExists(strDatPath) Then\n\tWScript.Echo &quot;Cannot find DAT file&quot;\n\tWScript.Quit\nEnd If\n\nDim strAge\nstrAge = GetHoursOld(strDatPath)\n&#039;WScript.Echo &quot;Age in hours: &quot; &amp; strAge\nIf strAge &gt; hoursThreshold Then\n\tWScript.Echo &quot;Out of Date&quot;\nElse\n\tWScript.Echo &quot;Up to Date&quot;\nEnd If\t\nWScript.Quit\n\n\nFunction GetHoursOld(strDatPath)\n\tDim objDatFile\n\tSet objDatFile = objFso.GetFile(strDatPath)\t\n\tGetHoursOld = DateDiff(&quot;h&quot;, objDatFile.DateLastModified, Now())\nEnd Function\n\nFunction RegKey32Exists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 6, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 12, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "A sensor to return error conditions that would prevent the timely scan and delivery of patches.\nExample: \"Error: WUA Version is less than supported version 6.1.0022.4\"", 
      "exclude_from_parse_flag": 1, 
      "hash": 293035193, 
      "hidden_flag": 0, 
      "id": 21, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Patch Tools Errors", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patch Tools Errors\n&#039;========================================\n\n&#039; this sensor will return error conditions\n&#039; that would prevent the timely scan and delivery of patches\n\nOption Explicit\n\nOn Error Resume Next\nSetLocale(1033) &#039; this sensor uses date math, setting to us/english\n\n&#039; Hold whether to report a final error state\nDim bGlobalError : bGlobalError = False\n\n&#039; Global objects the functions may as well use\nDim objFSO,objReg\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\n\n&#039; First try the very basic access (FSO and registry access)\n\nIf Not TestFSO Then\n\tWScript.Echo &quot;Error: Cannot properly access filesystem&quot;\n\tWScript.Quit\nEnd If\n\nIf Not TestRegistry Then\n\tWScript.Echo &quot;Error: Cannot properly access registry&quot;\n\tWScript.Quit\nEnd If\n\n&#039; Pass the global error flag down each of the functions\n&#039; which will flip it and report their own errors\n\n&#039; do not use parentheses or will not pass ByRef.\n&#039; could use parentheses and use the Call keyword, however\n\nPatchCabOutOfDateOrNotFound bGlobalError\nPatchResultsErrors bGlobalError\nPatchResultsOutOfDate bGlobalError\nWUAVersionTooLow bGlobalError\nWSHVersionTooLow bGlobalError\n\nIf bGlobalError Then\n\t&#039; Do not report &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;Healthy&quot;\nEnd If\n\n&#039; --- Health Check Functions --- &#039;\n\nFunction WUAVersionTooLow(ByRef bHasError)\n\tDim strOutput, strSysDir, strWuaDll, i\n\tDim strNeededVersion, arrNeededVersion\n\tDim strVersion, arrVersion, intVersionPiece, bOldVersion\n\t\n\t&#039;adjust as required version changes\n\tstrNeededVersion = &quot;6.1.0022.4&quot;\n\tarrNeededVersion = Split(strNeededVersion,&quot;.&quot;)\n\t\n\tstrSysDir = GetSystemDir\t\t\n\tstrWuaDll = strSysDir &amp; &quot;\\wuaueng.dll&quot;\n\tIf objFSO.FileExists(strWuaDll) Then\n\t\tstrVersion = objFSO.GetFileVersion(strWuaDll)\n\t\tIf strVersion &lt;&gt; strNeededVersion Then\n\t\tarrVersion = Split(strVersion, &quot;.&quot;)\n\t\t&#039; We assume there will be 4 fields, if not throw error\n\t\t\tIf UBound(arrVersion) &lt;&gt; 3 Then\n\t\t\t\tbHasError = True\n\t\t\t\tstrOutput = &quot;Error: Cannot determine Windows Update Agent version, does not look like X.X.X.X&quot;\n\t\t\tElse\n\t\t\t\tbOldVersion = False &#039;assume version is good\n\t\t\t\t&#039; loop through each part\n\t\t\t\t&#039; if any individual part is less than its corresponding required part\n\t\t\t\tFor i = 0 To UBound(arrVersion)\n\t\t\t\t\tIf CInt(arrVersion(i)) &lt; CInt(arrNeededVersion(i)) Then\n\t\t\t\t\t\tbOldVersion = True\n\t\t\t\t\t\tExit For &#039; No further checking necessary, it&#039;s out of date\n\t\t\t\t\tEnd If\n\t\t\t\tNext\n\t\t\t\tIf bOldVersion Then \n\t\t\t\t\tstrOutput = &quot;Error: WUA Version is less than supported version &quot; &amp; strNeededVersion\n\t\t\t\t\tbHasError = True\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; versions are the same\n\t\tEnd If\n\tElse \n\t\tstrOutput = &quot;Error: WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;\n\t\tbHasError = True\n\tEnd If\n\t\n\tWScript.Echo strOutput\n\nEnd Function &#039;WUAVersionTooLow\n\nFunction WSHVersionTooLow(ByRef bGlobalError)\n&#039; this function ensures wsh version 5.6\n\tDim WSHVersion\n\tWSHVersion = &quot;&quot;\n\tWSHVersion = WScript.Version\n\tIf Not MyIsNumeric(WSHVersion) Then\n\t\tWScript.Echo &quot;Error: Unknown Windows Script Host version&quot;\n\t\tbGlobalError = True\n\tElse\n\t\tWSHVersion = CDbl(WSHVersion)\n\t\tIf WSHVersion &lt; 5.6 Then\n\t\t\tWScript.Echo &quot;Error: Windows Script Host version must be at least 5.6&quot;\n\t\t\tbGlobalError = True\n\t\tEnd If\n\tEnd If\nEnd Function &#039;WSHVersionTooLow\n\nFunction MyIsNumeric(strTemp)\n\tDim i,d\n\tIf IsNull(strTemp) Then\n\t\tMyIsNumeric = False\n\t\tExit Function\n\tEnd If\n\tIf strTemp = &quot;&quot; Then\n\t\tMyIsNumeric = False\n\t\tExit Function\n\tEnd If\n\t\n    MyIsNumeric = True\n    For i = 1 to Len(strTemp) \n        d = Mid(strTemp, i, 1) \n        If Asc(d) &lt; 48 OR Asc(d) &gt; 57 Then \n            isReallyNumeric = False \n            Exit For \n        End If \n    Next \nEnd Function\n\n\n\n\nFunction PatchCabOutOfDateOrNotFound(ByRef bHasError)\n&#039; This function will return an error message if the patch cab is\n&#039; out of date\n\tDim objCabFile\n\tDim ageThreshold,strToolsDir,strPatchCabPath\n\tDim words,minutesOld\n\t\n\tageThreshold = 60*48       &#039;2 days in minutes\n\t\n\tstrToolsDir = GetTaniumDir(&quot;Tools&quot;)\n\tstrPatchCabPath = strToolsDir &amp; &quot;\\wsusscn2.cab&quot;\n\n\tIf objFSO.FileExists(strPatchCabPath) Then\n\t\tSet objCabFile = objFSO.GetFile(strPatchCabPath)\n\t\twords = Split(objCabFile.DateLastModified, &quot; &quot;)\n\t\t\n\t\tminutesOld = GetMinutesOld(objCabFile.DateLastModified)\n\t\tif cint(minutesOld) &gt;= ageThreshold Then\n\t\t  Wscript.echo  &quot;Error: Patch definition Cab file hasn&#039;t been modified in over 2 days&quot;\n\t\t  bHasError = True\n\t\tEnd If\n\tElse\n\t\t  Wscript.echo  &quot;Error: Patch Cab not found&quot;\n\t\t  bHasError = True\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet objCabFile = Nothing\n\nEnd Function &#039;PatchCabOutOfDateOrNotFound\n\nFunction PatchResultsErrors(ByRef bHasError)\n\n\tDim fn, objReadFile, contents, path, strSep\n\tstrSep = &quot;|&quot;\n\t\n\t&#039; results should look like:\n\t&#039;title|severity|bulletins|creation date|urls|filenames|etc ..\n\t\n\t&#039; first check \n\tpath = GetTaniumDir(&quot;Tools\\Scans&quot;)\n\n\tfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\n\tIf objFSO.FileExists(fn) Then\n\t\t&#039; If file exists but there&#039;s an issue opening it\n\t\tOn Error Resume Next\n\t\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\t\tIf Err.Number &lt;&gt; 0 Then\n\t\t\tWScript.Echo &quot;Error: Patch results file exists but cannot open&quot;\n\t\t\tbHasError = True\n\t\t\tExit Function\n\t\tEnd If\n\t\n\t\tOn Error Goto 0\n\t\t&#039; Check on all patch results lines\n\t\t&#039; If we locate any that do not have the separator value in them, throw an\n\t\t&#039; invalid line entry and exit the function\n\t\tDim strLine, words\n\t\tDo While Not objReadFile.AtEndOfStream\n\t\t\tstrLine = objReadFile.ReadLine\n\t\n\t\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\t\tIf Not InStr(strLine,strSep) &gt; 0 Then &#039; must be an invalid line\n\t\t\t\tWScript.Echo &quot;Error: Invalid patch results line says - &quot; &amp; strLine\n\t\t\t\tbHasError = True\n\t\t\tEnd If\n\t\tLoop\n\t\n\t\tobjReadFile.close\n\tElse\n\t   Wscript.echo &quot;Error: Patch results output not found&quot;\n\t   bHasError = True\n\tEnd If\nEnd Function &#039;PatchResultsErrors\n\nFunction PatchResultsOutOfDate(ByRef bHasError)\n\tDim objFile\n\tDim strScansDir, strResultsPath, daysOld, words\n\t\n\t&#039; This sensor uses date math which is locale specific\n\tSetLocale(1033) &#039;us/english\n\t\t\n\tstrScansDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\n\tstrResultsPath = strScansDir &amp; &quot;\\patchresultsreadable.txt&quot;\n\t\t\n\tIf objFso.FileExists(strResultsPath) Then\n\t\tSet objFile = objFso.GetFile(strResultsPath)\n\t\twords = Split(objFile.DateLastModified, &quot; &quot;)\n\t\t\n\t\tdaysOld = GetDaysOld(words(0))\n\t\tif cint(daysOld) &gt;= 4 Then\n\t\t  Wscript.echo  &quot;Error: Microsoft patches not scanned in at least 4 days&quot;\n\t\t  bHasError = True\n\t\tEnd If\n\t\n\tElse\n\t\t&#039; Results not found, but would be checked with other function\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet objFile = Nothing\n\nEnd Function &#039;PatchResultsOutOfDate\n\n\n&#039; ---- Support Functions ---- &#039;\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction GetMinutesOld(strDate)\n&#039;date format is MM/DD/YYYY \n\tSetLocale(1033)\n\tDim patternDate, today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( now )\n\tGetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)\nEnd Function &#039;GetMinutesOld\n\nFunction GetDaysOld(strDate)\n&#039;date format is MM/DD/YYYY \n\tSetLocale(1033)\n\tDim patternDate, today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( now )\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function &#039;GetDaysOld\n\n\nFunction GetSystemDir \n\tDim strWinDir,strSysDir\n\t\n\t&#039;Check for 64-bit sysnative directory to avoid win redirect\n\tstrWinDir = objFSO.GetSpecialFolder(0)\n\tstrSysDir = strWinDir &amp; &quot;\\sysnative&quot;\n\t\n\tIf Not objFSO.FolderExists(strSysDir) Then\n\t\tstrSysDir = objFSO.GetSpecialFolder(1)\n\tEnd If\n\tGetSystemDir = strSysDir\nEnd Function &#039; GetSystemDir\n\nFunction TestRegistry\n&#039; this function will return true if a registry access test via WMI succeeds\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim aValueNames, aValueTypes\n\tOn Error Resume Next\n\tIf objReg.EnumValues(HKLM, &quot;SYSTEM&quot;, aValueNames, aValueTypes) = 0 Then\n\t\tTestRegistry = True\n\tElse\n\t\tTestRegistry = False\n\tEnd If\n\tOn Error Goto 0\n\nEnd Function &#039;TestRegistry\n\nFunction TestFSO\n&#039; this function will return true if an FSO call succeeds\n\n\tDim strWinDir\n\t&#039;Every machine has a windir\n\tOn Error Resume Next\n\tstrWinDir = objFSO.GetSpecialFolder(0)\n\t\n\tIf Not objFSO.FolderExists(strWinDir) Then\n\t\tTestFSO = False\n\tElse\n\t\tTestFSO = True\n\tEnd If\n\tOn Error Goto 0\n\nEnd Function &#039;TestFSO", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 13, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns whether the client is in a 'locked' state. Use the package \"Tanium Client Action Unlock\" to unlock the Client and allow actions.\nExample: Action Lock On", 
      "exclude_from_parse_flag": 1, 
      "hash": 2671758800, 
      "hidden_flag": 0, 
      "id": 23, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 120, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Action Lock Status", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Action Lock Status\n&#039;========================================\n\nOption Explicit\n\nIf ActionLockOn Then\n\tWScript.Echo &quot;Action Lock On&quot;\nElse\n\tWScript.Echo &quot;Action Lock Off&quot;\nEnd If\n\nFunction ActionLockOn\n&#039; returns true or false\n\tDim objShell,strRegistryPath,intLockStatus\n\t\n\tstrRegistryPath = GetTaniumRegistryPath\n\t\n\tSet objShell = WScript.CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLockStatus = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRegistryPath&amp;&quot;\\ActionLockFlag&quot;)\n\t\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLockStatus = 0\n\tEnd If\n\tOn Error Goto 0\n\t\n\tIf intLockStatus = 1 Then\n\t\tActionLockOn = True\n\tElse\n\t\tActionLockOn = False\n\tEnd If\n\nEnd Function &#039;ActionLockOn\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;GetTaniumRegistryPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 14, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Retrieves the PowerShell Execution Policy as the Tanium Client sees it", 
      "exclude_from_parse_flag": 1, 
      "hash": 1805210070, 
      "hidden_flag": 0, 
      "id": 25, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium PowerShell Execution Policy", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium PowerShell Execution Policy\n&#039;========================================\n\n&#039; this sensor will retrieve the PowerShell Execution Policy\n&#039; of the 32-bit environment\n\nOption Explicit\n\nDim objShell : Set objShell = CreateObject(&quot;WScript.Shell&quot;)\nDim objShellExec\nDim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nDim strPSPath,strLine\nstrPSPath = objFSO.GetSpecialFolder(1)&amp;&quot;\\WindowsPowerShell\\v1.0\\powershell.exe&quot;\nIf objFSO.FileExists(strPSPath) Then\n\tSet objShellExec = objShell.Exec(Chr(34)&amp;strPSPath&amp;Chr(34)&amp;&quot; -Command Get-ExecutionPolicy;Exit&quot;)\n\tDo Until objShellExec.StdOut.AtEndOfStream\n\t\tstrLine = objShellExec.StdOut.ReadLine\n\t\tIf Not strLine = &quot;&quot; Then\n\t\t\tWScript.Echo strLine\n\t\t\tExit Do\n\t\tEnd If\n\tLoop\nElse\n\tWScript.Echo &quot;Cannot locate PowerShell executable&quot;\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 15, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Version number of  Tanium Server installed. \nExample: 6.2.314.3218", 
      "exclude_from_parse_flag": 1, 
      "hash": 711837192, 
      "hidden_flag": 0, 
      "id": 27, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium Server Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Server Version\n&#039;========================================\n\nOption Explicit\n\n\nDim fso, filePath, objFile\n\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nIf GetTaniumDir(&quot;&quot;) = False Then \n\tWScript.Echo &quot;Not installed&quot;\n\tWScript.Quit\nEnd If \n\nfilePath = GetTaniumDir(&quot;&quot;) &amp; &quot;TaniumReceiver.exe&quot;\n\nIf fso.FileExists(filePath) Then\n\tSet objFile = fso.GetFile(filePath)\n\tWScript.Echo fso.GetFileVersion(objFile)\nElse\n\tWScript.Echo &quot;Not installed&quot;\nEnd If\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Server&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Server&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 16, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Version number of  Tanium Zone Server installed. \nExample: 6.2.314.3218", 
      "exclude_from_parse_flag": 1, 
      "hash": 333178608, 
      "hidden_flag": 0, 
      "id": 29, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium Zone Server Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Zone Server Version\n&#039;========================================\n\nOption Explicit\n\nConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\nConst keyNativePath = &quot;Software\\Tanium\\Tanium ZoneServer&quot;\nConst keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium ZoneServer&quot;\n\nDim fso, dirPath, filePath, objFile, objReg\n\n&#039; Zone Server has to be treated differently than client and server\n&#039; The latest Zone Server will write the \nSet objReg = Getx64RegistryProvider()\n\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nSet objReg = Getx64RegistryProvider()\n\ndirPath = Null\n\nIf RegKeyExists(objReg, HKEY_LOCAL_MACHINE, keyNativePath) Then \n\tobjReg.GetStringValue HKEY_LOCAL_MACHINE, keyNativePath, &quot;Path&quot;, dirPath\nEnd If\n\nIf IsNull(dirPath) Then \n\tIf RegKeyExists(objReg, HKEY_LOCAL_MACHINE, keyWowPath) Then \n\t\tobjReg.GetStringValue HKEY_LOCAL_MACHINE, keyWowPath, &quot;Path&quot;, dirPath\n\tEnd If\nEnd If\n\nfilePath = dirPath &amp; &quot;\\TaniumZoneServer.exe&quot;\n\nIf fso.FileExists(filePath) Then\n\tSet objFile = fso.GetFile(filePath)\n\tWScript.Echo fso.GetFileVersion(objFile)\nElse\n\tWScript.Echo &quot;Not installed&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 17, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the value of a supplied Tanium Client Setting fom the Tanium Clients registry key.  Supply only the client setting name, for instance: ServerName and the output will appear as follows:\nExample: berkeley.tanium.com", 
      "exclude_from_parse_flag": 1, 
      "hash": 3760050184, 
      "hidden_flag": 0, 
      "id": 31, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Tanium Client Explicit Setting", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)\",\"value\":\"\",\"promptText\":\"Enter the Client Setting Name\",\"defaultValue\":\"\",\"label\":\"Client Setting Name\",\"maxChars\":64,\"key\":\"setting\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Value Data\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Data | Type | Architecture | KeyPath | Value\n\n&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)\n\nstrKey = &quot;HKLM\\&quot;&amp;GetTaniumRegistryPath()\nstrValue = unescape(&quot;||setting||&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n&#039;strValue = &quot;Version&quot;\n\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n&#039;strValue = &quot;Emailname&quot;\nstrSep = &quot;~~&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\n\t\thasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\n\tEnd If\nEnd If\n\nIf Not (hasAnyResult) Then\n\tWScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\tarrTypes = Outparams.Types\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\t\n\t\t\t&#039;if strValue is found, echo\n\t\t\tIf LCase(strValueName) = LCase(strValue) Then\n\t\t\t\tEchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit\n\t\t\t\tCheckValues = True\n\t\t\t\tExit Function\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\tCheckValues = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit)\n\tIf intBit = 64 Then\n\t\tstrArch = &quot;64-bit&quot;\n\tElse\n\t\tstrArch = &quot;32-bit&quot;\n\tEnd If\n\t\t\t\n\tGetDisplayString = strValue\nEnd Function\n\nFunction EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)\n\t&#039; Note the key that was being searched, will be a hidden column\n\tstrOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n\t\n\tDim objInParams, objOutParams\n\tSelect Case constType\n\t\tCase REG_SZ  \n\t\t\tSet objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_EXPAND_SZ\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_BINARY\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)\n\n\t\t\tstrBytes = &quot;&quot;\n\t\t\tFor Each uByte in objOutParams.uValue\n\t\t\t\tstrTemp = Hex(uByte)\n\t\t\t\tIf Len(strTemp) &lt; 2 Then\n\t\t\t\t\tstrTemp = &quot;0&quot; &amp; strTemp\n\t\t\t\tEnd If\t\n\t\t\t\tstrBytes = strBytes &amp; strTemp &amp; &quot; &quot;\n\t\t\tNext\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)\n\t\tCase REG_DWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_QWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_MULTI_SZ\n\t\t    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tarrValues = objOutParams.sValue\n\t\t\tstrResponse = &quot;&quot;\n\n\t\t\tFor Each strTemp In arrValues\n\t\t\t\tIf strResponse = &quot;&quot; Then\n\t\t\t\t\tstrResponse = strTemp\n\t\t\t\tElse\n\t\t\t\t\tstrResponse = strResponse &amp; vbCrLf &amp; strTemp\n\t\t\t\tEnd If\n\t\t\tNext\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)\n\tEnd Select\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||setting||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||setting||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 18, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns Yes or No to indicate whether the hardware is virtual.\nEcho: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 1022769818, 
      "hidden_flag": 0, 
      "id": 33, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Is Virtual", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Is Virtual\n&#039;========================================\n\n&#039; This sensor will determine if a machine is a virtual machine or not\n&#039; Comparing values for certain properties against known values.\n&#039; It will need to be updated for some current tech and \n&#039; as new technologies come to market.\n\n\nOption Explicit\n\nIf IsVM Then \n    WScript.Echo &quot;Yes&quot;\nElse\n    WScript.Echo &quot;No&quot;\nEnd If\n\n\nFunction IsVM\n\tDim sVMPlatform, sMake, sModel, sBIOSVersion,bIsVM\n\n    &#039; Check the WMI information against known values\n\n    bIsVM = false\n    sVMPlatform = &quot;&quot;\n\n    sMake = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Manufacturer&quot;)\n    sModel = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Model&quot;)\n    sBIOSVersion = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_BIOS&quot;, &quot;Version&quot;)\n\n    &#039;WScript.Echo &quot;Manufacturer=&quot; &amp; sMake\n    &#039;WScript.Echo &quot;Model=&quot; &amp; sModel\n    &#039;WScript.Echo &quot;BIOSVersion=&quot; &amp; sBIOSVersion\n\n    If sModel = &quot;Virtual Machine&quot; Then\n\n        &#039; Microsoft virtualization technology detected, assign defaults\n\n        sVMPlatform = &quot;Hyper-V&quot;\n        bIsVM = true\n\n        &#039; Try to determine more specific values\n\n        Select Case sBIOSVersion\n        Case &quot;VRTUAL - 1000831&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 Beta or RC0&quot;\n        Case &quot;VRTUAL - 5000805&quot;, &quot;BIOS Date: 05/05/08 20:35:56  Ver: 08.00.02&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 RTM&quot;\n        Case &quot;VRTUAL - 3000919&quot; \n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 R2&quot;\n        Case &quot;A M I  - 2000622&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005R2SP1 or VPC2007&quot;\n        Case &quot;A M I  - 9000520&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005R2&quot;\n        Case &quot;A M I  - 9000816&quot;, &quot;A M I  - 6000901&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Windows Virtual PC&quot;\n        Case &quot;A M I  - 8000314&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005 or VPC2004&quot;\n        Case &quot;Xen - 0s&quot;\n        \tbIsVM = True\n        \tsVMPlatform = &quot;Xen&quot;\n        Case &quot;Xen - 0&quot;\n        \tbIsVM = True\n        \tsVMPlatform = &quot;Xen&quot;\n        End Select\n\n    ElseIf sMake = &quot;Xen&quot; Then\n    \n        &#039; Xen detected\n\n        sVMPlatform = &quot;Xen&quot;\n        bIsVM = true\n    \n    ElseIf sModel = &quot;VMware Virtual Platform&quot; then\n\n        &#039; VMware detected\n\n        sVMPlatform = &quot;VMware&quot;\n        bIsVM = true\n\n    ElseIf sModel  = &quot;VirtualBox&quot; then\n\n        &#039; VirtualBox detected\n\n        bIsVM = true\n        sVMPlatform = &quot;VirtualBox&quot;\n    \n    ElseIf sModel  = &quot;HVM domU&quot; then\n\n        &#039; Xen detected\n\n        bIsVM = true\n        sVMPlatform = &quot;Xen&quot;\n        \n    Else \n        &#039; This computer does not appear to be a virtual machine.\n    End if\n\n    &#039; Set the return value\n\n    If bIsVM Then\n    \t&#039; Let&#039;s not actually do anything here \n        &#039;WScript.Echo &quot;IsVirtualMachine=True&quot;\n        &#039;WScript.Echo &quot;VirtualMachinePlatform=&quot; &amp; sVMPlatform\n    Else\n        &#039;WScript.Echo &quot;IsVirtualMachine=False&quot;\n    End If\n\n    IsVM = bIsVM\n\nEnd Function\n\nFunction GetWmiPropertyValue(strNameSpace, strClassName, strPropertyName)\n\tDim strPropertyValue, oWMIClass, oWMIProperties, objWMIService, colItems\n\tDim objItem, objProperty\n\tDim sLine\n\t\n    On Error Resume Next\n\n    strPropertyValue = &quot;&quot;\n    set oWmiClass = getobject(&quot;winmgmts:&quot; &amp; strNameSpace).get(strClassName,&amp;h20000) &#039;amended\n    set oWmiProperties = oWmiClass.Properties_\n\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; &quot;.&quot; &amp; &quot;\\&quot; &amp; strNameSpace)\n    Set colItems = objWMIService.ExecQuery(&quot;Select * from &quot; &amp; strClassName,,48)\n\n    For Each objItem in colItems\n        For Each objProperty in oWmiProperties\n            sLine = &quot;&quot;\n            &#039;WScript.Echo &quot;- &quot; &amp; objProperty.name &amp; &quot;: &quot; &amp; strPropertyName\n\n            If objProperty.Name = strPropertyName Then\n                If objProperty.IsArray = True Then\n                    sLine = &quot;str&quot; &amp; objProperty.Name &amp; &quot; = Join(objItem.&quot; &amp; objProperty.Name &amp; &quot;, &quot; &amp; Chr(34) &amp; &quot;,&quot; &amp; Chr(34) &amp; &quot;)&quot; &amp; vbCrLf\n                    sLine = sLine &amp; &quot;strPropertyValue =  str&quot; &amp; objProperty.Name\n                &#039;ElseIf objProperty.CIMTYPE = 101 Then\n                &#039;    bHasDates = True\n                &#039;    sLine =  &quot;strPropertyValue =  WMIDateStringToDate(objItem.&quot; &amp; objProperty.Name &amp; &quot;)&quot;\n                Else\n                    sLine =  &quot;strPropertyValue =  objItem.&quot; &amp; objProperty.Name\n                End If\n\n                &#039;WScript.Echo sLine\n                Execute sLine\n            End If\n\n        Next\n    Next\n\n    GetWmiPropertyValue = strPropertyValue\n    \n    &#039;Cleanup!\n    set oWmiClass = Nothing\n    set oWmiProperties = Nothing\n\n    Set objWMIService = Nothing\n    Set colItems = Nothing\n\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 19, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns whether the machine runs Windows.  True if so, False if not.\nExample: True", 
      "exclude_from_parse_flag": 0, 
      "hash": 2721439124, 
      "hidden_flag": 0, 
      "id": 35, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Is Windows", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Is Windows\n&#039;========================================\n\nWscript.echo &quot;True&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\necho False\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\necho False\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 20, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": "|", 
      "description": "Returns a group name and a member of that group on each line. For each member in any group, two columns of output will appear.\nExample: Administrators|user.name", 
      "exclude_from_parse_flag": 0, 
      "hash": 443412787, 
      "hidden_flag": 0, 
      "id": 37, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Local Groups With Members", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Local Groups With Members\n&#039;========================================\n\n&#039; output all local groups\n&#039; for each member of a group, output the group in the first column\n&#039; and the member in the second column.\n\n&#039; Contains hidden columns, full output is:\n&#039; Group Name|Member Name|ADSPath|PerfectMatchMember|PerfectMatchGroup\n&#039; Final three are hidden. ADSPath is for feeding actions. PerfectMatch columns\n&#039; allow for exact beginning to end matches in a column using contains.\n\n\nOption Explicit\n\nDim strGroup, dictBlacklist,dictGroups,bShouldWrite\nSet dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; Add one line for each user or group that you do not want listed in the sensor output.  \n&#039;dictBlacklist.Add (&quot;IgnoreMe&quot;), True &#039;Case insensitive\n\n&#039; Do not run on a Domain Controller, would list all domain groups\nIf IsDC Then WScript.Quit\n\nSet dictGroups = GetLocalGroupsAndMembers\nFor Each strGroup In dictGroups.Keys\n\tbShouldWrite = True\n\tDim strItem,strMember\n\tFor Each strMember In Split(dictGroups.Item(strGroup),&quot;,&quot;)\n\t\tFor Each strItem In dictBlacklist.Keys\n\t\t\tIf ( InStr(1,strGroup, strItem, vbTextCompare) &gt; 0 _ \n\t\t\t\tOr InStr(1,strMember,strItem,vbTextCompare) &gt; 0) Then\n\t\t\t\tbShouldWrite = False\n\t\t\tEnd If\n\t\tNext\n\t\tIf bShouldWrite Then WScript.Echo strGroup &amp;&quot;|&quot;&amp; strMember\t\n\tNext\nNext\n\nFunction GetLocalGroupsAndMembers\n\n\tDim colGroups,objGroup,dictGroups,strMembers,objMember,i\n\tDim objReg,objCTX,strMember,strDomain,strADSPath,strShortDomain\n\tDim strPostADS,arrDomainSplit,objWshNet,strComputer\n\tDim strPerfectMatchMemberName,strPerfectMatchGroupName\n\t\n\tSet objCtx = GetObjCtx(32)\n\tSet objReg = GetObjReg(objCtx)\t\n\t\t\n\tSet colGroups = GetObject(&quot;WinNT://.&quot;)\n\tcolGroups.Filter = Array(&quot;group&quot;)\n\tSet dictGroups = CreateObject(&quot;Scripting.Dictionary&quot;)\n\tSet objWshNet = CreateObject(&quot;WScript.Network&quot;)\n\n\tstrComputer = objWshNet.ComputerName\n\t\t\n\tFor Each objGroup In colGroups\n\t\t&#039; encapsulate group string in something we can compare against in questions. Hidden column at end\n\t\tstrPerfectMatchGroupName = &quot;:G:&quot;&amp;objGroup.Name&amp;&quot;:&quot;\n\t\ti = 0\n\t\tstrMembers = &quot;&quot;\n    \tIf Not dictGroups.Exists(objGroup.Name) Then\n    \t\tFor Each objMember in objGroup.Members\n    \t\t\tIf objMember.Name = &quot;&quot; Then\n    \t\t\t\tstrMember = &quot;::Blank/Error::&quot;\n    \t\t\tElse\n    \t\t\t\tstrMember = objMember.Name\n    \t\t\tEnd If\n    \t\t\t\n    \t\t\tIf InStr(strMember,&quot;S-&quot;) &gt; 0 Then\n\t\t\t\t\t&#039; Possible SID entry, try to resolve\n\t\t\t\t\tstrMember = GetUserForSIDLocal(objReg,strMember)&amp;&quot; (unresolvable)&quot;\n\t\t\t\tEnd If\t\n\t\t\t\tstrADSPath = objMember.ADSPath\n\t\t\t\tstrPostADS = Replace(strADSPath,&quot;WinNT://&quot;,&quot;&quot;)\n\t\t\t\t\n\t\t\t\tIf InStr(strPostADS,&quot;/&quot;) &gt; 0 Then\n\t\t\t\t\t&#039;domain user\n\t\t\t\t\tarrDomainSplit = Split(strPostADS,&quot;/&quot;)\n\t\t\t\t\tIf UBound(arrDomainSplit) &gt; 0 Then\n\t\t\t\t\t\tstrDomain = arrDomainSplit(0)\n\t\t\t\t\t\tstrMember = arrDomainSplit(1)\n\t\t    \t\t\tIf InStr(strMember,&quot;S-&quot;) &gt; 0 Then\n\t\t\t\t\t\t\t&#039; Possible SID entry, try to resolve\n\t\t\t\t\t\t\tstrMember = GetUserForSIDLocal(objReg,strMember)&amp;&quot; (unresolvable / cached)&quot;\n\t\t\t\t\t\tEnd If\t\t\t\t\n\t\t\t\t\tElse\n\t\t\t\t\t\tstrDomain = &quot;Unknown&quot;\n\t\t\t\t\t\tstrMember = &quot;Unknown&quot;\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\n\t\t\t\tIf InStr(1,objMember.ADSPath,strComputer) &gt; 0 Then &#039;local entry\t\t\n\t\t\t\t\tstrADSPath = Replace(objMember.ADSPath,strComputer,&quot;::ComputerName::&quot;,1,1,vbTextCompare)\n\t\t\t\t\t&#039; output a perfect match name like &quot;::GroupName::&quot; so you cna do contains &quot;::GroupName::&quot;\n\t\t\t\t\t&#039; and know you&#039;re matching the group name, beginning to end and no other entries\n\t\t\t\t\tstrPerfectMatchMemberName=&quot;:M:&quot;&amp;strMember&amp;&quot;:&quot;\n\t\t\t\t\tstrMembers = strMembers&amp;&quot;,&quot;&amp;strMember&amp;&quot;|&quot;&amp;strADSPath&amp;&quot;|&quot; _\n\t\t\t\t\t\t&amp;strPerfectMatchMemberName&amp;&quot;|&quot;&amp;strPerfectMatchGroupName\n\t\t\t\tElse\n\t\t\t\t\tstrADSPath = objMember.ADSPath\n\t\t\t\t\tstrPerfectMatchMemberName=&quot;:M:&quot;&amp;strDomain&amp;&quot;\\&quot;&amp;strMember&amp;&quot;:&quot;\n\t\t\t\t\tstrMembers = strMembers&amp;&quot;,&quot;&amp;strDomain&amp;&quot;\\&quot;&amp;strMember&amp;&quot;|&quot;&amp;strADSPath&amp;&quot;|&quot; _\n\t\t\t\t\t\t&amp;strPerfectMatchMemberName&amp;&quot;|&quot;&amp;strPerfectMatchGroupName\n\t\t\t\tEnd If\n    \t\t\ti = i + 1\n    \t\tNext\n    \t\tIf i &gt; 0 Then\n\t\t\t\t&#039; Remove preceeding delimiter\n\t\t\t\tstrMembers = Right(strMembers,Len(strMembers) - 1)\n\t\t\tElse\n\t\t\t\tstrMembers = &quot;::Empty Group::&quot;\n\t    \tEnd If\n\t    \tdictGroups.Add objGroup.Name,strMembers\t    \t\n    \tEnd If\t\n    Next\n\tSet GetLocalGroupsAndMembers = dictGroups\nEnd Function &#039;GetLocalGroups\n\n\nFunction IsDC\n&#039; This function will return True if the machine is on a domain\n&#039; and False if not or if it&#039;s a domain controller\n\t\n\tDim objWMIService, colItems, objItem\n\tDim bDomainMember, intDomainRole\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;,,48)\n\n\tFor Each objItem in colItems\n\t\tbDomainMember = objItem.PartOfDomain\n\t\tintDomainRole = objItem.DomainRole\n\tNext\n\t\n\tIf bDomainMember = &quot;True&quot; And (intDomainRole = 4 Or intDomainRole = 5) Then\n\t\t&#039; Skip if on domain and is domain controller\t\n\t\tIsDC = True\n\tElse\n\t\tIsDC = False\n\tEnd If\n\nEnd Function &#039;IsDC\n\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = strSID\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = strSID\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\n\nFunction SplitDomain(strEntry)\n\t&#039; examines entry, returns array:\n\t&#039; Domain|Member\n\t\n\tDim arrOut,strDomain,strMember,arrSplit,objWshNet,strComputer\n\tDim arrADSSplit,strRest\n\t\n\tSet objWshNet = CreateObject(&quot;WScript.Network&quot;)\n\tstrComputer = objWshNet.ComputerName\n\t\n\t&#039;&#039; right here we need to return a domain|Member split from the adspath\n\t&#039;&#039; if the domain is the computer name, don&#039;t output that\n\t\n\tIf InStr(strEntry,&quot;@&quot;) &gt; 0 Then\n\t\tarrSplit = Split(strEntry,&quot;@&quot;)\n\t\tIf UBound(arrSplit) &gt; 0 Then\n\t\t\tstrMember = arrSplit(0)\n\t\t\tstrDomain = arrSplit(1)\n\t\tEnd If\n\tElseIf InStr(strEntry,&quot;\\&quot;) &gt; 0 Then\n\t\tarrSplit = Split(strEntry,&quot;\\&quot;)\n\t\tIf UBound(arrSplit) &gt; 0 Then\n\t\t\tstrDomain = arrSplit(0)\n\t\t\tstrMember = arrSplit(1)\n\t\tEnd If\n\tElseIf InStr(strEntry,&quot;//&quot;) &gt; 0 Then\n\t\t&#039; is ADSPath\n\t\tarrADSSplit = Split(strEntry,&quot;//&quot;)\n\t\tstrDomain = Split(arrADSSplit(1),&quot;/&quot;)(0)\n\t\tstrMember = Split(arrADSSplit(1),&quot;/&quot;)(1)\t\n\tElse\n\t\tstrDomain = &quot;&quot;\n\t\tstrMember = strEntry\n\tEnd If\n\t\n\tarrOut = Array(strDomain,strMember)\n\t\n\tSplitDomain = arrOut\n\t\nEnd Function &#039;SplitDomain", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 25, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Group Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Member Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "ADSPath", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "PerfectMatch Member Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "PerfectMatch Group Name", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 21, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the names of Local Groups on Windows machines.\nExample:Administrators", 
      "exclude_from_parse_flag": 0, 
      "hash": 28471576, 
      "hidden_flag": 0, 
      "id": 39, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Local Groups", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Local Groups\n&#039;========================================\n\n&#039; output all local groups\n\nOption Explicit\n\nDim strGroup, dictBlacklist,dictGroups\nSet dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; Add one line for each user or group that you do not want listed in the sensor output.  \n&#039;dictBlacklist.Add LCase(&quot;IgnoreMe&quot;), True\n\n&#039; Do not run on a Domain Controller, would list all domain groups\nIf IsDC Then WScript.Quit\n\nSet dictGroups = GetLocalGroups\nFor Each strGroup In dictGroups.Keys\n\tDim bShouldList,strItem\n\tbShouldList = True\n\n\tFor Each strItem In dictBlacklist.Keys\n\t\tIf InStr(LCase(strGroup), strItem) &gt; 0 Then \n\t\t\tbShouldList = False\n\t\tEnd If\n\tNext\n\n\tIf bShouldList Then \n\t\tWScript.Echo strGroup\n\tEnd If \nNext\n\nFunction GetLocalGroups\n\n\tDim colGroups,objGroup,dictGroups\n\tSet colGroups = GetObject(&quot;WinNT://.&quot;)\n\tcolGroups.Filter = Array(&quot;group&quot;)\n\tSet dictGroups = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\n\tFor Each objGroup In colGroups\n    \tIf Not dictGroups.Exists(objGroup.Name) Then\n\t    \tdictGroups.Add objGroup.Name, 1\n    \tEnd If\t\n    Next\n\tSet GetLocalGroups = dictGroups\nEnd Function &#039;GetLocalGroups\n\n\nFunction IsDC\n&#039; This function will return True if the machine is on a domain\n&#039; and is a domain controller\n\t\n\tDim objWMIService, colItems, objItem\n\tDim bDomainMember, intDomainRole\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;,,48)\n\n\tFor Each objItem in colItems\n\t\tbDomainMember = objItem.PartOfDomain\n\t\tintDomainRole = objItem.DomainRole\n\tNext\n\t\n\tIf bDomainMember = &quot;True&quot; And (intDomainRole = 4 Or intDomainRole = 5) Then\n\t\t&#039; on domain and is domain controller\t\n\t\tIsDC = True\n\tElse\n\t\tIsDC = False\n\tEnd If\n\nEnd Function &#039;IsDC", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 20, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 22, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": "|", 
      "description": "List of the applications and versions of those applications installed on the client machine.\nExample: Mozilla Firefox | 16.0.1", 
      "exclude_from_parse_flag": 1, 
      "hash": 1511329504, 
      "hidden_flag": 0, 
      "id": 41, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Installed Applications", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Installed Applications\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039; This sensor will return information in the uninstall areas of the registry.\n&#039; There are two hidden columns which can be filtered on despite the fact that\n&#039; they&#039;re hidden, and can also feed actions.\n&#039; if the uninstallstring is msi based, it is altered to show the\n&#039; silent uninstall options and marked as &quot;Is Uninstallable&quot;\n&#039; finally, if it&#039;s a user installed application, it will note that\n&#039; The columns look like:\n&#039; Name|Version|Silent Uninstall String|Uninstallable\n\nSensorRandomize()\n\nSet objRegistry = Getx64RegistryProvider()\n\nkeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;\nkey64Path = &quot;SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;\n\nConst HKLM = &amp;H80000002\nConst HKEY_USERS = &amp;H80000003\n\n&#039; list out 32-bit applications on a 64-bit system\nIf RegKeyExists(HKLM, key64Path) Then\n\tobjRegistry.EnumKey HKLM, key64Path, arrSubKeys\n\tGetApplications HKLM,key64path,arrSubKeys\nEnd If\n\n&#039; list out 32-bit applications on a 32-bit system, or 64-bit applications\n&#039; on a 64-bit system.\nIf RegKeyExists(HKLM, keyPath) Then\n\tobjRegistry.EnumKey HKLM, keypath, arrSubKeys\n\tGetApplications HKLM,keypath,arrSubKeys\nEnd If\n\n&#039; Also list out applications installed to HKEY_Users areas\n&#039; which will be appended to the arrSubKeys\nobjRegistry.EnumKey HKEY_USERS, &quot;&quot;, arrUserKeys\nFor Each strSIDkey In arrUserKeys\n\tIf RegKeyExists(HKEY_USERS, strSIDKEY&amp;&quot;\\&quot;&amp;keyPath) Then\n\t\tobjRegistry.EnumKey HKEY_USERS, strSIDkey&amp;&quot;\\&quot;&amp;keyPath, arrSubKeys\n\t\tGetApplications HKEY_USERS,strSIDKey&amp;&quot;\\&quot;&amp;keyPath,arrSubKeys\n\tEnd If\nNext\n\n\nFunction GetApplications(HIVE, keypath,arrSubKeys)\n\tSet applications = CreateObject(&quot;Scripting.Dictionary&quot;)\n\tOn Error Resume Next\n\tFor Each key in arrSubKeys\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;DisplayName&quot;, displayName\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;DisplayVersion&quot;, version\n\t\tobjRegistry.GetDWORDValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;SystemComponent&quot;, systemComponent\t\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;UninstallString&quot;, uninstallString\t\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;ParentKeyName&quot;, parentKey\t\n\t\t&#039; on error goto 0\n\t\t&#039; assume it&#039;s not uninstallable\n\t\tbUninstallable = &quot;Not Uninstallable&quot;\n\t\t\t\t\n\t\tIf displayName &lt;&gt; &quot;&quot; _\n\t\t\tAnd Not IsNull(uninstallString) _ \n\t\t\tAnd IsNull(parentKey) _\n\t\t\tAnd InStr(displayName, &quot;Hotfix&quot;) = 0 _\n\t\t\tAnd InStr(displayName, &quot;Update for&quot;) = 0 _\n\t \t\tAnd InStr(displayName, &quot;Security Update for&quot;) = 0 _\n\t \tThen \n\t \t\tIf InStr(LCase(uninstallString), &quot;msiexec&quot;) Then\n\t \t\t\t&#039; replace any /I with /X and add silent flags\n\t \t\t\tuninstallString = Replace(uninstallString,&quot;/I&quot;,&quot;/X&quot;) &amp; &quot; /qn /noreboot&quot; \n\t  \t\t\tbUninstallable = &quot;Is Uninstallable&quot;\n\t  \t\tEnd If\n\t \t\tIf IsNull(systemComponent) Or systemComponent = 0 Then\n\t\t\t\tIf IsNull(version) Then\n\t\t\t\t\tversion = GetVersionInString(displayName)\n\t\t\t\tEnd If\n\t\t\t\t&#039; This is a multi-column sensor.  Last two columns are hidden.\n\n\t\t\t\tdisplayString = displayName &amp; &quot;|&quot; &amp; version &amp; &quot;|&quot; &amp; uninstallString &amp; &quot;|&quot; &amp; bUninstallable\n\n\t\t\t\t&#039; treat displayString as the unique value - cannot be listed twice.\n\t\t\t\tIf Not applications.Exists(displayString) Then\n\t\t\t\t\tapplications.Add displayString, &quot;&quot;\n\t\t\t\tEnd If \t\n\t\t\tEnd If \t\n\t\tEnd If \n\tNext\n\tOn Error Goto 0\n\t\n\tSortDictionary applications, 1 &#039; This calls a sorting function specific to dictionaries\n\tarrApplicationsKeys = applications.Keys\n\tFor Each application In arrApplicationsKeys\n\t\t&#039; final output of the sensor\n\t\tWScript.Echo CleanCharacters(application)\n\tNext\nEnd Function &#039;GetApplications\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction SortDictionary(objDict, intSort)\n &#039;   objDict - the dictionary to sort\n &#039;   intSort - the field to sort (1=key, 2=item)\n \n   &#039; declare constants\n   Const dictKey  = 1\n   Const dictItem = 2\n \n   &#039; declare our variables\n   Dim strDict()\n   Dim objKey\n   Dim strKey,strItem\n   Dim X,Y,Z\n \n   &#039; get the dictionary count\n   Z = objDict.Count\n \n   &#039; we need more than one item to warrant sorting\n   If Z &gt; 1 Then\n     &#039; create an array to store dictionary information\n     ReDim strDict(Z,2)\n     X = 0\n     &#039; populate the string array\n     For Each objKey In objDict\n         strDict(X,dictKey)  = CStr(objKey)\n         strDict(X,dictItem) = CStr(objDict(objKey))\n         X = X + 1\n     Next\n \n     &#039; perform a a shell sort of the string array\n     For X = 0 To (Z - 2)\n       For Y = X To (Z - 1)\n         If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) &gt; 0 Then\n             strKey  = strDict(X,dictKey)\n             strItem = strDict(X,dictItem)\n             strDict(X,dictKey)  = strDict(Y,dictKey)\n             strDict(X,dictItem) = strDict(Y,dictItem)\n             strDict(Y,dictKey)  = strKey\n             strDict(Y,dictItem) = strItem\n         End If\n       Next\n     Next\n \n     &#039; erase the contents of the dictionary object\n     objDict.RemoveAll\n \n     &#039; repopulate the dictionary with the sorted information\n     For X = 0 To (Z - 1)\n       objDict.Add strDict(X,dictKey), strDict(X,dictItem)\n     Next\n \n   End If\n End Function &#039;SortDictionary\n\nFunction GetVersionInString(ByVal strTemp)\n&#039; examines a string and returns a version string at the end of it\n\tDim strOut\n\tstrOut = &quot;&quot;\n\tIf Not IsNull(strTemp) Then\n\t\tstrTemp = StrReverse(strTemp)\n\t\tDim strLookAtChar,intCurPos\n\t\tDim bNumbersStartMarked : bNumbersStartMarked = False\n\n\t\tFor intCurPos = 1 To Len(strTemp)\t\t\n\t\t\tstrLookAtChar = Mid(strTemp,intCurPos,1)\n\t\t\tIf IsNumeric(strLookAtChar) Or strLookAtChar = &quot;.&quot; Or strLookAtChar = &quot;-&quot; Then\n\t\t\t\tbNumbersStartMarked = True\n\t\t\t\tstrOut = strOut &amp; strLookAtChar\n\t\t\tEnd If\n\t\tIf bNumbersStartMarked And ( (Not IsNumeric(strLookAtChar) And strLookAtChar &lt;&gt; &quot;.&quot; And strLookAtChar &lt;&gt; &quot;-&quot;) ) Then\n\t\t\tExit For\n\t\tEnd If\t\n\t\tNext\n\t\tstrOut = StrReverse(strOut)\n\tElse\n\t\tstrOut = &quot;&quot;\n\tEnd If\n\t\n\tIf Len(strOut) = 0 Then strOut = &quot;N/A&quot;\n\t\n\tGetVersionInString = strOut\n\t\nEnd Function &#039;GetVersionInString\n\nFunction CleanCharacters(strTest)\n&#039; String returned will not have characters in the output which\n&#039; are not friendly to the console app\n\tstrPattern = &quot;[^\\x20-\\x7E]&quot;\n\tstrReplace = &quot;&quot;\n\tSet objRegExp = New RegExp\n\tobjRegExp.Global = True\n\tobjRegExp.IgnoreCase = True\n\tobjRegExp.Pattern = strPattern\n\tobjRegExp.Global = True\n\tCleanCharacters = objRegExp.Replace(strTest, strReplace)\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n# Detects which OS and if it is Linux then it will detect which Linux\n# Distribution.\n\n# Can be used as a starting point for shell scripts that need to work differently on\n# Mac, and various flavors of Linux\n\nOS=`uname -s`\n\nGetVersionFromFile()\n{\n    VERSION=`cat $1 | tr &quot;\\n&quot; &#039; &#039; | sed s/.*VERSION.*=\\ // `\n}\n\nif [ &quot;${OS}&quot; = &quot;Linux&quot; ] ; then\n    KERNEL=`uname -r`\n    if [ -f /etc/redhat-release ] ; then\n        # Redhat based system\n        rpm -qa --queryformat &quot;%{NAME}|%{VERSION}|nothing|Not Uninstallable\\n&quot;\n    elif [ -f /etc/SuSE-release ] ; then\n        # SuSE / OpenSuSE based system\n        rpm -qa --queryformat &quot;%{NAME}|%{VERSION}|nothing|Not Uninstallable\\n&quot;\n    elif [ -f /etc/lsb-release ] ; then\n        # Usually Ubuntu -- this is a Linux Standard Based system, which\n        # Ubuntu is by far the biggest.  But general LSB commands should work\n        dpkg -l | awk &#039;{print $2&quot;|&quot;$3&quot;|nothing|Not Uninstallable&quot;}&#039;\n    elif [ -f /etc/debian_version ] ; then\n        # Debian -- note that Ubuntu is Debian based, but Debian does not have a\n        # lsb-release file\n        dpkg -l | awk &#039;{print $2&quot;|&quot;$3&quot;|nothing|Not Uninstallable&quot;}&#039;\n        #else\n\t# a less common distribution.  Most all really popular distributions will\n        # be caught by the tree above.\n    fi\n#else\n   # not Linux -- could be anything, BSD / Solaris / AIX / etc\nfi\n\necho ${OSSTR}\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nnotcontains() {\n    string=&quot;$1&quot;\n    substring=&quot;$2&quot;\n    if test &quot;${string#*$substring}&quot; != &quot;$string&quot;\n    then\n        return 1    # $substring is not in $string\n    else\n        return 0    # $substring is in $string\n    fi\n}\n\nftemp=$(mktemp -t &#039;apps.xml&#039;)\nsystem_profiler -xml SPApplicationsDataType &gt; &quot;$ftemp&quot;\n\ncount=1\n\nwhile true\ndo\n        app=`/usr/libexec/PlistBuddy -c &quot;Print :0:_items:$count:_name&quot; $ftemp 2&gt;/dev/null`\n        version=`/usr/libexec/PlistBuddy -c &quot;Print :0:_items:$count:version&quot; $ftemp 2&gt;/dev/null`\n        if [ -z &quot;$app&quot; ]; then\n                break\n        fi\n        test=&quot;VMware&quot;\n        if notcontains &quot;$version&quot; &quot;$test&quot;; then\n                echo $app&quot;|&quot;$version&quot;|nothing|Not Uninstallable&quot;\n        fi\n        let count=count+1\ndone\nrm -rf &quot;$ftemp&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3229, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Version", 
            "value_type": "Version"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Silent Uninstall String", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Uninstallable", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 23, 
      "category": "Kaspersky", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the version of the Kaspersky Antivirus Scanner.\nExample:5.6", 
      "exclude_from_parse_flag": 1, 
      "hash": 2527517741, 
      "hidden_flag": 0, 
      "id": 43, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 1800, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Kaspersky Client Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Kaspersky Client Version\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;H80000002 \n\nkeyPath = &quot;Software\\KasperskyLab&quot;\nkey64Path = &quot;Software\\WOW6432Node\\KasperskyLab&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\n&#039;Check for AVP11\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP11\\environment&quot;) Then\n\tWScript.Echo GetVersion(keyPath &amp; &quot;\\protected\\AVP11\\environment&quot;)\n\n&#039;Check for AVP10\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP10\\environment&quot;) Then\n\tWScript.Echo GetVersion(keyPath &amp; &quot;\\protected\\AVP10\\environment&quot;)\n\n&#039;Check for AVP9\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP9\\environment&quot;) Then\n\tWScript.Echo GetVersion(keyPath &amp; &quot;\\protected\\AVP9\\environment&quot;)\n\n&#039;Check for AVP8\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP8\\environment&quot;) Then\n\tWScript.Echo GetVersion(keyPath &amp; &quot;\\protected\\AVP8\\environment&quot;)\n\nElse\n\tWScript.Echo &quot;Version not found&quot;\nEnd If\n\n\nFunction GetVersion(fullKeyPath)\n\tobjRegistry.GetStringValue HKLM,fullKeyPath ,&quot;ProductVersion&quot;, strVersion\n\tIf Not IsNull(strVersion) Then\n\t\tGetVersion = strVersion\n\t\tExit Function\n\tEnd If\t\n\n\tGetVersion = &quot;Version not found&quot;\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 24, 
      "category": "Kaspersky", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the age, in days, of the the Kaspersky Antivirus DAT file.\nExample: 5", 
      "exclude_from_parse_flag": 1, 
      "hash": 1220267691, 
      "hidden_flag": 0, 
      "id": 45, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Kaspersky DAT Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Kaspersky DAT Days Old\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;H80000002 \n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nkeyPath = &quot;Software\\KasperskyLab&quot;\nkey64Path = &quot;Software\\WOW6432Node\\KasperskyLab&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\n&#039;Check for AVP11\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP11\\environment&quot;) Then\n\tWScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\\protected\\AVP11\\environment&quot;))\n\n&#039;Check for AVP10\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP10\\environment&quot;) Then\n\tWScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\\protected\\AVP10\\environment&quot;))\n\n&#039;Check for AVP9\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP9\\environment&quot;) Then\n\tWScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\\protected\\AVP9\\environment&quot;))\n\n&#039;Check for AVP8\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP8\\environment&quot;) Then\n\tWScript.Echo GetDatDaysOld(GetDatVersion(keyPath &amp; &quot;\\protected\\AVP8\\environment&quot;))\n\nElse\n\tWScript.Echo &quot;DAT version not found&quot;\nEnd If\n\n\nFunction GetDatVersion(fullKeyPath)\n\tobjRegistry.GetStringValue HKLM,fullKeyPath ,&quot;DataRoot&quot;, dataRoot\n\tobjRegistry.GetStringValue HKLM,fullKeyPath ,&quot;UpdateRoot&quot;, updateRoot\n\twords = Split(updateRoot, &quot;/&quot;)\n\tupdateFile = words(UBound(words))\n\tstrFile = dataRoot &amp; &quot;\\data\\&quot; &amp; updateFile\n\t\n\tSet fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tIf fso.FileExists(strFile) Then\n\t\tSet objFile = fso.OpenTextFile(strFile, 1)\n\t\tDo Until objFile.AtEndOfStream\n\t\t    strLine = objFile.ReadLine\n\t\t    If InStr(strLine, &quot;UpdateDate=&quot;) Then\n\t\t    \twords = Split(strLine, &quot;&quot;&quot;&quot;)\n\t\t    \tdats = Split(words(UBound(words)-1))\n\t\t    \tGetDatVersion = dats(0)\n\t\t    \tExit Function\n\t\t    End If\n\t\tLoop\n\tEnd If\n\tGetDatVersion = &quot;DAT version not found&quot;\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction GetDatDaysOld(strValue)\n\tdatDate = CDate( Mid(strValue, 3, 2) &amp; &quot;/&quot; &amp; Left(strValue, 2) &amp; &quot;/&quot; &amp; Right(strValue, 4) )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDatDaysOld = DateDiff(&quot;d&quot;, datDate, today)\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 25, 
      "category": "Kaspersky", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the version of the Kaspersky Antivirus DAT file.\nExample: 5.0.0.3", 
      "exclude_from_parse_flag": 1, 
      "hash": 1391517255, 
      "hidden_flag": 0, 
      "id": 47, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Kaspersky DAT Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Kaspersky DAT Version\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;H80000002 \n\nkeyPath = &quot;Software\\KasperskyLab&quot;\nkey64Path = &quot;Software\\WOW6432Node\\KasperskyLab&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\n&#039;Check for AVP11\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP11\\environment&quot;) Then\n\tWScript.Echo GetDatVersion(keyPath &amp; &quot;\\protected\\AVP11\\environment&quot;)\n\n&#039;Check for AVP10\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP10\\environment&quot;) Then\n\tWScript.Echo GetDatVersion(keyPath &amp; &quot;\\protected\\AVP10\\environment&quot;)\n\n&#039;Check for AVP9\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP9\\environment&quot;) Then\n\tWScript.Echo GetDatVersion(keyPath &amp; &quot;\\protected\\AVP9\\environment&quot;)\n\n&#039;Check for AVP8\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\protected\\AVP8\\environment&quot;) Then\n\tWScript.Echo GetDatVersion(keyPath &amp; &quot;\\protected\\AVP8\\environment&quot;)\n\nElse\n\tWScript.Echo &quot;DAT version not found&quot;\nEnd If\n\n\nFunction GetDatVersion(fullKeyPath)\n\tobjRegistry.GetStringValue HKLM,fullKeyPath ,&quot;DataRoot&quot;, dataRoot\n\tobjRegistry.GetStringValue HKLM,fullKeyPath ,&quot;UpdateRoot&quot;, updateRoot\n\twords = Split(updateRoot, &quot;/&quot;)\n\tupdateFile = words(UBound(words))\n\tstrFile = dataRoot &amp; &quot;\\data\\&quot; &amp; updateFile\n\t\n\tSet fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tIf fso.FileExists(strFile) Then\n\t\tSet objFile = fso.OpenTextFile(strFile, 1)\n\t\tDo Until objFile.AtEndOfStream\n\t\t    strLine = objFile.ReadLine\n\t\t    If InStr(strLine, &quot;UpdateDate=&quot;) Then\n\t\t    \twords = Split(strLine, &quot;&quot;&quot;&quot;)\n\t\t    \tdats = Split(words(UBound(words)-1))\n\t\t    \tGetDatVersion = dats(0)\n\t\t    \tExit Function\n\t\t    End If\n\t\tLoop\n\tEnd If \t\n\tGetDatVersion = &quot;DAT version not found&quot;\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 26, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Provides a list of currently running services on the client machine.\nExample: DHCP Client", 
      "exclude_from_parse_flag": 1, 
      "hash": 1497251383, 
      "hidden_flag": 0, 
      "id": 49, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "Running Service", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from win32_Service where State=&#039;Running&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n# Detects which OS and if it is Linux then it will detect which Linux\n# Distribution.\n\n# Can be used as a starting point for shell scripts that need to work differently on\n# Mac, and various flavors of Linux\n\nOS=`uname -s`\n\nGetVersionFromFile()\n{\n    VERSION=`cat $1 | tr &quot;\\n&quot; &#039; &#039; | sed s/.*VERSION.*=\\ // `\n}\n\nif [ &quot;${OS}&quot; = &quot;Linux&quot; ] ; then\n    KERNEL=`uname -r`\n    if [ -f /etc/redhat-release ] ; then\n        # Redhat based system\n        chkconfig --list | grep 3:on | awk &#039;{print $1}&#039;\n    elif [ -f /etc/SuSE-release ] ; then\n        # SuSE / OpenSuSE based system\n        ps aux | awk &#039;{print $11}&#039;\n    elif [ -f /etc/lsb-release ] ; then\n        # Usually Ubuntu -- this is a Linux Standard Based system, which\n        # Ubuntu is by far the biggest.  But general LSB commands should work\n        ps aux | awk &#039;{print $11}&#039;\n    elif [ -f /etc/debian_version ] ; then\n        # Debian -- note that Ubuntu is Debian based, but Debian does not have a\n        # lsb-release file\n        ps aux | awk &#039;{print $11}&#039;\n        #else\n\t# a less common distribution.  Most all really popular distributions will\n        # be caught by the tree above.\n    fi\n#else\n   # not Linux -- could be anything, BSD / Solaris / AIX / etc\nfi\n\necho ${OSSTR}\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nfirst=true\nlaunchctl list | while read line\ndo\n    set -- $line\nif ( $first ); \nthen\n\tfirst=false\nelse\n\tif [ &quot;$2&quot; == &quot;-&quot; ]; \n\tthen\n\t\techo $3\n\tfi\nfi\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 59, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 27, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns whether on-access scanning is enabled on the machine.\nExample: Enabled", 
      "exclude_from_parse_flag": 1, 
      "hash": 1053039240, 
      "hidden_flag": 0, 
      "id": 51, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "VirusScan Enterprise On-Access Scan State", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; VirusScan Enterprise On-Access Scan State\n&#039;========================================\n\nOption Explicit\n\nDim strServiceState\n&#039; First get the state of the service\nstrServiceState = ServiceState(&quot;McShield&quot;)\nIf strServiceState = &quot;Not Installed&quot; Then\n    &#039;No further tests are necessary\n    WScript.Echo &quot;VirusScan Enterprise Not Installed&quot;\n    WScript.Quit\nEnd If\n\nConst HKLM = &amp;h80000002\nDim objReg\n\nSet objReg = Getx64RegistryProvider()\n\nWScript.Echo GetOASStatus\n\nFunction GetOASStatus\n\n    Dim intOnAccessScanEnabled\n    Dim strRegPath, strReport\n\n    strRegPath = GetMcAfeeProductRegRootKey(&quot;DesktopProtection&quot;)\n\n    If Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n        objReg.GetDWORDValue HKLM,strRegPath,&quot;OASState&quot;,intOnAccessScanEnabled\n        Select Case intOnAccessScanEnabled\n            Case 2\n                strReport = &quot;Disabled&quot;\n            Case 3\n                strReport = &quot;Enabled&quot;\n        End Select\n    Else\n        WScript.Echo &quot;Error: Cannot determine On-Access Scan Status&quot;\n    End If\n\n    GetOASStatus = strReport\n\nEnd Function &#039;GetOASStatus\n\nFunction GetMcAfeeProductRegRootKey(strProductString)\n&#039; Retrieves McAfee key for a product\n&#039; products are passed in and defined in the function\n\n    Dim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey\n    Dim strProductKeyPath\n\n    &#039; select on input\n    strProductString = UCase(strProductString)\n    Select Case strProductString\n        Case &quot;AGENT&quot;\n            strProductSubKey = &quot;McAfee\\Agent&quot;\n        Case &quot;AVENGINE&quot;\n            strProductSubKey = &quot;McAfee\\AVEngine&quot;\n        Case &quot;DESKTOPPROTECTION&quot;\n            strProductSubKey = &quot;McAfee\\DesktopProtection&quot;\n        Case &quot;EPO&quot;\n            strProductSubKey = &quot;McAfee\\ePolicy Orchestrator&quot;\n        Case &quot;HIPS&quot;\n            strProductSubKey = &quot;McAfee\\HIP&quot;\n        Case &quot;HIPSCORE&quot;\n            strProductSubKey = &quot;McAfee\\HIPSCore&quot;\n        Case &quot;MCTRAY&quot;\n            strProductSubKey = &quot;McAfee\\McTray&quot;\n        Case &quot;SITEADVISOR&quot;\n            strProductSubKey = &quot;McAfee\\SiteAdvisor Enterprise Plus&quot;\n        Case &quot;SYSTEMCORE&quot;\n            strProductSubKey = &quot;McAfee\\SystemCore&quot;\n        Case &quot;VSCORE&quot;\n            strProductSubKey = &quot;McAfee\\VSCore&quot;\n        Case &quot;NAIEPO&quot;\n            strProductSubKey = &quot;Network Associates\\ePolicy Orchestrator&quot;\n        Case &quot;NAITVD&quot;\n            strProductSubKey = &quot;Network Associates\\TVD&quot;\n        Case Else\n            strProductSubKey = False\n    End Select\n\n    Const HKLM = &amp;h80000002\n\n    strRootSoftwareKeyNative = &quot;Software&quot;\n    strRootSoftwareKeyWow64 = &quot;Software\\Wow6432Node&quot;\n    If Not strProductSubKey = False Then\n        &#039; Assume not in both places on a 64-bit machine\n        If RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n            strProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey\n        ElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n            strProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey\n        End If\n    Else\n        strProductKeyPath = False\n    End If\n\n    GetMcAfeeProductRegRootKey = strProductKeyPath\n\nEnd Function &#039;GetMcAfeeProductRegRootKey\n\nFunction RegKeyExists(sHive, sRegKey)\n    Dim aValueNames, aValueTypes\n    If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n        RegKeyExists = True\n    Else\n        RegKeyExists = False\n    End If\nEnd Function &#039;RegKeyExists\n\nFunction ServiceState(strServiceName)\n&#039; This function determines if a service is in a bad state and returns\n&#039; values indicating the state.  Examples:\n&#039; &quot;Stopped&quot;\n&#039; &quot;Stopped Manual&quot;\n&#039; &quot;Running Disabled&quot;\n&#039; &quot;Not Installed&quot;\n\n    Dim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState\n\n    strWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;\n\n    strState = &quot;&quot;\n    strStartMode = &quot;&quot;\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; _\n        &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n    Set colItems = objWMIService.ExecQuery(strWMIQuery)\n\n    If colItems.Count = 0 Then\n        ServiceState = &quot;Not Installed&quot;\n    Else\n        For Each objItem In colItems\n            If objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then\n                strState = objItem.State\n            End If\n            If objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then\n                strStartMode = objItem.StartMode\n            End If\n            ServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)\n        Next\n    End If\n\nEnd Function &#039;ServiceState\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)\n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n\n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)\n\n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 28, 
      "category": "Anti-Virus", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the version number of the McAfee AntiVirus client running on the machine.\nExample: 8.8.0.975", 
      "exclude_from_parse_flag": 1, 
      "hash": 2481801758, 
      "hidden_flag": 0, 
      "id": 53, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "VirusScan Enterprise Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; VirusScan Enterprise Version\n&#039;========================================\nConst HKLM = &amp;H80000002\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _\n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\n&#039;Check for VirusScan key\nkeyPath = &quot;Software\\Network Associates\\TVD\\VirusScan&quot;\nkey64Path = &quot;Software\\WOW6432Node\\Network Associates\\TVD\\VirusScan&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\nEnd If\n\nIf RegKeyExists(HKLM, keyPath) Then\n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;szCurrentVersionNumber&quot;, strVersion\n\tIf Not IsNull(strVersion) Then\n\t\tWScript.Echo strVersion\n\t\tWScript.Quit\n\tEnd If\nEnd If\n\n&#039;Check for VirusScan Enterprise key\nkeyPath = &quot;Software\\Network Associates\\TVD\\VirusScan Enterprise\\CurrentVersion&quot;\nkey64Path = &quot;Software\\WOW6432Node\\Network Associates\\TVD\\VirusScan Enterprise\\CurrentVersion&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\nEnd If\n\nIf RegKeyExists(HKLM, keyPath) Then\n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;szProductVer&quot;, strVersion\n\tIf Not IsNull(strVersion) Then\n\t\tWScript.Echo strVersion\n\t\tWScript.Quit\n\tEnd If\nEnd If\n\n&#039;Check for DesktopProtection key\nkeyPath = &quot;Software\\McAfee\\DesktopProtection&quot;\nkey64Path = &quot;Software\\WOW6432Node\\McAfee\\DesktopProtection&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\nEnd If\n\nIf RegKeyExists(HKLM, keyPath) Then\n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;szProductVer&quot;, strVersion\n\tIf Not IsNull(strVersion) Then\n\t\tWScript.Echo strVersion\n\t\tWScript.Quit\n\tEnd If\nEnd If\n\nWScript.Echo &quot;Not Installed&quot;\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 29, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the version of the McAfee VirusScan Enterprise DAT file currently loaded.\nExample: 6910", 
      "exclude_from_parse_flag": 1, 
      "hash": 213927111, 
      "hidden_flag": 0, 
      "id": 55, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "VirusScan Enterprise DAT Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039;McAfee VirusScan Enterprise DAT Version\n&#039;========================================\n\n&#039; Returns the DAT number for VSE\n\n\nOption Explicit\n\nConst HKLM = &amp;h80000002\nDim objReg\t\nSet objReg = Getx64RegistryProvider()\t\n\nDim strServiceState\n&#039; First get the state of the service\nstrServiceState = ServiceState(&quot;McShield&quot;)\nIf strServiceState = &quot;Not Installed&quot; Then\n\t&#039;No further tests are necessary\n\tWScript.Echo &quot;VirusScan Enterprise Not Installed&quot;\n\tWScript.Quit\nEnd If\n\nWScript.Echo GetDatVersion\n\nFunction GetDatVersion\n\n\tDim intDatVersion,intDatVersionMinor\n\tDim strRegPath\n\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;AVDatVersion&quot;,intDatVersion\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;AVDatVersionMinor&quot;,intDatVersionMinor\n\n\t\tIf IsNumeric(intDatVersion)Then\n\t\t\tIf IsNumeric(intDatVersionMinor) Then\n\t\t\t\tIf CInt(intDatVersionMinor) = 0 Then\n\t\t\t\t\tGetDatVersion = intDatVersion\n\t\t\t\tElse\n\t\t\t\t\tGetDatVersion = intDatVersion&amp;&quot;.&quot;&amp;intDatVersionMinor\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\tGetDatVersion = intDatVersion\n\t\t\tEnd If\n\t\tElse\n\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT Version&quot;\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT Version&quot;\n\tEnd If\nEnd Function &#039;GetDatVersion\n\n\n\nFunction GetMcAfeeProductRegRootKey(strProductString)\n&#039; Retrieves McAfee key for a product\n&#039; products are passed in and defined in the function\n\n\tDim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey\n\tDim strProductKeyPath\n\n\t&#039; select on input\n\tstrProductString = UCase(strProductString)\n\tSelect Case strProductString\n\t\tCase &quot;AGENT&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\Agent&quot;\t\n\t\tCase &quot;AVENGINE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\AVEngine&quot;\n\t\tCase &quot;DESKTOPPROTECTION&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\DesktopProtection&quot;\n\t\tCase &quot;EPO&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\ePolicy Orchestrator&quot;\n\t\tCase &quot;HIPS&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIP&quot;\n\t\tCase &quot;HIPSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIPSCore&quot;\n\t\tCase &quot;MCTRAY&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\McTray&quot;\t\t\t\t\t\n\t\tCase &quot;SITEADVISOR&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SiteAdvisor Enterprise Plus&quot;\n\t\tCase &quot;SYSTEMCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SystemCore&quot;\n\t\tCase &quot;VSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\VSCore&quot;\n\t\tCase &quot;NAIEPO&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\ePolicy Orchestrator&quot;\n\t\tCase &quot;NAITVD&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\TVD&quot;\n\t\tCase Else\n\t\t\tstrProductSubKey = False\n\tEnd Select\n\t\t\t\n\tConst HKLM = &amp;h80000002\n\t\n    \n\tstrRootSoftwareKeyNative = &quot;Software&quot;\n\tstrRootSoftwareKeyWow64 = &quot;Software\\Wow6432Node&quot;\n    If Not strProductSubKey = False Then\n\t    &#039; Assume not in both places on a 64-bit machine\n\t\tIf RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tEnd If\n\tElse\n\t\tstrProductKeyPath = False\t\t\n\tEnd If\n\t\n\tGetMcAfeeProductRegRootKey = strProductKeyPath\n\nEnd Function &#039;GetMcAfeeProductRegRootKey\n\nFunction RegKeyExists(sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function &#039;RegKeyExists\n\nFunction ServiceState(strServiceName)\n&#039; This function determines if a service is in a bad state and returns\n&#039; values indicating the state.  Examples: \n&#039; &quot;Stopped&quot;\n&#039; &quot;Stopped Manual&quot;\n&#039; &quot;Running Disabled&quot;\n&#039; &quot;Not Installed&quot;\n\n\tDim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState\n\n\tstrWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;\n\n\tstrState = &quot;&quot;\n\tstrStartMode = &quot;&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(strWMIQuery)\n\t\n\tIf colItems.Count = 0 Then\n\t\tServiceState = &quot;Not Installed&quot;\n\tElse\n\t\tFor Each objItem In colItems\n\t\t\tIf objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then\n\t\t\t\tstrState = objItem.State\n\t\t\tEnd If\n\t\t\tIf objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then\n\t\t\t\tstrStartMode = objItem.StartMode\n\t\t\tEnd If\n\t\t\tServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)\n\t\tNext\n\tEnd If\n\nEnd Function &#039;ServiceState\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 30, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the age, in days, of the currently loaded DAT file for McAfee VirusScan Enterprise.\nExample: 1", 
      "exclude_from_parse_flag": 1, 
      "hash": 69663275, 
      "hidden_flag": 0, 
      "id": 57, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "VirusScan Enterprise DAT Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; McAfee VirusScan Enterprise Dat Days Old\n&#039;========================================\n\n&#039; Returns, in days, the age of the currently applied DAT file\n\nOption Explicit\n\nDim strServiceState\n&#039; First get the state of the service\nstrServiceState = ServiceState(&quot;McShield&quot;)\nIf strServiceState = &quot;Not Installed&quot; Then\n\t&#039;No further tests are necessary\n\tWScript.Echo &quot;VirusScan Enterprise Not Installed&quot;\n\tWScript.Quit\nEnd If\n\nConst HKLM = &amp;h80000002\nDim objReg\t\nSet objReg = Getx64RegistryProvider()\n\nWScript.Echo GetDatAgeInDays\n\nFunction GetDatAgeInDays\n\n\tDim strDatDate,dtmDatDate,arrDatDateBits\n\tDim strRegPath, intDaysOld\n\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetStringValue HKLM,strRegPath,&quot;AVDatDate&quot;,strDatDate\n\t\t\n\t\t&#039;Date is in YYYY/MM/DD format, move to US/English\n\t\tIf InStr(strDatDate,&quot;/&quot;) &gt; 0 Then &#039;valid value\n\t\t\tarrDatDateBits = Split(strDatDate,&quot;/&quot;)\n\t\t\tstrDatDate = arrDatDateBits(1)&amp;&quot;/&quot;&amp;arrDatDateBits(2)&amp;&quot;/&quot;&amp;arrDatDateBits(0)\n\t\t\tIf IsDate(strDatDate) Then\n\t\t\t\tintDaysOld = CInt(GetDaysOld(strDatDate))\n\t\t\t\tGetDatAgeInDays = intDaysOld\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT age&quot;\n\t\t\tEnd If\n\t\tElse &#039; Dat Date has no &quot;/&quot; in it and cannot be parsed or compared\n\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT age&quot;\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT age&quot;\n\tEnd If\nEnd Function &#039;GetDatAgeInDays\n\n\n\nFunction GetMcAfeeProductRegRootKey(strProductString)\n&#039; Retrieves McAfee key for a product\n&#039; products are passed in and defined in the function\n\n\tDim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey\n\tDim strProductKeyPath\n\n\t&#039; select on input\n\tstrProductString = UCase(strProductString)\n\tSelect Case strProductString\n\t\tCase &quot;AGENT&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\Agent&quot;\t\n\t\tCase &quot;AVENGINE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\AVEngine&quot;\n\t\tCase &quot;DESKTOPPROTECTION&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\DesktopProtection&quot;\n\t\tCase &quot;EPO&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\ePolicy Orchestrator&quot;\n\t\tCase &quot;HIPS&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIP&quot;\n\t\tCase &quot;HIPSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIPSCore&quot;\n\t\tCase &quot;MCTRAY&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\McTray&quot;\t\t\t\t\t\n\t\tCase &quot;SITEADVISOR&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SiteAdvisor Enterprise Plus&quot;\n\t\tCase &quot;SYSTEMCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SystemCore&quot;\n\t\tCase &quot;VSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\VSCore&quot;\n\t\tCase &quot;NAIEPO&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\ePolicy Orchestrator&quot;\n\t\tCase &quot;NAITVD&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\TVD&quot;\n\t\tCase Else\n\t\t\tstrProductSubKey = False\n\tEnd Select\n\t\t\t\n\tConst HKLM = &amp;h80000002\n\t\n    \n\tstrRootSoftwareKeyNative = &quot;Software&quot;\n\tstrRootSoftwareKeyWow64 = &quot;Software\\Wow6432Node&quot;\n    If Not strProductSubKey = False Then\n\t    &#039; Assume not in both places on a 64-bit machine\n\t\tIf RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tEnd If\n\tElse\n\t\tstrProductKeyPath = False\t\t\n\tEnd If\n\t\n\tGetMcAfeeProductRegRootKey = strProductKeyPath\n\nEnd Function &#039;GetMcAfeeProductRegRootKey\n\nFunction ServiceState(strServiceName)\n&#039; This function determines if a service is in a bad state and returns\n&#039; values indicating the state.  Examples: \n&#039; &quot;Stopped&quot;\n&#039; &quot;Stopped Manual&quot;\n&#039; &quot;Running Disabled&quot;\n&#039; &quot;Not Installed&quot;\n\n\tDim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState\n\n\tstrWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;\n\n\tstrState = &quot;&quot;\n\tstrStartMode = &quot;&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(strWMIQuery)\n\t\n\tIf colItems.Count = 0 Then\n\t\tServiceState = &quot;Not Installed&quot;\n\tElse\n\t\tFor Each objItem In colItems\n\t\t\tIf objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then\n\t\t\t\tstrState = objItem.State\n\t\t\tEnd If\n\t\t\tIf objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then\n\t\t\t\tstrStartMode = objItem.StartMode\n\t\t\tEnd If\n\t\t\tServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)\n\t\tNext\n\tEnd If\n\nEnd Function &#039;ServiceState\n\nFunction RegKeyExists(sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function &#039;RegKeyExists\n\nFunction GetDaysOld(strDate)\n&#039;date format is MM/DD/YYYY \n\tSetLocale(1033)\n\tDim patternDate, today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( now )\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function &#039;GetDaysOld\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 31, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:01", 
      "delimiter": ",", 
      "description": "Returns the 64-bit and 32-bit engine versions for VirusScan Enterprise\nExample: 5400.1158 (32-bit)  5400.1158 (64-bit)", 
      "exclude_from_parse_flag": 1, 
      "hash": 2816391364, 
      "hidden_flag": 0, 
      "id": 59, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:01", 
      "name": "VirusScan Enterprise Engine Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039;McAfee VirusScan Enterprise Engine Version\n&#039;========================================\n\n&#039; Returns the version number of the McAfee Scan Engine\n\n\nOption Explicit\n\nConst HKLM = &amp;h80000002\nDim objReg\t\nSet objReg = Getx64RegistryProvider()\n\nDim strServiceState\n&#039; First get the state of the service\nstrServiceState = ServiceState(&quot;McShield&quot;)\nIf strServiceState = &quot;Not Installed&quot; Then\n\t&#039;No further tests are necessary\n\tWScript.Echo &quot;VirusScan Enterprise Not Installed&quot;\n\tWScript.Quit\nEnd If\n\nDim bHadOutput,strEngineVersion32,strEngineVersion64,bHas32\nstrEngineVersion32 = GetEngineVersion32\nstrEngineVersion64 = GetEngineVersion64\n\nIf Not (IsNull(strEngineVersion32) Or strEngineVersion32 = &quot;&quot;) Then\n\tWScript.Echo strEngineVersion32 &amp; &quot; (32-bit)&quot;\n\tbHas32 = True\nEnd If\nIf Not (IsNull(strEngineVersion64) Or strEngineVersion64 = &quot;&quot;) Then\n\tWScript.Echo strEngineVersion64 &amp; &quot; (64-bit)&quot;\nEnd If\n\nIf Not bHadOutput And Not bHas32 Then &#039; other engine variables were not present, use non-bitness-specific\n\tWScript.Echo GetEngineVersion &amp; &quot; (32-bit)&quot;\nEnd If\n\t\nFunction GetEngineVersion32\n\n\tDim intEngineVersion,intEngineVersionMinor\n\tDim strRegPath\n\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion32Major&quot;,intEngineVersion\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion32Minor&quot;,intEngineVersionMinor\n\n\t\tIf IsNumeric(intEngineVersion) And IsNumeric(intEngineVersionMinor) Then\n\t\t\tbHadOutput = True\n\t\t\tIf CInt(intEngineVersionMinor) = 0 Then\n\t\t\t\tGetEngineVersion32 = intEngineVersion\n\t\t\tElse\n\t\t\t\tGetEngineVersion32 = intEngineVersion&amp;&quot;.&quot;&amp;intEngineVersionMinor\n\t\t\tEnd If\n\t\tElse\n\t\t\tbHadOutput = False\n\t\tEnd If\n\tElse\n\t\tbHadOutput = False\n\tEnd If\nEnd Function &#039;GetEngineVersion32\n\nFunction GetEngineVersion64\n\n\tDim intEngineVersion,intEngineVersionMinor\n\tDim strRegPath\n\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion64Major&quot;,intEngineVersion\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersion64Minor&quot;,intEngineVersionMinor\n\n\t\tIf IsNumeric(intEngineVersion) And IsNumeric(intEngineVersionMinor) Then\n\t\t\tbHadOutput = True\n\t\t\tIf CInt(intEngineVersionMinor) = 0 Then\n\t\t\t\tGetEngineVersion64 = intEngineVersion\n\t\t\tElse\n\t\t\t\tGetEngineVersion64 = intEngineVersion&amp;&quot;.&quot;&amp;intEngineVersionMinor\n\t\t\tEnd If\n\t\tElse\n\t\t\tbHadOutput = False\n\t\tEnd If\n\tElse\n\t\tbHadOutput = False\n\tEnd If\nEnd Function &#039;GetEngineVersion64\n\nFunction GetEngineVersion\n\n\tDim intEngineVersion,intEngineVersionMinor\n\tDim strRegPath\n\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersionMajor&quot;,intEngineVersion\n\t\tobjReg.GetDWORDValue HKLM,strRegPath,&quot;EngineVersionMinor&quot;,intEngineVersionMinor\n\n\t\tIf IsNumeric(intEngineVersion) And IsNumeric(intEngineVersionMinor) Then\n\t\t\tIf CInt(intEngineVersionMinor) = 0 Then\n\t\t\t\tGetEngineVersion = intEngineVersion\n\t\t\tElse\n\t\t\t\tGetEngineVersion = intEngineVersion&amp;&quot;.&quot;&amp;intEngineVersionMinor\n\t\t\tEnd If\n\t\tElse\n\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Engine Version&quot;\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Engine Version&quot;\n\tEnd If\nEnd Function &#039;GetEngineVersion\n\n\n\n\nFunction GetMcAfeeProductRegRootKey(strProductString)\n&#039; Retrieves McAfee key for a product\n&#039; products are passed in and defined in the function\n\n\tDim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey\n\tDim strProductKeyPath\n\n\t&#039; select on input\n\tstrProductString = UCase(strProductString)\n\tSelect Case strProductString\n\t\tCase &quot;AGENT&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\Agent&quot;\t\n\t\tCase &quot;AVENGINE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\AVEngine&quot;\n\t\tCase &quot;DESKTOPPROTECTION&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\DesktopProtection&quot;\n\t\tCase &quot;EPO&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\ePolicy Orchestrator&quot;\n\t\tCase &quot;HIPS&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIP&quot;\n\t\tCase &quot;HIPSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIPSCore&quot;\n\t\tCase &quot;MCTRAY&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\McTray&quot;\t\t\t\t\t\n\t\tCase &quot;SITEADVISOR&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SiteAdvisor Enterprise Plus&quot;\n\t\tCase &quot;SYSTEMCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SystemCore&quot;\n\t\tCase &quot;VSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\VSCore&quot;\n\t\tCase &quot;NAIEPO&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\ePolicy Orchestrator&quot;\n\t\tCase &quot;NAITVD&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\TVD&quot;\n\t\tCase Else\n\t\t\tstrProductSubKey = False\n\tEnd Select\n\t\t\t\n\tConst HKLM = &amp;h80000002\n\t\n    \n\tstrRootSoftwareKeyNative = &quot;Software&quot;\n\tstrRootSoftwareKeyWow64 = &quot;Software\\Wow6432Node&quot;\n    If Not strProductSubKey = False Then\n\t    &#039; Assume not in both places on a 64-bit machine\n\t\tIf RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tEnd If\n\tElse\n\t\tstrProductKeyPath = False\t\t\n\tEnd If\n\t\n\tGetMcAfeeProductRegRootKey = strProductKeyPath\n\nEnd Function &#039;GetMcAfeeProductRegRootKey\n\nFunction RegKeyExists(sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function &#039;RegKeyExists\n\nFunction ServiceState(strServiceName)\n&#039; This function determines if a service is in a bad state and returns\n&#039; values indicating the state.  Examples: \n&#039; &quot;Stopped&quot;\n&#039; &quot;Stopped Manual&quot;\n&#039; &quot;Running Disabled&quot;\n&#039; &quot;Not Installed&quot;\n\n\tDim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState\n\n\tstrWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;\n\n\tstrState = &quot;&quot;\n\tstrStartMode = &quot;&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(strWMIQuery)\n\t\n\tIf colItems.Count = 0 Then\n\t\tServiceState = &quot;Not Installed&quot;\n\tElse\n\t\tFor Each objItem In colItems\n\t\t\tIf objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then\n\t\t\t\tstrState = objItem.State\n\t\t\tEnd If\n\t\t\tIf objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then\n\t\t\t\tstrStartMode = objItem.StartMode\n\t\t\tEnd If\n\t\t\tServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)\n\t\tNext\n\tEnd If\n\nEnd Function &#039;ServiceState\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 32, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "If no user is logged in, returns the last user to log in is reported.  If a user is currently logged in, that user is returned.\nExample: DOMAIN\\Jane.Doe", 
      "exclude_from_parse_flag": 1, 
      "hash": 7318847, 
      "hidden_flag": 0, 
      "id": 61, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Last Logged In User", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last Logged In User\n&#039;========================================\n\n&#039; This sensor will report the user that was logged in the last time\n&#039; the sensor was run.  If there is no user logged in, it will return\n&#039; the last user to log in.\n&#039;\n&#039; note - for this sensor to be effective, it must be reissued as a saved question\n\nOption Explicit\nConst HKLM = &amp;h80000002\n\nDim objWMIService, objReg, colComputer\nDim objComputer, strLastUser, strLastLastUser\n\n\nOn Error Resume Next\n\n\nSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\n\n&#039; Get the last logged in user from registry\nstrLastUser = GetLastUser(objReg)\n\nIf Err.Number &lt;&gt; 0 Then\n\t&#039;WScript.Echo &quot;setting initially, line 24&quot; &amp; Err.Description\n\tErr.Number = 0\nEnd If\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \nSet colComputer = objWMIService.ExecQuery (&quot;Select UserName from Win32_ComputerSystem&quot;)\n\nFor Each objComputer in colComputer\n\tIf IsNull(strLastUser) Or strLastUser = &quot;&quot; Or strLastUser = False Then &#039; first run or error, try to set\n\t\tIf Err.Number &lt;&gt; 0 Then\n\t\t\t&#039; WScript.Echo &quot;line 34&quot; &amp; Err.Description\n\t\t\tErr.Number = 0\n\t\tEnd If\n\t\tIf objComputer.UserName &lt;&gt; &quot;&quot; Then &#039;someone is currently logged in\n\t\t\tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t&#039; WScript.Echo &quot;line 39&quot; &amp; Err.Description\n\t\t\t\tErr.Number = 0\n\t\t\tEnd If\t\t \n\t\t\tSetLastUser objReg, objComputer.UserName\n\n\t\t\tstrLastUser = objComputer.UserName &#039; this may set to no value if nobody is logged in\n\t\t\tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t&#039; WScript.Echo &quot;setting on line 37&quot; &amp; Err.Description\n\t\t\t\tErr.Number = 0\n\t\t\tEnd If\n\t\tElse &#039; nobody is logged in and it&#039;s not yet been run\n\t\t\tSetLastUser objReg,&quot;Uninitialized - waiting for login&quot;\n\t\tEnd If\n\tElse &#039; this has previously been set, overwrite the registry value if someone is logged in\n\t\tIf objComputer.UserName &lt;&gt; &quot;&quot; Then &#039; if someone is logged in\n\t\t\tSetLastUser objReg, objComputer.UserName\n\t\tElse &#039; No one is logged in and it&#039;s been run before\n&#039;\t\t\tWScript.Echo &quot;no user logged in and strLastUser is &quot; &amp; strLastUser\n\t\t\tSetLastUser objReg,&quot;Uninitialized - waiting for login&quot;\n\t\tEnd If\n\tEnd If\n\t\n\t&#039; whether anyone is logged in or nobody is logged in, echo out\n\t&#039; value in the registry which is either a login or the uninitialized phrase\n\tstrLastUser = GetLastUser(objReg) &#039; pull again now that it&#039;s been set\n\tIf Err.Number &lt;&gt; 0 Then\n\t\t&#039;WScript.Echo &quot;setting again, line 52&quot; &amp; Err.Description\n\t\tErr.Number = 0\n\tEnd If\n\tWScript.Echo strLastUser\nNext\n\n\n&#039; Cleanup\nSet colComputer = Nothing\nSet objWMIService = Nothing\nSet objReg = Nothing\n\nFunction GetLastUser(objRegistry)\n&#039; This function will look into the Tanium Registry Key to get the last logged in user\n\t\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strLastUserRegValueData, strTaniumPath, Result\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\tResult = objReg.GetStringValue(HKLM,strTaniumPath &amp; &quot;\\Sensor Data&quot;,&quot;LastLoggedInUser&quot;,strLastUserRegValueData)\n\n\tIf strLastUserRegValueData = &quot;&quot; Then &#039; data is not initialized\n\t\tGetLastUser = False\n\tElse\n\t\tGetLastUser = strLastUserRegValueData\n\tEnd If\n\t\nEnd Function &#039;GetLastUser\n\nFunction SetLastUser(objRegistry, strUserName)\n&#039; This function will look into the Tanium Registry Key to push the currently\n&#039; logged in user to the front of the array and push the previous last to the end\n\t\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strTaniumPath, strLastUser\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, strTaniumPath &amp; &quot;\\Sensor Data&quot;) Then\n\t\tobjRegistry.CreateKey HKLM, strTaniumPath &amp; &quot;\\Sensor Data&quot;\n\tEnd If\n\t\n\tobjReg.SetStringValue HKLM,strTaniumPath &amp; &quot;\\Sensor Data&quot;,&quot;LastLoggedInUser&quot;,strUserName\n\t\nEnd Function &#039;SetLastUser\n\t\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 6, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 33, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "A list of the short names of all services currently in the stopped state.\nExample: defragsvc", 
      "exclude_from_parse_flag": 1, 
      "hash": 2254780098, 
      "hidden_flag": 0, 
      "id": 63, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Stopped Service Short Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Name from win32_Service where State=&#039;Stopped&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 89, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 34, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates whether Forefront Realtime Monitoring is enabled.\nExample: enabled", 
      "exclude_from_parse_flag": 1, 
      "hash": 1453502334, 
      "hidden_flag": 0, 
      "id": 65, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Realtime Monitoring Status", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Realtime Monitoring Status\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Real-Time Protection&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Real-Time Protection&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Real-Time Protection&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Real-Time Protection&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWordValue HKLM, strKey, &quot;DisableRealtimeMonitoring&quot;, strValue\n\t\n\tIf IsNull(strValue) Then\n\t\tWScript.Echo &quot;Enabled&quot;\n\tElse\n\t\tIf strValue = &quot;1&quot; Then\n\t\t\tWScript.Echo &quot;Disabled&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;Enabled&quot;\n\t\tEnd If\n\tEnd If\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 35, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates the last time that a scan was run", 
      "exclude_from_parse_flag": 1, 
      "hash": 2875871002, 
      "hidden_flag": 0, 
      "id": 67, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Last Scan Run Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Last Scan Run\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;LastScanRun&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\tWScript.Echo BinaryToDate(binValue)\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 36, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "indicates the last scan type", 
      "exclude_from_parse_flag": 1, 
      "hash": 2835039726, 
      "hidden_flag": 0, 
      "id": 69, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Last Scan Run Type", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Last Scan Type\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;LastScanType&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tWScript.Echo GetScanType(dValue)\n\tElse\n\t\tWScript.Echo &quot;Scan Type not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider\n\n&#039;===============================================================\n&#039;Function GetScanType will return a string with the scan type that corresponds to the enum\n&#039;  Parameter: iScanType - type of scan\n&#039;  Return: a VARIANT string containing text type of scan\nFunction GetScanType(iScanType)\n Select case(iScanType)\n   Case 1 : GetScanType= &quot;Quick Scan&quot;\n   Case 2 : GetScanType= &quot;Full Scan&quot;\n   Case Else GetScanType= &quot;Invalid Scan type&quot;\n End Select\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 37, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates the last time that the client AV signature was updated.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 4191267132, 
      "hidden_flag": 0, 
      "id": 71, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client AS Signature Applied Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signature Applied Date\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;ASSignatureApplied&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\t\n\t\tWScript.Echo BinaryToDate(binValue)\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 38, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates the last time that the client AV signature was updated.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 3506422825, 
      "hidden_flag": 0, 
      "id": 73, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client AV Signature Applied Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signature Applied Date\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;AVSignatureApplied&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\t\n\t\tWScript.Echo BinaryToDate(binValue)\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 39, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates the last time that the client AV signature was updated.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 488010600, 
      "hidden_flag": 0, 
      "id": 75, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client NIS Signature Applied Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signature Applied Date\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;NISSignatureApplied&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\t\n\t\tWScript.Echo BinaryToDate(binValue)\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 40, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates the last time that the client AV signature was updated.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 2299414733, 
      "hidden_flag": 0, 
      "id": 77, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Signatures Last Updated Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signature Applied Date\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastUpdated&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\t\n\t\tWScript.Echo BinaryToDate(binValue)\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 41, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The current version of the AV signature being used by Forefront.\nExample: 1.85.1626.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 4008943778, 
      "hidden_flag": 0, 
      "id": 79, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client AV Signature Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client AV Signature Version\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetStringValue HKLM, strKey, &quot;AVSignatureVersion&quot;, strValue\n\t\t\n\tIf Not IsNull(strValue) Then\n\t\tWScript.Echo strValue\n\tElse\n\t\tWScript.Echo &quot;Signature version not found&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 42, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates how many days ago a new AS signature was applied.\nExample: 8", 
      "exclude_from_parse_flag": 1, 
      "hash": 3821169579, 
      "hidden_flag": 0, 
      "id": 81, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client AV Signature Applied Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client AS Signature Applied Days Old\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;AVSignatureApplied&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\twords = Split(BinaryToDate(binValue))\n\t\tWScript.Echo GetDaysOld(words(0))\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nEnd If\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 43, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The current version of the AV signature being used by Forefront.\nExample: 1.85.1626.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 4187016545, 
      "hidden_flag": 0, 
      "id": 83, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client AS Signature Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client AV Signature Version\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetStringValue HKLM, strKey, &quot;ASSignatureVersion&quot;, strValue\n\t\t\n\tIf Not IsNull(strValue) Then\n\t\tWScript.Echo strValue\n\tElse\n\t\tWScript.Echo &quot;Signature version not found&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 44, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates how many days ago a new AS signature was applied.\nExample: 8", 
      "exclude_from_parse_flag": 1, 
      "hash": 2636428026, 
      "hidden_flag": 0, 
      "id": 85, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client AS Signature Applied Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client AS Signature Applied Days Old\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;ASSignatureApplied&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\twords = Split(BinaryToDate(binValue))\n\t\tWScript.Echo GetDaysOld(words(0))\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nEnd If\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 45, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The version of the Forefront NIS signature file on the client machine.\nExample: 1.12.2131.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 1114146405, 
      "hidden_flag": 0, 
      "id": 87, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client NIS Signature Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client NIS Signature Version\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetStringValue HKLM, strKey, &quot;NISSignatureVersion&quot;, strValue\n\t\t\n\tIf Not IsNull(strValue) Then\n\t\tWScript.Echo strValue\n\tElse\n\t\tWScript.Echo &quot;Signature version not found&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 46, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates how many days ago a new AS signature was applied.\nExample: 8", 
      "exclude_from_parse_flag": 1, 
      "hash": 1247546398, 
      "hidden_flag": 0, 
      "id": 89, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client NIS Signature Applied Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client AS Signature Applied Days Old\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;NISSignatureApplied&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\twords = Split(BinaryToDate(binValue))\n\t\tWScript.Echo GetDaysOld(words(0))\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nEnd If\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 47, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The version of  the Forefront client on the client machine", 
      "exclude_from_parse_flag": 1, 
      "hash": 508630093, 
      "hidden_flag": 0, 
      "id": 91, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Version\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware&quot;\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetStringValue HKLM, strKey, &quot;InstallLocation&quot;, strValue\n\t\t\n\tIf Not IsNull(strValue) Then\n\t\tfileToCheck = strValue &amp; &quot;\\msmpeng.exe&quot;\n\t\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\tWScript.Echo objFso.GetFileVersion(fileToCheck)\n\tElse\n\t\tWScript.Echo &quot;Client version not found&quot;\n\tEnd If\nElse\n\t&#039; check for windows defender\n\tCheckWindowsDefender\nEnd If\n\nSub CheckWindowsDefender\n\tstrPath = &quot;c:\\program files\\windows defender\\MsMpEng.exe&quot;\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tIf objfso.FileExists(strPath) Then\n\t\tWScript.Echo objFSO.GetFileVersion(strPath)\n\tElse\n\t\tWScript.Echo &quot;Client version not found&quot;\n\tEnd If\nEnd Sub\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 48, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The version of the engine being used by Forefront on the client machine.\nExample: 1.1.5902.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 391298201, 
      "hidden_flag": 0, 
      "id": 93, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Engine Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Engine Version\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetStringValue HKLM, strKey, &quot;EngineVersion&quot;, strValue\n\t\t\n\tIf Not IsNull(strValue) Then\n\t\tWScript.Echo strValue\n\tElse\n\t\tWScript.Echo &quot;Engine version not found&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 49, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The version fo the Forefront NIS engine running on the client machine.\nExample: 1.3.1106.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 2813418207, 
      "hidden_flag": 0, 
      "id": 95, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client NIS Engine Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client NIS Engine Version\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetStringValue HKLM, strKey, &quot;NISEngineVersion&quot;, strValue\n\t\t\n\tIf Not IsNull(strValue) Then\n\t\tWScript.Echo strValue\n\tElse\n\t\tWScript.Echo &quot;Engine version not found&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 50, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The version of the client spyware signatures used by Forefront.\nExample: 1.20.3423.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 3973828276, 
      "hidden_flag": 0, 
      "id": 97, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Spyware Signature Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Spyware Signature Version\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Signature Updates&quot;\n\tEnd If\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetStringValue HKLM, strKey, &quot;ASSignatureVersion&quot;, strValue\n\t\t\n\tIf Not IsNull(strValue) Then\n\t\tWScript.Echo strValue\n\tElse\n\t\tWScript.Echo &quot;Signature version not found&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 51, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates if a Scheduled Scan is enabled or not", 
      "exclude_from_parse_flag": 0, 
      "hash": 2877564299, 
      "hidden_flag": 0, 
      "id": 99, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Scheduled Scan Enabled", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Scheduled Scan Enabled\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\n\tdIsDefender = 1\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;ScheduleDay&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tIf dValue = 8 Then\n\t\t\tWScript.Echo &quot;No&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;Yes&quot;\n\t\tEnd If\n\tElse\n\t\tif dIsDefender =1 then\n\t\t\tWScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;\n\t\telse\n\t\t\tWScript.Echo &quot;Scan Type not found&quot;\t\n\t\tend if\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 52, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates the Scheduled Scan Type", 
      "exclude_from_parse_flag": 0, 
      "hash": 1872660430, 
      "hidden_flag": 0, 
      "id": 101, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Scheduled Scan Type", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Scheduled Scan Type\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\n\tdIsDefender = 1\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;ScanParameters&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tIf dValue = 1 Then\n\t\t\tWScript.Echo &quot;Quick Scan&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;Full Scan&quot;\n\t\tEnd If\n\tElse\n\t\tIf dIsDefender = 1 Then\n\t\t\tWScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;Quick Scan&quot;\n\t\tEnd If\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 53, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "indicates the the scheduled scan day\nExample: Sunday", 
      "exclude_from_parse_flag": 1, 
      "hash": 3957460633, 
      "hidden_flag": 0, 
      "id": 103, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Scheduled Scan Day", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Scheduled Scan Day\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\n\tdIsDefender = 1\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;ScheduleDay&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tSelect Case dValue\n\t\t\tCase 0\n\t\t\t\tWScript.Echo &quot;Daily&quot;\n\t\t\t\t\t\t\n\t\t\tCase 1\n\t\t\t\tWScript.Echo &quot;Sunday&quot;\n\t\t\t\n\t\t\tCase 2\n\t\t\t\tWScript.Echo &quot;Monday&quot;\n\t\t\t\t\n\t\t\tCase 3\n\t\t\t\tWScript.Echo &quot;Tuesday&quot;\n\t\t\t\t\n\t\t\tCase 4\n\t\t\t\tWScript.Echo &quot;Wednesday&quot;\n\t\t\t\t\n\t\t\tCase 5\n\t\t\t\tWScript.Echo &quot;Thursday&quot;\n\t\t\t\t\n\t\t\tCase 6\n\t\t\t\tWScript.Echo &quot;Friday&quot;\n\t\t\t\t\n\t\t\tCase 7\n\t\t\t\tWScript.Echo &quot;Saturday&quot;\n\t\tEnd Select\n\tElse\n\t\tif dIsDefender = 1 then\n\t\t\tWScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;\n\t\telse\n\t\t\tWScript.Echo &quot;Not found&quot;\n\t\tend if\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 54, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates the scheduled scan time\nExample: 2:00 AM", 
      "exclude_from_parse_flag": 0, 
      "hash": 2174883544, 
      "hidden_flag": 0, 
      "id": 105, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Scheduled Scan Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Scheduled Scan Time\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\n\tdIsDefender = 1\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;ScheduleTime&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tIf dvalue = 0 Then\n\t\t\tWScript.Echo &quot;12:00 AM&quot;\n\t\tElse\n\t\t\t&#039; need to divide by 60 to get\n\t\t\t&#039; the hour\n\t\t\tdHour = dvalue / 60\n\t\t\tdTT = &quot;AM&quot;\n\t\t\t\n\t\t\tIf dhour &gt; 12 Then\n\t\t\t\tdhour = dhour - 12\n\t\t\t\tdTT = &quot;PM&quot;\n\t\t\tEnd If\n\t\t\t\n\t\t\tWScript.Echo dhour &amp; &quot;:00 &quot; &amp; dTT\n\t\tEnd If\n\t\t&#039; divide by 60 to get the hour\n\tElse\n\t\tif dIsDefender = 1 then\n\t\t\twscript.echo &quot;No Scheduled Scan: Windows Defender&quot;\n\t\telse \n\t\t\tWScript.Echo &quot;2:00 AM&quot;\n\t\tend if\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 55, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates checking for definitions before running scheduled scan\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 270604477, 
      "hidden_flag": 0, 
      "id": 107, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Scheduled Scan Check Definitions", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Scheduled Scan Check definitions\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\n\tdIsDefender = 1\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;CheckForSignaturesBeforeRunningScan&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tIf dValue = 1 Then\n\t\t\tWScript.Echo &quot;Yes&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;No&quot;\n\t\tEnd if\n\tElse\n\t\tif dIsDefender = 1 then\n\t\t\tWScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;\n\t\telse\n\t\t\tWScript.Echo &quot;Not found&quot;\n\t\tend if\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 56, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates scheduled scan only when idle\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 1096615317, 
      "hidden_flag": 0, 
      "id": 109, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Scheduled Scan Only When Idle", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Scheduled Scan Only When Idle\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\n\tdIsDefender = 1\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;ScanOnlyIfIdle&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tIf dValue = 1 Then\n\t\t\tWScript.Echo &quot;Yes&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;No&quot;\n\t\tEnd if\n\tElse\n\t\tif dIsDefender = 1 then\n\t\t\tWScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;\n\t\telse\n\t\t\tWScript.Echo &quot;Yes&quot;\n\t\tend if\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 57, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates Limit CPU usage for scan\nExample: 50%", 
      "exclude_from_parse_flag": 1, 
      "hash": 2645000905, 
      "hidden_flag": 0, 
      "id": 111, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Forefront Client Scheduled Scan Limit CPU Usage", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Scheduled Scan Limit CPU Usage\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Scan&quot;\nEnd If\n\n&#039; check for windows defender (win 8 and &gt;)\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Microsoft\\Windows Defender\\Scan&quot;\n\tIf Not RegKeyExists(reg, HKLM, strKey) Then\n\t\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Windows Defender\\Scan&quot;\n\tEnd If\n\tdIsDefender = 1\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetDWORDValue HKLM, strKey, &quot;AvgCPULoadFactor&quot;, dValue\n\t\n\tIf Not IsNull(dValue) Then\n\t\tWScript.Echo dvalue &amp; &quot;%&quot;\n\tElse\n\t\tif dIsDefender = 1 then\n\t\t\tWScript.Echo &quot;No Scheduled Scan: Windows Defender&quot;\n\t\telse\n\t\t\tWScript.Echo &quot;50%&quot;\n\t\tend if\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 58, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Shows the details of two sophos services:  sophos anti-virus and the sophos autoupdate service.\nExample: Service | StartMode | State | Healthy", 
      "exclude_from_parse_flag": 1, 
      "hash": 2103988074, 
      "hidden_flag": 0, 
      "id": 113, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Client Health", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Client Health\n&#039;========================================\n\n&#039; This sensor will return the status of the sophos services\n&#039; and make a health determination\n&#039; output looks like \n\nOption Explicit\n\nDim strSep \n\nstrSep = &quot;|&quot;\n\nGetSophosClientStatus(strSep)\n\nFunction GetSophosClientStatus(strSep)\n&#039; This function will echo back the details of two sophos services:\n&#039; sophos anti-virus and the sophos autoupdate service.\n&#039; The output will look like:\n&#039; Service|StartMode|State|Healthy\n\n\tDim objWMIService, colItems\n\tDim strComputer, strServiceDisplayName, strMainServiceStartMode, strMainServiceState\n\tDim strUpdateServiceStartMode, strUpdateServiceState, strHealthy\n\tDim objItem\n\t\n\t\n\tstrComputer = &quot;.&quot;\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\t\n\t&#039; First the main service\n\tstrMainServiceStartMode = &quot;&quot;\n\tstrMainServiceState = &quot;&quot;\n\tstrServiceDisplayName = &quot;sophos anti-virus&quot;\n\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Service where DisplayName&quot; _\n\t\t&amp; &quot; = &#039;&quot;&amp;strServiceDisplayName&amp;&quot;&#039;&quot;)\n\tIf (colItems.Count &gt; 0 )Then\n\t\tFor Each objItem in colItems\n\t\t\tstrMainServiceStartMode = objItem.StartMode\n\t\t\tstrMainServiceState = objItem.State\n\t\tNext\n\tElse\n\t\tstrMainServiceStartMode = &quot;Not Installed&quot;\n\t\tstrMainServiceState = &quot;Not Installed&quot;\n\tEnd If\n\t\n\tIf LCase(strMainServiceStartMode) = &quot;auto&quot; And LCase(strMainServiceState) = &quot;running&quot; Then\n\t\tstrHealthy = &quot;Yes&quot;\n\tElse\n\t\tstrHealthy = &quot;No&quot;\n\tEnd If\n\t&#039; part one of sensor output\n\tWScript.Echo strServiceDisplayName &amp; strSep &amp; strMainServiceStartMode _\n\t\t&amp; strSep &amp; strMainServiceState &amp; strSep &amp; strHealthy\n\t\t\n\t&#039; Next the sophos auto update service\n\t\n\tstrUpdateServiceStartMode = &quot;&quot;\n\tstrUpdateServiceState = &quot;&quot;\n\tstrServiceDisplayName = &quot;sophos autoupdate service&quot;\n\t\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Service where DisplayName&quot; _\n\t\t&amp; &quot; = &#039;&quot;&amp;strServiceDisplayName&amp;&quot;&#039;&quot;)\n\tIf ( colItems.Count &gt; 0 ) Then\n\t\tFor Each objItem in colItems\n\t\t\tstrUpdateServiceStartMode = objItem.StartMode\n\t\t\tstrUpdateServiceState = objItem.State\n\t\tNext\n\tElse\n\t\tstrUpdateServiceStartMode = &quot;Not Installed&quot;\n\t\tstrUpdateServiceState = &quot;Not Installed&quot;\n\tEnd If\n\n\tIf LCase(strUpdateServiceStartMode) = &quot;auto&quot; And LCase(strUpdateServiceState) = &quot;running&quot; Then\n\t\tstrHealthy = &quot;Yes&quot;\n\tElse\n\t\tstrHealthy = &quot;No&quot;\n\tEnd If\n\tWScript.Echo strServiceDisplayName &amp; strSep &amp; strUpdateServiceStartMode _\n\t\t&amp; strSep &amp; strUpdateServiceState &amp; strSep &amp; strHealthy\n\t\t\t\n\t&#039;Cleanup\n\tSet colItems = Nothing\n\tSet objWMIService = Nothing\n\nEnd Function &#039;GetSophosClientStatus", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Service", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Start Mode", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Healthy", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 59, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns the version of Sophos anti-virus installed on the client machine.\nExample:  4.80.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 1244581312, 
      "hidden_flag": 0, 
      "id": 115, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Client Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Client Version\n&#039;========================================\n\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;H80000002 \n\nkeyPath = &quot;Software\\Sophos&quot;\nkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\SAVService\\Application&quot;) Then\n\tWScript.Echo GetVersion(keyPath &amp; &quot;\\SAVService\\Application&quot;)\n\nElse\n\tWScript.Echo &quot;Version not found&quot;\nEnd If\n\n\nFunction GetVersion(fullKeyPath)\n\tobjRegistry.GetStringValue HKLM,fullKeyPath ,&quot;Path&quot;, strDir\n\tIf Not IsNull(strDir) Then\n\t\tstrExe = &quot;SavMain.exe&quot;\n\t\tSet theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\n\t\tIf theFso.FileExists(strDir &amp; strExe) Then\n\t\t\tWScript.Echo GetFileVersion(strDir &amp; strExe)\n\t\t\tWScript.Quit\n\t\tEnd If\n\t\t\n\t\tGetVersion = strVersion\n\t\tExit Function\n\tEnd If\t\n\n\tGetVersion = &quot;Version not found&quot;\nEnd Function\n\nfunction GetFileVersion(theFile)\n\tdim theFso, theVer\n\tset theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\ttheVer = theFso.getFileVersion(theFile)\n\t\n\tif theVer = &quot;&quot; then\n\t\ttheVer = &quot;-1&quot;\n\tend If\n\t\n\tgetFileVersion = theVer   \nend Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 60, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The engine version of Sophos AV installed on the client machine.\nExample: 4.80.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 3528246009, 
      "hidden_flag": 0, 
      "id": 117, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 1800, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Engine Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Engine Version\n&#039;========================================\n\n&#039; This sensor will return the value of the sophos AV detection engine\n\nSet objRegistry = Getx64RegistryProvider()\n\nConst HKLM = &amp;H80000002 \n\nkeyPath = &quot;Software\\Sophos&quot;\nkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\SAVService\\Application&quot;) Then\n\tWScript.Echo GetVersion(keyPath &amp; &quot;\\SAVService\\Application&quot;)\nElse\n\tWScript.Echo &quot;Sophos Registry Not Found&quot;\n\tWScript.Quit\nEnd If\n\n\nFunction GetVersion(fullKeyPath)\n\tobjRegistry.GetStringValue HKLM,fullKeyPath ,&quot;Path&quot;, strDir\n\tIf Not IsNull(strDir) Then\n\t\tstrFile = &quot;veex.dll&quot;\n\t\tSet theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\n\t\tIf theFso.FileExists(strDir &amp; strFile) Then\n\t\t\tWScript.Echo GetFileVersion(strDir &amp; strFile)\n\t\tElse\n\t\t\tWScript.Echo &quot;Engine File Not Found&quot;\n\t\tEnd If\n\tElse\t\n\tGetVersion = &quot;Sophos Path Registry Value Not Found&quot;\n\tEnd If\nEnd Function\n\nFunction GetFileVersion(theFile)\n\tdim theFso, theVer\n\tset theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\ttheVer = theFso.getFileVersion(theFile)\n\t\n\tif theVer = &quot;&quot; then\n\t\ttheVer = &quot;-1&quot;\n\tend If\n\t\n\tgetFileVersion = theVer   \nend Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 61, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The last time that Sophos AV was updated on the client machine.\nExample: 2006-11-07T18:00:000Z", 
      "exclude_from_parse_flag": 1, 
      "hash": 2221806865, 
      "hidden_flag": 0, 
      "id": 119, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Last Update Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Last Update Time\n&#039;========================================\n\n&#039; This sensor will read a registry key and determine the last time\n&#039; the software updated itself.\n\nOption Explicit\n\n&#039; return the time\nWScript.Echo GetSophosLastUpdateTime\n\n\nFunction GetSophosLastUpdateTime\n&#039; This function returns a time, in UTC, which is the last\n&#039; successful update of Sophos\n\n\t\n\tConst HKLM = &amp;H80000002 \n\t\n\tDim objRegistry\n\tDim keyPath, key64Path, tZ, strFullKeyPath\n\tDim dwordLastUpdateTime\n\n\tSet objRegistry = Getx64RegistryProvider()\n\n\tkeyPath = &quot;Software\\Sophos&quot;\n\tkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\tkeyPath = key64Path\n\t\n\t\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\t\tWScript.Echo &quot;Not installed&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tEnd If\n\t\n\ttZ = GetClientTimeZoneBias &#039;time relative to GMT\n\tstrFullKeyPath = keyPath &amp; &quot;\\AutoUpdate\\UpdateStatus&quot;\n\n\tIf RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then\n\t\tobjRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;LastUpdateTime&quot;, dwordLastUpdateTime\n\t\tGetSophosLastUpdateTime = DateAdd(&quot;h&quot;,tZ,(DateAdd(&quot;s&quot;,dwordLastUpdateTime,&quot;01/01/1970 00:00:00&quot;)))\n\tElse\n\t\tWScript.Echo &quot;Last Update Time Not Found&quot;\n\tEnd If\nEnd Function &#039; GetSophosLastUpdateTime\n\nFunction GetClientTimeZoneBias\n&#039; This will return the hour offset from GMT to be used in date math\n\tDim objWMIService, colItems\n\tDim strComputer, objItem\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\t\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_TimeZone&quot;)\n\t\n\tFor Each objItem in colItems\n\t\t&#039;Looks like -480\n\t    GetClientTimeZoneBias = objItem.Bias / 60\n\tNext\n\t\n\t&#039; Cleanup\n\tSet colItems = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;GetClientTimeZoneOffset\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 62, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The last time Sophos AV scanned the client machine.\nExample: 2006-11-07T18:00:000Z", 
      "exclude_from_parse_flag": 1, 
      "hash": 2918720813, 
      "hidden_flag": 0, 
      "id": 121, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Last Scan Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Last Scan Time\n&#039;========================================\n\n&#039; This sensor will read a registry key and determine the last time\n&#039; the software updated itself.\n\nOption Explicit\n\n&#039; return the time\nWScript.Echo GetSophosLastScanTime\n\n\nFunction GetSophosLastScanTime\n&#039; This function returns a time, in UTC, which is the last\n&#039; successful update of Sophos\n\n\t\n\tConst HKLM = &amp;H80000002 \n\t\n\tDim objRegistry\n\tDim keyPath, key64Path, tZ, strFullKeyPath\n\tDim dwordLastScanTime\n\n\tSet objRegistry = Getx64RegistryProvider()\n\n\tkeyPath = &quot;Software\\Sophos&quot;\n\tkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\tkeyPath = key64Path\n\t\n\t\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\t\tWScript.Echo &quot;Not installed&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tEnd If\n\t\n\ttZ = GetClientTimeZoneBias &#039;time relative to GMT\n\tstrFullKeyPath = keyPath &amp; &quot;\\SAVService\\Status\\LastScan&quot;\n\n\tIf RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then\n\t\tobjRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;EnterpriseScan&quot;, dwordLastScanTime\n\t\tGetSophosLastScanTime = DateAdd(&quot;h&quot;,tZ,(DateAdd(&quot;s&quot;,dwordLastScanTime,&quot;01/01/1970 00:00:00&quot;)))\n\tElse\n\t\tWScript.Echo &quot;Last Scan Time Not Found&quot;\n\tEnd If\nEnd Function &#039; GetSophosLastScanTime\n\nFunction GetClientTimeZoneBias\n&#039; This will return the hour offset from GMT to be used in date math\n\tDim objWMIService, colItems\n\tDim strComputer, objItem\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\t\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_TimeZone&quot;)\n\t\n\tFor Each objItem in colItems\n\t\t&#039;Looks like -480\n\t    GetClientTimeZoneBias = objItem.Bias / 60\n\tNext\n\t\n\t&#039; Cleanup\n\tSet colItems = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;GetClientTimeZoneOffset\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 63, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns True or False whether Sophos AV Controlled App detection is installed.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 60117748, 
      "hidden_flag": 0, 
      "id": 123, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Controlled App Detected", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Controlled App Detected\n&#039;========================================\n\n&#039; This sensor will read a registry key and determine if the machine\n&#039; has a Controlled App detection according to Sophos AV\n\nOption Explicit\n\n&#039; return the time\nWScript.Echo GetSophosControlledAppDetected\n\n\nFunction GetSophosControlledAppDetected\n&#039; This function returns a time, in UTC, which is the last\n&#039; successful update of Sophos\n\n\t\n\tConst HKLM = &amp;H80000002 \n\t\n\tDim objRegistry\n\tDim keyPath, key64Path, strFullKeyPath\n\tDim dwordControlledAppDetected\n\n\tSet objRegistry = Getx64RegistryProvider()\n\t\n\tkeyPath = &quot;Software\\Sophos&quot;\n\tkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\tkeyPath = key64Path\n\t\n\t\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\t\tWScript.Echo &quot;Not installed&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tEnd If\n\t\n\tstrFullKeyPath = keyPath &amp; &quot;\\SAVService\\Status\\Infected&quot;\n\n\tIf RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then\n\t\tobjRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;ControlledAppDetected&quot;, dwordControlledAppDetected\n\t\tIf Not IsNull(dwordControlledAppDetected) And dwordControlledAppDetected = 0 Then\n\t\t\tGetSophosControlledAppDetected = &quot;False&quot;\n\t\tElseIf Not IsNull(dwordControlledAppDetected) And dwordControlledAppDetected &gt; 0 Then\n\t\t\tGetSophosControlledAppDetected = &quot;True&quot;\n\t\tElse\n\t\t\tGetSophosControlledAppDetected = &quot;ControlledAppDetected Registry Value Not Found&quot; &#039;This should never happen\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;SAVService\\Status\\Infected Registry Value Not Found&quot;\n\tEnd If\nEnd Function &#039; GetSophosControlledAppDetected\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 64, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns True or False based on whether Sophos AV has detected infection or malware.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 3661718872, 
      "hidden_flag": 0, 
      "id": 125, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Malware Detected", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Malware Detected\n&#039;========================================\n\n&#039; This sensor will read a registry key and determine if the machine\n&#039; has a malware detection / infection according to Sophos AV\n\nOption Explicit\n\n&#039; return the time\nWScript.Echo GetSophosInfected\n\n\nFunction GetSophosInfected\n&#039; This function returns a time, in UTC, which is the last\n&#039; successful update of Sophos\n\n\t\n\tConst HKLM = &amp;H80000002 \n\t\n\tDim objRegistry\n\tDim keyPath, key64Path, strFullKeyPath\n\tDim dwordMalwareDetected\n\n\tSet objRegistry = Getx64RegistryProvider()\n\n\tkeyPath = &quot;Software\\Sophos&quot;\n\tkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\tkeyPath = key64Path\n\t\n\t\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\t\tWScript.Echo &quot;Not installed&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tEnd If\n\t\n\tstrFullKeyPath = keyPath &amp; &quot;\\SAVService\\Status\\Infected&quot;\n\n\tIf RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then\n\t\tobjRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;MalwareDetected&quot;, dwordMalwareDetected\n\t\tIf Not IsNull(dwordMalwareDetected) And dwordMalwareDetected = 0 Then\n\t\t\tGetSophosInfected = &quot;False&quot;\n\t\tElseIf Not IsNull(dwordMalwareDetected) And dwordMalwareDetected &gt; 0 Then\n\t\t\tGetSophosInfected = &quot;True&quot;\n\t\tElse\n\t\t\tGetSophosInfected = &quot;MalwareDetected Registry Value Not Found&quot; &#039;This should never happen\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;SAVService\\Status\\Infected Registry Value Not Found&quot;\n\tEnd If\nEnd Function &#039; GetSophosInfected\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 65, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns True or False if Sophos AV has detected a potentially unwanted program.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 2583495206, 
      "hidden_flag": 0, 
      "id": 127, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Potentially Unwanted Program Detected", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Potentially Unwanted Program Detected\n&#039;========================================\n\n&#039; This sensor will read a registry key and determine if the machine\n&#039; has a PUA detection according to Sophos AV\n\nOption Explicit\n\n&#039; return the time\nWScript.Echo GetSophosPUADetected\n\n\nFunction GetSophosPUADetected\n&#039; This function returns a time, in UTC, which is the last\n&#039; successful update of Sophos\n\n\t\n\tConst HKLM = &amp;H80000002 \n\t\n\tDim objRegistry\n\tDim keyPath, key64Path, strFullKeyPath\n\tDim dwordPUADetected\n\n\tSet objRegistry = Getx64RegistryProvider()\n\n\tkeyPath = &quot;Software\\Sophos&quot;\n\tkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\tkeyPath = key64Path\n\t\n\t\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\t\tWScript.Echo &quot;Not installed&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tEnd If\n\t\n\tstrFullKeyPath = keyPath &amp; &quot;\\SAVService\\Status\\Infected&quot;\n\n\tIf RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then\n\t\tobjRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;PUADetected&quot;, dwordPUADetected\n\t\tIf Not IsNull(dwordPUADetected) And dwordPUADetected = 0 Then\n\t\t\tGetSophosPUADetected = &quot;False&quot;\n\t\tElseIf Not IsNull(dwordPUADetected) And dwordPUADetected &gt; 0 Then\n\t\t\tGetSophosPUADetected = &quot;True&quot;\n\t\tElse\n\t\t\tGetSophosPUADetected = &quot;PUADetected Registry Value Not Found&quot; &#039;This should never happen\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;SAVService\\Status\\Infected Registry Value Not Found&quot;\n\tEnd If\nEnd Function &#039; GetSophosPUADetected\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 66, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns True or False if Sophos AV has detected suspicious behavior.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 762809308, 
      "hidden_flag": 0, 
      "id": 129, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Suspicious Behavior Detected", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Suspicious Behavior Detected\n&#039;========================================\n\n&#039; This sensor will read a registry key and determine if the machine\n&#039; has a Suspicious Behavior detection according to Sophos AV\n\nOption Explicit\n\n&#039; return the time\nWScript.Echo GetSophosSuspiciousBehaviorDetected\n\n\nFunction GetSophosSuspiciousBehaviorDetected\n&#039; This function returns a time, in UTC, which is the last\n&#039; successful update of Sophos\n\n\t\n\tConst HKLM = &amp;H80000002 \n\t\n\tDim objRegistry\n\tDim keyPath, key64Path, strFullKeyPath\n\tDim dwordSuspiciousBehaviorDetected\n\n\tSet objRegistry = Getx64RegistryProvider()\n\n\tkeyPath = &quot;Software\\Sophos&quot;\n\tkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\tkeyPath = key64Path\n\t\n\t\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\t\tWScript.Echo &quot;Not installed&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tEnd If\n\t\n\tstrFullKeyPath = keyPath &amp; &quot;\\SAVService\\Status\\Infected&quot;\n\n\tIf RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then\n\t\tobjRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;SuspiciousBehaviorDetected&quot;, dwordSuspiciousBehaviorDetected\n\t\tIf Not IsNull(dwordSuspiciousBehaviorDetected) And dwordSuspiciousBehaviorDetected = 0 Then\n\t\t\tGetSophosSuspiciousBehaviorDetected = &quot;False&quot;\n\t\tElseIf Not IsNull(dwordSuspiciousBehaviorDetected) And dwordSuspiciousBehaviorDetected &gt; 0 Then\n\t\t\tGetSophosSuspiciousBehaviorDetected = &quot;True&quot;\n\t\tElse\n\t\t\tGetSophosSuspiciousBehaviorDetected = &quot;SuspiciousBehaviorDetected Registry Value Not Found&quot; &#039;This should never happen\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;SAVService\\Status\\Infected Registry Value Not Found&quot;\n\tEnd If\nEnd Function &#039; GetSophosSuspiciousBehaviorDetected\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 67, 
      "category": "Sophos", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns True or False if Sophos AV has detected suspicious files.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 3753226920, 
      "hidden_flag": 0, 
      "id": 131, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Sophos Suspicious File Detected", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Sophos Suspicious File Detected\n&#039;========================================\n\n&#039; This sensor will read a registry key and determine if the machine\n&#039; has a Suspicious File detection according to Sophos AV\n\nOption Explicit\n\n&#039; return the time\nWScript.Echo GetSophosSuspiciousFileDetected\n\n\nFunction GetSophosSuspiciousFileDetected\n&#039; This function returns a time, in UTC, which is the last\n&#039; successful update of Sophos\n\n\t\n\tConst HKLM = &amp;H80000002 \n\t\n\tDim objRegistry\n\tDim keyPath, key64Path, strFullKeyPath\n\tDim dwordSuspiciousFileDetected\n\n\tSet objRegistry = Getx64RegistryProvider()\n\n\tkeyPath = &quot;Software\\Sophos&quot;\n\tkey64Path = &quot;Software\\WOW6432Node\\Sophos&quot;\n\t\n\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\tkeyPath = key64Path\n\t\n\t\tIf Not RegKeyExists(objRegistry, HKLM, keyPath) Then\n\t\t\tWScript.Echo &quot;Not installed&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tEnd If\n\t\n\tstrFullKeyPath = keyPath &amp; &quot;\\SAVService\\Status\\Infected&quot;\n\n\tIf RegKeyExists(objRegistry, HKLM, strFullKeyPath) Then\n\t\tobjRegistry.GetDWORDValue HKLM, strFullKeyPath ,&quot;SuspiciousFileDetected&quot;, dwordSuspiciousFileDetected\n\t\tIf Not IsNull(dwordSuspiciousFileDetected) And dwordSuspiciousFileDetected = 0 Then\n\t\t\tGetSophosSuspiciousFileDetected = &quot;False&quot;\n\t\tElseIf Not IsNull(dwordSuspiciousFileDetected) And dwordSuspiciousFileDetected &gt; 0 Then\n\t\t\tGetSophosSuspiciousFileDetected = &quot;True&quot;\n\t\tElse\n\t\t\tGetSophosSuspiciousFileDetected = &quot;SuspiciousFileDetected Registry Value Not Found&quot; &#039;This should never happen\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;SAVService\\Status\\Infected Registry Value Not Found&quot;\n\tEnd If\nEnd Function &#039; GetSophosSuspiciousFileDetected\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 68, 
      "category": "Symantec", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Version of Symantec AV installed on client machine.\nExample: 11.0.6200.513", 
      "exclude_from_parse_flag": 1, 
      "hash": 932508344, 
      "hidden_flag": 0, 
      "id": 133, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Symantec Client Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Symantec Client Version\n&#039;========================================\n\nOption Explicit\n\nConst HKLM = &amp;H80000002 \nConst strExe = &quot;rtvscan.exe&quot;\n&#039;SEP 12+ no longer include rtvscan, but instead RtvStart&#039;\nConst strExe12 = &quot;RtvStart.exe&quot;\n\nDim objRegistry, objFso, strResult, keyPath, strDir\n\nSet objRegistry = Getx32RegistryProvider()\n\nstrResult = &quot;&quot;\n\nkeyPath = &quot;SOFTWARE\\Symantec\\InstalledApps&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tstrResult = &quot;Not Installed&quot;\nEnd If\n\n\nSet objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\n&#039;check SAV Install Directory&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;SAV Install Directory&quot;, strDir\n\tIf objFso.FileExists(strDir &amp; strExe) Then\n\t\tstrResult = GetFileVersion(strDir &amp; strExe)\n\tEnd If\nEnd If\n\n&#039;check SAV Install Directory for 12&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;SAV Install Directory&quot;, strDir\n\tIf objFso.FileExists(strDir &amp; strExe) Then\n\t\tstrResult = GetFileVersion(strDir &amp; strExe12)\n\tEnd If\nEnd If\n\n&#039;check SAVCE&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;SAVCE&quot;, strDir\n\tIf objFso.FileExists(strDir &amp; strExe) Then\n\t\tstrResult GetFileVersion(strDir &amp; strExe)\n\tEnd If\nEnd If\n\n&#039;check SAVCE for SEP 12&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;SAVCE&quot;, strDir\n\tIf objFso.FileExists(strDir &amp; strExe12) Then\n\t\tstrResult = GetFileVersion(strDir &amp; strExe12)\n\tEnd If\nEnd If\n\n&#039;check NAVNT&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT&quot;, strDir\n\tIf objFso.FileExists(strDir &amp; strExe) Then\n\t\tstrResult = GetFileVersion(strDir &amp; strExe)\n\tEnd If\nEnd If \n\n&#039;check NAV&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAV&quot;, strDir\n\tIf objFso.FileExists(strDir &amp; strExe) Then\n\t\tstrResult = GetFileVersion(strDir &amp; strExe)\n\tEnd If\nEnd If \n\nIf strResult = &quot;&quot; Then \n\tWScript.Echo &quot;Not Installed&quot;\nElse \n\tWScript.Echo strResult\nEnd If\n\nfunction GetFileVersion(theFile)\n\tdim objFso, theVer\n\tset objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\ttheVer = objFso.getFileVersion(theFile)\n\t\n\tif theVer = &quot;&quot; then\n\t\ttheVer = &quot;-1&quot;\n\tend If\n\t\n\tgetFileVersion = theVer   \nend Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx32RegistryProvider\n    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems\n    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript\n    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv\n    \n    iArchType = 32\n   \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx32RegistryProvider = objRegProv\nEnd Function &#039; Getx32RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 69, 
      "category": "Symantec", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Age in days of the last scan report by Symantec AV on the client machine if it exists.\nExample: 9", 
      "exclude_from_parse_flag": 1, 
      "hash": 1065011811, 
      "hidden_flag": 0, 
      "id": 135, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Symantec Last Report Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Symantec Last Report Days Old\n&#039;========================================\n\nOption Explicit\n\n&#039; Force correct date handling\nSetLocale(1033)\n\nConst HKLM = &amp;H80000002 \nConst keyPath = &quot;SOFTWARE\\Symantec\\InstalledApps&quot;\n&#039;SEP 12 uses a different path to the serstate.dat file&#039;\nConst keyPath12 = &quot;SOFTWARE\\Symantec\\Symantec Endpoint Protection\\CurrentVersion\\Common Client\\PathExpansionMap&quot;\nConst strFile = &quot;serstate.dat&quot;\nConst strFile12 = &quot;\\Data\\State\\SerState.dat&quot;\n\nDim objRegistry, strResult, strDir, objFSO\n\nSet objRegistry = Getx32RegistryProvider()\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tstrResult = &quot;Not Installed&quot;\nEnd If\n\n\nset objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\nEnd If \n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tstrResult = &quot;Not Installed&quot;\nEnd If\n\n&#039; check SEP 12\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath12 ,&quot;APPDATABASE&quot;, strDir\n\tIf objFSO.FileExists(strDir &amp; strFile12) Then\n\t\tstrResult = GetReportDaysOld(strDir &amp; strFile12)\n\tEnd If\nEnd If\n\n&#039;check SAV Install Directory&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;SAV Install Directory&quot;, strDir\n\tIf objFSO.FileExists(strDir &amp; strFile) Then\n\t\tstrResult = GetReportDaysOld(strDir &amp; strFile)\n\tEnd If\nEnd If\n\n&#039;check SAVCE&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;SAVCE&quot;, strDir\n\tIf objFSO.FileExists(strDir &amp; strFile) Then\n\t\tstrResult = GetReportDaysOld(strDir &amp; strFile)\n\tEnd If\nEnd If \n\n&#039;check NAVNT&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT&quot;, strDir\n\tIf objFSO.FileExists(strDir &amp; strFile) Then\n\t\tstrResult = GetReportDaysOld(strDir &amp; strFile)\n\tEnd If\nEnd If\n\n&#039;check NAV&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAV&quot;, strDir\n\tIf objFSO.FileExists(strDir &amp; strFile) Then\n\t\tstrResult = GetReportDaysOld(strDir &amp; strFile)\n\tEnd If\nEnd If\n\nIf strResult = &quot;&quot; Then \n\tWScript.Echo &quot;Not Installed&quot;\nElse \n\tWScript.Echo strResult\nEnd if\n\nfunction GetReportDaysOld(theFile)\n\tdim objFSO, theVer, reportDate, today\n\tset objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\treportDate = FormatDateTime(objFSO.GetFile(theFile).DateLastModified,2)\n\t&#039;WScript.Echo (&quot;reportdate: &quot; &amp; reportDate)\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetReportDaysOld = DateDiff(&quot;d&quot;, reportDate, today)\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx32RegistryProvider\n    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems\n    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript\n    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv\n    \n    iArchType = 32\n   \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx32RegistryProvider = objRegProv\nEnd Function &#039; Getx32RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 70, 
      "category": "Symantec", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Age of Symantec AV virus definitions in days if installed on client machine.\nExample: 12", 
      "exclude_from_parse_flag": 1, 
      "hash": 558954146, 
      "hidden_flag": 0, 
      "id": 137, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Symantec DAT Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Symantec DAT Days Old\n&#039;========================================\n\nOption Explicit\n\n&#039; Force correct date handling\nSetLocale(1033)\n\nConst HKLM = &amp;H80000002 \n\nDim objRegistry, keyPath, keyPath12, strResult, strValue\n\nSet objRegistry = Getx32RegistryProvider()\n\nkeyPath = &quot;Software\\Symantec\\SharedDefs&quot;\n&#039;check for SEP 12, which uses a different location for definitions&#039;\nkeyPath12 = &quot;Software\\Symantec\\Symantec Endpoint Protection\\CurrentVersion\\SharedDefs&quot;\n\nstrResult = &quot;&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tstrResult = &quot;Not Installed&quot;\nEnd If\n\n&#039;check NAVCORP_70 value at SEP 12 location&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath12 ,&quot;NAVCORP_70&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatDaysOld(strValue)\n\tEnd If\nEnd If\n\n&#039;check NAVCORP_70 value&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVCORP_70&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatDaysOld(strValue)\n\tEnd If\nEnd If\n\n&#039;check NAVNO_50_AP1 value&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNO_50_AP1&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatDaysOld(strValue)\n\tEnd If\nEnd If\n\n&#039;check NAVNT_50_AP1 value&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT_50_AP1&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatDaysOld(strValue)\n\tEnd If\nEnd If \n\nIf strResult = &quot;&quot; Then \n\tWScript.Echo &quot;Dat value not found&quot;\nElse \n\tWScript.Echo strResult\nEnd If\n\nFunction GetDatDaysOld(strValue)\n\tDim words, datFile, strDat, datDate, today\n\twords = Split(strValue, &quot;\\&quot;)\n\tdatFile = words(UBound(words))\n\twords = Split(datFile, &quot;.&quot;)\n\tstrDat = words(0)\n\tdatDate = CDate( Mid(strDat, 5, 2) &amp; &quot;/&quot; &amp; Right(strDat, 2) &amp; &quot;/&quot; &amp; Left(strDat, 4) )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDatDaysOld = DateDiff(&quot;d&quot;, datDate, today)\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx32RegistryProvider\n    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems\n    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript\n    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv\n    \n    iArchType = 32\n   \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx32RegistryProvider = objRegProv\nEnd Function &#039; Getx32RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 71, 
      "category": "Trend Micro", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The version number of Trend Micro AV if installed on the client machine.\nExample: 17.50.1366.0000", 
      "exclude_from_parse_flag": 1, 
      "hash": 3327439715, 
      "hidden_flag": 0, 
      "id": 139, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Trend Micro Client Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Trend Micro Client Version\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;H80000002 \n\nkeyPath = &quot;Software\\TrendMicro&quot;\nkey64Path = &quot;Software\\WOW6432Node\\TrendMicro&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\CPM&quot;) Then\n\tobjRegistry.GetStringValue HKLM, keyPath &amp; &quot;\\CPM&quot; ,&quot;Version&quot;, strVersion\n\n\tIf IsNull(strVersion) Then\n\t\tWScript.Echo &quot;Version not found&quot;\n\tElse\n\t\tobjRegistry.GetStringValue HKLM, keyPath &amp; &quot;\\CPM&quot; ,&quot;ServicePackVersion&quot;, strSPVersion\n\t\tIf IsNull(strSPVersion) Or Not(CInt(strSPVersion) &gt; 0) Then\n\t\t\tWScript.Echo strVersion\n\t\tElse \n\t\t\tWScript.Echo strVersion &amp; &quot; Service Pack &quot; &amp; strSPVersion\n\t\tEnd If\n\tEnd If\nElseIf RegKeyExists(HKLM, keyPath &amp; &quot;\\PC-cillinNTCorp\\CurrentVersion&quot;) Then\t\n\tobjRegistry.GetStringValue HKLM, keyPath &amp; &quot;\\PC-cillinNTCorp\\CurrentVersion&quot; ,&quot;Application Path&quot;, strAppPath\n\t&#039;WScript.Echo &quot;file path: &quot; &amp; strAppPath\n\t\n\tDim fso\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\tIf fso.FileExists(strAppPath &amp; &quot;PccNT.exe&quot;) Then\n\t\tWScript.Echo fso.GetFileVersion(strAppPath &amp; &quot;PccNT.exe&quot;)\n\tElse \n\t\tWScript.Echo &quot;Trend Console not found&quot;\n\tEnd If \nElse\n\tWScript.Echo &quot;Not installed&quot;\n\tWScript.Quit\nEnd If\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 72, 
      "category": "Trend Micro", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Age of Trend Micro AV virus definitions in days if installed on the client machine.\nExample: 4", 
      "exclude_from_parse_flag": 1, 
      "hash": 1666713228, 
      "hidden_flag": 0, 
      "id": 141, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Trend Micro Pattern Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Trend Micro Pattern Days Old\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;H80000002 \n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nkeyPath = &quot;Software\\TrendMicro&quot;\nkey64Path = &quot;Software\\WOW6432Node\\TrendMicro&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\nEnd If \n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tWScript.Echo &quot;Not Installed&quot;\n\tWScript.Quit\nEnd If\n\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\PC-cillinNTCorp\\CurrentVersion\\Misc.&quot;) Then\t\n\tobjRegistry.GetStringValue HKLM, keyPath &amp; &quot;\\PC-cillinNTCorp\\CurrentVersion\\Misc.&quot; ,&quot;NonCrcPatternDate&quot;, strPatternDate\n\n\tIf Not IsNull(strPatternDate) Then\n\t\tWScript.Echo GetDaysOld(strPatternDate)\n\t\tWScript.Quit\t\n\tEnd If\nEnd If \n\nWScript.Echo &quot;Pattern date not found&quot;\n\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( Right(Left(strDate, 6), 2) &amp; &quot;/&quot; &amp; Right(strDate, 2) &amp; &quot;/&quot; &amp; Left(strDate, 4) )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 73, 
      "category": "Trend Micro", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Version number of Trend Micro AV virus definitions if installed on the client machine.\nExample: 9.501.50", 
      "exclude_from_parse_flag": 1, 
      "hash": 1469085758, 
      "hidden_flag": 0, 
      "id": 143, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Trend Micro Pattern Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Trend Micro Pattern Version \n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;H80000002 \n\nkeyPath = &quot;Software\\TrendMicro&quot;\nkey64Path = &quot;Software\\WOW6432Node\\TrendMicro&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\nIf RegKeyExists(HKLM, keyPath &amp; &quot;\\PC-cillinNTCorp\\CurrentVersion\\Misc.&quot;) Then\n\tobjRegistry.GetDWordValue HKLM, keyPath &amp; &quot;\\PC-cillinNTCorp\\CurrentVersion\\Misc.&quot; ,&quot;InternalPatternVer&quot;, strInternalVersion\n\tobjRegistry.GetDWordValue HKLM, keyPath &amp; &quot;\\PC-cillinNTCorp\\CurrentVersion\\Misc.&quot; ,&quot;InternalNonCrcPatternVer&quot;, strNonCrcPatternVersion\n\t\n\tIf Not IsNull(strInternalVersion) And strInternalVersion &lt;&gt; 0 Then\n\t\tWScript.Echo FormatPatternVersion(strInternalVersion)\n\t\tWScript.Quit\n\tElseIf Not IsNull(strNonCrcPatternVersion) Then\n\t\tWScript.Echo FormatPatternVersion(strNonCrcPatternVersion)\n\t\tWScript.Quit\n\tEnd If\n\tWScript.Echo &quot;Pattern version not found&quot;\nElse\n\tWScript.Echo &quot;Not installed&quot;\n\tWScript.Quit\nEnd If\n\nFunction FormatPatternVersion(str)\n\tIf Len(str) &gt;=6 Then\n\t\tFormatPatternVersion = Left(str, Len(str)-5) &amp; &quot;.&quot; &amp; Left(Right(str, 5), 3) &amp; &quot;.&quot; &amp; Right(str, 2)\n\t\tExit Function\n\tElse\n\t\tFormatPatternVersion = &quot;0.&quot; &amp; Left(Right(str, 5), 3) &amp; &quot;.&quot; &amp; Right(str, 2)\n\t\tExit Function\n\tEnd If\n\tFormatPatternVersion = &quot;&quot;\nEnd Function\n\nFunction IsValidVersion(version)\n\tIf IsNull(version) Or IsEmpty(version) Then\n\t\tIsValidVersion = False\n\t\tExit Function\n\tEnd If \n\t\n\tnumberArr = Split(version, &quot;.&quot;)\n\tFor Each number In numberArr\n\t\tIf IsNumeric(number) Then\n\t\t\t&#039;Good to go.  keep looking\n\t\tElse\n\t\t\tIsValidVersion = False\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\tIsValidVersion = True\nEnd Function\n\nFunction VersionIsGreaterThan(version, compareToVersion)\n\tIf Not IsValidVersion(version) Or Not IsValidVersion(compareToVersion) Then\n\t\tWScript.Echo &quot;not valid versions: &quot; &amp; version &amp; &quot;, &quot; &amp; compareToVersion\n\t\tExit Function\n\tEnd If\n\n\tversionNumbers = Split(version, &quot;.&quot;)\n\tcompareToVersionNumbers = Split(compareToVersion, &quot;.&quot;)\n\t\n\tFor count = 0 To UBound(versionNumbers)\n\t\tversionNumber = versionNumbers(count)\n\t\tIf UBound(compareToVersionNumbers) &gt;= count Then\n\t\t\tcompareToVersionNumber = compareToVersionNumbers(count)\n\t\tElse\n\t\t\tcompareToVersionNumber = -1\n\t\tEnd If \n\t\t\n\t\tIf versionNumber &gt; compareToVersionNumber Then\n\t\t\tVersionIsGreaterThan = True\n\t\t\tExit function\n\t\tElseIf versionNumber &lt; compareToVersionNumber Then\n\t\t\tVersionIsGreaterThan = False\n\t\t\tExit function\n\t\tEnd If\n\tNext\n\t\n\tVersionIsGreaterThan = False\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 74, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Provides a list of processes currently running on the client machine.\nExample: svchost.exe", 
      "exclude_from_parse_flag": 1, 
      "hash": 4142232197, 
      "hidden_flag": 0, 
      "id": 145, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Running Processes", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from win32_process", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nps -ef | grep -v &quot; $$ &quot; | awk &#039;{ print substr($0,index($0,$8)) }&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nps -ef | grep -v &quot; $$ &quot; | awk &#039;{ print substr($0,index($0,$8)) }&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 75, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Current IP Addresses of client machine.\nExample: 192.168.1.1", 
      "exclude_from_parse_flag": 1, 
      "hash": 3209138996, 
      "hidden_flag": 0, 
      "id": 147, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "IP Address", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select IPAddress from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nifconfig | grep -w inet | grep -v 127.0.0.1 | awk &#039;{print $2}&#039; | sed -e &#039;s/addr://&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nifconfig -a -u |grep &quot;inet&quot; | grep -v &quot;::1&quot; | grep -v &quot;127.0.0.1&quot;| awk &#039;{print $2}&#039; | cut -f1 -d&#039;%&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 95, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 76, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Provides a list of users currently logged in to the client machine.  Includes Remote Desktop sessions on Windows.\nExample: Administrator", 
      "exclude_from_parse_flag": 1, 
      "hash": 1092986182, 
      "hidden_flag": 0, 
      "id": 149, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Logged In Users", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Logged In Users\n&#039;========================================\n\nOption Explicit\n\nDim objWMIService,colItems,objItem,strUser,strUserDomain,strFullUser,i\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;) \nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process Where Name=&#039;explorer.exe&#039;&quot;,,48)\n\ni = 0\nFor Each objItem in colItems\n\tobjItem.GetOwner strUser, strUserDomain\n\tstrFullUser = strUserDomain &amp; &quot;\\&quot; &amp; strUser\n\ti = i + 1\n\tWScript.Echo strFullUser\nNext\n\nIf i = 0 Then\n\tWscript.Echo &quot;No User&quot;\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nwho -u | cut -d&quot; &quot; -f1 | sort | uniq\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "w -h | sort -u -t&#039; &#039; -k1,1 | awk &#039;{print $1}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 77, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Provides the last time a local administrator logged into the machine.\nExample: Administrator 5/10/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 2634431519, 
      "hidden_flag": 0, 
      "id": 151, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Last Date of Local Administrator Login", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last Date of Local Administrator Login\n&#039;========================================\n\nOption Explicit  \n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\t\t\nDim objNetwork : Set objNetwork = CreateObject(&quot;WScript.Network&quot;) \nDim objGroup : Set objGroup = GetObject(&quot;WinNT://.&quot;) \nobjGroup.Filter = Array(&quot;user&quot;) \nDim objUser \nFor Each objUser In objGroup     \nOn Error Resume Next         \nWScript.Echo objUser.name &amp; vbTab &amp; left(GetObject(objUser.adsPath).LastLogin,Instr(GetObject(objUser.adsPath).LastLogin,&quot; &quot;))     \nOn Error GoTo 0 \nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 94, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 78, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The Active Directory organizational unit (OU) where the machine is located.\nExample: CN=Computers,DC=corp,DC=com", 
      "exclude_from_parse_flag": 1, 
      "hash": 21983240, 
      "hidden_flag": 0, 
      "id": 153, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "AD Organizational Unit", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; AD Organizational Unit\n&#039;========================================\n\n\n&#039; Returns a single column value\n&#039; Only checks a single registry context\n\nConst GPKey = &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy&quot;\nDim strSubKey,strValue,strSep,strKey,words,strHive,constHive,hasValues32,hasAnyResult\nDim hasValues64,strUserKey,strFullUserKey,bEchoOnlyValue\nDim objCtx,objReg,bSkipSecondCheckOverride\n\nDim dictOut\nSet dictOut = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nbEchoOnlyValue = True\nbSkipSecondCheckOverride = True &#039; Check in one place\nstrSubKey = &quot;\\DataStore\\Machine\\0&quot;\nstrValue = &quot;DNName&quot;\nstrSep = &quot;~~&quot;\n\nstrKey = GPKey&amp;strSubKey\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n   For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n         strUserName = GetUserForSIDLocal(objReg,strUserKey)\n         If strUserName = False Then strUserName = strUserKey\n         strFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n         hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n         If hasValues32 Then hasAnyResult = True\n      End If\n   Next\nElse &#039; was another hive\n   hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n   If hasValues32 Then hasAnyResult = True\nEnd If\n\n&#039; Do not return second value set in different context unnecessarily\nDim strKeyPrefix,bSkipSecondContextCheck\nbSkipSecondContextCheck = False\nstrKeyPrefix = Split(strKey,&quot;\\&quot;)(0) &#039; Software, for instance, even for HEKY_USERS\n\nSelect Case Ucase(strKeyPrefix)\n   Case &quot;SOFTWARE&quot;\n      If bSkipSecondCheckOverride Then\n         bSkipSecondContextCheck = True\n      Else\n         bSkipSecondContextCheck = False\n      End If\n   Case Else\n      bSkipSecondContextCheck = True\nEnd Select\n\nIf Is64 And Not bSkipSecondContextCheck Then\n   Set objCtx = GetObjCtx(64)\n   Set objReg = GetObjReg(objCtx)\n   If strHive = &quot;HKEY_USERS&quot; Then\n   &#039; go through each User&#039;s hive in 64-bit context\n      For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n            strUserName = GetUserForSIDLocal(objReg,strUserKey)\n            If strUserName = False Then strUserName = strUserKey\n            strFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n            hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n            If hasValues64 Then hasAnyResult = True   \n         End If\n      Next\n   Else &#039; was another hive\n      hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n      If hasValues64 Then hasAnyResult = True\n   End If\nEnd If\n\nEchoOutDictFunctionFilter dictOut,&quot;Not Found&quot;,&quot;GetOUFromDN&quot;\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n   Dim Inparams, Outparams,arrNames,arrTypes,i,strValueName\n   Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n   Inparams.Hdefkey = constHive\n   Inparams.sSubkeyname = strKey\n   Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n   \n   arrNames = Outparams.sNames\n   arrTypes = Outparams.Types\n\n   If Not IsNull(arrNames) Then\n      For i = LBound(arrNames) To UBound(arrNames)\n         strValueName = arrNames(i)\n         \n         &#039;if strValue is found, echo\n         If LCase(strValueName) = LCase(strValue) Then\n            AddValToEchoDict dictOut, objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit, bEchoOnlyValue\n            CheckValues = True\n            Exit Function\n         End If\n      Next\n   End If\n   CheckValues = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit, bEchoOnlyValue)\n   Dim strArch\n   If intBit = 64 Then\n      strArch = &quot;64-bit&quot;\n   Else\n      strArch = &quot;32-bit&quot;\n   End If\n   If bEchoOnlyValue Then\n      GetDisplayString = strValue\n   Else\n      GetDisplayString = _\n         strValue &amp; strSep &amp; _\n         strType &amp; strSep &amp; _\n         strArch\n   End If\nEnd Function\n\nFunction AddValToEchoDict(ByRef dicOut, objReg, objCtx, constHive, strKey, strValue, constType, intBit, bOnlyValueData)\n   &#039; Note the key that was being searched, will be a hidden column\n   Dim strOutputKey\n   strOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n   \n   Dim objInParams, objOutParams\n   Select Case constType\n      Case REG_SZ  \n         Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters\n         objInParams.hDefKey = constHive\n         objInParams.sSubKeyName = strKey\n         objInParams.sValueName = strValue         \n         Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)\n         Else\n            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_EXPAND_SZ\n         Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters\n         objInParams.hDefKey = constHive\n         objInParams.sSubKeyName = strKey\n         objInParams.sValueName = strValue         \n         Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)\n         Else  \n            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_BINARY\n         Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters\n         objInParams.hDefKey = constHive\n         objInParams.sSubKeyName = strKey\n         objInParams.sValueName = strValue         \n         Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)\n\n         strBytes = &quot;&quot;\n         For Each uByte in objOutParams.uValue\n            strTemp = Hex(uByte)\n            If Len(strTemp) &lt; 2 Then\n               strTemp = &quot;0&quot; &amp; strTemp\n            End If   \n            strBytes = strBytes &amp; strTemp &amp; &quot; &quot;\n         Next\n         If bOnlyValueData Then\n            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)\n         Else\n            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit, bOnlyValueData) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If         \n      Case REG_DWORD\n          Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n          objInParams.hDefKey = constHive\n          objInParams.sSubKeyName = strKey\n          objInParams.sValueName = strValue\n          Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)\n         Else     \n            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_QWORD\n          Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters\n          objInParams.hDefKey = constHive\n          objInParams.sSubKeyName = strKey\n          objInParams.sValueName = strValue\n          Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            AddToOut dictOut, GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)\n         Else     \n            AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_MULTI_SZ\n          Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters\n          objInParams.hDefKey = constHive\n          objInParams.sSubKeyName = strKey\n          objInParams.sValueName = strValue\n          Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)\n      \n         arrValues = objOutParams.sValue\n         strResponse = &quot;&quot;\n\n         For Each strTemp In arrValues\n            If bOnlyValueData Then\n               AddToOut dictOut, GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit, bOnlyValueData)\n            Else\n               AddToOut dictOut, strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit) _\n                  &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n            End If\n         Next\n   End Select\nEnd Function\n\nFunction GetObjCtx(intArch)\n   Dim objCtx\n   Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n   objCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n   objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n   Set GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n   Dim objLocator, objServices\n   Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n   Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n   Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n   Dim Inparams, Outparams\n   Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n   Inparams.Hdefkey = constHive\n   Inparams.sSubkeyname = strKey\n   Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n   GetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n   Dim objWMIService, colItems, objItem\n   Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n   Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n   For Each objItem In colItems\n      If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n         Is64 = True\n      Else\n         Is64 = False\n      End If      \n   Next\nEnd Function\n\n\nFunction GetHiveConst(hive)\n   Const HKEY_CLASSES_ROOT   = &amp;H80000000\n   Const HKEY_CURRENT_USER   = &amp;H80000001\n   Const HKEY_LOCAL_MACHINE  = &amp;H80000002\n   Const HKEY_USERS          = &amp;H80000003\n\n   Select Case UCase(hive)\n      Case &quot;HKLM&quot;\n         GetHiveConst = HKEY_LOCAL_MACHINE\n      Case &quot;HKEY_LOCAL_MACHINE&quot;\n         GetHiveConst = HKEY_LOCAL_MACHINE\n      Case &quot;HKCR&quot;\n         GetHiveConst = HKEY_CLASSES_ROOT\n      Case &quot;HKEY_CLASSES_ROOT&quot;\n         GetHiveConst = HKEY_CLASSES_ROOT\n      Case &quot;HKEY_CURRENT_USER&quot;\n         GetHiveConst = HKEY_CURRENT_USER\n      Case &quot;HKEY_USERS&quot;\n         GetHiveConst = HKEY_USERS\n   End Select\n   \n   If IsEmpty(GetHiveConst) Then\n      WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n      WScript.Quit\n   End If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n   Const HKLM = &amp;h80000002\n   \n   Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n   \n   strHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n   objReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n   If Not IsNull(strUserData) Then\n   &#039; strUserData would look like\n   &#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n      intDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n      &#039; strip off the dat file\n      If intDatPos &gt; 0 Then &#039; must be in string\n         strUserData = Left(strUserData,intDatPos - 1)\n         &#039; find last backslash\n         intFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n         &#039; get right from that pos\n         strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n         GetUserForSIDLocal = strUserData\n      Else\n         strUserData = False\n      End If\n   Else\n      GetUserForSIDLocal = False\n   End If\nEnd Function &#039;GetUserForSIDLocal\n\nSub AddToOut(ByRef dictOut, strIn)\n\tIf VarType(strIn) = vbString Then\n\t\tIf Not dictOut.Exists(strIn) Then\n\t\t\tdictOut.Add strIn,1\n\t\tEnd If\n\tEnd If\nEnd Sub\n\nFunction GetOUFromDN(strDN)\n\tDim intFirstComma\n\tintFirstComma = InStr(strDN,&quot;,&quot;)\n\tIf Not intFirstComma &gt; 0 Then\n\t\tGetOUFromDN = strDN\n\t\tExit Function\n\tEnd If\n\tintFromRight = Len(strDN) - intFirstComma\n\tIf intFromRight &gt;= 0 Then\n\t\tGetOUFromDN = Right(strDN,intFromRight)\n\tElse\n\t\tGetOUFromDN = strDN\n\tEnd If\nEnd Function &#039;GetOUFromDN\n\nSub EchoOutDictFunctionFilter(ByRef dictOut,strNoResultsMessage, ByRef funcRef)\n&#039;FuncRef returns a string which filters the key\n\tDim strKey\n\tIf dictOut.Count = 0 Then\n\t\tWScript.Echo strNoResultsMessage\n\t\tExit Sub\n\tEnd If\n\tDim out\n\tFor Each strKey In dictOut\n\t\tExecute(&quot;out = &quot;&amp;funcRef&amp;&quot;(strKey)&quot;)\n\t\tWScript.Echo out\n\tNext\nEnd Sub &#039;EchoOutDictFunctionFilter", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 79, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "All computer groups (if any) that a computer is a member of in Active Directory.\nExample: Berkeley Workstations", 
      "exclude_from_parse_flag": 1, 
      "hash": 525163843, 
      "hidden_flag": 0, 
      "id": 155, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "AD Computer Groups", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; AD Computer Groups\n&#039;========================================\n\nOn Error Resume Next\n&#039; Constants required for name translate\nCONST ADS_NAME_INITTYPE_GC = 3\nCONST ADS_NAME_TYPE_NT4 = 3\nCONST ADS_NAME_TYPE_1779 = 1\n\n&#039;Get the NETBIOS name of the domain\nSET objSystemInfo = CREATEOBJECT(&quot;ADSystemInfo&quot;) \nDim strDomain\nstrDomain = objSystemInfo.DomainShortName\nIf IsEmpty(strDomain) Then\n   WScript.Echo &quot;AD Information Unavailable&quot;\n   WScript.Quit\nEnd If\n\n&#039; Get the name of the computer\nSET objNetwork = CREATEOBJECT(&quot;Wscript.Network&quot;)\nstrComputer = objNetwork.ComputerName\n\n&#039; Call function to return the distinguished name (DN) of the computer\n\ndim strComputerDN\nstrComputerDN = getComputerDN(strComputer,strDomain)\n\nIf isEmpty(strComputerDN) Then\n   wscript.echo &quot;Cannot connect to AD server&quot;\nElse\n\tGetGroups(strComputerDN)\n\t \n\twscript.quit\nEnd If\n\nFunction GetGroups(strDn)\n&#039;\tWScript.Echo &quot;looking at: &quot;&amp; strDN\n\t&#039;\tOn Error Resume Next\n\tConst E_ADS_PROPERTY_NOT_FOUND  = &amp;h8000500D\n\t \n\tSet objUser = GetObject _\n\t    (&quot;LDAP://&quot; &amp; strDn)\n\t \n\tintPrimaryGroupID = objUser.Get(&quot;primaryGroupID&quot;)\n\tarrMemberOf = objUser.GetEx(&quot;memberOf&quot;)\n\t \n\tIf Err.Number = E_ADS_PROPERTY_NOT_FOUND Then\n\t    WScript.Echo &quot;The memberOf attribute is not set.&quot;\n\tElse\n\t    For Each Group in arrMemberOf\n\t        WScript.Echo Group\n\t    Next\n\tEnd If\nEnd Function\n\nFunction getComputerDN(BYVAL strComputer,BYVAL strDomain)\n   &#039; Function to get the distinguished name of a computer\n   &#039; from the NETBIOS name of the computer (strcomputer)\n   &#039; and the NETBIOS name of the domain (strDomain) using\n   &#039; name translate\n\n   SET objTrans = CREATEOBJECT(&quot;NameTranslate&quot;)\n   &#039; Initialize name translate using global catalog\n   objTrans.Init ADS_NAME_INITTYPE_GC, &quot;&quot;\n   &#039; Input computer name (NT Format)\n   objTrans.SET ADS_NAME_TYPE_NT4, strDomain &amp; &quot;\\&quot; &amp; strComputer &amp; &quot;$&quot;\n   &#039; Get Distinguished Name.\n   getComputerDN = objTrans.GET(ADS_NAME_TYPE_1779)\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 80, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Time since reboot in days of the client machine.\nExample: 48 days", 
      "exclude_from_parse_flag": 1, 
      "hash": 3480890585, 
      "hidden_flag": 0, 
      "id": 157, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 1800, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Uptime", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Uptime\n&#039;========================================\n\nstrComputer = &quot;.&quot; &#039; Local computer\n\nset objWMIDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\nset objWMI = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nset colOS = objWMI.InstancesOf(&quot;Win32_OperatingSystem&quot;)\nfor each objOS in colOS\n\tobjWMIDateTime.Value = objOS.LastBootUpTime\n         \n\tIf TimeSpan(objWMIDateTime.GetVarDate,Now) &gt; 0 Then\n        Wscript.echo TimeSpan(objWMIDateTime.GetVarDate,Now) &amp; &quot; days&quot;\nElse\n        Wscript.echo &quot;Less than 1 day&quot;\n        End If\nnext\n\nFunction TimeSpan(dt1, dt2) \n\tIf (isDate(dt1) And IsDate(dt2)) = false Then \n\t\tTimeSpan = &quot;00:00:00&quot; \n\t\tExit Function \n        End If \n \n        seconds = Abs(DateDiff(&quot;S&quot;, dt1, dt2)) \n        minutes = seconds \\ 60 \n        hours = minutes \\ 60 \n        days = hours \\ 24 \n        minutes = minutes mod 60 \n        seconds = seconds mod 60 \n \n        TimeSpan = days\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nline=$(cat /proc/uptime)\nset -- $line\necho $1\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nuptime | awk &#039;{\n  # chops off &quot;up&quot; and everything before it:\n  sub(/.*up[ ]+/,&quot;&quot;,$0)\n  # chops off &quot;, # users&quot; and everything after it:       \n  sub(/,[ ]+[0-9]+ user.*/,&quot;&quot;,$0)\n  # cleans up extra spaces, i think:    \n  sub(/,/,&quot;&quot;,$0)\n  # obvious enough, prints the results                       \n  print($0)\n}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 81, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns data indicating that a reboot is required and, if so, for which reason.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 568581921, 
      "hidden_flag": 0, 
      "id": 159, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Reboot Required", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Reboot Required\n&#039;========================================\n\n&#039;&#039; This sensor checks registry locations to determine if a reboot is required\n&#039;&#039; For any reason\n\n\nOption Explicit\nRebootRequired\n\nFunction RebootRequired\n&#039; This is the main function that determines if a reboot is necessary\n&#039; it will have WScript.Echo output and also set a true / false value\n&#039; as a return value so it can be used elsewhere\n\n\tDim strFinalOutputString\n\n\tDim strComputer\n\n\tDim strWUAPath\n\tDim strPendingFileRenamePath,strPendingFileRenameValueName\n\tDim strUpdateExeVolatilePath,strUpdateExeVolatileWowPath,strUpdateExeVolatileFlagsVal\n\tDim strRunOncePath,strRunOnceWowPath\n\tDim strRunOnceSetupPath,strRunOnceSetupWowPath\n\tDim strRunOnceExPath,strRunOnceExWowPath,strRunOnceExTitleVal\n\n\tDim intUpdateExeVolatileFlagsResult\n\n\tDim objReg\n\n\t&#039; The checks are all in the Local Machine hive\n\tConst HKLM = &amp;h80000002\n\n\t&#039;&#039; Case 1\n\t&#039; If the RebootRequired key exists at all, reboot is required\n\t&#039; Only seems to exist in the native registry (not in Wow6432Node)\n\tstrWUAPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\Auto Update\\RebootRequired&quot;\n\n\t&#039;&#039; Case 2\n\t&#039; If the Multi String value PendingRenameFileOperations exists at all, reboot is required\n\tstrPendingFileRenamePath = &quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager&quot;\n\tstrPendingFileRenameValueName = &quot;PendingFileRenameOperations&quot;\n\n\t&#039;&#039; Case 3\n\t&#039; If the UpdateExeVolatile key&#039;s DWORD value &#039;flags&#039; is 1 or 2, reboot is required\n\t&#039; Does exist in the native registry (in Wow6432Node) as well\n\tstrUpdateExeVolatilePath = &quot;SOFTWARE\\Microsoft\\Updates\\UpdateExeVolatile&quot;\n\tstrUpdateExeVolatileWowPath = &quot;SOFTWARE\\Wow6432Node\\Microsoft\\Updates\\UpdateExeVolatile&quot;\n\tstrUpdateExeVolatileFlagsVal = &quot;flags&quot;\n\n\t&#039;&#039; Case 4\n\t&#039;&#039; If there are any values in the RunOnce key, reboot is required\n\t&#039; Does exist in the native registry (in Wow6432Node) as well\n\tstrRunOncePath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce&quot;\n\tstrRunOnceWowPath = &quot;SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce&quot;\n\n\t&#039;&#039; Case 5\n\t&#039; If there is anything in the RunOnce\\Setup key, reboot is required\n\t&#039; Does exist in the native registry (in Wow6432Node) as well\n\tstrRunOnceSetupPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup&quot;\n\tstrRunOnceSetupWowPath = &quot;SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\Setup&quot;\n\n\t&#039;&#039; Case 6\n\t&#039; If there is anything in the RunOnceEx key&#039;s Title Value, a reboot is required\n\t&#039; Does exist in the native registry (in Wow6432Node) as well\n\tstrRunOnceExPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx&quot;\n\tstrRunOnceExWowPath = &quot;SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx&quot;\n\tstrRunOnceExTitleVal = &quot;Title&quot;\n\n\t&#039;&#039; Case 7\n\t&#039; RebootNeeded from UpdateSearcher class\n\n\tSet objReg=Getx64RegistryProvider()\n\n\tstrFinalOutputString = &quot;&quot;\n\n\t&#039; Now we begin the process of checking the various registry areas to determine if a reboot is needed\n\n\t&#039; Case 1\n\tIf RegKeyExists(objReg, HKLM, strWUAPath) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strWUAPath &amp; vbCrLf\n\tEnd If\n\n\t&#039; Case 2\n\tIf MultiStringValueExists(objReg,HKLM,strPendingFileRenamePath,strPendingFileRenameValueName) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strPendingFileRenamePath &amp; &quot;: &quot; &amp; strPendingFileRenameValueName &amp; vbCrLf\n\tEnd If\n\n\t&#039; Case 3\n\tintUpdateExeVolatileFlagsResult = GetDWORDValue(objReg,HKLM,strUpdateExeVolatilePath,strUpdateExeVolatileFlagsVal)\n\tIf intUpdateExeVolatileFlagsResult = 1 OR intUpdateExeVolatileFlagsResult = 2 Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strUpdateExeVolatilePath &amp; &quot;: &quot; &amp; strUpdateExeVolatileFlagsVal &amp; vbCrLf\n\tEnd If\n\n\tintUpdateExeVolatileFlagsResult = GetDWORDValue(objReg,HKLM,strUpdateExeVolatileWowPath,strUpdateExeVolatileFlagsVal)\n\tIf intUpdateExeVolatileFlagsResult = 1 OR intUpdateExeVolatileFlagsResult = 2 Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strUpdateExeVolatileWowPath &amp; &quot;: &quot; &amp; strUpdateExeVolatileFlagsVal &amp; vbCrLf\n\tEnd If\n\n\t&#039; Case 4\n\tIf ValuesExist(objReg,HKLM,strRunOncePath) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strRunOncePath &amp; vbCrLf\n\tEnd If\n\n\tIf ValuesExist(objReg,HKLM,strRunOnceWowPath) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strRunOnceWowPath &amp; vbCrLf\n\tEnd If\n\n\t&#039; Case 5\n\tIf ValuesExist(objReg,HKLM,strRunOnceSetupPath) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strRunOnceSetupPath &amp; vbCrLf\n\tEnd If\n\n\tIf ValuesExist(objReg,HKLM,strRunOnceSetupWowPath) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strRunOnceSetupWowPath &amp; vbCrLf\n\tEnd If\n\n\t&#039; Case 6\n\tIf StringValueExists(objReg,HKLM,strRunOnceExPath,strRunOnceExTitleVal) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strRunOnceExPath &amp; &quot;: &quot; &amp; strRunOnceExTitleVal &amp; vbCrLf\n\tEnd If\n\n\tIf StringValueExists(objReg,HKLM,strRunOnceExWowPath,strRunOnceExTitleVal) Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; strRunOnceExWowPath &amp; &quot;: &quot; &amp; strRunOnceExTitleVal &amp; vbCrLf\n\tEnd If\n\n\t&#039; Case 7\n\tIf UpdateSystemInfoRebootRequired Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; &quot;Microsoft.Update.SystemInfo:RebootRequired&quot; &amp; vbCrLf\n\tEnd If\n\n\n\t&#039;&#039; At the end of the process, if strFinalOutputString is &quot;&quot; the sensor output is &quot;No&quot;\n\t&#039;&#039; Otherwise, the output is the value of strFinalOutputString\n\n\tIf strFinalOutputString = &quot;&quot; Then\n\t\tWScript.Echo &quot;No&quot;\n\t\tRebootRequired = false\n\tElse\n\t\tWScript.Echo &quot;Yes&quot; &amp; vbcrlf &amp; strFinalOutputString\n\t\tRebootRequired = true\n\tEnd If\nEnd Function &#039;RebootRequired\n\nFunction ValuesExist(objRegistry, HIVE, strKeyPath)\n&#039; This function checks to see if a registry value exists\n&#039; and returns true or false\n\tDim arrValueNames, arrTypes\n\t\n\tobjRegistry.EnumValues HIVE, strKeyPath, arrValueNames, arrTypes\n\t\n\tIf IsNull(arrValueNames) Then\n\t\tValuesExist = false\n\tElse\n\t\tValuesExist = true\n\tEnd If\t\nEnd Function\n\nFunction StringValueExists(objRegistry, HIVE, strKeyPath, strValueName)\n\tDim strValue\n\t\n\tobjRegistry.GetStringValue HIVE, strKeyPath, strValueName, strValue\n\t\n\tIf IsNull(strValue) Then\n\t\tStringValueExists = false\n\tElse\n\t\tStringValueExists = true\n\tEnd If\t\nEnd Function\n\nFunction GetDWORDValue(objRegistry, HIVE, strKeyPath, strValueName)\n\tDim uintValue\n\t\n\tobjRegistry.GetDWORDValue HIVE, strKeyPath, strValueName, uintValue\n\t\n\tIf IsNull(uintValue) Then\n\t\tGetDWORDValue = false\n\tElse\n\t\tGetDWORDValue = uintValue\n\tEnd If\t\nEnd Function\n\nFunction DWORDValueExists(objRegistry, HIVE, strKeyPath, strValueName)\n\tDim uintValue\n\t\n\tobjRegistry.GetDWORDValue HIVE, strKeyPath, strValueName, uintValue\n\t\n\tIf IsNull(uintValue) Then\n\t\tDWORDValueExists = false\n\tElse\n\t\tDWORDValueExists = true\n\tEnd If\nEnd Function\n\n&#039; For checking multi-string value exists\nFunction MultiStringValueExists(objRegistry, HIVE, strKeyPath, strValueName)\n\tDim arrValues\n\n\tobjRegistry.GetMultiStringValue HIVE,strKeyPath,strValueName,arrValues\n\n\tIf IsNull(arrValues) Then\n\t\tMultiStringValueExists = false\n\tElse\n\t\tMultiStringValueExists = true\n\tEnd If\nEnd Function\n\n\n&#039; For checking whether a key exists at all\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n   Dim aValueNames, aValueTypes\n   If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n      RegKeyExists = True\n   Else\n      RegKeyExists = False\n   End If\nEnd Function\n\nFunction UpdateSystemInfoRebootRequired()\n&#039; This will return true if a reboot is needed\n&#039; as indicated by the update.systeminfo object\n   \n\tDim objSystemInfo,bRebootRequired\n   \n\tbRebootRequired = False\n\tSet objSystemInfo = WScript.CreateObject(&quot;Microsoft.Update.SystemInfo&quot;)\n\t\n\tbRebootRequired = objSystemInfo.rebootrequired \n\n\tUpdateSystemInfoRebootRequired = bRebootRequired\n\tSet objSystemInfo = nothing\nEnd Function &#039; UpdateSystemInfoRebootRequired\n\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nif [ -f /var/run/reboot-required ]; then\n  echo &#039;Yes&#039;\nelse\n  echo &#039;No&#039;\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nif [ -f /var/run/reboot-required ]; then\n  echo &#039;Yes&#039;\nelse\n  echo &#039;No&#039;\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 82, 
      "category": "Tags", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Any specified custom tags that have been set for this machine.  See the Custom Tagging Dashboard.\nExample:  Development, Test-Machines", 
      "exclude_from_parse_flag": 1, 
      "hash": 3004497651, 
      "hidden_flag": 0, 
      "id": 161, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Custom Tags", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Custom Tags\n&#039;========================================\n\nDim reg\nSet reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\nconst HKLM = &amp;H80000002\n\nDim strRegKey\nstrRegKey = GetTaniumRegistryPath() &amp; &quot;\\Sensor Data\\Tags&quot;\n\nIf Not RegKeyExists(reg, HKLM, strRegKey) Then\n\treg.createKey HKLM, strRegKey\nEnd If\n\nreg.enumValues HKLM, strRegKey, arrValues\n\nIf Not IsNull(arrValues) Then\n\tFor Each strValueName In arrValues\n\t\tWScript.Echo strValueName\n\tNext\nEnd If\n\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;GetTaniumRegistryPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\nTAGFILE=&quot;Tools/CustomTags.txt&quot;\n\nif [ -e $TAGFILE ]; then\n  cat $TAGFILE\nelse\n  echo &quot;&quot;\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nTAGFILE=&quot;Tools/CustomTags.txt&quot;\n\nif [ -e $TAGFILE ]; then\n  cat $TAGFILE\nelse\n  echo &quot;&quot;\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 85, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 83, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Sensor which looks at the patch results file to determine how many security patches are necessary.  Can be edited to determine what severity counts as a security patch.\nExample:5", 
      "exclude_from_parse_flag": 1, 
      "hash": 1999869038, 
      "hidden_flag": 0, 
      "id": 163, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Security Patches Needed", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Security Patches Needed\n&#039;========================================\n\n&#039; sensor - security patches needed\n&#039; This sensor will return a count of the number of patches required\n&#039; provided they are security-related\n\n\nOption Explicit\n\nDim strHighestSeverityThatCounts\n&#039; This sensor is modifiable\n&#039; customers can decide how to flag an update as countable in this sensor\n&#039; by default, we include all available patches\n\n&#039; This string value will determine what we count.  The valid values here are:\n&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS\n\nstrHighestSeverityThatCounts = &quot;ALL&quot;\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, intCriticalThreshold\nstrSep = &quot;|&quot;\nintCriticalThreshold = 5\n\nDim showSingleStatus\nshowSingleStatus = True\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\n\t&#039;note: intNone refers to patches with severity=none\n\tDim intCritical, intImportant, intModerate, intLow, intNone, intSecurityBulletin\n\t\n\tintCritical = 0\n\tintImportant = 0\n\tintModerate = 0\n\tintLow = 0\t\n\tintNone = 0\n\tintSecurityBulletin = 0\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\t&#039;WScript.Echo words(0)\n\t\t\tElse \n\t\t\t\t&#039;WScript.Echo &quot;Run upgraded Patch Scan&quot;\n\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\n&#039; A previously defined string value will determine what we count.  \n&#039; The valid values here are:\n&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS\n\n\t\t\tIf Not isComplete Then\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Available&quot; patches\n\t\t\t\tElse\n\t\t\t\t\thasOutput = True\n\t\t\t\t\tSelect Case words(1)\n\t\t\t\t\t    Case &quot;Critical&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;CRITICALS&quot; Or _\n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _\n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\t\tintCritical = intCritical + 1\n\t\t\t\t\t    \tEnd If\n\t\t\t\t\t    Case &quot;Important&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _\n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\t\tintImportant = intImportant + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t    \t\n\n\t\t\t\t\t    Case &quot;Moderate&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\tintModerate = intModerate + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t    \t\t\t\t\t\t    \n\t\t\t\t\t    Case &quot;Low&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\tintLow = intLow + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\t    Case &quot;None&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\tintNone = intNone + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\tEnd Select\n\t\t\t\t\tIf LCase(words(2)) &lt;&gt; &quot;none&quot; Then &#039; there is an MS Security Bulletin ID associated\n\t\t\t\t\t\tintSecurityBulletin = intSecurityBulletin + 1\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued\n\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t&#039;If InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t&#039;\tWScript.Echo strLine\n\t\t\t\t&#039;End If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\n\tobjReadFile.close\n\n\tIf hasOutput Then &#039; output sum, ignoring the &#039;None&#039; category\n\t\tIf strHighestSeverityThatCounts = &quot;MS_SECURITY_BULLETINS&quot; Then\n\t\t\tWScript.Echo intSecurityBulletin\n\t\tElse\n\t\t\tIf intCritical + intImportant + intModerate + intLow + intNone &gt; 0 Then\n\t\t\t\tWScript.Echo intCritical + intImportant + intModerate + intLow + intNone &amp; &quot; updates&quot;\n\t\t\tElse\n\t\t\t\tWScript.Echo 0\n\t\t\tEnd If\n\t\tEnd If\n\tElse\n\t\tWScript.Echo 0\n\tEnd If\n\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd If\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 84, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The domain name (if any) that the computer is joined to or configured for.\nExample: intra.company.com", 
      "exclude_from_parse_flag": 1, 
      "hash": 794103688, 
      "hidden_flag": 0, 
      "id": 165, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Domain Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Domain from win32_ComputerSystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndomainname\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ndomainname\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 85, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Addresses of any configured DNS servers for active network adapters.\nExample: 192.168.1.1, 8.8.8.8", 
      "exclude_from_parse_flag": 1, 
      "hash": 3112892791, 
      "hidden_flag": 0, 
      "id": 167, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "DNS Server", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select DNSServerSearchOrder from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ncat /etc/resolv.conf | while read line\ndo\n\tif [[ $line == nameserver* ]];\n\tthen\n\t\techo ${line#*&quot;nameserver&quot;}\n\tfi\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ncat /etc/resolv.conf | while read line\ndo\n\tif [[ $line == nameserver* ]];\n\tthen\n\t\techo ${line#*&quot;nameserver&quot;}\n\tfi\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 86, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The local IP address the client is using to communicate with the Tanium Server.\nExample: 192.168.10.2", 
      "exclude_from_parse_flag": 1, 
      "hash": 4264271977, 
      "hidden_flag": 0, 
      "id": 169, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Tanium Client IP Address", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client IP Address\n&#039;========================================\n\nDim strTaniumPath, strStatusPath\nDim strClientAddress, arrClientAddress, strIPAddress\nDim objReg\n\n\nSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;h80000002\n\n&#039;Tanium registry key paths\nstrTaniumPath = GetTaniumRegistryPath()\nstrStatusPath = strTaniumPath &amp; &quot;\\Status&quot;\n\n&#039;Pull the registry value out\nobjReg.GetStringValue HKLM, strStatusPath, &quot;ClientAddress&quot;, strClientAddress\n\narrClientAddress = Split(strClientAddress,&quot;_&quot;)\n\n&#039; Final output\nstrIPAddress = Split(arrClientAddress(0),&quot;:&quot;)(2)\n\nWScript.Echo strIPAddress\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction ParseTaniumIPEntry(strIPEntry)\n&#039; This function will parse a Tanium IP address entry in the registry\n\t\n\tDim strLeftSplit\n\t\n\tstrLeftSplit = Left(strIPEntry,InStr(strIPEntry,&quot;_&quot;)-1)\n\tParseTaniumIPEntry = Right(strLeftSplit,len(strLeftSplit)-InStrRev(strLeftSplit,&quot;:&quot;))\n\nEnd Function &#039;ParseTaniumIPEntry", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\ngrep ClientAddress TaniumClientStatus.ini | awk -F &#039;:&#039; &#039;{ print $NF }&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\ngrep ClientAddress TaniumClientStatus.ini | awk -F &#039;:&#039; &#039;{ print $NF }&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 8, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 87, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The Subnet in use by the Tanium Client.\nExample: 192.168.10.0/24", 
      "exclude_from_parse_flag": 1, 
      "hash": 1744818157, 
      "hidden_flag": 0, 
      "id": 171, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Tanium Client Subnet", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Subnet\n&#039;========================================\n\nOption Explicit\n\nDim strTaniumIPAddress, strTaniumMask\n\nstrTaniumIPAddress = GetTaniumIPAddress\nIf strTaniumIPAddress = False Then \n\tWScript.Echo &quot;Can&#039;t retrieve Tanium Client&#039;s IP address&quot;\nEnd If\n\nstrTaniumMask = GetSubnetMaskForIP(strTaniumIPAddress)\n\nWScript.Echo CalcNetworkAddress(strTaniumIPAddress,strTaniumMask) &amp; &quot;/&quot; &amp; MaskLength(strTaniumMask)\n\nFunction CalcNetworkAddress(strIP, strMask)\n  &#039; Generates the Network Address from the IP and Mask\n \n  &#039; Conversion of IP and Mask to binary\n  Dim strBinIP : strBinIP = ConvertIPToBinary(strIP)\n  Dim strBinMask : strBinMask = ConvertIPToBinary(strMask)\n \n  &#039; Bitwise AND operation (except for the dot)\n  Dim i, strBinNetwork\n  For i = 1 to Len(strBinIP)\n    Dim strIPBit : strIPBit = Mid(strBinIP, i, 1)\n    Dim strMaskBit : strMaskBit = Mid(strBinMask, i, 1)\n \n    If strIPBit = &quot;1&quot; And strMaskBit = &quot;1&quot; Then\n      strBinNetwork = strBinNetwork &amp; &quot;1&quot;\n    ElseIf strIPBit = &quot;.&quot; Then\n      strBinNetwork = strBinNetwork &amp; strIPBit\n    Else\n      strBinNetwork = strBinNetwork &amp; &quot;0&quot;\n    End If\n  Next\n \n  &#039; Conversion of Binary IP to Decimal\n  CalcNetworkAddress= ConvertBinIPToDecimal(strBinNetwork)\nEnd Function\n\nFunction MaskLength(strMask)\n  &#039; Converts an subnet mask into a mask length in bits\n \n  Dim arrOctets : arrOctets = Split(strMask, &quot;.&quot;)\n  Dim i\n  For i = 0 to UBound(arrOctets)\n    Dim intOctet : intOctet = CInt(arrOctets(i))\n    Dim j, intMaskLength\n    For j = 0 To 7\n      If intOctet And (2^(7 -j)) Then\n        intMaskLength = intMaskLength + 1\n      End If\n    Next\n  Next\n  MaskLength = intMaskLength\nEnd Function\n\nFunction ConvertBinIPToDecimal(strBinIP)\n  &#039; Convert binary form of an IP back to decimal\n \n  Dim arrOctets : arrOctets = Split(strBinIP, &quot;.&quot;)\n  Dim i\n  For i = 0 to UBound(arrOctets)\n    Dim intOctet : intOctet = 0\n    Dim j\n    For j = 0 to 7\n      Dim intBit : intBit = CInt(Mid(arrOctets(i), j + 1, 1))\n      If intBit = 1 Then\n        intOctet = intOctet + 2^(7 - j)\n      End If\n    Next\n    arrOctets(i) = CStr(intOctet)\n  Next\n \n  ConvertBinIPToDecimal = Join(arrOctets, &quot;.&quot;)\nEnd Function\n\nFunction ConvertIPToBinary(strIP)\n  &#039; Converts an IP Address into Binary\n \n  Dim arrOctets : arrOctets = Split(strIP, &quot;.&quot;)\n  Dim i\n  For i = 0 to UBound(arrOctets)\n    Dim intOctet : intOctet = CInt(arrOctets(i))\n    Dim strBinOctet : strBinOctet = &quot;&quot;\n    Dim j\n    For j = 0 To 7\n      If intOctet And (2^(7 - j)) Then\n        strBinOctet = strBinOctet &amp; &quot;1&quot;\n      Else\n        strBinOctet = strBinOctet &amp; &quot;0&quot;\n      End If\n    Next\n    arrOctets(i) = strBinOctet\n  Next\n  ConvertIPToBinary = Join(arrOctets, &quot;.&quot;)\nEnd Function\n\nFunction GetSubnetMaskForIP(strIP)\n&#039;This function will return the subnet for a particular IP address\n\n\tDim strIPAddress, strSubnet\n\tDim objWMIService,colItems\n\tDim objItem\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration&quot;,,48)\n\t\n\tOn Error Resume Next\n\tFor Each objItem in colItems\n\t\tIf IsArray(objItem.IPAddress) Then\n\t\t\tIf objItem.IPAddress(0)&lt;&gt;&quot;&quot; Then \n\t\t\t\tFor Each strIPAddress In objItem.IPAddress\n\t\t\t\t\tIf strIPAddress = strIP Then\n\t\t\t\t\t\tFor Each strSubnet In objItem.IPSubnet\n\t\t\t\t\t\t\tIf InStr(strSubnet,&quot;.&quot;) &gt; 0 Then &#039;IPv4 subnet\n\t\t\t\t\t\t\t\tGetSubnetMaskForIP = strSubnet\n\t\t\t\t\t\t\tEnd If\n\t\t\t\t\t\tNext\n\t\t\t\t\tEnd If\n\t\t\t\tNext\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\n\t&#039;Cleanup\n\tSet colItems = Nothing\n\tSet objWMIService = Nothing\n\nEnd Function &#039;GetSubnetMaskForIP\n\nFunction GetTaniumIPAddress\n&#039; Returns the IP address that the client uses for Tanium activity\n&#039; (talking to server and other clients)\n\n\tDim strComputer, objReg, strCommand, objShell, objScriptExec\n\tDim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords\n\tDim strIPAddress, strTaniumPath, strClientAddress\n\tDim strServerName\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\tConst HKLM = &amp;h80000002\n\t\n\t\t\n\t&#039;&#039;###########Get Tanium Key on 64/32bit computers##########\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\t\n\t&#039; if we can pull this from the registry (newer client version), just use that\n\tobjReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\\Status&quot;, &quot;ClientAddress&quot;, strClientAddress\n\tIf strClientAddress &lt;&gt; &quot;&quot; Then\n\t\tstrClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)\n\t\tstrClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))\n\t\t&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;\n\t\tGetTaniumIPAddress = strClientAddress\n\t\t&#039;Cleanup\n\t\tSet objReg = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\t&#039;Otherwise use PathPing to determine client IP used by Tanium\n\n\t&#039;&#039;# Read the ServerName value\n\n\tobjReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName\n\n\tstrCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\tstrResults = objScriptExec.StdOut.ReadAll\n\t\n\tarrPathPingLines = Split(strResults, vbCrLf)\n\tFor Each strPathPingLine In arrPathPingLines\n\t\tarrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)\n\t\tIf UBound(arrPathPingWords) &gt; 0 Then\n\t\t\tIf arrPathPingWords(0) = &quot;0&quot; Then\n\t\t\t\tstrIPAddress = arrPathPingWords(1)\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tEnd If\t\n\tNext\n\t\n\tSet objShell = Nothing\n\tSet objScriptExec = Nothing\n\tSet objReg = Nothing\n\n\tIf Not IsNull(strIPAddress) Then\n\t\tGetTaniumIPAddress = strIPAddress\n\tElse\n\t\tGetTaniumIPAddress = False\n\tEnd If\nEnd Function &#039;GetTaniumIPAddress\n\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 88, 
      "category": "Security", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Returns information on the BitLocker status of a machine.\nExample: Drive | Device ID | Encryption Method", 
      "exclude_from_parse_flag": 1, 
      "hash": 1281370578, 
      "hidden_flag": 0, 
      "id": 173, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "BitLocker Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; BitLocker Details\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nDim objWMIService\nOn Error Resume Next\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\CIMV2\\Security\\MicrosoftVolumeEncryption&quot;)\nOn Error Goto 0\n\nIf IsEmpty(objWMIService) Then\n\t&#039; Don&#039;t output any values --- just exit.  This matches other\n\t&#039; OSes where BitLocker is available, but not in use.\n\tWScript.Quit\nEnd If \n \nSet colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_EncryptableVolume&quot;,,48)\nDim arEncryptionMethod\narEncryptionMethod = Array(&quot;None&quot;, &quot;AES 128 With Diffuser&quot;, &quot;AES 256 With Diffuser&quot;, &quot;AES 128&quot;, &quot;AES 256&quot;)\nDim arProtectionStatus\narProtectionStatus = Array(&quot;Protection Off&quot;, &quot;Protection On&quot;, &quot;Protection Unknown&quot;)\nDim arConversionStatus\narConversionStatus = Array(&quot;Fully Decrypted&quot;, &quot;Fully Encrypted&quot;, &quot;Encryption In Progress&quot;, &quot;Decryption In Progress&quot;, &quot;Encryption Paused&quot;, &quot;Decryption Paused&quot;)\nDim arLockStatus\narLockStatus = Array(&quot;Unlocked&quot;, &quot;Locked&quot;)\nFor Each objItem in colItems\n Dim EncryptionMethod\n Dim ProtectionStatus\n Dim ConversionStatus\n Dim EncryptionPercentage &#039;Percentage of the volume that is encrypted\n Dim VolumeKeyProtectorID\n Dim LockStatus\n \n objItem.GetEncryptionMethod EncryptionMethod\n objItem.GetProtectionStatus ProtectionStatus\n objItem.GetConversionStatus ConversionStatus, EncryptionPercentage\n objItem.GetKeyProtectors 0,VolumeKeyProtectorID\n objItem.GetLockStatus LockStatus\n \n strSep = &quot;|&quot;\n \n &#039;Drive Letter, Device ID, Encryption Method, Protection Status, Conversion Status, Encryption Percentage, Lock Status\n \n Wscript.Echo _\n \tobjItem.DriveLetter &amp; strSep &amp; _\n \tarEncryptionMethod(EncryptionMethod) &amp; strSep &amp; _\n \tarProtectionStatus(ProtectionStatus) &amp; strSep &amp; _\n \tarConversionStatus(ConversionStatus) &amp; strSep &amp; _\n \tEncryptionPercentage &amp; &quot;%&quot; &amp; strSep &amp; _\n \tarLockStatus(LockStatus)\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Drive", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Device ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Encryption Method", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Protection Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Conversion Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Encryption Percentage", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Lock Status", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 89, 
      "category": "Software", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns the number of application crashes that have occurred in the last number of days supplied to the sensor.\nExample: 3", 
      "exclude_from_parse_flag": 1, 
      "hash": 3027378756, 
      "hidden_flag": 0, 
      "id": 175, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Number of Application Crashes in Last X Days", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Number of Application Crashes in Last X Days\n&#039;========================================\n\nOption Explicit\nDim strSep\nDim objWMIService, colEvents, objEvent\nDim dtmStart\n\nstrSep = &quot;|&quot;\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\n\ndtmStart = GetTimeWrittenByDaysOld(||days||)\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\\\.\\root\\cimv2&quot;) \n\nSet colEvents = objWMIService.ExecQuery _\n    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _\n        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _\n        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)\n\nDim numCrashes\nnumCrashes = 0\n\nFor Each objEvent In colEvents\n    Dim strMessage, arrLines, strLine, strApp, strModule, strTime\n    \n    strMessage = objEvent.Message\n    arrLines = Split(strMessage, vbCrLf)\n    \n    Dim strIndex, strIndexXp\n\n\t&#039;just go through first line of log to grab app name\n\tstrLine = arrLines(0)\n\t\n\t&#039;strIndex is for new OSes, strIndexXP for older...\n\tstrIndex = &quot;Faulting application name: &quot;\n\tstrIndexXp = &quot;Faulting application &quot;\n\tIf Left(strLine, Len(strIndex)) = strIndex Then\n\t\tstrApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)\n\tElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then\n\t\tstrApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)\n\tEnd If\n\t\n    strTime = DatetimeToDate(objEvent.TimeWritten)\n    \t \n\tIf Not IsNull(strApp) And Not IsEmpty(strApp) Then\n\t\tnumCrashes = numCrashes + 1\n\tEnd If\nNext\n\nWScript.Echo numCrashes\n\nFunction DatetimeToDate(strDate)\n   DatetimeToDate = _\n       CDate(Mid(strDate, 5, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Mid(strDate, 7, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Left(strDate, 4) &amp; _\n       &quot; &quot; &amp; _\n       Mid (strDate, 9, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 11, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 13, 2))\nEnd Function\n\nFunction GetTimeWrittenByDaysOld(days)\n   &#039;subtract &quot;days&quot; days worth of seconds\n\n\tDim epoc, monthAgo   \n   \tepoc = date2epoch(Now()) - days*24*60*60\n   \tmonthAgo = epoch2date(epoc)\n   \n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate monthAgo, True\n\t \n  \tGetTimeWrittenByDaysOld = dateTime\nEnd Function\n\nfunction date2epoch(myDate)\n   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)\nend Function\n\nfunction epoch2date(myEpoch)\n   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)\nend Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||days||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||days||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 90, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The machine or chassis type for the machine.\nExample: Server or Virtual", 
      "exclude_from_parse_flag": 1, 
      "hash": 2728641061, 
      "hidden_flag": 0, 
      "id": 177, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Chassis Type", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Chassis Type\n&#039;========================================\n\nOn Error Resume Next\n\nstrResult = &quot;Unknown&quot;\n\nIf IsVM Then\n\tstrResult = &quot;Virtual&quot;\nElse\n\tSet objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colChassis = objWMIService.ExecQuery(&quot;Select * from Win32_SystemEnclosure&quot;)\n\t\n\tFor Each objChassis in colChassis\n\t    For  Each strChassisType in objChassis.ChassisTypes\n\t        Select Case strChassisType\n\t            Case 1\n\t                strResult = &quot;Other&quot;\n\t            Case 2\n\t                strResult = &quot;Unknown&quot;\n\t            Case 3\n\t                strResult = &quot;Desktop&quot;\n\t            Case 4\n\t                strResult = &quot;Low Profile Desktop&quot;\n\t            Case 5\n\t                strResult = &quot;Pizza Box&quot;\n\t            Case 6\n\t                strResult = &quot;Mini Tower&quot;\n\t            Case 7\n\t                strResult = &quot;Tower&quot;\n\t            Case 8\n\t                strResult = &quot;Portable&quot;\n\t            Case 9\n\t                strResult = &quot;Laptop&quot;\n\t            Case 10\n\t                strResult = &quot;Notebook&quot;\n\t            Case 11\n\t                strResult = &quot;Handheld&quot;\n\t            Case 12\n\t                strResult = &quot;Docking Station&quot;\n\t            Case 13\n\t                strResult = &quot;All-in-One&quot;\n\t            Case 14\n\t                strResult = &quot;Sub-Notebook&quot;\n\t            Case 15\n\t                strResult = &quot;Space Saving&quot;\n\t            Case 16\n\t                strResult = &quot;Lunch Box&quot;\n\t            Case 17\n\t                strResult = &quot;Main System Chassis&quot;\n\t            Case 18\n\t                strResult = &quot;Expansion Chassis&quot;\n\t            Case 19\n\t                strResult = &quot;Sub-Chassis&quot;\n\t            Case 20\n\t                strResult = &quot;Bus Expansion Chassis&quot;\n\t            Case 21\n\t                strResult = &quot;Peripheral Chassis&quot;\n\t            Case 22\n\t                strResult = &quot;Storage Chassis&quot;\n\t            Case 23\n\t                strResult = &quot;Rack Mount Chassis&quot;\n\t            Case 24\n\t                strResult = &quot;Sealed-Case PC&quot;\n\t            Case Else\n\t                strResult = &quot;Unknown&quot;\n\t            End Select\n\t    Next\n\tNext\nEnd If \n\nWScript.Echo strResult\n\nFunction IsVM\n\tDim sVMPlatform, sMake, sModel, sBIOSVersion,bIsVM\n\n    &#039; Check the WMI information against known values\n\n    bIsVM = false\n    sVMPlatform = &quot;&quot;\n\n    sMake = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Manufacturer&quot;)\n    sModel = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Model&quot;)\n    sBIOSVersion = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_BIOS&quot;, &quot;Version&quot;)\n\n    &#039;WScript.Echo &quot;Manufacturer=&quot; &amp; sMake\n    &#039;WScript.Echo &quot;Model=&quot; &amp; sModel\n    &#039;WScript.Echo &quot;BIOSVersion=&quot; &amp; sBIOSVersion\n\n    If sModel = &quot;Virtual Machine&quot; then\n\n        &#039; Microsoft virtualization technology detected, assign defaults\n\n        sVMPlatform = &quot;Hyper-V&quot;\n        bIsVM = true\n\n        &#039; Try to determine more specific values\n\n        Select Case sBIOSVersion\n        Case &quot;VRTUAL - 1000831&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 Beta or RC0&quot;\n        Case &quot;VRTUAL - 5000805&quot;, &quot;BIOS Date: 05/05/08 20:35:56  Ver: 08.00.02&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 RTM&quot;\n        Case &quot;VRTUAL - 3000919&quot; \n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 R2&quot;\n        Case &quot;A M I  - 2000622&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005R2SP1 or VPC2007&quot;\n        Case &quot;A M I  - 9000520&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005R2&quot;\n        Case &quot;A M I  - 9000816&quot;, &quot;A M I  - 6000901&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Windows Virtual PC&quot;\n        Case &quot;A M I  - 8000314&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005 or VPC2004&quot;\n        Case &quot;Xen - 0s&quot;\n        \tbIsVM = True\n        \tsVMPlatform = &quot;Xen&quot;\n        Case &quot;Xen - 0&quot;\n            bIsVM = True\n            sVMPlatform = &quot;Xen&quot;\n        End Select\n\n    ElseIf sModel = &quot;VMware Virtual Platform&quot; then\n\n        &#039; VMware detected\n\n        sVMPlatform = &quot;VMware&quot;\n        bIsVM = true\n\n    ElseIf sModel  = &quot;VirtualBox&quot; then\n\n        &#039; VirtualBox detected\n\n        bIsVM = true\n        sVMPlatform = &quot;VirtualBox&quot;\n\n    Else \n        &#039; This computer does not appear to be a virtual machine.\n    End if\n\n    &#039; Set the return value\n\n    If bIsVM Then\n    \t&#039; Let&#039;s not actually do anything here \n        &#039;WScript.Echo &quot;IsVirtualMachine=True&quot;\n        &#039;WScript.Echo &quot;VirtualMachinePlatform=&quot; &amp; sVMPlatform\n    Else\n        &#039;WScript.Echo &quot;IsVirtualMachine=False&quot;\n    End If\n\n    IsVM = bIsVM\n\nEnd Function\n\nFunction GetWmiPropertyValue(strNameSpace, strClassName, strPropertyName)\n\tDim strPropertyValue, oWMIClass, oWMIProperties, objWMIService, colItems\n\tDim objItem, objProperty\n\tDim sLine\n\t\n    On Error Resume Next\n\n    strPropertyValue = &quot;&quot;\n    set oWmiClass = getobject(&quot;winmgmts:&quot; &amp; strNameSpace).get(strClassName,&amp;h20000) &#039;amended\n    set oWmiProperties = oWmiClass.Properties_\n\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; &quot;.&quot; &amp; &quot;\\&quot; &amp; strNameSpace)\n    Set colItems = objWMIService.ExecQuery(&quot;Select * from &quot; &amp; strClassName,,48)\n\n    For Each objItem in colItems\n        For Each objProperty in oWmiProperties\n            sLine = &quot;&quot;\n            &#039;WScript.Echo &quot;- &quot; &amp; objProperty.name &amp; &quot;: &quot; &amp; strPropertyName\n\n            If objProperty.Name = strPropertyName Then\n                If objProperty.IsArray = True Then\n                    sLine = &quot;str&quot; &amp; objProperty.Name &amp; &quot; = Join(objItem.&quot; &amp; objProperty.Name &amp; &quot;, &quot; &amp; Chr(34) &amp; &quot;,&quot; &amp; Chr(34) &amp; &quot;)&quot; &amp; vbCrLf\n                    sLine = sLine &amp; &quot;strPropertyValue =  str&quot; &amp; objProperty.Name\n                &#039;ElseIf objProperty.CIMTYPE = 101 Then\n                &#039;    bHasDates = True\n                &#039;    sLine =  &quot;strPropertyValue =  WMIDateStringToDate(objItem.&quot; &amp; objProperty.Name &amp; &quot;)&quot;\n                Else\n                    sLine =  &quot;strPropertyValue =  objItem.&quot; &amp; objProperty.Name\n                End If\n\n                &#039;WScript.Echo sLine\n                Execute sLine\n            End If\n\n        Next\n    Next\n\n    GetWmiPropertyValue = strPropertyValue\n    \n    &#039;Cleanup!\n    set oWmiClass = Nothing\n    set oWmiProperties = Nothing\n\n    Set objWMIService = Nothing\n    Set colItems = Nothing\n\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s chassis-type\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 91, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Returns details of attached physical monitors.\nExample: Model Name, Serial Number, VESA Manufacturer ID, Manufacture Date", 
      "exclude_from_parse_flag": 1, 
      "hash": 1502679547, 
      "hidden_flag": 0, 
      "id": 179, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Monitor Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Monitor Details\n&#039;========================================\n\nOption Explicit\nDim strSep\nstrSep = &quot;|&quot;\nDim WshShell\nSet WshShell = WScript.CreateObject(&quot;WScript.Shell&quot;)\nDim strComputer, message\n\nDim intMonitorCount\nDim oRegistry, sBaseKey, sBaseKey2, sBaseKey3, skey, skey2, skey3\nDim sValue\ndim i, iRC, iRC2, iRC3\nDim arSubKeys, arSubKeys2, arSubKeys3, arrintEDID\nDim strRawEDID\nDim ByteValue, strSerFind, strMdlFind\nDim intSerFoundAt, intMdlFoundAt, findit\nDim tmp, tmpser, tmpmdl, tmpctr\nDim batch, bHeader\nbatch = False\n\nstrComputer = &quot;.&quot;\n\nIf strcomputer = &quot;&quot; Then WScript.Quit\nstrComputer = UCase(strComputer)\n\nIf batch Then\nDim fso,logfile, appendout\nlogfile = wshShell.ExpandEnvironmentStrings(&quot;%userprofile%&quot;) &amp; &quot;\\desktop\\MonitorInfo.csv&quot;\n\n&#039;setup Log\nConst ForAppend = 8\nSet fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nIf Not fso.FileExists(logfile) Then bHeader = True\nset appendout = fso.OpenTextFile(logfile, ForAppend, True)\n\nIf bHeader Then\nappendout.writeline &quot;Computer,Model,Serial #,Vendor ID,Manufacture Date,Messages&quot;\nEnd If\nEnd If\n\nDim strarrRawEDID()\nintMonitorCount=0\nConst HKLM = &amp;H80000002 &#039;HKEY_LOCAL_MACHINE\n&#039;get a handle to the WMI registry object\nOn Error Resume Next\nSet oRegistry = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;/root/default:StdRegProv&quot;)\n\nIf Err &lt;&gt; 0 Then\nIf batch Then\nEchoAndLog strComputer &amp; &quot;,,,,,&quot; &amp; Err.Description\nElse\nWScript.echo &quot;Failed. &quot; &amp; Err.Description,vbCritical + vbOKOnly,strComputer\nWScript.Quit\nEnd If\nEnd If\n\n\nsBaseKey = &quot;SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\\&quot;\n&#039;enumerate all the keys HKLM\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\\ \niRC = oRegistry.EnumKey(HKLM, sBaseKey, arSubKeys)\nFor Each sKey In arSubKeys\n&#039;we are now in the registry at the level of:\n&#039;HKLM\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\\&lt;VESA_Monitor_ID\\ \n&#039;we need to dive in one more level and check the data of the &quot;HardwareID&quot; value\nsBaseKey2 = sBaseKey &amp; sKey &amp; &quot;\\&quot;\niRC2 = oRegistry.EnumKey(HKLM, sBaseKey2, arSubKeys2)\nFor Each sKey2 In arSubKeys2\n&#039;now we are at the level of:\n&#039;HKLM\\SYSTEM\\CurrentControlSet\\Enum\\DISPLAY\\&lt;VESA_Monitor_ID\\&lt;PNP_ID&gt;\\ \n&#039;so we can check the &quot;HardwareID&quot; value\noRegistry.GetMultiStringValue HKLM, sBaseKey2 &amp; sKey2 &amp; &quot;\\&quot;, &quot;HardwareID&quot;, sValue\nfor tmpctr=0 to ubound(svalue)\nIf lcase(left(svalue(tmpctr),8))=&quot;monitor\\&quot; then\n&#039;If it is a monitor we will check for the existance of a control subkey\n&#039;that way we know it is an active monitor\nsBaseKey3 = sBaseKey2 &amp; sKey2 &amp; &quot;\\&quot;\niRC3 = oRegistry.EnumKey(HKLM, sBaseKey3, arSubKeys3)\nFor Each sKey3 In arSubKeys3\n&#039;Kaplan edit\nstrRawEDID = &quot;&quot;\nIf skey3=&quot;Control&quot; Then\n&#039;If the Control sub-key exists then we should read the edid info\noRegistry.GetBinaryValue HKLM, sbasekey3 &amp; &quot;Device Parameters\\&quot;, &quot;EDID&quot;, arrintEDID\nIf vartype(arrintedid) &lt;&gt; 8204 then &#039;and If we don&#039;t find it...\nstrRawEDID=&quot;EDID Not Available&quot; &#039;store an &quot;unavailable message\nelse\nfor each bytevalue in arrintedid &#039;otherwise conver the byte array from the registry into a string (for easier processing later)\nstrRawEDID=strRawEDID &amp; chr(bytevalue)\nNext\nEnd If\n&#039;now take the string and store it in an array, that way we can support multiple monitors\nredim preserve strarrRawEDID(intMonitorCount)\nstrarrRawEDID(intMonitorCount)=strRawEDID\nintMonitorCount=intMonitorCount+1\nEnd If\nNext\nEnd If\nNext\nNext\nNext\n&#039;*****************************************************************************************\n&#039;now the EDID info for each active monitor is stored in an array of strings called strarrRawEDID\n&#039;so we can process it to get the good stuff out of it which we will store in a 5 dimensional array\n&#039;called arrMonitorInfo, the dimensions are as follows:\n&#039;0=VESA Mfg ID, 1=VESA Device ID, 2=MFG Date (M/YYYY),3=Serial Num (If available),4=Model Descriptor\n&#039;5=EDID Version\n&#039;*****************************************************************************************\nOn Error Resume Next\ndim arrMonitorInfo()\nredim arrMonitorInfo(intMonitorCount-1,5)\ndim location(3)\nfor tmpctr=0 to intMonitorCount-1\nIf strarrRawEDID(tmpctr) &lt;&gt; &quot;EDID Not Available&quot; then\n&#039;*********************************************************************\n&#039;first get the model and serial numbers from the vesa descriptor\n&#039;blocks in the edid. the model number is required to be present\n&#039;according to the spec. (v1.2 and beyond)but serial number is not\n&#039;required. There are 4 descriptor blocks in edid at offset locations\n&#039;&amp;H36 &amp;H48 &amp;H5a and &amp;H6c each block is 18 bytes long\n&#039;*********************************************************************\nlocation(0)=mid(strarrRawEDID(tmpctr),&amp;H36+1,18)\nlocation(1)=mid(strarrRawEDID(tmpctr),&amp;H48+1,18)\nlocation(2)=mid(strarrRawEDID(tmpctr),&amp;H5a+1,18)\nlocation(3)=mid(strarrRawEDID(tmpctr),&amp;H6c+1,18)\n\n&#039;you can tell If the location contains a serial number If it starts with &amp;H00 00 00 ff\nstrSerFind=chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;Hff)\n&#039;or a model description If it starts with &amp;H00 00 00 fc\nstrMdlFind=chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;H00) &amp; chr(&amp;Hfc)\n\nintSerFoundAt=-1\nintMdlFoundAt=-1\nfor findit = 0 to 3\nIf instr(location(findit),strSerFind)&gt;0 then\nintSerFoundAt=findit\nEnd If\nIf instr(location(findit),strMdlFind)&gt;0 then\nintMdlFoundAt=findit\nEnd If\nNext\n\n&#039;If a location containing a serial number block was found then store it\nIf intSerFoundAt&lt;&gt;-1 then\ntmp=right(location(intSerFoundAt),14)\nIf instr(tmp,chr(&amp;H0a))&gt;0 then\ntmpser=trim(left(tmp,instr(tmp,chr(&amp;H0a))-1))\nElse\ntmpser=trim(tmp)\nEnd If\n&#039;although it is not part of the edid spec it seems as though the\n&#039;serial number will frequently be preceeded by &amp;H00, this\n&#039;compensates for that\nIf left(tmpser,1)=chr(0) then tmpser=right(tmpser,len(tmpser)-1)\nelse\ntmpser=&quot;Not Found&quot;\nEnd If\n\n&#039;If a location containing a model number block was found then store it\nIf intMdlFoundAt&lt;&gt;-1 then\ntmp=right(location(intMdlFoundAt),14)\nIf instr(tmp,chr(&amp;H0a))&gt;0 then\ntmpmdl=trim(left(tmp,instr(tmp,chr(&amp;H0a))-1))\nelse\ntmpmdl=trim(tmp)\nEnd If\n&#039;although it is not part of the edid spec it seems as though the\n&#039;serial number will frequently be preceeded by &amp;H00, this\n&#039;compensates for that\nIf left(tmpmdl,1)=chr(0) then tmpmdl=right(tmpmdl,len(tmpmdl)-1)\nelse\ntmpmdl=&quot;Not Found&quot;\nEnd If\n\n&#039;**************************************************************\n&#039;Next get the mfg date\n&#039;**************************************************************\nDim tmpmfgweek,tmpmfgyear,tmpmdt\n&#039;the week of manufacture is stored at EDID offset &amp;H10\ntmpmfgweek=asc(mid(strarrRawEDID(tmpctr),&amp;H10+1,1))\n\n&#039;the year of manufacture is stored at EDID offset &amp;H11\n&#039;and is the current year -1990\ntmpmfgyear=(asc(mid(strarrRawEDID(tmpctr),&amp;H11+1,1)))+1990\n\n&#039;store it in month/year format\ntmpmdt=month(dateadd(&quot;ww&quot;,tmpmfgweek,datevalue(&quot;1/1/&quot; &amp; tmpmfgyear))) &amp; &quot;/&quot; &amp; tmpmfgyear\n\n&#039;**************************************************************\n&#039;Next get the edid version\n&#039;**************************************************************\n&#039;the version is at EDID offset &amp;H12\nDim tmpEDIDMajorVer, tmpEDIDRev, tmpVer\ntmpEDIDMajorVer=asc(mid(strarrRawEDID(tmpctr),&amp;H12+1,1))\n\n&#039;the revision level is at EDID offset &amp;H13\ntmpEDIDRev=asc(mid(strarrRawEDID(tmpctr),&amp;H13+1,1))\n\n&#039;store it in month/year format\ntmpver=chr(48+tmpEDIDMajorVer) &amp; &quot;.&quot; &amp; chr(48+tmpEDIDRev)\n\n&#039;**************************************************************\n&#039;Next get the mfg id\n&#039;**************************************************************\n&#039;the mfg id is 2 bytes starting at EDID offset &amp;H08\n&#039;the id is three characters long. using 5 bits to represent\n&#039;each character. the bits are used so that 1=A 2=B etc..\n&#039;\n&#039;get the data\nDim tmpEDIDMfg, tmpMfg\ndim Char1, Char2, Char3\nDim Byte1, Byte2\ntmpEDIDMfg=mid(strarrRawEDID(tmpctr),&amp;H08+1,2)\nChar1=0 : Char2=0 : Char3=0\nByte1=asc(left(tmpEDIDMfg,1)) &#039;get the first half of the string\nByte2=asc(right(tmpEDIDMfg,1)) &#039;get the first half of the string\n&#039;now shift the bits\n&#039;shift the 64 bit to the 16 bit\nIf (Byte1 and 64) &gt; 0 then Char1=Char1+16\n&#039;shift the 32 bit to the 8 bit\nIf (Byte1 and 32) &gt; 0 then Char1=Char1+8\n&#039;etc....\nIf (Byte1 and 16) &gt; 0 then Char1=Char1+4\nIf (Byte1 and 8) &gt; 0 then Char1=Char1+2\nIf (Byte1 and 4) &gt; 0 then Char1=Char1+1\n\n&#039;the 2nd character uses the 2 bit and the 1 bit of the 1st byte\nIf (Byte1 and 2) &gt; 0 then Char2=Char2+16\nIf (Byte1 and 1) &gt; 0 then Char2=Char2+8\n&#039;and the 128,64 and 32 bits of the 2nd byte\nIf (Byte2 and 128) &gt; 0 then Char2=Char2+4\nIf (Byte2 and 64) &gt; 0 then Char2=Char2+2\nIf (Byte2 and 32) &gt; 0 then Char2=Char2+1\n\n&#039;the bits for the 3rd character don&#039;t need shifting\n&#039;we can use them as they are\nChar3=Char3+(Byte2 and 16)\nChar3=Char3+(Byte2 and 8)\nChar3=Char3+(Byte2 and 4)\nChar3=Char3+(Byte2 and 2)\nChar3=Char3+(Byte2 and 1)\ntmpmfg=chr(Char1+64) &amp; chr(Char2+64) &amp; chr(Char3+64)\n\n&#039;**************************************************************\n&#039;Next get the device id\n&#039;**************************************************************\n&#039;the device id is 2bytes starting at EDID offset &amp;H0a\n&#039;the bytes are in reverse order.\n&#039;this code is not text. it is just a 2 byte code assigned\n&#039;by the manufacturer. they should be unique to a model\nDim tmpEDIDDev1, tmpEDIDDev2, tmpDev\n\ntmpEDIDDev1=hex(asc(mid(strarrRawEDID(tmpctr),&amp;H0a+1,1)))\ntmpEDIDDev2=hex(asc(mid(strarrRawEDID(tmpctr),&amp;H0b+1,1)))\nIf len(tmpEDIDDev1)=1 then tmpEDIDDev1=&quot;0&quot; &amp; tmpEDIDDev1\nIf len(tmpEDIDDev2)=1 then tmpEDIDDev2=&quot;0&quot; &amp; tmpEDIDDev2\ntmpdev=tmpEDIDDev2 &amp; tmpEDIDDev1\n\n&#039;**************************************************************\n&#039;finally store all the values into the array\n&#039;**************************************************************\n&#039;Kaplan adds code to avoid duplication...\n\nIf Not InArray(tmpser,arrMonitorInfo,3) Then\narrMonitorInfo(tmpctr,0)=tmpmfg\narrMonitorInfo(tmpctr,1)=tmpdev\narrMonitorInfo(tmpctr,2)=tmpmdt\narrMonitorInfo(tmpctr,3)=tmpser\narrMonitorInfo(tmpctr,4)=tmpmdl\narrMonitorInfo(tmpctr,5)=tmpVer\nEnd If\nEnd If\nNext\n\n&#039;For now just a simple screen print will suffice for output.\n&#039;But you could take this output and write it to a database or a file\n&#039;and in that way use it for asset management.\ni = 0\nfor tmpctr = 0 to intMonitorCount-1\nIf arrMonitorInfo(tmpctr,1) &lt;&gt; &quot;&quot; And arrMonitorInfo(tmpctr,0) &lt;&gt; &quot;PNP&quot; Then\nIf batch Then\nEchoAndLog strComputer &amp; &quot;,&quot; &amp; arrMonitorInfo(tmpctr,4) &amp; &quot;,&quot; &amp; _\narrMonitorInfo(tmpctr,3)&amp; &quot;,&quot; &amp; arrMonitorInfo(tmpctr,0) &amp; &quot;,&quot; &amp; _\narrMonitorInfo(tmpctr,2)\nElse\nDim strModel, strSerial, strVesa, strManDate\nstrModel = arrMonitorInfo(tmpctr,4)\nstrSerial = arrMonitorInfo(tmpctr,3)\nstrVesa = arrMonitorInfo(tmpctr,0)\nstrManDate = arrMonitorInfo(tmpctr,2)\n\nmessage = message &amp; &quot;Monitor &quot; &amp; chr(i+65) &amp; &quot;)&quot; &amp; VbCrLf &amp; _\n&quot;Model Name: &quot; &amp; arrMonitorInfo(tmpctr,4) &amp; VbCrLf &amp; _\n&quot;Serial Number: &quot; &amp; arrMonitorInfo(tmpctr,3)&amp; VbCrLf &amp; _\n&quot;VESA Manufacturer ID: &quot; &amp; arrMonitorInfo(tmpctr,0) &amp; VbCrLf &amp; _\n&quot;Manufacture Date: &quot; &amp; arrMonitorInfo(tmpctr,2) &amp; VbCrLf &amp; vbCrLf\n\nIf InStr(strManDate, &quot;/&quot;) &gt; 0 Then\n\tDim words\n\twords = Split(strManDate, &quot;/&quot;)\n\tIf UBound(words) &gt; 0 Then\n\t\tstrManDate = words(1) &amp; &quot;-&quot; &amp; words(0)\n\tEnd If\nEnd If\n\nWScript.Echo _\n\tstrModel &amp; strSep &amp;_\n\tstrSerial &amp; strSep &amp;_\n\tstrVesa &amp; strSep &amp;_\n\tstrManDate\n\n&#039;wscript.echo &quot;..........&quot; &amp; &quot;Device ID: &quot; &amp; arrMonitorInfo(tmpctr,1)\n&#039;wscript.echo &quot;..........&quot; &amp; &quot;EDID Version: &quot; &amp; arrMonitorInfo(tmpctr,5)\ni = i + 1\nEnd If\nEnd If\nNext\n\nIf not batch Then\n&#039; WScript.echo message , vbInformation + vbOKOnly,strComputer &amp; &quot; Monitor Info&quot;\nEnd If\n\nFunction InArray(strValue,List,Col)\nDim i\nFor i = 0 to UBound(List)\nIf List(i,col) = cstr(strValue) Then\nInArray = True\nExit Function\nEnd If\nNext\nInArray = False\nEnd Function\n\nSub EchoAndLog (message)\n&#039;Echo output and write to log\nWscript.Echo message\nAppendOut.WriteLine message\nEnd Sub", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Model Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Serial Number", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "VESA Manufacturer ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Manufacture Date", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 92, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "A multi-column sensor that provides CPU details: system type, CPU description, speed, # of processors, # of cores, and # of logical processors.\nExample: x64-based PC | Intel(R) Xeon(R) CPU X3430 | 2390 Mhz | 1 | 4 | 4", 
      "exclude_from_parse_flag": 1, 
      "hash": 4055028299, 
      "hidden_flag": 0, 
      "id": 181, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "CPU Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CPU Details\n&#039;========================================\n\nOn Error Resume Next\n\nstrComputer = &quot;.&quot; \nSet objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)\nSet colCSes = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_ComputerSystem&quot;)\n\nFor Each objCS In colCSes\n\tsystemType = objCS.SystemType\n\tIf(Left(systemType, 1) = &quot;X&quot;) Then \n\t\tsystemType = &quot;x&quot; &amp; Right(systemType, Len(systemType) -1)\n\tEnd If \n\tnumProcessors = objCS.NumberOfProcessors\nNext\n\nnumCores = 0\nnumLogicalProcessors = 0\nDim strProcName, intSpeed, strSpeed\n\nSet colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) \nFor Each objItem in colItems \n\tnumCores = numCores + CInt(objItem.NumberOfCores)\n\tnumLogicalProcessors = numLogicalProcessors + CInt(objItem.NumberOfLogicalProcessors)\n\tstrProcName = objItem.Name\n\tintSpeed = objItem.MaxClockSpeed\nNext\n\n\nif instr(strProcName, &quot;@&quot;) &gt; 0 Then\n\tstrProcName = Trim(Left(strProcName, InStr(strProcName, &quot;@&quot;) - 1))\nEnd If\n\n&#039;Check all properties to make sure they exist\nstrProcName = CleanWhitespace(trim(strProcName))\nIf strProcName = &quot;&quot; Then\n\tstrProcName = &quot;N/A&quot;\nEnd If\n\nIf intSpeed = &quot;&quot; Then\n\tstrSpeed = &quot;N/A&quot;\nElse\n\tintSpeed = CInt(intSpeed/10)*10\n\tstrSpeed = CStr(intSpeed) &amp; &quot; Mhz&quot;\nEnd If\n\nIf numProcessors = 0 Then\n\tnumProcessors = &quot;N/A&quot;\nEnd If\n\nstrOs = GetOS\nIf numLogicalProcessors = 0 Then\n\t&#039;if this is not available, then numProcessors\n\t&#039;is actually the Logical Processors count\n\n\tnumLogicalProcessors = numProcessors\n\n\t&#039;Windows 2000 isn&#039;t supported for logical processors\n\tIf InStr(strOs, &quot;2000&quot;) &gt; 0 Then\n\t\tnumProcessors = &quot;Unsupported&quot;\n\tElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then\n\t\tnumProcessors = &quot;XP SP3 Required&quot;\n\tElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then\n\t\t&#039;For Win Server 2003 SEE KB 932370\n\t\t&#039;http://support.microsoft.com/kb/932370/\n\t\tnumProcessors = &quot;KB932370 Required&quot;\n\tElse\n\t\tnumProcessors = &quot;N/A&quot;\n\tEnd If\nEnd If\n\nIf numCores = 0 Then\n\t&#039;Windows 2000 isn&#039;t supported for cores\n\tIf InStr(strOs, &quot;2000&quot;) &gt; 0 Then\n\t\tnumCores = &quot;Unsupported&quot;\n\tElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then\n\t\tnumCores = &quot;SP3 Required&quot;\n\tElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then\n\t\t&#039;For Win Server 2003 SEE KB 932370\n\t\t&#039;http://support.microsoft.com/kb/932370/\n\t\tnumCores = &quot;KB932370 Required&quot;\n\tElse\n\t\tnumCores = &quot;N/A&quot;\n\tEnd If\nEnd If\n\n\n\nWScript.Echo _\n\tsystemType &amp; &quot;|&quot; &amp; _\n\tstrProcName &amp; &quot;|&quot; &amp; _\n\tstrSpeed &amp; &quot;|&quot; &amp; _\n\tnumProcessors &amp; &quot;|&quot; &amp; _\n\tnumCores &amp; &quot;|&quot; &amp; _\n\tnumLogicalProcessors\n\t\nFunction CleanWhitespace(strStarter)\n\tintStarter = Len(strStarter)\n\tFor i = intStarter to 2 Step -1\n\t\tstrChars = Space(i)\n\t\tstrStarter = Replace(strStarter, strChars, &quot; &quot;)\n\tNext\n\tcleanWhitespace = strStarter\nEnd Function\n\nFunction GetOS\n\tSet oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    \n\tSet oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    \n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)    \n\tSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    \n\tFor Each objItem In colItems       \n\tstrStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   \n\t&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   \n\tif Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   \n\tstrOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   \n\tElse   \n\tstrOS = strStrip1\n\tEnd IF   \n\tGetOS = Trim(strOS)\n\tNext\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "System Type", 
            "value_type": "Numeric"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "CPU", 
            "value_type": "Numeric"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "CPU Speed", 
            "value_type": "Numeric"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Total Physical Processors", 
            "value_type": "Numeric"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Total Cores", 
            "value_type": "Numeric"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Total Logical Processors", 
            "value_type": "Numeric"
          }
        ]
      }, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 93, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Current total CPU consumption in %.\nExample: 50%", 
      "exclude_from_parse_flag": 1, 
      "hash": 1260646358, 
      "hidden_flag": 0, 
      "id": 183, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "CPU Consumption", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CPU Consumption\n&#039;========================================\n\nConst HKLM = &amp;H80000002 \nstrComputer = &quot;.&quot;\n\nSet objWMIService = _\n  \tGetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)\n\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)\nFor Each objItem in colProcItems\n\tN1 = objItem.PercentProcessorTime\n\tD1 = objItem.TimeStamp_Sys100NS\nNext\n\nWScript.sleep(3000)\n\t\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)\nFor Each objItem in colProcItems\n\tN2 = objItem.PercentProcessorTime\n\tD2 = objItem.TimeStamp_Sys100NS\nNext\n\nnumLogicalProcessors = 0\n\nSet colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) \nFor Each objItem in colItems \n\tDim intLogicalProcessors \n\tintLogicalProcessors = 1\n\t\n\tOn Error Resume Next\n\tintLogicalProcessors = CInt(objItem.NumberOfLogicalProcessors)\n\tOn Error Goto 0\n\n\tnumLogicalProcessors = numLogicalProcessors + intLogicalProcessors\nNext\n\n&#039; CounterType - PERF_100NSEC_TIMER\n&#039; Formula = ((N2 - N1) / (D2 - D1)) x 100\nIf ( 0 = (D2-D1) ) Or D1 &gt; D2 then\n\tWScript.echo &quot;System Timestamp Error&quot;\nElseIf N1 &gt; N2 Then\n\tWScript.Echo &quot;Performance Counter Error&quot;\nElse\n\tpercentage = Round(100 - ((N2 - N1) / (D2 - D1)) * 100 / numLogicalProcessors, 0)\n\tWScript.echo percentage &amp; &quot; %&quot;\nEnd if\n\nSet wmi_service = nothing", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ncpu=`top -bn 1 | awk &#039;{print $9}&#039; | tail -n +8 | awk &#039;{s+=$1} END {print s}&#039;`\necho &quot;${cpu} %&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ncpu=$(top -o cpu -l1 | awk &#039;{print substr($0,24,5)}&#039; | tail -n +13 | awk &#039;{s+=$1} END {print s}&#039;) ; echo ${cpu} %\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 94, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Descriptions of any installed disk drives, including external or USB drives.\nExample: ST3808110AS ATA Device", 
      "exclude_from_parse_flag": 1, 
      "hash": 945314213, 
      "hidden_flag": 0, 
      "id": 185, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Disk Drives", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from Win32_DiskDrive", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 95, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The amount of total disk space per drive.\nExample: C: 100 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 4244410676, 
      "hidden_flag": 0, 
      "id": 187, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Disk Total Space", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Disk Total Space\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; _\n    &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colDisks = objWMIService.ExecQuery _\n    (&quot;Select * from Win32_LogicalDisk&quot;)\nFor Each objDisk in colDisks\n &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID\n    \n    If Not IsNull(objDisk.Size) Then\n\t    dblSize = CDbl(objDisk.Size)\n\t    dblSize = dblSize / 1024 / 1024 / 1024\n\t    intSize = CInt(dblSize)\n\t\tWScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intSize &amp; &quot; GB&quot;\n    End If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndf -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line\ndo\n\tset -- $line\n\techo $7: $3\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ndf -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\\// { print $9&quot;: &quot; $2 }&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 8, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 96, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The amount of free disk space per drive.\nExample: C: 40 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 1302957088, 
      "hidden_flag": 0, 
      "id": 189, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Disk Free Space", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Disk Free Space\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; _\n    &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colDisks = objWMIService.ExecQuery _\n    (&quot;Select * from Win32_LogicalDisk&quot;)\n\nFor Each objDisk in colDisks\n  If Not IsNull(objDisk.FreeSpace) Then\n    dblFree = CDbl(objDisk.FreeSpace)\n    dblFree = dblFree / 1024 / 1024 / 1024\n    intFree = CInt(dblFree)\n    Wscript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intFree &amp; &quot; GB&quot;\n  END IF\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndf -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line\ndo\n\tset -- $line\n\techo $7: $5\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ndf -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\\// { print $9&quot;: &quot; $4 }&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 10, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 97, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The percentage of used disk space per partition.\nExample: C: 24%", 
      "exclude_from_parse_flag": 1, 
      "hash": 533135859, 
      "hidden_flag": 0, 
      "id": 191, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Disk Used Percentage", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Disk Used Percentage\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; _\n    &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colDisks = objWMIService.ExecQuery _\n    (&quot;Select * from Win32_LogicalDisk&quot;)\nFor Each objDisk in colDisks\n &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID\n    \n    If Not IsNull(objDisk.Size) And Not IsNull(objDisk.FreeSpace) Then\n        dblPercent = ((CDbl(objDisk.Size) - CDbl(objDisk.FreeSpace)) / CDbl(objDisk.Size)) * 100\n        intPercent = CInt(dblPercent)\n        WScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intPercent &amp; &quot;%&quot;\n    End If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndf -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line\ndo\n    set -- $line\n    echo $7: $6\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ndf -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\\// { print $9&quot;: &quot; $5 }&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 98, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "File system type of the C drive.\nExample: NTFS", 
      "exclude_from_parse_flag": 1, 
      "hash": 2207214962, 
      "hidden_flag": 0, 
      "id": 193, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Disk Type of C:", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select FileSystem from Win32_LogicalDisk where Caption = &#039;c:&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 99, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns the total amount of installed RAM, in Megabytes.\nExample: 2048 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 4279567267, 
      "hidden_flag": 0, 
      "id": 195, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "RAM", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; RAM\n&#039;========================================\n\nstrComputer = &quot;.&quot;\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; _\n&amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colComputer = objWMIService.ExecQuery _\n(&quot;Select * from Win32_ComputerSystem&quot;)\n\nFor Each objComputer in colComputer\n   intRamMB = int((objComputer.TotalPhysicalMemory) /1048576)+1\n   Wscript.Echo intRamMB &amp; &quot; MB&quot;\nNext\n\nWScript.Quit", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 100, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns the percentage of used (committed) memory on a system.\nExample: 27 percent", 
      "exclude_from_parse_flag": 1, 
      "hash": 2177703669, 
      "hidden_flag": 0, 
      "id": 197, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Memory Consumption", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Memory Consumption\n&#039;========================================\n\nOption Explicit\n\nDim objWMIService, colItems, objItem, strLinePercentCommittedBytesInUse\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n \n&#039;Gets MEMORY Usage\nSet colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)\nFor Each objItem In colItems  \n strLinePercentCommittedBytesInUse = objItem.PercentCommittedBytesInUse\n wscript.echo strLinePercentCommittedBytesInUse &amp; &quot; %&quot;\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 101, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Returns information on network adapters.\nExample:Intel(R) Centrino(R) Ultimate-N 6300 AGN|Intel Corporation|Ethernet 802.3|00:24:D7:21:9C:70|65 Mbps|Wi-Fi", 
      "exclude_from_parse_flag": 1, 
      "hash": 3009680784, 
      "hidden_flag": 0, 
      "id": 199, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Network Adapter Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Network Adapter Details\n&#039;========================================\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapter&quot;,,48)\n\nDim arrNdisAdapters\nSet arrNdisAdapters = GetNdisArray\n\nFor Each objItem in colItems\n\tIf _\n\t\tInStr(objItem.AdapterType, &quot;Ethernet&quot;) &gt; 0 Or _\n\t\tInStr(objItem.AdapterType, &quot;Wireless&quot;) &gt; 0 _\n\tThen\n\t\t\t\n\t\tdblSpeed = CDbl(objItem.Speed) / 1000000\n\t\tIf (arrNdisAdapters.count &gt; 0) Then\n\t\t\tFor Each objAdapter in arrNdisAdapters\n\t\t\t\tIf objAdapter.InstanceName = objItem.Name Then\n\t\t\t\t\tdblSpeed = CDbl(objAdapter.NdisLinkSpeed) / 10000\n\t\t\t\tEnd If\n\t\t\tNext\n\t\tEnd If\n\t\tstrSpeed = dblSpeed &amp; &quot; Mbps&quot;\n\n\t\tWScript.Echo _\n\t\t\tobjItem.Name &amp; &quot;|&quot; &amp; _\n\t\t\tobjItem.Manufacturer &amp; &quot;|&quot; &amp; _\n\t\t\tobjItem.AdapterType &amp; &quot;|&quot; &amp; _\n\t\t\tobjItem.MACAddress &amp; &quot;|&quot; &amp; _\n\t\t\tstrSpeed &amp; &quot;|&quot; &amp; _\n\t\t\tobjItem.NetConnectionID\n\tEnd If\nNext\n\nFunction GetNdisArray\n\tConst cWMINameSpace = &quot;root/wmi&quot;\n\tConst cWMIInstance = &quot;MSNdis_LinkSpeed&quot;\n\tConst strComputerName = &quot;.&quot;\n\t\n\tDim strWinMgmts, objWMI, listAdapters, objAdapter\n\t\n\tstrWinMgMts = &quot;winmgmts:{impersonationLevel=impersonate}!//&quot; &amp; strComputerName &amp; &quot;/&quot; &amp; cWMINameSpace\n\tSet objWMI = GetObject(strWinMgMts)\n\t\n\tSet listAdapters = objWMI.InstancesOf(cWMIInstance)\n\tSet GetNdisArray = listAdapters\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Adapter Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Manufacturer", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Adapter Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "MAC Address", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Speed", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Network Connection ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 102, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Name of BIOS.\nExample: Phoenix ROM BIOS PLUS Version 1.10 A10", 
      "exclude_from_parse_flag": 1, 
      "hash": 367063513, 
      "hidden_flag": 0, 
      "id": 201, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "BIOS Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from win32_BIOS", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\nLINUX=`uname -o | grep -c -i linux`\n\nif [ $LINUX -eq 1 ]\nthen\ndmidecode -s bios-vendor\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 103, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Release date of the BIOS.\nExample: 20080436.2.314.851300+000", 
      "exclude_from_parse_flag": 1, 
      "hash": 3798171813, 
      "hidden_flag": 0, 
      "id": 203, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "BIOS Release Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039; =================\n&#039; BIOS Release Date\n&#039; =================\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\nSet win32bios = objWMIService.ExecQuery(&quot;select * from win32_BIOS&quot;)\n\nFor Each objItem in win32bios\n\n\tDim releaseDate, biosYear, biosMonth, biosDate\n\treleaseDate = objItem.ReleaseDate\n\tbiosYear = Mid(releaseDate, 1, 4)\n\tbiosMonth = Mid(releaseDate, 5, 2) \n    \tbiosDate = Mid(releaseDate, 7, 2)\n\tWScript.Echo biosMonth &amp; &quot;/&quot; &amp; biosDate &amp; &quot;/&quot; &amp; biosYear\n\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s bios-release-date\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "WMIDate"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 104, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Version of the BIOS.\nExample: A11", 
      "exclude_from_parse_flag": 1, 
      "hash": 833799742, 
      "hidden_flag": 0, 
      "id": 205, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "BIOS Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select SMBIOSBIOSVersion from win32_BIOS", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s bios-version\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 105, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Provides a list of applications that are running at the present time on the client machine.\nExample: Google Chrome | 23.0.1271.64", 
      "exclude_from_parse_flag": 1, 
      "hash": 1559751995, 
      "hidden_flag": 0, 
      "id": 207, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Running Applications", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Running Applications\n&#039;========================================\n\n&#039; This sensor will list the pretty names of running applications.\n&#039; it is a multiple column sensor, and a hidden column will show the\n&#039; process name.\n\nstrSep = &quot;|&quot;\n&#039; Sensor output looks like:\n&#039; Running Application | Version | Process Name\n\nSetLocale(1033)\n\nshowDuplicates = False \nshowVersion = True\nrecordUsageStats = True\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select Caption, Name, ExecutablePath, CreationDate from Win32_Process&quot;,,48)\n\nDim nameDictionary, processDictionary\nSet nameDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)\nSet processDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039;ADD PROCESS NAME IN LOWER CASE\n&#039;nameDictionary.Add &quot;hppusg.exe&quot;, &quot;Some HP Application&quot;\n&#039;nameDictionary.Add &quot;taniumclient.exe&quot;, &quot;TANIUM CLIENT&quot;\n\n&#039;array used to print output (no dictionary since we need duplicates)\nDim arrOutput()\nintSize = 0\nReDim Preserve arrOutput(intSize)\n\nstrComputer = &quot;.&quot;\nConst HKLM = &amp;h80000002\nSet reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nregPath = GetTaniumRegistryPath() &amp; &quot;\\Sensor Data\\Applications&quot;\nIf Not RegKeyExists(reg, HKLM, regPath) Then\n\treg.createKey HKLM, regPath\nEnd If\n\n&#039; if recording Usage stats, then we need to record when we first started \n&#039; recording usage stats\nIf recordUsageStats Then \n\treg.GetStringValue HKLM, regPath, &quot;UsageStatsStart&quot;, strUsageStatsStart\n\t\n\tIf IsNull(strUsageStatsStart) Or IsEmpty(strUsageStatsStart) Then \n\t\treg.SetStringValue HKLM, regPath, &quot;UsageStatsStart&quot;, CStr(Now())\n\tEnd If\nEnd If \n\n&#039;SET UP INSTALLED APPLICATIONS PROCESS DICTIONARY TO FACILITATE ACCESS LATER\nDim installedProcs\nSet installedProcs = CreateObject(&quot;scripting.dictionary&quot;)\n\ninstalledRegPath = GetTaniumRegistryPath() &amp; &quot;\\Sensor Data\\Applications\\Installed&quot;\nIf Not RegKeyExists(reg, HKLM, regPath) Then\n\treg.createKey HKLM, installedRegPath\nElse\t\n\treg.EnumKey HKLM, installedRegPath, arrAppKeys\n\tif not isNull(arrAppKeys) Then\n\t\tFor Each appKey In arrAppKeys\n\t\t\tfullAppKey = installedRegPath &amp; &quot;\\&quot; &amp; appKey\n\t\t\treg.EnumKey HKLM, fullAppKey, arrProcKeys\n\t\t\tIf Not IsNull(arrProcKeys) Then\n\t\t\t\tFor Each procKey In arrProcKeys\n\t\t\t\t\tfullProcKey = fullAppKey &amp; &quot;\\&quot; &amp; procKey\n\t\t\t\t\treg.GetStringValue HKLM, fullProcKey, &quot;Path&quot;, strPath\n\t\t\t\t\treg.GetStringValue HKLM, fullProcKey, &quot;Process&quot;, strProc\n\t\t\t\t\tIf Right(strPath, 1) &lt;&gt; &quot;\\&quot; Then\n\t\t\t\t\t\tstrPath = strPath &amp; &quot;\\&quot;\n\t\t\t\t\tEnd If\t\n\t\t\t\t\tIf Not installedProcs.Exists(strPath &amp; strProc) Then\n\t\t\t\t\t\tinstalledProcs.Add strPath &amp; strProc, fullAppKey\n&#039;\t\t\t\t\t\tWScript.Echo &quot;added: &quot; &amp; installedProcs.Item(strPath &amp; strProc)\n\t\t\t\t\tEnd If\t\n\t\t\t\tNext\n\t\t\tEnd If\n\t\tNext\n\tEnd If\nEnd If\n\nFor Each objItem in colItems\n\tIf InStr(LCase(objItem.ExecutablePath), &quot;windows\\system32\\&quot;) = 0 Then\n\t    Dim fso\n\t    Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t    If fso.FileExists(objItem.ExecutablePath) Then\n    \t\tDim strOutput, fileVersion, fileVersionOutput, fullName\n\n\t    \tSet execFile = fso.GetFile(objItem.ExecutablePath)\n\t    \t\n    \t\tfileVersion = fso.GetFileVersion(objItem.ExecutablePath)\n    \t\tfileVersionOutput = &quot;N/A&quot;\n\t    \tIf showVersion Then\n\t    \t\tIf fileVersion &lt;&gt; &quot;&quot; Then\n\t    \t\t\tfileVersionOutput = fileVersion\n\t    \t\tElse\n\t    \t\t\tfileVersionOutput = &quot;N/A&quot;\n\t    \t\tEnd If\n\t\t\tEnd If \n\t\t\t\n   \t\t\tfullName = nameDictionary.Item(LCase(objItem.Name))\n\n\t\t\tIf IsEmpty(fullName) Then\n\t\t\t\tfullName = GetDescription(execFile.ParentFolder.Path, objItem.Name)\n\t\t\tEnd If\n\t\t\t\t\t\t\n\t\t\tIf fullName = &quot;&quot; Then\n\t\t\t\tfullName = objItem.Name\n\t\t\tEnd If\n\t\t\t&#039; sensor output looks like:\n\t\t\t&#039; Application Name | Version | Process\n   \t\t\tstrOutput = fullName &amp; strSep &amp; fileVersionOutput &amp; strSep &amp; objItem.Caption\n    \t\t\n \t\t\tIf not ArrayContains(arrOutput, strOutput) Or showDuplicates Then\n\t\t\t\tarrOutput(intSize) = strOutput\n\t\t\t\tintSize = intSize + 1\n\t\t\t\tReDim Preserve arrOutput(intSize)\n\t\t\tEnd If\n\t\t\t\n\t\t\t&#039;Process Last Started, First Started, etc.\n\t\t\tcreationDate = objItem.CreationDate\n\t\t\tstrDate = WMIDateStringToDate(creationDate)\n\t\t\tStoreData execFile.ParentFolder.Path, objItem.Name, fullName, fileVersion, cstr(strDate), reg, HKLM, regPath, false\n\t\t\t\n\t\t\t&#039;Look in installed processes for match, if yes then update data\n\t\t\tstrKey = execFile.ParentFolder.Path &amp; &quot;\\&quot; &amp; objItem.Name\n\t\t\tIf installedProcs.Exists(strKey) Then\n\t\t\t\tinstalledAppKey = installedProcs.Item(strKey)\n\t\t\t\t\n\t\t\t\tStoreData execFile.ParentFolder.Path, objItem.Name, fullName, fileVersion, cstr(strDate), reg, HKLM, installedAppKey, True\n\t\t\t\t\n\t\t\t\t&#039;Also add &quot;Application&quot; value to process key\n\t\t\t\treg.GetStringValue HKLM, installedAppKey, &quot;Description&quot;, strApp\n\t\t\t\t\n\t\t\t\treg.SetStringValue HKLM, regPath&amp;&quot;\\&quot;&amp;GetKeyName(objItem.Name), &quot;Application&quot;, strApp\n\t\t\tEnd If\n\t    End If\n\tEnd If\nNext\n\nFor Each output In arrOutput \n\tWScript.Echo output\nNext\n\nFunction GetKeyName(strProcess)\n\twords = Split(strProcess, &quot;.&quot;)\n\tGetKeyName = words(0)\nEnd Function\n\nFunction StoreData(strPath, strProc, fullName, version, strDate, objReg, hive, baseRegKey, isInstalled)\n\tDim regKey\n\t\n\tIf isInstalled Then\n\t\tregKey = baseRegKey\n\tElse\n\t\tregKey = baseRegKey &amp; &quot;\\&quot; &amp; GetKeyName(strProc)\n\tEnd If\n\t\n\tIf Not RegKeyExists(objReg, hive, regKey) Then\n\t\tobjReg.createKey hive, regKey\n\tEnd If\n\t\n\n\t&#039;only update file-specific data if not installed\n\tIf Not isInstalled Then\n\t\tpublisher = GetPublisher(strPath, strProc)\n\t\tobjReg.SetStringValue hive, regKey, &quot;Publisher&quot;, publisher\n\t\tobjReg.SetStringValue hive, regKey, &quot;Version&quot;, version\n\t\tobjReg.SetStringValue hive, regKey, &quot;Description&quot;, fullName\n\t\tobjReg.SetStringValue hive, regKey, &quot;Path&quot;, strPath\n\t\tobjReg.SetStringValue hive, regKey, &quot;Process&quot;, strProc\n\tEnd If\n\t\t\n\t&#039;always update first/last data\t\n\tDim strFirstStart, strLastStart\n\t&#039;Get &quot;First Start&quot;, compare value\n\tobjReg.GetStringValue hive, regKey, &quot;First Start&quot;, strFirstStart\n\tIf IsNull(strFirstStart) Then\n\t\tobjReg.SetStringValue hive, regKey, &quot;First Start&quot;, strDate\n\tElse\n\t\t&#039;Check if first start value needs to be replaced\n\t\tdiff = DateDiff(&quot;d&quot;, strFirstStart, strDate)\n\t\tIf diff &lt; 0 Then\n\t\t\tobjReg.SetStringValue hive, regKey, &quot;First Start&quot;, strDate\n\t\tEnd If\n\tEnd If\n\t\n\t&#039;Get &quot;Last Start&quot;, compare value\n\tobjReg.GetStringValue hive, regKey, &quot;Last Start&quot;, strLastStart\n\tIf IsNull(strLastStart) Then\n\t\tobjReg.SetStringValue hive, regKey, &quot;Last Start&quot;, strDate\n\tElse\n\t\t&#039;Check if first start value needs to be replaced\n\t\tdiff = DateDiff(&quot;d&quot;, strLastStart, strDate)\n\t\tIf diff &gt; 0 Then\n\t\t\tobjReg.SetStringValue hive, regKey, &quot;Last Start&quot;, strDate\n\t\tEnd If\n\tEnd If\n\t\n\t&#039; record the number of times seen, if enabled\n\tIf recordUsageStats Then\n\t\t\n\t\t&#039; Assuming the usual time that this sensor runs is once every 5 minutes,\n\t\t&#039; never record and increment usage stats more often than once every 4\n\t\t&#039; minutes.  This stops us from recording an increment more often, in \n\t\t&#039; the case that someone uses the sensor in some other question\n\t\tobjReg.GetStringValue hive, regKey, &quot;LastStatUpdate&quot;, strLastUpdate\n\t\t\n\t\tbRecordUpdate = False\n\t\tIf IsNull(strLastUpdate) Or IsEmpty(strLastUpdate) Then \n\t\t\tbRecordUpdate = True\n\t\tElse \n\t\t\tintSecondsPast = DateDiff(&quot;s&quot;, CDate(strLastUpdate), Now())\n\t\t\t\n\t\t\t&#039; allow the update if its very close to 5 minutes\n\t\t\tIf(intSecondsPast &gt;= 270) Then \n\t\t\t\tbRecordUpdate = True\n\t\t\tEnd If\n\t\tEnd If\n\t\t\n\t\tIf bRecordUpdate Then \n\t\t\t&#039; key for usage stats is month-day-year\n\t\t\tstrUsageKey = Month(Now) &amp; &quot;-&quot; &amp; Year(Now) &amp; &quot;-Usage&quot;\n\t\t\tobjReg.GetDWORDValue hive, regKey, strUsageKey, intNumSeen\n\t\t\t\n\t\t\tIf IsNull(intNumSeen) Or IsEmpty(intNumSeen) Then\n\t\t\t\tintNumSeen = 0\n\t\t\tEnd If\n\t\t\t\n\t\t\tintNumSeen = intNumSeen + 1\n\t\t\t\n\t\t\tobjReg.SetDWORDValue hive, regKey, strUsageKey, intNumSeen\n\t\t\tobjReg.SetStringValue hive, regKey, &quot;LastStatUpdate&quot;, CStr(Now())\n\t\tEnd If\n\tEnd If \n\t\nEnd Function\n\n\nFunction ArrayContains(arr, str)\n\tFor Each obj In arr \n\t\tIf obj = str Then\n\t\t\tArrayContains = True\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\tArrayContains = False\nEnd Function\n\nFunction GetAttributeIndex(folderPath, attrTarget)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tFor i = 0 to 400\n\t\tattrName = objFolder.GetDetailsOf(objFolder.Items, i)\n\t\tIf LCase(attrName) = LCase(attrTarget) Then\n\t\t\tGetAttributeIndex = i\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\nEnd Function\n\nFunction GetFileProperty(folderPath, fileName, fileProperty)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tGetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)\nEnd Function\n\nFunction GetDescription(folderPath, fileName)\n\tdescIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)\n\tIf IsEmpty(descIndex) Then\n\t\tdescIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)\n\tEnd If\n\tGetDescription = GetFileProperty(folderPath, fileName, descIndex)\nEnd Function\n\nFunction GetPublisher(folderPath, fileName)\n\tdescIndex = GetAttributeIndex(folderPath, &quot;Company&quot;)\n\tGetPublisher = GetFileProperty(folderPath, fileName, descIndex)\nEnd Function\n\nFunction WMIDateStringToDate(dtmInstallDate)\n   WMIDateStringToDate = CDate(Mid(dtmInstallDate, 5, 2) &amp; &quot;/&quot; &amp; _\n   Mid(dtmInstallDate, 7, 2) &amp; &quot;/&quot; &amp; Left(dtmInstallDate, 4))\nEnd Function\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 48, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Version", 
            "value_type": "Version"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Process Name", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 106, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns the version of Internet Explorer installed on a system.\nExample:8.0.6001.18702", 
      "exclude_from_parse_flag": 1, 
      "hash": 1140552555, 
      "hidden_flag": 0, 
      "id": 209, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Internet Explorer Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Internet Explorer Version\n&#039;========================================\n\nConst HKEY_LOCAL_MACHINE = &amp;H80000002\nstrComputer = &quot;.&quot;\nSet oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; _\n    strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\nstrKeyPath = &quot;SOFTWARE\\Microsoft\\Internet Explorer&quot;\nstrValueName = &quot;Version&quot;\nstrValueName2 = &quot;svcVersion&quot;\nOn Error Resume Next\noReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName2,strValue\nIf strValue &lt;&gt; &quot;&quot; Then\n\tWScript.Echo strValue\n\tWScript.Quit\nEnd If\n\noReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue\nWscript.Echo  strValue", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 107, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The Service Pack level of the machine if available, and \"No Service Pack found\" if unavailable.\nExample: Service Pack 1", 
      "exclude_from_parse_flag": 1, 
      "hash": 2881145629, 
      "hidden_flag": 0, 
      "id": 211, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Service Pack", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Service Pack\n&#039;========================================\n\nOn Error Resume Next\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\nSet colItems = objWMIService.ExecQuery(&quot;select CSDVersion from win32_operatingsystem&quot;)\n\nFor Each objItem in colItems\nif not isnull(objItem.CSDVersion) then\n\tWScript.Echo objItem.CSDVersion\n\tWScript.Quit\nEnd if\nNext\n\nWScript.Echo &quot;No Service Pack found&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 108, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns the build number of the installed operating system.\nExample:7601", 
      "exclude_from_parse_flag": 1, 
      "hash": 3770282786, 
      "hidden_flag": 0, 
      "id": 213, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Operating System Build Number", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select BuildNumber from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 109, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns the date the OS was installed.\nExample: 8/24/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 1982695066, 
      "hidden_flag": 0, 
      "id": 215, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 43200, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Operating System Install Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Operating System Install Date\n&#039;========================================\n\n&#039; This sensor uses date math which is locale specific\nSetLocale(GetTaniumLocale)\n\nSet dtmConvertedDate = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\nSet colOperatingSystems = objWMIService.ExecQuery _\n    (&quot;Select * from Win32_OperatingSystem&quot;)\n\nFor Each objOperatingSystem in colOperatingSystems\n    dtmConvertedDate.Value = objOperatingSystem.InstallDate\n    dtmInstallDate = dtmConvertedDate.GetVarDate\n    \n    \n    words = Split(dtmInstallDate, &quot; &quot;)\n    Wscript.Echo words(0)\nNext\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 110, 
      "category": "Java", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Returns a list of all installed Java runtimes on the client machine.\nExample: Java(TM) 6 Update 20", 
      "exclude_from_parse_flag": 1, 
      "hash": 3993657420, 
      "hidden_flag": 0, 
      "id": 217, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Installed Java Runtimes", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Installed Java Runtimes\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039; This sensor will return information in the uninstall areas of the registry.\n&#039; There are two hidden columns which can be filtered on despite the fact that\n&#039; they&#039;re hidden, and can also feed actions.\n&#039; if the uninstallstring is msi based, it is altered to show the\n&#039; silent uninstall options and marked as &quot;Is Uninstallable&quot;\n&#039; finally, if it&#039;s a user installed application, it will note that\n&#039; The columns look like:\n&#039; Name|Version|Silent Uninstall String|Uninstallable\n\nSensorRandomize()\n\nDim hasJava \nhasJava = False\n\n&#039; This sensor uses date math which is locale specific\nSetLocale(GetTaniumLocale) &#039;us/english\n\nSet objRegistry = Getx64RegistryProvider()\n\nkeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;\nkey64Path = &quot;SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;\n\nConst HKLM = &amp;H80000002\nConst HKEY_USERS = &amp;H80000003\n\n&#039; list out 32-bit applications on a 64-bit system\nIf RegKeyExists(HKLM, key64Path) Then\n\tobjRegistry.EnumKey HKLM, key64Path, arrSubKeys\n\tGetApplications HKLM,key64path,arrSubKeys\nEnd If\n\n&#039; list out 32-bit applications on a 32-bit system, or 64-bit applications\n&#039; on a 64-bit system.\nIf RegKeyExists(HKLM, keyPath) Then\n\tobjRegistry.EnumKey HKLM, keypath, arrSubKeys\n\tGetApplications HKLM,keypath,arrSubKeys\nEnd If\n\n&#039; Also list out applications installed to HKEY_Users areas\n&#039; which will be appended to the arrSubKeys\nobjRegistry.EnumKey HKEY_USERS, &quot;&quot;, arrUserKeys\nFor Each strSIDkey In arrUserKeys\n\tIf RegKeyExists(HKEY_USERS, strSIDKEY&amp;&quot;\\&quot;&amp;keyPath) Then\n\t\tobjRegistry.EnumKey HKEY_USERS, strSIDkey&amp;&quot;\\&quot;&amp;keyPath, arrSubKeys\n\t\tGetApplications HKEY_USERS,strSIDKey&amp;&quot;\\&quot;&amp;keyPath,arrSubKeys\n\tEnd If\nNext\n\nIf Not(hasJava) Then\n\tWScript.Echo &quot;Java not installed&quot;\nEnd If\n\nFunction IsJava(strName)\n\tIf ContainsString(strName, &quot;(^Java\\(TM\\) \\d Update)|(^Java \\d Update)|(^Java 2 Runtime Environment)|(^Java Runtime Environment)&quot;) Then\n\t\tIsJava = True\n\t\tExit Function\n\tElse\n\t\tIsJava = False\n\tEnd If\nEnd Function\n\nFunction GetApplications(HIVE, keypath,arrSubKeys)\n\tSet applications = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\n\tIf Not IsNull(arrSubKeys) Then\n\t\tFor Each key in arrSubKeys\n\t\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;DisplayName&quot;, displayName\n\t\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;DisplayVersion&quot;, version\n\t\t\tobjRegistry.GetDWORDValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;SystemComponent&quot;, systemComponent\t\n\t\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;UninstallString&quot;, uninstallString\t\n\t\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;ParentKeyName&quot;, parentKey\t\n\t\t\t&#039; on error goto 0\n\t\t\t&#039; assume it&#039;s not uninstallable\n\t\t\tbUninstallable = &quot;Not Uninstallable&quot;\n\t\t\t\t\t\n\t\t\tIf displayName &lt;&gt; &quot;&quot; _\n\t\t\t\tAnd Not IsNull(uninstallString) _ \n\t\t\t\tAnd IsNull(parentKey) _\n\t\t\t\tAnd InStr(displayName, &quot;Hotfix&quot;) = 0 _\n\t\t\t\tAnd InStr(displayName, &quot;Update for&quot;) = 0 _\n\t\t \t\tAnd InStr(displayName, &quot;Security Update for&quot;) = 0 _\n\t\t \tThen \n\t\t \t\tIf InStr(LCase(uninstallString), &quot;msiexec&quot;) Then\n\t\t \t\t\t&#039; replace any /I with /X and add silent flags\n\t\t \t\t\tuninstallString = Replace(uninstallString,&quot;/I&quot;,&quot;/X&quot;) &amp; &quot; /qn /noreboot&quot; \n\t\t  \t\t\tbUninstallable = &quot;Is Uninstallable&quot;\n\t\t  \t\tEnd If\n\t\t \t\tIf IsNull(systemComponent) Or systemComponent = 0 Then\n\t\t\t\t\tIf IsNull(version) Then\n\t\t\t\t\t\tversion = &quot;&quot;\n\t\t\t\t\tEnd If\n\t\t\t\t\t&#039; This is a multi-column sensor.  Last two columns are hidden.\n\t\n\t\t\t\t\tdisplayString = displayName &amp; &quot;|&quot; &amp; version &amp; &quot;|&quot; &amp; uninstallString &amp; &quot;|&quot; &amp; bUninstallable\n\t\n\t\t\t\t\t&#039; treat displayString as the unique value - cannot be listed twice.\n\t\t\t\t\tIf Not applications.Exists(displayName) Then\n\t\t\t\t\t\t&#039;Check for various Java Installation patterns\n\t\t\t\t\t\tIf IsJava(displayName) Then\n\t\t\t\t\t\t\tapplications.Add displayName, displayString\n\t\t\t\t\t\t\thasJava = True\n\t\t\t\t\t\tEnd If\t\n\t\t\t\t\tEnd If \t\n\t\t\t\tEnd If \t\n\t\t\tEnd If \n\t\tNext\n\tEnd If\n\t\n\tSortDictionary applications, 1 &#039; This calls a sorting function specific to dictionaries\n\tarrApplicationsKeys = applications.Keys\n\tFor Each strKey In arrApplicationsKeys\n\t\t&#039; final output of the sensor\n\t\tWScript.Echo applications.Item(strKey)\n\tNext\nEnd Function &#039;GetApplications\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction SortDictionary(objDict, intSort)\n &#039;   objDict - the dictionary to sort\n &#039;   intSort - the field to sort (1=key, 2=item)\n \n   &#039; declare constants\n   Const dictKey  = 1\n   Const dictItem = 2\n \n   &#039; declare our variables\n   Dim strDict()\n   Dim objKey\n   Dim strKey,strItem\n   Dim X,Y,Z\n \n   &#039; get the dictionary count\n   Z = objDict.Count\n \n   &#039; we need more than one item to warrant sorting\n   If Z &gt; 1 Then\n     &#039; create an array to store dictionary information\n     ReDim strDict(Z,2)\n     X = 0\n     &#039; populate the string array\n     For Each objKey In objDict\n         strDict(X,dictKey)  = CStr(objKey)\n         strDict(X,dictItem) = CStr(objDict(objKey))\n         X = X + 1\n     Next\n \n     &#039; perform a a shell sort of the string array\n     For X = 0 To (Z - 2)\n       For Y = X To (Z - 1)\n         If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) &gt; 0 Then\n             strKey  = strDict(X,dictKey)\n             strItem = strDict(X,dictItem)\n             strDict(X,dictKey)  = strDict(Y,dictKey)\n             strDict(X,dictItem) = strDict(Y,dictItem)\n             strDict(Y,dictKey)  = strKey\n             strDict(Y,dictItem) = strItem\n         End If\n       Next\n     Next\n \n     &#039; erase the contents of the dictionary object\n     objDict.RemoveAll\n \n     &#039; repopulate the dictionary with the sorted information\n     For X = 0 To (Z - 1)\n       objDict.Add strDict(X,dictKey), strDict(X,dictItem)\n     Next\n \n   End If\n End Function &#039;SortDictionary\n\n\nFunction ContainsString(strToCheck, strRegex)\n&#039;\tIf isDebug Then WScript.Echo &quot;About to check: &quot; &amp; strToCheck\n\n\tIf IsNull(strToCheck) Or IsEmpty(strToCheck) Then\n\t\tContainsString = False\n\t\tExit Function\n\tEnd If\n\n\tDim re, matches\n\tSet re = New RegExp\n\tre.Pattern = strRegex\n\tSet matches = re.Execute(strToCheck)\n\tIf matches.Count &gt; 0 Then\n\t\tIf isDebug Then WScript.Echo &quot;   match: &quot; &amp; matches(0) &amp; &quot;, strRegex: &quot; &amp; strRegex\n\t\tContainsString = True\n\t\tExit Function\n\tEnd If\n\tContainsString = False\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "JRE", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Version", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Uninstaller", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Uninstallable", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 111, 
      "category": "Java", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Returns the state of the Java Auto Update service, per architecture.\nExample: Enabled 32-bit", 
      "exclude_from_parse_flag": 1, 
      "hash": 3134254821, 
      "hidden_flag": 0, 
      "id": 219, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Java Auto Update", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Java Auto Update\n&#039;========================================\n\nOption Explicit\n\nConst HKLM = &amp;H80000002\n\nDim b32BitJavaFound, b64BitJavaFound\nb32BitJavaFound = False\nb64BitJavaFound = False\n\nb32BitJavaFound = CheckForJavaAndUpdatePolicy(32)\nIf Is64 Then\n\tb64BitJavaFound = CheckForJavaAndUpdatePolicy(64)\nEnd If\n\nIf Not b32BitJavaFound And Not b64BitJavaFound Then\n\t&#039; Only print this if neither bit of java was found\n\tWScript.Echo &quot;Java Not Found&quot;\nEnd If\n\n\nFunction CheckForJavaAndUpdatePolicy(intBit)\n\tDim strRuntimeInstalledKey, strUpdatePolicyKey, intRegToUse, strArch, strValue\n\tDim objCtx, objReg, bJavaFound\n\t\n\tbJavaFound = False\n\n\tstrRuntimeInstalledKey = &quot;SOFTWARE\\Javasoft\\Java Runtime Environment&quot;\n\tstrUpdatePolicyKey = &quot;SOFTWARE\\JavaSoft\\Java Update\\Policy&quot;\n\t\n\tintRegToUse = 32\n\tIf Is64 Then \n\t\tintRegToUse = 64 &#039; always use highest available registry\n\tEnd if\n\t\n\tSet objCtx = GetObjCtx(intRegToUse)\n\tSet objReg = GetObjReg(objCtx)\n\n\tstrArch = &quot;32-bit&quot;\n\tIf intBit = 64 Then\n\t\tstrArch = &quot;64-bit&quot;\n\tEnd If\n\t\n\tIf Is64 And intBit = 32 Then\n\t\t&#039; special case of looking for 32 bit jvms on 64 bit machines\n\t\tstrRuntimeInstalledKey = &quot;SOFTWARE\\WOW6432Node\\Javasoft\\Java Runtime Environment&quot;\n\t\tstrUpdatePolicyKey = &quot;SOFTWARE\\WOW6432Node\\JavaSoft\\Java Update\\Policy&quot;\n\tEnd If\t\n\t\n\tIf RegKeyExists(objReg, objCtx, HKLM, strRuntimeInstalledKey) Then\n\t\tbJavaFound = True\n\t\tIf RegKeyExists(objReg, objCtx, HKLM, strUpdatePolicyKey) Then\n\t\t\tstrValue = GetDWordValue(objReg, objCtx, HKLM, strUpdatePolicyKey, &quot;EnableJavaUpdate&quot;)\n\t\t\n\t\t\tIf Not IsNull(strValue) Then\n\t\t\t\tIf strValue = 1 Then\n\t\t\t\t\tWScript.Echo &quot;Enabled|&quot; &amp; strArch\n\t\t\t\tElse\n\t\t\t\t\tWScript.Echo &quot;Disabled|&quot; &amp; strArch\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse \n\t\t\t&#039; case where jvm installed, but no Java Update reg branch available\n\t\t\tWScript.Echo &quot;Disabled|&quot; &amp; strArch\n\t\tEnd If\n\tEnd If\n\t\n\tCheckForJavaAndUpdatePolicy = bJavaFound\nEnd Function\n\nFunction GetDWordValue(objReg, objCtx, constHive, strKey, strValue)\n\tDim objInParams, objOutParams, objValue\n    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n    objInParams.hDefKey = constHive\n    objInParams.sSubKeyName = strKey\n    objInParams.sValueName = strValue\n    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n\tobjValue = objOutParams.uValue\n\tIf IsNull(objOutParams.uValue) Then\n\t\tGetDWordValue = Null\n\tElse\n\t\tGetDWordValue = CStr(objOutParams.uValue)\n\tEnd If\t\nEnd Function\n\nFunction RegKeyExists(objReg, objCtx, constHive, strKey)\n\tDim objNames, objTypes, objValues, Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tIf Outparams.ReturnValue = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\t\t\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Architecture", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 112, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Multi-column Sensor that shows operating system patches that can be installed to this computer.  The title, severity, bulletin, date, total package size, and KB article for the patch are displayed.\nExample: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663", 
      "exclude_from_parse_flag": 1, 
      "hash": 259673374, 
      "hidden_flag": 0, 
      "id": 221, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 60, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Available Patches", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Available Patches\n&#039;========================================\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, bAirgapped, strAirgapUrl\nDim dictScanResultFiles,strCustomCabSupportVal,bCustomCabSupport\nDim strScansPath, strToolsPath\n\nstrSep = &quot;|&quot;\n\n&#039;title|severity|bulletins|date|download|filename|status|guid|package size|kb|cve|Unique ID|Reboot Required|Revision|Endpoint Impact\n\nbAirgapped = False\nstrAirgapUrl = &quot;AIRGAP_LOCAL_SERVER_URL/Dropoff/&quot;\nIf( Not(Left(strAirgapUrl, 19) = &quot;AIRGAP_LOCAL_SERVER&quot;)) Then \n\tbAirgapped = True  &#039; the AIRGAP url is rewritten by the install process, so this\n\t                   &#039; set to true will mean we need to airgap the urls\nEnd If\n\n\nstrToolsPath = GetTaniumDir(&quot;Tools&quot;)\nstrScansPath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nstrCustomCabSupportVal = LCase(GetPatchManagementValueFromRegistry(&quot;CustomCabSupport&quot;))\nIf strCustomCabSupportVal = &quot;true&quot; Or strCustomCabSupportVal = &quot;yes&quot; Then\n\tSet dictScanResultFiles = GetValidScanFiles &#039; retrieves all\n\tbCustomCabSupport = True\n\t\n\t&#039; True if you need to support custom support cabs\n\t&#039; Typically set with the Distribute Custom Patch Scan Cabs job\n\t&#039; If above is true:\n\t&#039; Use the Distribute Custom Patch Scan Cabs package /CustomDownloadURLFolder flag to set a value such as\n\t&#039; http://myserver.com/folder\n\t&#039; ensure that if the url is retrieved via https that all Tanium servers will trust the certificate presented\n\t&#039; The server chosen to host the patch files must have enough space for all patch files\n\t&#039; (typically XP Custom Support Patches)\n\t&#039; Note that the URL will be lowercase but Microsoft will provide updates in Mixed-Case\n\t&#039; so be sure to place on a web server which ignores case sensitivity when URLs/Files\n\t&#039; are accessed - no case sensitive web servers, please\n\t\n\tDim strCustomDownloadURLFolder\n\t&#039; Set this value using the /CustomDownloadURLFolder flag when you distribute a custom\n\t&#039; cab file using Distribute Custom Patch Scan Cabs package. The same folder must be used with all custom cab files\n\tstrCustomDownloadURLFolder = _\n\t\tEnsureSuffix(GetPatchManagementValueFromRegistry(&quot;CustomDownloadURLFolder&quot;),&quot;/&quot;)\n\tIf strCustomDownloadURLFolder = &quot;&quot; Then &#039; value was not appropriately set\n\t\t&#039; this will appear as the download URL instead\n\t\tstrCustomDownloadURLFolder = &quot;http://Set.This.Value.When.Distributing.Custom.Cab/see_available_patches_sensor/&quot;\n\tEnd If\nElse\n\tbCustomCabSupport = False\n\t&#039; standard scan file support\n\tSet dictScanResultFiles = CreateObject(&quot;Scripting.Dictionary&quot;)\n\tdictScanResultFiles.Add strScansPath&amp;&quot;patchresultsreadable.txt&quot;,&quot;wsusscn2.cab&quot;\nEnd If\n\n&#039;-------------\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet dictScanResultFiles = GetValidScanFiles\n\nFor Each fn In dictScanResultFiles.Keys\n\tEchoScanResults(fn)\nNext\n\nFunction EchoScanResults(strScanFile)\n\t&#039;Set up exclusions list\n\tDim excludeFile\n\texcludeFile = strToolsPath &amp; &quot;\\patch-exclude.txt&quot;\n\t\n\tDim objExclusions\n\tSet objExclusions = GetPatchExclusions(excludeFile)\n\t\n\tIf objFSO.FileExists(fn) Then\n\t\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\t\n\t\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\t\n\t\thasOutput = False\n\t\t\n\t\tDo While Not objReadFile.AtEndOfStream\n\t\t\tstrLine = objReadFile.ReadLine\n\t\n\t\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\t\twords = Split(strLine, strSep)\n\t\t\t\n\t\t\t&#039;Ignore old Patch Results format without separator\n\t\t\tIf UBound(words) &lt; 4 Then \n\t\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\t\thasOutput = True\n\t\t\t\t\tWScript.Echo words(0)\n\t\t\t\t&#039;Else \n\t&#039;\t\t\t\tWScript.Echo &quot;Run upgraded Patch Scan&quot;\n\t&#039;\t\t\t\tWScript.Quit\n\t\t\t\tEnd If\t\n\t&#039;\t\tElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then\n\t\t\tElse\n\t\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\t\tDim fso\n\t\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\t\n\t\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\t\n\t\t\t\tisComplete = True\n\t\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\t\tisComplete = False\n\t\t\t\t\tEnd If\t\t\t\n\t\t\t\tNext\n\t\n\t\t\t\tIf Not isComplete Then\n\t\t\t\t\thasOutput = True\n\t\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\t\t&#039;if InStr(strLine, &quot;(KB&quot;) Then\n\t\t\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)\n\t\t\t\t\t\t&#039;End If\n\t\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t\tElse\n\t\t\t\t\t\t&#039;Check to see if KB article should be excluded\n\t\t\t\t\t\tIf Not IsExclusion(strLine, objExclusions) Then\n\t\t\t\t\t\t\tWScript.Echo RewriteLine(strLine)\n\t\t\t\t\t\tEnd If\n\t\t\t\t\tEnd If\n\t\t\t\tElse\n\t\t\t\t\t&#039;If we&#039;re here, update has been queued\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t\t&#039;If InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t\t&#039;\tWScript.Echo strLine\n\t\t\t\t\t&#039;End If\n\t\t\t\tEnd If \n\t\t\tEnd If\t\n\t\tLoop\n\t\n\t\tIf Not hasOutput Then\n\t\t\tWScript.Echo &quot;All available patches queued for installation&quot;\n\t\tEnd If\n\t\n\t\tobjReadFile.close\n\tElse\n\t   &#039; Wscript.echo &quot;Patch results output not found&quot;\n\tEnd if\n\nEnd Function &#039;EchoScanResults\n\nFunction RewriteLine(strLine) \n\tDim strResult, arrTokens, strDownloads, strFilenames, i, x\n\tstrResult = strLine\n\tIf bAirgapped Then \n\t\t&#039; if the system is running airgapped, then we need to rewrite\n\t\t&#039; all of the patch location URLs to have the internal url\n\t\t&#039; we have to pull out the url and file name values, then recreate the\n\t\t&#039; line\n\t\tarrTokens = Split(strLine, &quot;|&quot;)\n\t\tstrFilenames = Split(arrTokens(5), &quot;,&quot;)\n\n\t\tstrDownloads = strAirgapUrl &amp; strFilenames(0)\n\t\tFor i=1 To UBound(strFilenames)\n\t\t\tstrDownloads = strDownloads &amp; &quot;,&quot; &amp; strAirgapUrl &amp; strFilenames(i)\n\t\tNext\n\n\t\tstrResult = arrTokens(0)\n\t\tFor i=1 To Ubound(arrTokens) \n\t\t\tIf i=4 Then \n\t\t\t\tstrResult = strResult &amp; &quot;|&quot; &amp; strDownloads\n\t\t\tElse\n\t\t\t\tstrResult = strResult &amp; &quot;|&quot; &amp; arrTokens(i)\n\t\t\tEnd If \n\t\tNext\n\tEnd If\n\t&#039; Consider also XP Custom Support Downloads\n\t&#039; which may be at a different URL\n\tIf bCustomCabSupport Then\n\t\tstrResult = ReplaceCustomXPURL(strResult,strCustomDownloadURLFolder)\n\tEnd If\n\tRewriteLine = strResult\nEnd Function\n\nFunction RegKeyExists(reg, sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction IsExclusion(strLine, objDic)\n\tDim colKeys, strKey\n\tcolKeys = objDic.Keys\n\tFor Each strKey in colKeys\n\t\tIf InStr(strLine, strSep &amp; strKey &amp; strSep) &lt;&gt; 0 Then\n\t\t\tIsExclusion = True\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\n\tIsExclusion = False\nEnd Function\n\nFunction GetPatchExclusions(strFile)\n\tDim oDic\n\tSet oDic = CreateObject(&quot;scripting.dictionary&quot;)\n\t\n\tDim fso\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tConst ForReading = 1\n\tIf fso.FileExists(strFile) Then\n\t\tDim objFile\n\t\tSet objFile = fso.OpenTextFile(strFile, ForReading)\n\t\t\n\t\tDim strLine\n\t\tDo While objFile.AtEndOfStream &lt;&gt; True\n\t\t\tstrLine = Trim(objFile.ReadLine)\n\t\t\t\n\t\t\t&#039;Ignore lines that start with #\n\t\t\tIf Left(strLine, 1) &lt;&gt; &quot;#&quot; Then\n\t\t\t\toDic.Item(strLine) = &quot;placeholder&quot;\n\t\t\tEnd If\n\t\tLoop\n\tEnd If\n\t\n\tSet GetPatchExclusions = oDic\nEnd Function\n\nFunction GetValidScanFiles\n\t&#039; if global constant bCustomCabSupport is True\n\t&#039; Returns a dictionary of valid scan results files\n\t&#039; which are those that are based on cab files which exist\n\tDim dictScanResultFiles,objFSO,objCabFolder,objFile,strToolsDir\n\tDim strExtraCabDir,strResultsReadablePath,strScanDir,strCabPath\n\tSet dictScanResultFiles = CreateObject(&quot;Scripting.Dictionary&quot;)\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tstrToolsDir = GetTaniumDir(&quot;Tools&quot;)\n\tstrScanDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\n\tIf bCustomCabSupport Then\n\t\tstrExtraCabDir = strToolsDir&amp;&quot;ExtraPatchCabs&quot;\n\t\tIf objFSO.FolderExists(strExtraCabDir) Then\n\t\t\tSet objCabFolder = objFSO.GetFolder(strExtraCabDir)\n\t\t\tFor Each objFile In objCabFolder.Files\n\t\t\t\tIf LCase(Right(objFile.Name,4)) = &quot;.cab&quot; Then\n\t\t\t\t\tstrResultsReadablePath = strScanDir&amp;&quot;patchresultsreadable-&quot;&amp;objFile.Name&amp;&quot;.txt&quot;\n\t\t\t\t\tIf Not dictScanResultFiles.Exists(strResultsReadablePath) Then\n\t\t\t\t\t\tdictScanResultFiles.Add strResultsReadablePath,objFile.Name\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tNext\n\t\tEnd If\n\tEnd If\n\t\n\t&#039; always add the default distributed wsusscn2.cab\n\tstrCabPath = strToolsDir &amp; &quot;wsusscn2.cab&quot;\n\tIf objFSO.FileExists(strCabPath) And Not dictScanResultFiles.Exists(strCabPath) Then\n\t\tdictScanResultFiles.Add strScanDir&amp;&quot;patchresultsreadable.txt&quot;,&quot;wsusscn2.cab&quot;\n\tEnd If\n\n\tSet GetValidScanFiles = dictScanResultFiles\nEnd Function &#039;GetValidScanFiles\n\nFunction EnsureSuffix(strIn,strSuffix)\n\n\tIf Not Right(strIn,Len(strSuffix)) = strSuffix Then\n\t\tEnsureSuffix = strIn&amp;strSuffix\n\tElse\n\t\tEnsureSuffix = strIn\n\tEnd If\n\t\nEnd Function &#039;EnsureSuffix\n\nFunction ReplaceCustomXPURL(strLine,strCustomDownloadURLFolder)\n\t&#039; a line may look like\n\t&#039; strLine = &quot;Security Update for Internet Explorer 6 for Windows XP Service Pack 3 (KB2953522) Custom Support|Critical|MS14-030|2014-05|http://download.windowsupdate.com/msdownload/update/csa/secu/2014/05/windowsxp-kb2953522-x86-custom-enu_c6820e06d430fa90266689e71652327c057737ea.exe,http://download.windowsupdate.com/msdownload/update/csa/secu/2014/05/windowscrapola-kb2453252-x86-custom-enu_hohogreedo.exe|windowsxp-kb2953522-x86-custom-enu_c6820e06d430fa90266689e71652327c057737ea.exe,windowsxp-kb2453252-x86-custom-enu_abacab.exe|Not Installed|1c5202d5-2f75-4f1a-a97e-506891aa31a1|0 B|KB2953522|None|fc73bc9ddef26aea82a337dff0897c13|Maybe|11|Normal&quot;\n\t&#039; For each mention of the file (in the downloadURL and the file name) there is\n\t&#039; a data string which does not appear in the actual name of the file made available\n\t&#039; from Microsoft. This function finds and removes that text.\n\t\n\tDim strBytesVal,strDownloadURLsField,arrLine\n\tarrLine = Split(strLine,strSep)\n\tIf UBound(arrLine) &gt; 7 Then\n\t\t&#039; likely valid\n\t\tstrDownloadURLsField = arrLine(4)\n\t\t&#039; LCase(strBytesVal) seems to be &quot;0 b&quot; but unsure if reliable\n\t\tstrBytesVal = arrline(8)\n\t\t&#039; also the phrase &quot;custom support&quot; seems to follow the KB indicator in title but unsure if reliable\n\t\t&#039; so use either\n\t\tIf LCase(strBytesVal) = &quot;0 b&quot; Or InStr(LCase(strLine),&quot;) custom support&quot;&amp;strSep) &gt; 0 Then &#039; seems to indicate Custom XP Patches\n\t\t\t&#039; manipulate the downloadURLs to remove everything between the last _ and the last .\n\t\t\tDim arrDownloadURLs,strDownloadURL,dictUselessData\n\t\t\tarrDownloadURLs = Split(strDownloadURLsField,&quot;,&quot;)\n\t\t\tSet dictUselessData = CreateObject(&quot;Scripting.Dictionary&quot;) &#039; hold the bits we strip away from filenames\n\t\t\tDim intLastDotPos,intLastUnderscorePos,strUselessData,intLastForwardSlashPos\n\t\t\tDim strOriginalDownloadPrefix,strNewDownloadURL,strCommaSepDownloadURLs\n\t\t\tFor Each strDownloadURL In arrDownloadURLs\n\t\t\t\tintLastDotPos = InStrRev(strDownloadURL,&quot;.&quot;)\n\t\t\t\tintLastUnderscorePos = InStrRev(strDownloadURL,&quot;_&quot;)\n\t\t\t\t&#039; will also replace the URL prefix (up to the file)\n\t\t\t\tintLastForwardSlashPos = InStrRev(strDownloadURL,&quot;/&quot;)\n\t\t\t\tstrOriginalDownloadPrefix = Left(strDownloadURL,intLastForwardSlashPos)\n\t\t\t\tstrUselessData = Mid(strDownloadURL,intLastUnderscorePos,intLastDotPos-intLastUnderscorePos)\n\t\t\t\tIf Not dictUselessData.Exists(strUselessData) Then dictUselessData.Add strUselessData,1 &#039; save for later replacement\n\t\t\t\tstrNewDownloadURL = Replace(Replace(strDownloadURL,strUselessData,&quot;&quot;),strOriginalDownloadPrefix,strCustomDownloadURLFolder)\n\t\t\t\tstrCommaSepDownloadURLs = strCommaSepDownloadURLs&amp;&quot; &quot;&amp;strNewDownloadURL\n\t\t\tNext\n\t\t\tstrCommaSepDownloadURLs = Replace(Trim(strCommaSepDownloadURLs),&quot; &quot;,&quot;,&quot;)\n\t\t\t&#039; Replace the Download URLs field from original line with the new comma separated value\n\t\t\tstrLine = Replace(strLine,strDownloadURLsField,strCommaSepDownloadURLs,1,-1,vbTextCompare)\n\t\t\t&#039; remove this unnecessary data anywhere it might exist in the files column\n\t\t\tDim strNewFilesField\n\t\t\tstrNewFilesField = arrLine(5)\n\t\t\tFor Each strUselessData In dictUselessData.Keys\n\t\t\t\tstrNewFilesField = Replace(strNewFilesField,strUselessData,&quot;&quot;,1,-1,vbTextCompare)\n\t\t\tNext\n\t\t\tstrLine = Replace(strLine,arrLine(5),strNewFilesField)\n\t\tEnd If\n\tEnd If\n\tReplaceCustomXPURL = strLine\nEnd Function &#039;ReplaceCustomXPURL\n\nFunction GetPatchManagementValueFromRegistry(strPatchManagementValue)\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPatchManagementValueData, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client\\PatchManagement&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client\\PatchManagement&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPatchManagementValueData = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\&quot;&amp;strPatchManagementValue)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPatchManagementValueData = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPatchManagementValueData = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\&quot;&amp;strPatchManagementValue)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPatchManagementValueData = &quot;&quot; Then\n  \t\tGetPatchManagementValueFromRegistry = strPatchManagementValueData\n  \tElse\n  \t\tGetPatchManagementValueFromRegistry = &quot;&quot;\n  \tEnd If\nEnd Function &#039;GetPatchManagementValueFromRegistry", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 117, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Bulletins", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Download", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Filename", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "GUID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Package Size", 
            "value_type": "DataSize"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 9, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 10, 
            "name": "CVE ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 11, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 12, 
            "name": "Reboot Required", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 13, 
            "name": "Revision", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 14, 
            "name": "Endpoint Impact", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 113, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Multi-column Sensor that shows operating system patches that are installed to this computer.  The title, severity, bulletin, date, total package size, and KB article for the patch are displayed.\nExample: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663", 
      "exclude_from_parse_flag": 1, 
      "hash": 2517008879, 
      "hidden_flag": 0, 
      "id": 223, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Installed Patches", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Installed Patches\n&#039;========================================\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput\nstrSep = &quot;|&quot;\n\n&#039;title|severity|bulletins|date|download|filename|status|guid|package size|kb|cve\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\tWScript.Echo words(0)\n\t\t\t&#039;Else \n&#039;\t\t\t\tWScript.Echo &quot;Run upgraded Patch Scan&quot;\n&#039;\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n&#039;\t\tElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\t\t\tIf Not isComplete Then\n\t\t\t\thasOutput = True\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\tif InStr(strLine, &quot;(KB&quot;) Then\n\t\t\t\t\t\tstrLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)\n\t\t\t\t\tEnd If\n\t\t\t\t\tWScript.Echo strLine\n\t\t\t\tElse\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued\n\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t&#039;If InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t&#039;\tWScript.Echo strLine\n\t\t\t\t&#039;End If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\n\tIf Not hasOutput Then\n\t\tWScript.Echo &quot;All available patches queued for installation&quot;\n\tEnd If\n\n\tobjReadFile.close\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd if\nWScript.Quit()\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 210, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Bulletins", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Download", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Filename", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "GUID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Package Size", 
            "value_type": "DataSize"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 9, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 10, 
            "name": "CVE ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 11, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 12, 
            "name": "Revision", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 114, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Shows information about patches that are installing on endpoints when the question is asked.\nExample: Title | Severity | KB Article", 
      "exclude_from_parse_flag": 1, 
      "hash": 221242344, 
      "hidden_flag": 0, 
      "id": 225, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Patches Currently Installing", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patches Currently Installing\n&#039;========================================\n\n&#039; sensor - patches currently installing\n&#039; This sensor will report the patches currently installing\n&#039; the columns look like\n&#039; title|severity|KB Article\n\nOption Explicit\n\nConst FORREADING = 1\n\nDim objFSO,objTextFile,strInstallingCurrentlyTextFilePath\nDim strScanDir\n\nDim strSep : strSep = &quot;|&quot;\nDim strLine,arrLine,strGUID,strCVE\n\nSet objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nstrScanDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\nstrInstallingCurrentlyTextFilePath = strScanDir &amp; &quot;\\installingcurrently.txt&quot;\n\nIf Not objFSO.FileExists(strInstallingCurrentlyTextFilePath) Then\n\tSet objFSO = Nothing\n\tWScript.Quit\nEnd If\n\n&#039; read contents of file\nSet objTextFile = objFSO.OpenTextFile(strInstallingCurrentlyTextFilePath,FORREADING)\n\nWhile objTextFile.AtEndOfStream = False\n\tstrLine = objTextFile.ReadLine\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t\tIf UBound(arrLine) &gt; 1 Then\n\t\t\tWScript.Echo strLine\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\tEnd If\n\tElse\n\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\tEnd If\nWend\n\nobjTextFile.Close\nSet objTextFile = Nothing\nSet objFSO = Nothing\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 115, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns Yes or No depending on whether the patch installer script is running.  This differs from the sensor \"Patches Currently Installing\" which returns the patches that are installing on endpoints.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 2350222692, 
      "hidden_flag": 0, 
      "id": 227, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Currently Running Patch Installer", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Currently Running Patch Installer\n&#039;========================================\n\n&#039;&#039; sensor to report on if a machine has been running a command and command line passed in\n&#039; for longer than a time threshold - modified for patch install\n\nOption Explicit\n\nDim intSecondsOldThreshold,strExecutableName,strCommandLinePartial\nDim strSep\n\nintSecondsOldThreshold = 30\nstrExecutableName = &quot;cscript.exe&quot;\nstrCommandLinePartial = &quot;install-patches.vbs&quot;\n\nExecutionStartTimeSecondsOld strExecutableName,strCommandLinePartial\n\nSub ExecutionStartTimeSecondsOld(strExecutable, strCommandLineMatch)\n&#039; This function will return the execution start time of exectuable / command line\n&#039; instances running.  if the executable\n&#039; passed in is running with a command line that matches part of what\n&#039; the CommandLineMatch parameter, it will be added to the count.  If the count is greater\n&#039; than one, we can assume this process is already running, so don&#039;t run the scan.\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim objWMIService,colItems\n\tDim objItem,strCmd,intRunningCount,intSecondsOld\n\n\tstrCommandLineMatch = LCase(strCommandLineMatch)\n\tintRunningCount = 0\n\tOn Error Resume Next\n\t\n\tSetLocale(1033) &#039; Uses Date Math which requires us/english to work correctly\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\t\n\tSet colItems = objWMIService.ExecQuery(&quot;Select CreationDate,CommandLine from Win32_Process where Name = &#039;&quot;&amp;strExecutable&amp;&quot;&#039;&quot;,,48)\n\tFor Each objItem in colItems\n\t\tstrCmd = LCase(objItem.CommandLine)\n\t\tIf InStr(strCmd,strCommandLineMatch) &gt; 0 Then\n\t\t\tintRunningCount = intRunningCount + 1\n\t\tEnd If\n\t\tIf intRunningCount &gt; 0 Then\n\t\t\tintSecondsOld = GetSecondsOld(ConvertDate(objItem.CreationDate))\n\t\t\tIf IsNumeric(intSecondsOld) Then\n\t\t\t\tIf intSecondsOld &gt; intSecondsOldThreshold Then\n\t\t\t\t\tWScript.Echo &quot;Yes&quot;\n\t\t\t\t\tWScript.Quit\n\t\t\t\tElse\n\t\t\t\t\tWScript.Echo &quot;No&quot;\n\t\t\t\t\tWScript.Quit\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse\n\t\t\tWScript.Echo &quot;No&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tNext\n\tOn Error Goto 0\n\t\nEnd Sub &#039;ExecutionStartTimeSecondsOld\n\nFunction ConvertDate(dtString)\n&#039;SetLocale outside of function in global scope\n\tIf Not GetLocale = 1033 Then\n\t\tWScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;\n\t\tWScript.Quit\n\tEnd If\n\t\n\tDim dtDate\n\tdtDate = left(dtString,InStr(dtString,&quot;.&quot;)-1)\n\t\n\tdtDate = CDate(Mid(dtDate, 5, 2) &amp; &quot;/&quot; &amp; _\n\t\tMid(dtDate, 7, 2) &amp; &quot;/&quot; &amp; Left(dtDate, 4) _\n\t\t&amp; &quot; &quot; &amp; Mid (dtDate, 9, 2) &amp; &quot;:&quot; &amp; _\n\t\tMid(dtDate, 11, 2) &amp; &quot;:&quot; &amp; Mid(dtDate, _\n\t\t13, 2))\n\tConvertDate = dtDate\nEnd Function &#039;ConvertDate\n\nFunction GetSecondsOld(strDate)\n\tDim objDate\n\tIf IsDate(strDate) Then\n\t\tobjDate = FormatDateTime(strDate, 0)\n\tElse\n\t\tGetSecondsOld = &quot;Bad Date Value to GetSecondsOld&quot;\n\tEnd If\n\tGetSecondsOld = DateDiff(&quot;s&quot;, objDate, Now())\nEnd Function &#039;GetSecondsOld", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 116, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Multi-column Sensor that shows operating system patches that have been excluded on this computer.  The title, severity, bulletin, date, total package size, and KB article for the patch are displayed.\nExample: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663", 
      "exclude_from_parse_flag": 1, 
      "hash": 3551011466, 
      "hidden_flag": 0, 
      "id": 229, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Patch Exclusions", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patch Exclusions\n&#039;========================================\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput\nstrSep = &quot;|&quot;\n\n&#039;title|severity|bulletins|date|download|filename|status|guid|package size|kb|cve\n\nDim strScansPath, strToolsPath\nstrToolsPath = GetTaniumDir(&quot;Tools&quot;)\nstrScansPath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = strScansPath &amp; &quot;\\patchresultsreadable.txt&quot;\n\n&#039;Set up exclusions list\nDim excludeFile\nexcludeFile = strToolsPath &amp; &quot;\\patch-exclude.txt&quot;\n\nDim objExclusions\nSet objExclusions = GetPatchExclusions(excludeFile)\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\tWScript.Echo words(0)\n\t\t\t&#039;Else \n&#039;\t\t\t\tWScript.Echo &quot;Run upgraded Patch Scan&quot;\n&#039;\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n&#039;\t\tElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\t\t\tIf Not isComplete Then\n\t\t\t\thasOutput = True\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\t&#039;if InStr(strLine, &quot;(KB&quot;) Then\n\t\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)\n\t\t\t\t\t&#039;End If\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\tElse\n\t\t\t\t\t&#039;Check to see if KB article should be excluded\n\t\t\t\t\tIf IsExclusion(strLine, objExclusions) Then\n\t\t\t\t\t\tWScript.Echo strLine\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued\n\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t&#039;If InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t&#039;\tWScript.Echo strLine\n\t\t\t\t&#039;End If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\n\tIf Not hasOutput Then\n\t\tWScript.Echo &quot;All available patches queued for installation&quot;\n\tEnd If\n\n\tobjReadFile.close\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd if\nWScript.Quit()\n\nFunction RegKeyExists(reg, sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\n\nFunction IsExclusion(strLine, objDic)\n\tDim colKeys, strKey\n\tcolKeys = objDic.Keys\n\tFor Each strKey in colKeys\n\t\tIf InStr(strLine, strSep &amp; strKey &amp; strSep) &lt;&gt; 0 Then\n\t\t\tIsExclusion = True\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\n\tIsExclusion = False\nEnd Function\n\nFunction GetPatchExclusions(strFile)\n\tDim oDic\n\tSet oDic = CreateObject(&quot;scripting.dictionary&quot;)\n\t\n\tDim fso\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tConst ForReading = 1\n\tIf fso.FileExists(strFile) Then\n\t\tDim objFile\n\t\tSet objFile = fso.OpenTextFile(strFile, ForReading)\n\t\t\n\t\tDim strLine\n\t\tDo While objFile.AtEndOfStream &lt;&gt; True\n\t\t\tstrLine = Trim(objFile.ReadLine)\n\t\t\t\n\t\t\t&#039;Ignore lines that start with #\n\t\t\tIf Left(strLine, 1) &lt;&gt; &quot;#&quot; Then\n\t\t\t\toDic.Item(strLine) = &quot;placeholder&quot;\n\t\t\tEnd If\n\t\tLoop\n\tEnd If\n\t\n\tSet GetPatchExclusions = oDic\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Bulletins", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Download", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Filename", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "GUID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Package Size", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 9, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 10, 
            "name": "CVE ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 117, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Provides a high level snapshot view of the patch application status of the environment.\nExample: More than 5 Critical Patches Required", 
      "exclude_from_parse_flag": 1, 
      "hash": 1773001148, 
      "hidden_flag": 0, 
      "id": 231, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Available Patch Status", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Available Patch Status\n&#039;========================================\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, intCriticalThreshold\nstrSep = &quot;|&quot;\nintCriticalThreshold = 5\n\nDim showSingleStatus\nshowSingleStatus = True\n\n&#039;title|severity|bulletins|date|download|filename|status|package size|kb\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\n\t&#039;note: intNone refers to patches with severity=none\n\tDim intCritical, intImportant, intModerate, intLow, intNone\n\t\n\tintCritical = 0\n\tintImportant = 0\n\tintModerate = 0\n\tintLow = 0\t\n\tintNone = 0\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\tWScript.Echo words(0)\n\t\t\tElse \n\t\t\t\tWScript.Echo &quot;Run upgraded Patch Scan&quot;\n\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\t\t\tIf Not isComplete Then\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Available&quot; patches\n\t\t\t\tElse\n\t\t\t\t\thasOutput = True\n\t\t\t\t\tSelect Case words(1)\n\t\t\t\t\t    Case &quot;Critical&quot;\n\t\t\t\t\t    \tintCritical = intCritical + 1\n\t\t\t\t\t    Case &quot;Important&quot;\n\t\t\t\t\t    \tintImportant = intImportant + 1\n\t\t\t\t\t    Case &quot;Moderate&quot;\n\t\t\t\t\t    \tintModerate = intModerate + 1\n\t\t\t\t\t    Case &quot;Low&quot;\n\t\t\t\t\t    \tintLow = intLow + 1\n\t\t\t\t\t    Case &quot;None&quot;\n\t\t\t\t\t    \tintNone = intNone + 1\n\t\t\t\t\tEnd Select\n\t\t\t\t\t\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued\n\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t&#039;If InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t&#039;\tWScript.Echo strLine\n\t\t\t\t&#039;End If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\n\tobjReadFile.close\n\n\tIf hasOutput Then\n\t\tIf intCritical &gt; 5 Then\n\t\t\tWScript.Echo &quot;More than 5 Critical Patches Required&quot;\n\t\t\tIf showSingleStatus Then WScript.Quit\n\t\tEnd If\n\t\tIf intCritical &gt; 0 Then\n\t\t\tWScript.Echo &quot;Critical Patches Required&quot;\n\t\t\tIf showSingleStatus Then WScript.Quit\n\t\tEnd If\n\t\tIf intImportant &gt; 0 Then\n\t\t\tWScript.Echo &quot;Important Patches Required&quot;\n\t\t\tIf showSingleStatus Then WScript.Quit\n\t\tEnd If\n\t\tIf intModerate &gt; 0 Then\n\t\t\tWScript.Echo &quot;Moderate Patches Required&quot;\n\t\t\tIf showSingleStatus Then WScript.Quit\n\t\tEnd If\n\t\tIf intLow &gt; 0 Then\n\t\t\tWScript.Echo &quot;Low Patches Required&quot;\n\t\t\tIf showSingleStatus Then WScript.Quit\n\t\tEnd If\n\t\tIf intNone &gt; 0 Then\n\t\t\tWScript.Echo &quot;Non-Severe Patches Required&quot;\n\t\t\tIf showSingleStatus Then WScript.Quit\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;No Security Patches Required&quot;\n\tEnd If\n\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd if\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 5, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 118, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Pulls patches which have failed to install out of a client's patch history.\nExample: title | error | date", 
      "exclude_from_parse_flag": 1, 
      "hash": 2775576456, 
      "hidden_flag": 0, 
      "id": 233, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Patch Failures", 
      "parameter_definition": "{\"parameters\":[{\"helpString\":\"Enter Yes, or No, to return failures for applicable patches only\",\"value\":\"\",\"promptText\":\"Yes/No\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Show failures only for needed patches\",\"key\":\"ShowOnlyIfApplicable\",\"values\":[\"Yes\",\"No\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patch Failures\n&#039;========================================\n\n&#039; sensor: patch failures\n&#039; paramterized sensor which can show failures for all patches\n&#039; or only for patches which are failed but necessary\n\nOption Explicit\n\nConst FORREADING = 1\n\nDim objFSO,objTextFile\nDim dictHistory\nDim strScanDir\nDim strHistoryTextReadableFilePath\nDim strSep : strSep = &quot;|&quot;\nDim strLine,arrLine,strGUID,strCVE\nDim strTitle,strKB,strBulletin,strDate,strException,strSeverity\nDim dictResults,bShowOnlyIfApplicable,strShowOnlyIfApplicable\nDim strResultsReadableFilePath,strInstallStatus,strTaniumPatchID\n\n&#039; take parameter\nstrShowOnlyIfApplicable=Trim(Unescape(&quot;||ShowOnlyIfApplicable||&quot;))\n\nSelect Case LCase(strShowOnlyIfApplicable)\n\tCase &quot;yes&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase &quot;true&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase &quot;no&quot;\n\t\tbShowOnlyIfApplicable = False\n\tCase &quot;false&quot;\n\t\tbShowOnlyIfApplicable = False\n\tCase &quot;&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase Else\n\t\tWScript.Echo &quot;Parameter must be Yes or No, Quitting&quot;\n\t\tWScript.Quit\nEnd Select\n\n\nSet objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)\nstrScanDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\n\nstrHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;\nstrResultsReadableFilePath = strScanDir&amp;&quot;patchresultsreadable.txt&quot;\n\nIf Not objFSO.FileExists(strHistoryTextReadableFilePath) Then\n\tWScript.Echo &quot;Cannot find History file&quot;\n\tSet objFSO = Nothing\n\tWScript.Quit\nEnd If\n\n&#039;uses date math, may need locale set\nSetLocale(GetTaniumLocale)\n\nSet dictHistory = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; read History into dictionary\nSet objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)\nWhile objTextFile.AtEndOfStream = False\n\tstrLine = objTextFile.ReadLine\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t\tIf UBound(arrLine) &gt; 0 Then\n\t\t\tIf Not dictHistory.Exists(strLine) Then\n\t\t\t\tdictHistory.Add strLine,1\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\tEnd If\n\tElse\n\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\tEnd If\nWend\nobjTextFile.Close\n\nSet dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)\nIf bShowOnlyIfApplicable Then\n\t&#039; We will tie the GUID in history to the GUID here - if it exists in patch results and if it says\n\t&#039; not installed, only then will we write it\n\t&#039; Read results into dictionary\n\tSet objTextFile = objFSO.OpenTextFile(strResultsReadableFilePath,FORREADING)\n\tWhile objTextFile.AtEndOfStream = False\n\t\tstrLine = objTextFile.ReadLine\n\t\t&#039; WScript.Echo strLIne \n\t\t&#039;element 5 must be not installed\n\t\tarrLine = Split(strLine,strSep)\n\t\tIf IsArray(arrLine) Then\n\t\t\tIf UBound(arrLine) &gt; 0 Then\n\t\t\t\t&#039; pull GUID to use as key\n\t\t\t\tstrGUID = arrLine(7)\n\t\t\t\tIf Not (UBound(arrLine) &gt; 4 And dictResults.Exists(strGUID)) Then\n\t\t\t\t\tdictResults.Add strGUID,strLine\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\tEnd If\n\tWend\n\tobjTextFile.Close\nEnd If\n\n\nDim strkey\n\nFor Each strkey In dictHistory.Keys\n\t&#039; WScript.Echo dictHistory.Item(strkey)\n\tstrLine = strkey\n\t&#039; 13 History Columns\n\t&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|PatchID\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t\tIf UBound(arrLine) &gt; 11 Then\n\t\t\tIf LCase(arrLine(1)) = &quot;installation&quot; And LCase(arrLine(2)) = &quot;failed&quot; Then\n\t\t\t\t&#039; install failure\n\t\t\t\t&#039; report title, kb, bulletin, date, and exception\n\t\t\t\tstrGUID = arrLine(0)\n\t\t\t\tstrTitle=arrLine(6)\n\t\t\t\tstrKB=arrLine(10)\n\t\t\t\tstrBulletin=arrLine(9)\n\t\t\t\tstrCVE = arrLine(11)\n\t\t\t\tOn Error Resume Next\n\t\t\t\t&#039; Convert from UTC to Local and show only the date\n\t\t\t\tstrDate = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)\n\t\t\t\tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t\tstrDate = &quot;Unknown&quot;\n\t\t\t\t\tErr.Clear\n\t\t\t\tEnd If\n\t\t\t\tOn Error Goto 0\n\t\t\t\tstrException=arrLine(3)\n\t\t\t\tstrSeverity=arrLine(8)\n\t\t\t\tIf UBound(arrLine) &gt; 12 Then\n\t\t\t\t\tstrTaniumPatchID=arrLine(13)\n\t\t\t\tElse\n\t\t\t\t\tstrTaniumPatchID=&quot;Unknown&quot;\n\t\t\t\tEnd If\n\t\t\t\tIf bShowOnlyIfApplicable Then\n\t\t\t\t\tIf dictResults.Exists(strGUID) Then\n\t\t\t\t\t\tstrInstallStatus = Split(dictResults.Item(strGUID),&quot;|&quot;)(6)\n\t\t\t\t\t\tIf LCase(strInstallStatus) = &quot;not installed&quot; Then\n\t\t\t\t\t\t\tWScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _\n\t\t\t\t\t\t\t\t&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _\n\t\t\t\t\t\t\t\t&amp;strSep&amp;strTaniumPatchID\n\t\t\t\t\t\tEnd If\n\t\t\t\t\tEnd If\n\t\t\t\tElse\n\t\t\t\t\tWScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _\n\t\t\t\t\t\t&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _\n\t\t\t\t\t\t&amp;strSep&amp;strTaniumPatchID\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;History Line malformed - needs 11 fields&quot;\n\t\tEnd If\n\tElse\n\t\t&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable\n\tEnd If\nNext\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale\n\nFunction GetTZBias\n&#039; This functiong returns the number of minutes\n&#039; (positive or negative) to add to current time to get UTC\n&#039; considers daylight savings\n\n\tDim objLocalTimeZone, intTZBiasInMinutes\n\n\n\tFor Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)\n\t\tintTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone\n\tNext\n\n\tGetTZBias = intTZBiasInMinutes\n\t\t\nEnd Function &#039;GetTZBias", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||ShowOnlyIfApplicable||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||ShowOnlyIfApplicable||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Error", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Bulletin ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 119, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Sensor which shows information about patches queued for install.\nExample: Security Update for Windows Server 2003 (KB2510531) | Critical | MS11-031 | 2011-04 | 947 kB | KB2510531|CVE-2011-0663", 
      "exclude_from_parse_flag": 1, 
      "hash": 1076605530, 
      "hidden_flag": 0, 
      "id": 235, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Queued Patches", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Queued Patches\n&#039;========================================\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput\nstrSep = &quot;|&quot;\n\n&#039;title|severity|bulletins|date|download|filename|status|package size|kb|cve\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\tWScript.Echo words(0)\n\t\t\t&#039;Else \n&#039;\t\t\t\tWScript.Echo &quot;Run upgraded Patch Scan&quot;\n&#039;\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n&#039;\t\tElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\t\t\tIf Not isComplete Then\n\t\t\t\thasOutput = True\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\tif InStr(strLine, &quot;(KB&quot;) Then\n\t\t\t\t\t\tstrLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)\n\t\t\t\t\tEnd If\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Queued&quot; patches\n\t\t\t\t\t&#039;WScript.Echo strLine\n&#039;\t\t\t\tElse\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Queued&quot; patches\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued \n\t\t\t\tIf InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t\tWScript.Echo strLine\n\t\t\t\tEnd If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\n\tIf Not hasOutput Then\n\t\tWScript.Echo &quot;All available patches queued for installation&quot;\n\tEnd If\n\n\tobjReadFile.close\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd if\nWScript.Quit()\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "TItle", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Bulletins", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Download", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "FIlename", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "GUID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Package Size", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 9, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 10, 
            "name": "CVE ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 11, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 12, 
            "name": "Reboot Required", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 13, 
            "name": "Revision", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 14, 
            "name": "Endpoint Impact", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 120, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns whether the client machine is 64-bit or 32-bit (x86).\nExample: X86-based PC", 
      "exclude_from_parse_flag": 0, 
      "hash": 1742036917, 
      "hidden_flag": 0, 
      "id": 237, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "x64/x86?", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039; x64-x86.vbs - returns the architecture of the machine\n\nOption Explicit\n\nIf Is64() Then\n\tWScript.Echo &quot;x64-based PC&quot;\nElse\n\tWScript.Echo &quot;x86-based PC&quot;\nEnd If\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\n\tNext\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n#http://www.stata.com/support/faqs/windows/64-bit-compliance/\n\narch=`uname -a | tr &#039;[A-Z]&#039; &#039;[a-z]&#039;`;\n\nif [[ &quot;${arch}&quot; == *x86_64* ]]; then\n\techo &quot;x64-based PC&quot;;\nelif [[ &quot;${arch}&quot; == *ia64* ]]; then\n\techo &quot;x64-based PC&quot;;\nelif [[ &quot;${arch}&quot; == *i686* ]]; then\n\techo &quot;x86-based PC&quot;;\n \nelse\n\techo &quot;&quot;;\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n#http://www.stata.com/support/faqs/windows/64-bit-compliance/\n\narch=`uname -a | tr &#039;[A-Z]&#039; &#039;[a-z]&#039;`;\n\nif [[ &quot;${arch}&quot; == *x86_64* ]]; then\n\techo &quot;x64-based PC&quot;;\nelif [[ &quot;${arch}&quot; == *ia64* ]]; then\n\techo &quot;x64-based PC&quot;;\nelif [[ &quot;${arch}&quot; == *i686* ]]; then\n\techo &quot;x86-based PC&quot;;\n \nelse\n\techo &quot;&quot;;\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 121, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The version of the Windows Update Agent on the client machine.\nExample: 7.6.7600.256", 
      "exclude_from_parse_flag": 1, 
      "hash": 2835566148, 
      "hidden_flag": 0, 
      "id": 239, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "WUA Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; WUA Version\n&#039;========================================\nOption Explicit\n\nWuaVersion()\nWScript.Quit\n\nFunction WuaVersion\n\tDim strOutput, fso, strSysDir, strWuaDll\n\t\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tstrSysDir = GetSystemDir\n\tstrWuaDll = strSysDir &amp; &quot;\\wuaueng.dll&quot;\n\tIf fso.FileExists(strWuaDll) Then\n\t\tstrOutput = fso.GetFileVersion(strWuaDll)\n\tElse \n\t\tstrOutput = &quot;WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;\n\tEnd If\n\t\n\tWScript.Echo strOutput\nEnd Function \n\nFunction GetSystemDir \n\tDim fso, fsoSys, strWinDir, strSysDir\n\tSet fsoSys = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\t&#039;Check for 64-bit sysnative directory to avoid win redirect\n\tstrWinDir = fsoSys.GetSpecialFolder(0)\n\tstrSysDir = strWinDir &amp; &quot;\\sysnative&quot;\n\t\n\tIf Not fsoSys.FolderExists(strSysDir) Then\n\t\tstrSysDir = fsoSys.GetSpecialFolder(1)\n\tEnd If\n\tGetSystemDir = strSysDir\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 122, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Returns Enabled if the user has access to Windows Update Agent configuration settings and Disabled if not.\nExample: Enabled", 
      "exclude_from_parse_flag": 1, 
      "hash": 2504149222, 
      "hidden_flag": 0, 
      "id": 241, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "WUA User Access Enabled", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; WUA User Access Enabled\n&#039;========================================\nOption Explicit\n\nIf (checkForWuaAccessDisabled = True) Then\n\tWScript.Echo &quot;Disabled&quot;\nElse\n\tWScript.Echo &quot;Enabled&quot;\nEnd If\nWScript.Quit\n\nFunction checkForWuaAccessDisabled\n\n\tDim strComputer, strKeyPath, strValueName, strValue, reg, result\n\t\n\tConst HKLM = &amp;H80000002 \n\tstrComputer = &quot;.&quot;\n\t\n\tSet reg = _\n\t    GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t    &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\t\n\t\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer&quot;\n\tstrValueName = &quot;NoWindowsUpdate&quot;\n\tstrValue = 0\n\treg.getDWordValue HKLM, strKeyPath, strValueName, strValue\n\tIf strValue &lt;&gt; 1 Then\n\t\tcheckForWuaAccessDisabled = False\n\t\tExit Function\n\tEnd If\n\t\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer&quot;\n\tstrValueName = &quot;NoDevMgrUpdate&quot;\n\tstrValue = 0\n\treg.getDWordValue HKLM, strKeyPath, strValueName, strValue\n\tIf strValue &lt;&gt; 1 Then\n\t\tcheckForWuaAccessDisabled = False\n\t\tExit Function\n\tEnd If\t\n\t\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\don&#039;t load&quot;\n\tstrValueName = &quot;wuaucpl.cpl&quot;\n\tstrValue = null\n\treg.getStringValue HKLM, strKeyPath, strValueName, strValue\n\tIf IsNull(strValue) Then\n\t\tcheckForWuaAccessDisabled = False\n\t\tExit Function\n\tEnd If\n\n\tcheckForWuaAccessDisabled = True\n\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 123, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "Details about all running services on the client machine, including name, display name, running status, and startup mode.\nExample: MDM | Machine Debug Manager | Running | Auto", 
      "exclude_from_parse_flag": 1, 
      "hash": 2384520458, 
      "hidden_flag": 0, 
      "id": 243, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Service Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Service Details\n&#039;========================================\n\ngetServiceDetails()\nWScript.Quit\n\nFunction getServiceDetails()\n\t&#039;Check to see if Windows Update Service needs to be enabled and/or stopped at end\n\tDim objWMIService, colComputer, objComputer\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n\tSet colServices = objWMIService.ExecQuery (&quot;select DisplayName, State, StartMode from win32_Service&quot;)    \n\t\n\tFor Each objService in colServices\n\t\tstrServiceName = objService.Name\n\t\tstrServiceDisplayName = objService.DisplayName\n\t\tstrServiceStatus = objService.State\n\t\tstrServiceMode = objService.StartMode\n\t\tWScript.Echo strServiceName &amp; &quot;|&quot; &amp; strServiceDisplayName &amp; &quot;|&quot; &amp; strServiceStatus &amp; &quot;|&quot; &amp; strServiceMode\n\tNext\n\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Service Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Service Display Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Service Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Service Startup Mode", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 124, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "The settings for the Windows Update Agent on the client machine.\nAutomatic Install|Every Day 3:00 AM", 
      "exclude_from_parse_flag": 1, 
      "hash": 4118090245, 
      "hidden_flag": 0, 
      "id": 245, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "WUA Settings", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;\n&#039; wua-settings.vbs\n&#039;\n&#039; Retrieves the settings for automatic update\n&#039;\n\nOption Explicit\n\nDim objAutoUpdate, objSettings\nDim strLevel, strScheduledTime\n\nSet objAutoUpdate = CreateObject(&quot;Microsoft.Update.AutoUpdate&quot;)\nSet objSettings = objAutoUpdate.Settings\n\nstrLevel=&quot;Unknown&quot;\nstrScheduledTime=&quot;N/A&quot;\n\nSelect Case objSettings.NotificationLevel\n    Case 0\n    \tstrLevel = &quot;Not Configured&quot;\n    Case 1\n        strLevel = &quot;Disabled&quot;\n    Case 2\n      \tstrLevel = &quot;User Prompted Before Downloading&quot;\n      \t&#039;strScheduledTime = GetScheduledString(objSettings)\n    Case 3\n\t\tstrLevel = &quot;User Prompted Before Installing&quot;             \n      \t&#039;strScheduledTime = GetScheduledString(objSettings)\n    Case 4\n     \tstrLevel = &quot;Automatic Install&quot;       \n      \tstrScheduledTime = GetScheduledString(objSettings)\nEnd Select\n\nWScript.Echo strLevel &amp; &quot;|&quot; &amp; strScheduledTime\n\nFunction GetScheduledString(objSettings)\n\tDim strResult, strScheduledTime\n\n\tSelect Case objSettings.ScheduledInstallationDay\n\t    Case 0\n\t        strResult = &quot;Every Day&quot;\n\t    Case 1\n\t        strResult = &quot;Sunday&quot;\n\t    Case 2\n\t        strResult = &quot;Monday&quot;\n\t    Case 3\n\t        strResult = &quot;Tuesday&quot;\n\t    Case 4\n\t        strResult = &quot;Wednesday&quot;\n\t    Case 5\n\t        strResult = &quot;Thursday&quot;\n\t    Case 6\n\t        strResult = &quot;Friday&quot;\n\t    Case 7\n\t        strResult = &quot;Saturday&quot;\n\t    Case Else\n\t        strResult = &quot;Unknown&quot;\n\tEnd Select\n\t\n\tIf objSettings.ScheduledInstallationTime = 0 Then\n\t    strResult = strResult &amp; &quot; 12:00 AM&quot;\n\tElseIf objSettings.ScheduledInstallationTime = 12 Then\n\t    strResult = strResult &amp; &quot; 12:00 PM&quot;\n\tElse\n\t    If objSettings.ScheduledInstallationTime &gt; 12 Then\n\t        intScheduledTime = objSettings.ScheduledInstallationTime - 12\n\t        strScheduledTime = intScheduledTime &amp; &quot;:00 PM&quot;\n\t    Else\n\t        strScheduledTime = objSettings.ScheduledInstallationTime &amp; &quot;:00 AM&quot;\n\t    End If\n\t    strResult = strResult &amp; &quot; &quot; &amp; strScheduledTime\n\tEnd If\n\n\tGetScheduledString = strResult\nEnd Function &#039; GetScheduledString", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Mode", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Schedule", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 125, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "3rd party applications that are not up to the latest published version.  This multi-column Sensor provides the name of the software, the publisher, the architecture (32-bit or 64-bit), the current version, the latest version, and the status\nExample: \"Adobe Reader | Adobe | 32-bit | 10.1.4 | 10.1.4 | Up to Date", 
      "exclude_from_parse_flag": 1, 
      "hash": 4203533580, 
      "hidden_flag": 0, 
      "id": 247, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Out of Date Managed Applications", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Out of Date Managed Applications\n&#039;========================================\n\nOption Explicit\nDim strSep\nstrSep = &quot;|&quot;\n\nDim strSearch\nstrSearch = &quot;Out of Date&quot;\n\nDim strReadablePath\nstrReadablePath = GetTaniumDir(&quot;&quot;) &amp; &quot;\\Tools\\Scans\\maresultsreadable.txt&quot;\n\nDim objFso\nSet objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nIf objFso.FileExists(strReadablePath) Then\n\tDim objReadFile\n\tSet objReadFile = objFSO.OpenTextFile(strReadablePath, 1, False)\n\n\tDim strLine\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\t\t\n\t\tIf InStr(strLine, strSearch) &gt; 0 Or InStr(strLine, &quot;Error:&quot;) Then\n\t\t\tWScript.Echo strLine\n\t\tEnd If\n\tLoop\nElse\n\tWScript.Echo &quot;Error: managed applications results not found&quot;\nEnd If\n\nFunction RegKeyExists(reg, sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Publisher", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Architecture", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Current Version", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Latest Version", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Filename", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "Download", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Command", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 126, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": "|", 
      "description": "3rd party applications that are up to the latest published version.  This multi-column Sensor provides the name of the software, the publisher, the architecture (32-bit or 64-bit), the current version, the latest version, and the status\nExample: \"Adobe Reader | Adobe | 32-bit | 10.1.4 | 10.1.4 | Up to Date", 
      "exclude_from_parse_flag": 1, 
      "hash": 4122594545, 
      "hidden_flag": 0, 
      "id": 249, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Up to Date Managed Applications", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Up to Date Managed Applications\n&#039;========================================\nOption Explicit\nDim strSep\nstrSep = &quot;|&quot;\n\nDim strSearch\nstrSearch = &quot;Up to Date&quot;\n\nDim strReadablePath\nstrReadablePath = GetTaniumDir(&quot;&quot;) &amp; &quot;\\Tools\\Scans\\maresultsreadable.txt&quot;\n\nDim objFso\nSet objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nIf objFso.FileExists(strReadablePath) Then\n\tDim objReadFile\n\tSet objReadFile = objFSO.OpenTextFile(strReadablePath, 1, False)\n\n\tDim strLine\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\t\t\n\t\tIf InStr(strLine, strSearch) &gt; 0 Or InStr(strLine, &quot;Error:&quot;) Then\n\t\t\tWScript.Echo strLine\n\t\tEnd If\n\tLoop\nElse\n\tWScript.Echo &quot;Error: managed applications results not found&quot;\nEnd If\n\nFunction RegKeyExists(reg, sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Publisher", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Architecture", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Current Version", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Latest Version", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Filename", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "Download", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Command", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 127, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "The speed of the processor in Mhz.\nExample: 3200 Mhz", 
      "exclude_from_parse_flag": 1, 
      "hash": 1646244079, 
      "hidden_flag": 0, 
      "id": 251, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "CPU Speed Mhz", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CPU Speed Mhz\n&#039;========================================\n\nOn Error Resume Next\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\nSet colItems = objWMIService.ExecQuery(&quot;select MaxClockSpeed from win32_processor&quot;)\n\nFor Each objItem in colItems\n    strSpeed = objItem.MaxClockSpeed\n    intSpeed = CInt(CInt(strSpeed)/10)*10\n    WScript.Echo intSpeed &amp; &quot; Mhz&quot;\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nline=$(grep -m 1 -i &quot;cpu MHz&quot; /proc/cpuinfo)\nset -- $line\nTGHZ=&quot;`echo ${line#*:} | awk &#039;{ printf &quot;%0.1f&quot;, $0/1000 }&#039;`&quot;\nTMHZ=&quot;`echo &quot;$TGHZ&quot; | awk &#039;{ print ($0 * 1000) }&#039;`&quot;\n#echo &quot;$TGHZ GHz&quot;\necho &quot;$TMHZ MHz&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nftemp=$(mktemp -t &#039;apps.xml&#039;)\nsystem_profiler -xml SPHardwareDataType &gt; &quot;$ftemp&quot;\n\ncpu=`/usr/libexec/PlistBuddy -c &quot;Print :0:_items:0:current_processor_speed&quot; $ftemp 2&gt;/dev/null | awk -F &#039; &#039; &#039;{print $1}&#039;`\nt=&quot;$(echo &quot;$cpu*1000&quot; | bc)&quot;\necho $t | awk -F &#039;.&#039; &#039;{print $1&quot; Mhz&quot;}&#039;\n\nrm -rf &quot;$ftemp&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 128, 
      "category": "Software", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Indicates whether the client machine has been online for more than 30 days.\nExample: Less than 30 days", 
      "exclude_from_parse_flag": 1, 
      "hash": 1263879283, 
      "hidden_flag": 0, 
      "id": 253, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "High Uptime", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; High Uptime\n&#039;========================================\n\nstrComputer = &quot;.&quot;     \nset objWMIDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)  \nset objWMI = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nset colOS = objWMI.InstancesOf(&quot;Win32_OperatingSystem&quot;)  \n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nfor each objOS in colOS   \nobjWMIDateTime.Value = objOS.LastBootUpTime              \nIf TimeSpan(objWMIDateTime.GetVarDate,Now) &gt; 30 Then          \nWscript.echo TimeSpan(objWMIDateTime.GetVarDate,Now) &amp; &quot; days&quot;  \nElse          \nWscript.echo &quot;Less than30&quot;          \nEnd If  \nnext    \nFunction TimeSpan(dt1, dt2)    \nIf (isDate(dt1) And IsDate(dt2)) = false Then     \nTimeSpan = &quot;00:00:00&quot;     \nExit Function           \nEnd If              \nseconds = Abs(DateDiff(&quot;S&quot;, dt1, dt2))           \nminutes = seconds \\ 60           \nhours = minutes \\ 60           \ndays = hours \\ 24           \nminutes = minutes mod 60           \nseconds = seconds mod 60              \nTimeSpan = days  \nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 129, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Lists the specified number of processes that are using the highest amount of CPU.\nExample: cmd", 
      "exclude_from_parse_flag": 1, 
      "hash": 2711879278, 
      "hidden_flag": 0, 
      "id": 255, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "High CPU Processes", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":50,\"stepSize\":1,\"helpString\":\"Enter the number of processes to return\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Processes\",\"minimum\":1,\"key\":\"numOutput\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; High CPU Processes\n&#039;========================================\n\ntopNum = Trim(Unescape(&quot;||numOutput||&quot;))\nIf Not IsNumeric(topNum) Then \n\tWScript.Echo &quot;Parameter Not Number&quot;\n\tWScript.Quit\nEnd If \ntopNum = Cint(topNum)\n\nprintPercent = false\nConst HKLM = &amp;H80000002 \nstrComputer = &quot;.&quot;\n\nSet objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)\n\nConst MaxCharacters = 255\nConst adBSTR = 8 \nConst adDouble = 5\n\nSet DataList = CreateObject(&quot;ADOR.Recordset&quot;)\nDataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters\nDataList.Fields.Append &quot;ProcessCPU1&quot;, adDouble\nDataList.Fields.Append &quot;ProcessCPU2&quot;, adDouble\nDataList.Fields.Append &quot;ProcessCPUDiff&quot;, adDouble\nDataList.Open\n\nDim total1, total2, totalDiff\n\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   \nFor Each objItem in colProcItems\n   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then\n      DataList.AddNew\n      DataList(&quot;ProcessName&quot;) = objItem.Name\n      DataList(&quot;ProcessCPU1&quot;) = objItem.PercentProcessorTime\n      DataList.Update\n   ElseIf objItem.Name = &quot;_Total&quot; Then \n      total1 = CDbl(objItem.PercentProcessorTime)\n   End If\nNext\n\nsleep = 5\nWScript.Sleep(sleep * 1000)\n\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   \nFor Each objItem in colProcItems\n   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then\n      \n      DataList.MoveFirst\n      DataList.Find(&quot;ProcessName = &#039;&quot;&amp; objItem.Name&amp;&quot;&#039;&quot;)\n\n      If DataList.EOF Then\n              WScript.Echo &quot;** Not Found **&quot;\n      Else\n         DataList(&quot;ProcessCPU2&quot;) = objItem.PercentProcessorTime\n         DataList(&quot;ProcessCPUDiff&quot;) = DataList(&quot;ProcessCPU2&quot;) - DataList(&quot;ProcessCPU1&quot;)\n         DataList.Update\n           &#039;WScript.Echo &quot;name: &quot; &amp; DataList.Fields.Item(&quot;ProcessName&quot;) &amp; &quot;, cpu 1: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU1&quot;) &amp; &quot;, cpu 2: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU2&quot;)\n      End if\n   ElseIf objItem.Name = &quot;_Total&quot; Then \n      total2 = CDbl(objItem.PercentProcessorTime)\n      totalDiff = total2 - total1\n   End If\nNext\n\nDataList.Sort = &quot;ProcessCPUDiff DESC&quot;\nDataList.MoveFirst\ni = 1\nDo Until DataList.EOF  Or i &gt; topNum\n   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))\n   If printPercent Then\n      strPrint = strPrint &amp; &quot; (&quot; &amp; Round(DataList.Fields.Item(&quot;ProcessCPUDiff&quot;) / totalDiff * 100, 0) &amp; &quot;%)&quot;\n   End if   \n   WScript.Echo strPrint\n   DataList.MoveNext\n   i = i + 1\nLoop\n\nWScript.Quit\n\n&#039;removes .exe and process number at end of \nFunction CleanString(str)\n\twords = Split(str, &quot;#&quot;)\n\tstr = words(0)\n\tCleanString = str\n\n\tIf Right(str, 4) = &quot;.exe&quot; Then\n\t\tstr = Left(str, Len(str) - 4)\n\tEnd If \nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||numOutput||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||numOutput||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 130, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "Lists the specified number processes based on ordering on amount of memory used.\nExample: cmd", 
      "exclude_from_parse_flag": 1, 
      "hash": 1527458369, 
      "hidden_flag": 0, 
      "id": 257, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "High Memory Processes", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":50,\"stepSize\":1,\"helpString\":\"Enter the number of processes to return\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Processes\",\"minimum\":1,\"key\":\"numOutput\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; High Memory Processes\n&#039;========================================\n\ntopNum = Trim(Unescape(&quot;||numOutput||&quot;))\nIf Not IsNumeric(topNum) Then \n\tWScript.Echo &quot;Parameter Not Number&quot;\n\tWScript.Quit\nEnd If \ntopNum = Cint(topNum)\n\nprintMemory = false\n\nDim objWMIService, objItem, colItems, query\nDim strComputer, strList\n\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer&amp; &quot;\\root\\cimv2&quot;)\n\nConst MaxCharacters = 255\nConst adBSTR = 8 \nConst adDouble = 5\nSet DataList = CreateObject(&quot;ADOR.Recordset&quot;)\nDataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters\nDataList.Fields.Append &quot;ProcessMemory&quot;, adDouble\n\nDataList.Open\n\nSet colProcs = objWMIService.ExecQuery(&quot;Select Name, WorkingSetSize From Win32_Process&quot;)\nFor Each proc in colProcs\n   DataList.AddNew\n   DataList(&quot;ProcessName&quot;) = proc.Name\n   DataList(&quot;ProcessMemory&quot;) = round(cdbl(proc.WorkingSetSize)/1024/1024, 0)\n   DataList.Update\nNext\nDataList.Sort = &quot;ProcessMemory DESC&quot;\nDataList.MoveFirst\ni = 1\nDo Until DataList.EOF Or i &gt; topNum\n   Set field = DataList.Fields\n   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))\n   If printMemory Then\n      strPrint = strPrint &amp; &quot; (&quot; &amp; DataList.Fields.Item(&quot;ProcessMemory&quot;) &amp; &quot; Mb)&quot;\n   End if   \n   WScript.Echo strPrint\n   DataList.MoveNext\n   i = i + 1\nLoop\n\nWScript.Quit\n\n&#039;removes .exe and process number at end of process\nFunction CleanString(str)\n\twords = Split(str, &quot;#&quot;)\n\tstr = words(0)\n\n\tIf Right(str, 4) = &quot;.exe&quot; Then\n\t\tstr = Left(str, Len(str) - 4)\n\tEnd If \n\tCleanString = str\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||numOutput||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||numOutput||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 131, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:02", 
      "delimiter": ",", 
      "description": "If a drive has less free space than the configured threshold, the drive and remaining free space is returned.  The threshold defaults to 2048 MB and can be altered.\nExample: C: 1 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 1043670154, 
      "hidden_flag": 0, 
      "id": 259, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:02", 
      "name": "Disk Free Space Below Threshold", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Disk Free Space Below Threshold\n&#039;========================================\n\nmbThreshold = 2048\n\nstrComputer = &quot;.&quot;  \nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nSet colDisks = objWMIService.ExecQuery (&quot;Select * from Win32_LogicalDisk where DriveType=3&quot;)    \nFor Each objDisk in colDisks      \nFreeMB = objDisk.FreeSpace/1024000    \nif (FreeMB &lt;&gt; &quot;&quot; and FreeMB &lt; mbThreshold and FreeMB &lt;&gt; 0) THEN      \nFreeGB = FreeMB/1024      \nWscript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; Round(FreeGB) &amp; &quot; GB&quot;    \nEND IF  \nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 132, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns a list of all services currently stopped on the client machine.\nExample: DHCP Client", 
      "exclude_from_parse_flag": 1, 
      "hash": 3188527889, 
      "hidden_flag": 0, 
      "id": 261, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Stopped Service", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from win32_Service where State=&#039;Stopped&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nfirst=true\nlaunchctl list | while read line\ndo\n    set -- $line\nif ( $first ); \nthen\n\tfirst=false\nelse\n\tif [ &quot;$2&quot; == &quot;0&quot; ]; \n\tthen\n\t\techo $3\n\tfi\nfi\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 133, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "The number of databases in SQL Server on the client machine.\nExample: 4", 
      "exclude_from_parse_flag": 1, 
      "hash": 3271577967, 
      "hidden_flag": 0, 
      "id": 263, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Database Count", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Database Count\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\nDim dictInstances, strInstance, objConnection\n\nSet dictInstances = GetMSSQLInstances()\n\nFor Each strInstance In dictInstances.Keys\n \tDim objRecordSet, objRecord, strValue\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  \n\t\n\tOn Error Resume Next\n\tobjConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)\n\t\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\t\n\tOn Error Goto 0\n\t\n\tobjRecordSet.Open &quot;select count(name) as count from master..sysdatabases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  \n\tobjRecordSet.MoveFirst  \n\tFor each objRecord in objRecordSet.Properties    \n\t\tstrValue = objRecordSet(&quot;count&quot;)    \n\t\tWScript.echo strValue &amp; GetMSSQLSensorInstanceStr(strInstance)\n\t\tobjRecordSet.MoveNext    \n\t\tIf (objRecordset.EOF = True) THEN       \n\t\t\tobjRecordset.Close       \n\t\t\tExit For    \n\t\tEnd If \n\tNext \nNext\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 134, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the Edition of SQL Server installed on the client machine if it exists.\nExample: Enterprise Edition (64-bit)", 
      "exclude_from_parse_flag": 1, 
      "hash": 749653644, 
      "hidden_flag": 0, 
      "id": 265, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Server Edition", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Server Edition\n&#039;========================================\nOption Explicit\n\nConst MAX_SQL_NUMBER = 15\nConst DEBUG_OUT = False\nDim strValueName, strSKUName, strEdition, strVersion, strArchitecture \nDim objWMI, dictWMIs, objProp, strOut, dictServices\n\nSet dictWMIs = CreateObject(&quot;Scripting.Dictionary&quot;)\nSet dictServices = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\nBuildSQLCompMgmtWMIsDict(dictWMIs)\n\nPrintProp &quot;SKUNAME&quot;\n\nFunction IsMultiple(ByRef dictWMIs)\n\n\tIf dictWMIs.Count &gt; 1 Then\n\t\tIsMultiple = True\n\tElse\n\t\tIsMultiple = False\n\tEnd If\n\t\nEnd Function &#039;IsMultiple\n\nSub PrintProp(strProp)\n\tDim intOutCount\n\tintOutCount = 1\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\tElse\n\t\tFor Each objWMI In dictWMIs.Keys\n\t\t\tstrOut = GetSQLServiceAdvancedProp(strProp,objWMI)\n\t\t\tIf Len(strOut) &gt; 0 Then\n\t\t\t\tintOutCount = intOutCount + 1\n\t\t\t\tWScript.Echo strOut\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\t\t\tDebugPrint &quot;SQL Property Not Found&quot;\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\nEnd Sub &#039;PrintProp \n\nFunction PrintServices\n\tBuildSQLServicesNames objWMI,dictServices\n\t&#039; Print Services\n\tDim strService\n\tFor Each strService In dictServices.Keys\n\t\tWScript.Echo strService\n\tNext\nEnd Function &#039;PrintServices\n\nFunction GetBitnessFromSKU(strSKUName)\n&#039; Returns appropriate bitness from SKU value\n\tDim strArchitecture\n\tIf Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then\n\t    strArchitecture = &quot;64-bit&quot;\n\tElse\n\t    strArchitecture = &quot;32-bit&quot;\n\tEnd If\n\tGetBitnessFromSKU = strArchitecture\n\t\nEnd Function &#039;GetBitnessFromSKU\n\nFunction GetCleanEdition(strSKUName)\n&#039; Removes bitness from SKU value\n\tDim strEdition\n\tIf Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then\n\t    strEdition = Left(strSKUName, Instr(strSKUName, &quot; (&quot;))\n\tElse\n\t    strEdition = strSKUName\n\tEnd If\n\n\tGetCleanEdition = strEdition\n\t\nEnd Function &#039;CleanSKU\n\nFunction GetSQLServiceAdvancedProp(strProp,ByRef objWMI)\n&#039; Property Names may change for different SQL versions\n&#039;SQLSTATES,VERSION,SPLEVEL,CLUSTERED,INSTALLPATH,DATAPATH,LANGUAGE,FILEVERSION,\n&#039;VSNAME,REGROOT,SKU,SKUNAME,INSTANCEID,STARTUPPARAMETERS,ERRORREPORTING,DUMPDIR,\n&#039;SQMREPORTING,ISWOW64\n\tOn Error Resume Next\n\tDim strOut, intType, strPropVal, colResults\n\tstrProp = UCase(strProp) &#039; text matches will happen when uppercased\n\tSet colResults = objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)\n\tFor Each objProp In colResults\n\t    If objProp.PropertyName = strProp Then\n\t    \tintType = objProp.PropertyValueType\n\t    \tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\tDebugPrint Err.Description &amp; &quot; inttype is &quot; &amp; objProp.PropertyValueType\n\t\t\t\tErr.Clear\n\t\t\tEnd If\t\n\t    \tIf intType = 0 Then\n\t        \tstrOut = objProp.PropertyStrValue\n\t\t      \tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t\tDebugPrint Err.Description &amp; &quot; strout is &quot; &amp; objProp.PropertyStrValue\n\t\t\t\t\tErr.Clear\n\t\t\t\tEnd If\t  \t\n\t        Else\n\t        \tstrOut = objProp.PropertyNumValue\n\t        End If\n\t\tEnd If\n\tNext\n\n\tErr.Clear\n\tOn Error Goto 0\n\tGetSQLServiceAdvancedProp = strOut\n\n\tIf DEBUG_OUT = True Then\n\t\tWScript.Echo &quot;Debug, listing all props &quot;\n\t\tOn Error Resume Next\n\t\tFor Each objProp In colResults\n\t    \tintType = objProp.PropertyValueType\n\n\t    \tIf intType = 0 Then\n\t        \tstrOut = objProp.PropertyStrValue\t\n\t        Else\n\t        \tstrOut = objProp.PropertyNumValue\n\t        End If\n\t\tWScript.Echo &quot;Property name: &quot;&amp;objProp.PropertyName&amp;&quot;, valuetype: &quot;&amp;intType&amp;&quot;, value: &quot;&amp;strOut\n\t   \tNext\n\t End If\nEnd Function &#039;GetSQLServiceAdvancedProp\n\nSub BuildSQLServicesNames(ByRef objWMI,ByRef dictServices)\n\n\tDim strService\n\t\n\tFor Each objProp In objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)\n\t\tstrService = objProp.ServiceName\n\t\tIf Not IsNull(strService) Then\n\t\t\tIf Not dictServices.Exists(strService) Then\n\t\t\t\tdictServices.Add strService,1\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\t\t\nEnd Sub &#039;BuildSQLServicesNames\n\nSub DebugPrint(ByRef strToPrint)\n\n\tIf DEBUG_OUT Then\n\t\tWScript.Echo strToPrint\n\tEnd If\nEnd Sub &#039;DebugPrint\n\nSub BuildSQLCompMgmtWMIsDict(ByRef dictWMIs)\n\n\t&#039; Define a constant MAX_SQL_NUMBER in global scope\n\tDim objWMI,i,strWMINameSpace\n\tOn Error Resume Next\n\n    &#039; First try 2005\n    strWMINameSpace = &quot;WINMGMTS:\\\\.\\root\\Microsoft\\SqlServer\\ComputerManagement&quot;\n    Set objWMI = GetObject(strWMINameSpace)\n    If Err.Number = 0 Then\n    \tdictWMIs.Add objWMI,strWMINameSpace\n    \tDebugPrint strWMINameSpace\n    Else\n    \tErr.Clear\n    \t&#039; Loop through 2008 to 2012 and beyond\n        For i = 10 To MAX_SQL_NUMBER\n        \tstrWMINameSpace = &quot;WINMGMTS:\\\\.\\root\\Microsoft\\SqlServer\\ComputerManagement&quot;&amp;CStr(i)\n        \tSet objWMI = GetObject(strWMINameSpace)\n        \tIf Err.Number = 0 Then\n        \t\tdictWMIs.Add objWMI,strWMINameSpace\n        \t\tDebugPrint strWMINameSpace\n        \tElse\n        \t\tErr.Clear\n        \tEnd If\n        Next\n\tEnd If\n\t\n\tErr.Clear\n\tOn Error Goto 0\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\tWScript.Quit\n\tEnd If\n\t\nEnd Sub &#039;BuildSQLCompMgmtWMIsDict", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 135, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Product version from SQL Server on client machine.\nExample: 10.50.1617.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 2195303088, 
      "hidden_flag": 0, 
      "id": 267, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Product Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Product Version\n&#039;========================================\nOption Explicit\n\nConst MAX_SQL_NUMBER = 15\nConst DEBUG_OUT = False\nDim strValueName, strSKUName, strEdition, strVersion, strArchitecture \nDim objWMI, dictWMIs, objProp, strOut, dictServices\n\nSet dictWMIs = CreateObject(&quot;Scripting.Dictionary&quot;)\nSet dictServices = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\nBuildSQLCompMgmtWMIsDict(dictWMIs)\n\nPrintProp(&quot;VERSION&quot;)\n\nFunction IsMultiple(ByRef dictWMIs)\n\n\tIf dictWMIs.Count &gt; 1 Then\n\t\tIsMultiple = True\n\tElse\n\t\tIsMultiple = False\n\tEnd If\n\t\nEnd Function &#039;IsMultiple\n\nSub PrintSPLevel\n\tDim strProp,intOutCount\n\n\tstrProp = &quot;SPLEVEL&quot;\n\tintOutCount = 1\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\tElse\n\t\tFor Each objWMI In dictWMIs.Keys\n\t\t\tstrOut = GetSQLServiceAdvancedProp(strProp,objWMI)\n\t\t\tIf Len(strOut) &gt; 0 Then\n\t\t\t\tintOutCount = intOutCount + 1\n\t\t\t\tIf strOut = 0 Then\n\t\t\t\t\tWScript.Echo &quot;RTM&quot;\n\t\t\t\tElseIf IsNumeric(strOut) Then\n\t\t\t\t\tWScript.Echo &quot;SP&quot;&amp;strOut\n\t\t\t\tElse\n\t\t\t\t\tWScript.Echo strOut\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\t\t\tDebugPrint &quot;SQL Property Not Found&quot;\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\nEnd Sub &#039;PrintProp \n\nSub PrintProp(strProp)\n\tDim intOutCount\n\tintOutCount = 1\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\tElse\n\t\tFor Each objWMI In dictWMIs.Keys\n\t\t\tstrOut = GetSQLServiceAdvancedProp(strProp,objWMI)\n\t\t\tIf Len(strOut) &gt; 0 Then\n\t\t\t\tintOutCount = intOutCount + 1\n\t\t\t\tWScript.Echo strOut\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\t\t\tDebugPrint &quot;SQL Property Not Found&quot;\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\nEnd Sub &#039;PrintProp \n\nFunction PrintServices\n\tBuildSQLServicesNames objWMI,dictServices\n\t&#039; Print Services\n\tDim strService\n\tFor Each strService In dictServices.Keys\n\t\tWScript.Echo strService\n\tNext\nEnd Function &#039;PrintServices\n\nFunction GetBitnessFromSKU(strSKUName)\n&#039; Returns appropriate bitness from SKU value\n\tDim strArchitecture\n\tIf Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then\n\t    strArchitecture = &quot;64-bit&quot;\n\tElse\n\t    strArchitecture = &quot;32-bit&quot;\n\tEnd If\n\tGetBitnessFromSKU = strArchitecture\n\t\nEnd Function &#039;GetBitnessFromSKU\n\nFunction GetCleanEdition(strSKUName)\n&#039; Removes bitness from SKU value\n\tDim strEdition\n\tIf Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then\n\t    strEdition = Left(strSKUName, Instr(strSKUName, &quot; (&quot;))\n\tElse\n\t    strEdition = strSKUName\n\tEnd If\n\n\tGetCleanEdition = strEdition\n\t\nEnd Function &#039;CleanSKU\n\nFunction GetSQLServiceAdvancedProp(strProp,ByRef objWMI)\n&#039; Property Names may change for different SQL versions\n&#039;SQLSTATES,VERSION,SPLEVEL,CLUSTERED,INSTALLPATH,DATAPATH,LANGUAGE,FILEVERSION,\n&#039;VSNAME,REGROOT,SKU,SKUNAME,INSTANCEID,STARTUPPARAMETERS,ERRORREPORTING,DUMPDIR,\n&#039;SQMREPORTING,ISWOW64\n\tOn Error Resume Next\n\tDim strOut, intType, strPropVal, colResults\n\tstrProp = UCase(strProp) &#039; text matches will happen when uppercased\n\tSet colResults = objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)\n\tFor Each objProp In colResults\n\t    If objProp.PropertyName = strProp Then\n\t    \tintType = objProp.PropertyValueType\n\t    \tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\tDebugPrint Err.Description &amp; &quot; inttype is &quot; &amp; objProp.PropertyValueType\n\t\t\t\tErr.Clear\n\t\t\tEnd If\t\n\t    \tIf intType = 0 Then\n\t        \tstrOut = objProp.PropertyStrValue\n\t\t      \tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t\tDebugPrint Err.Description &amp; &quot; strout is &quot; &amp; objProp.PropertyStrValue\n\t\t\t\t\tErr.Clear\n\t\t\t\tEnd If\t  \t\n\t        Else\n\t        \tstrOut = objProp.PropertyNumValue\n\t        End If\n\t\tEnd If\n\tNext\n\n\tErr.Clear\n\tOn Error Goto 0\n\tGetSQLServiceAdvancedProp = strOut\n\n\tIf DEBUG_OUT = True Then\n\t\tWScript.Echo &quot;Debug, listing all props &quot;\n\t\tOn Error Resume Next\n\t\tFor Each objProp In colResults\n\t    \tintType = objProp.PropertyValueType\n\n\t    \tIf intType = 0 Then\n\t        \tstrOut = objProp.PropertyStrValue\t\n\t        Else\n\t        \tstrOut = objProp.PropertyNumValue\n\t        End If\n\t\tWScript.Echo &quot;Property name: &quot;&amp;objProp.PropertyName&amp;&quot;, valuetype: &quot;&amp;intType&amp;&quot;, value: &quot;&amp;strOut\n\t   \tNext\n\t End If\nEnd Function &#039;GetSQLServiceAdvancedProp\n\nSub BuildSQLServicesNames(ByRef objWMI,ByRef dictServices)\n\n\tDim strService\n\t\n\tFor Each objProp In objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)\n\t\tstrService = objProp.ServiceName\n\t\tIf Not IsNull(strService) Then\n\t\t\tIf Not dictServices.Exists(strService) Then\n\t\t\t\tdictServices.Add strService,1\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\t\t\nEnd Sub &#039;BuildSQLServicesNames\n\nSub DebugPrint(ByRef strToPrint)\n\n\tIf DEBUG_OUT Then\n\t\tWScript.Echo strToPrint\n\tEnd If\nEnd Sub &#039;DebugPrint\n\nSub BuildSQLCompMgmtWMIsDict(ByRef dictWMIs)\n\n\t&#039; Define a constant MAX_SQL_NUMBER in global scope\n\tDim objWMI,i,strWMINameSpace\n\tOn Error Resume Next\n\n    &#039; First try 2005\n    strWMINameSpace = &quot;WINMGMTS:\\\\.\\root\\Microsoft\\SqlServer\\ComputerManagement&quot;\n    Set objWMI = GetObject(strWMINameSpace)\n    If Err.Number = 0 Then\n    \tdictWMIs.Add objWMI,strWMINameSpace\n    \tDebugPrint strWMINameSpace\n    Else\n    \tErr.Clear\n    \t&#039; Loop through 2008 to 2012 and beyond\n        For i = 10 To MAX_SQL_NUMBER\n        \tstrWMINameSpace = &quot;WINMGMTS:\\\\.\\root\\Microsoft\\SqlServer\\ComputerManagement&quot;&amp;CStr(i)\n        \tSet objWMI = GetObject(strWMINameSpace)\n        \tIf Err.Number = 0 Then\n        \t\tdictWMIs.Add objWMI,strWMINameSpace\n        \t\tDebugPrint strWMINameSpace\n        \tElse\n        \t\tErr.Clear\n        \tEnd If\n        Next\n\tEnd If\n\t\n\tErr.Clear\n\tOn Error Goto 0\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\tWScript.Quit\n\tEnd If\n\t\nEnd Sub &#039;BuildSQLCompMgmtWMIsDict", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 136, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Product level for SQL Server on client machine.\nExample: SP4", 
      "exclude_from_parse_flag": 1, 
      "hash": 482346946, 
      "hidden_flag": 0, 
      "id": 269, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Product Level", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Product Level\n&#039;========================================\nOption Explicit\n\nConst MAX_SQL_NUMBER = 15\nConst DEBUG_OUT = False\nDim strValueName, strSKUName, strEdition, strVersion, strArchitecture \nDim objWMI, dictWMIs, objProp, strOut, dictServices\n\nSet dictWMIs = CreateObject(&quot;Scripting.Dictionary&quot;)\nSet dictServices = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\nBuildSQLCompMgmtWMIsDict(dictWMIs)\n\nPrintSPLevel\n\nFunction IsMultiple(ByRef dictWMIs)\n\n\tIf dictWMIs.Count &gt; 1 Then\n\t\tIsMultiple = True\n\tElse\n\t\tIsMultiple = False\n\tEnd If\n\t\nEnd Function &#039;IsMultiple\n\nSub PrintSPLevel\n\tDim strProp,intOutCount\n\n\tstrProp = &quot;SPLEVEL&quot;\n\tintOutCount = 1\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\tElse\n\t\tFor Each objWMI In dictWMIs.Keys\n\t\t\tstrOut = GetSQLServiceAdvancedProp(strProp,objWMI)\n\t\t\tIf Len(strOut) &gt; 0 Then\n\t\t\t\tintOutCount = intOutCount + 1\n\t\t\t\tIf strOut = 0 Then\n\t\t\t\t\tWScript.Echo &quot;RTM&quot;\n\t\t\t\tElseIf IsNumeric(strOut) Then\n\t\t\t\t\tWScript.Echo &quot;SP&quot;&amp;strOut\n\t\t\t\tElse\n\t\t\t\t\tWScript.Echo strOut\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\t\t\tDebugPrint &quot;SQL Property Not Found&quot;\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\nEnd Sub &#039;PrintProp \n\nSub PrintProp(strProp)\n\tDim intOutCount\n\tintOutCount = 1\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\tElse\n\t\tFor Each objWMI In dictWMIs.Keys\n\t\t\tstrOut = GetSQLServiceAdvancedProp(strProp,objWMI)\n\t\t\tIf Len(strOut) &gt; 0 Then\n\t\t\t\tintOutCount = intOutCount + 1\n\t\t\t\tWScript.Echo strOut\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\t\t\tDebugPrint &quot;SQL Property Not Found&quot;\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\nEnd Sub &#039;PrintProp \n\nFunction PrintServices\n\tBuildSQLServicesNames objWMI,dictServices\n\t&#039; Print Services\n\tDim strService\n\tFor Each strService In dictServices.Keys\n\t\tWScript.Echo strService\n\tNext\nEnd Function &#039;PrintServices\n\nFunction GetBitnessFromSKU(strSKUName)\n&#039; Returns appropriate bitness from SKU value\n\tDim strArchitecture\n\tIf Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then\n\t    strArchitecture = &quot;64-bit&quot;\n\tElse\n\t    strArchitecture = &quot;32-bit&quot;\n\tEnd If\n\tGetBitnessFromSKU = strArchitecture\n\t\nEnd Function &#039;GetBitnessFromSKU\n\nFunction GetCleanEdition(strSKUName)\n&#039; Removes bitness from SKU value\n\tDim strEdition\n\tIf Instr(strSKUName, &quot; (&quot;) &lt;&gt; 0 Then\n\t    strEdition = Left(strSKUName, Instr(strSKUName, &quot; (&quot;))\n\tElse\n\t    strEdition = strSKUName\n\tEnd If\n\n\tGetCleanEdition = strEdition\n\t\nEnd Function &#039;CleanSKU\n\nFunction GetSQLServiceAdvancedProp(strProp,ByRef objWMI)\n&#039; Property Names may change for different SQL versions\n&#039;SQLSTATES,VERSION,SPLEVEL,CLUSTERED,INSTALLPATH,DATAPATH,LANGUAGE,FILEVERSION,\n&#039;VSNAME,REGROOT,SKU,SKUNAME,INSTANCEID,STARTUPPARAMETERS,ERRORREPORTING,DUMPDIR,\n&#039;SQMREPORTING,ISWOW64\n\tOn Error Resume Next\n\tDim strOut, intType, strPropVal, colResults\n\tstrProp = UCase(strProp) &#039; text matches will happen when uppercased\n\tSet colResults = objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)\n\tFor Each objProp In colResults\n\t    If objProp.PropertyName = strProp Then\n\t    \tintType = objProp.PropertyValueType\n\t    \tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\tDebugPrint Err.Description &amp; &quot; inttype is &quot; &amp; objProp.PropertyValueType\n\t\t\t\tErr.Clear\n\t\t\tEnd If\t\n\t    \tIf intType = 0 Then\n\t        \tstrOut = objProp.PropertyStrValue\n\t\t      \tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t\tDebugPrint Err.Description &amp; &quot; strout is &quot; &amp; objProp.PropertyStrValue\n\t\t\t\t\tErr.Clear\n\t\t\t\tEnd If\t  \t\n\t        Else\n\t        \tstrOut = objProp.PropertyNumValue\n\t        End If\n\t\tEnd If\n\tNext\n\n\tErr.Clear\n\tOn Error Goto 0\n\tGetSQLServiceAdvancedProp = strOut\n\n\tIf DEBUG_OUT = True Then\n\t\tWScript.Echo &quot;Debug, listing all props &quot;\n\t\tOn Error Resume Next\n\t\tFor Each objProp In colResults\n\t    \tintType = objProp.PropertyValueType\n\n\t    \tIf intType = 0 Then\n\t        \tstrOut = objProp.PropertyStrValue\t\n\t        Else\n\t        \tstrOut = objProp.PropertyNumValue\n\t        End If\n\t\tWScript.Echo &quot;Property name: &quot;&amp;objProp.PropertyName&amp;&quot;, valuetype: &quot;&amp;intType&amp;&quot;, value: &quot;&amp;strOut\n\t   \tNext\n\t End If\nEnd Function &#039;GetSQLServiceAdvancedProp\n\nSub BuildSQLServicesNames(ByRef objWMI,ByRef dictServices)\n\n\tDim strService\n\t\n\tFor Each objProp In objWMI.ExecQuery(&quot;select * from SqlServiceAdvancedProperty where SQLServiceType = 1&quot;)\n\t\tstrService = objProp.ServiceName\n\t\tIf Not IsNull(strService) Then\n\t\t\tIf Not dictServices.Exists(strService) Then\n\t\t\t\tdictServices.Add strService,1\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\t\t\nEnd Sub &#039;BuildSQLServicesNames\n\nSub DebugPrint(ByRef strToPrint)\n\n\tIf DEBUG_OUT Then\n\t\tWScript.Echo strToPrint\n\tEnd If\nEnd Sub &#039;DebugPrint\n\nSub BuildSQLCompMgmtWMIsDict(ByRef dictWMIs)\n\n\t&#039; Define a constant MAX_SQL_NUMBER in global scope\n\tDim objWMI,i,strWMINameSpace\n\tOn Error Resume Next\n\n    &#039; First try 2005\n    strWMINameSpace = &quot;WINMGMTS:\\\\.\\root\\Microsoft\\SqlServer\\ComputerManagement&quot;\n    Set objWMI = GetObject(strWMINameSpace)\n    If Err.Number = 0 Then\n    \tdictWMIs.Add objWMI,strWMINameSpace\n    \tDebugPrint strWMINameSpace\n    Else\n    \tErr.Clear\n    \t&#039; Loop through 2008 to 2012 and beyond\n        For i = 10 To MAX_SQL_NUMBER\n        \tstrWMINameSpace = &quot;WINMGMTS:\\\\.\\root\\Microsoft\\SqlServer\\ComputerManagement&quot;&amp;CStr(i)\n        \tSet objWMI = GetObject(strWMINameSpace)\n        \tIf Err.Number = 0 Then\n        \t\tdictWMIs.Add objWMI,strWMINameSpace\n        \t\tDebugPrint strWMINameSpace\n        \tElse\n        \t\tErr.Clear\n        \tEnd If\n        Next\n\tEnd If\n\t\n\tErr.Clear\n\tOn Error Goto 0\n\tIf dictWMIs.Count = 0 Then\n\t\tWScript.Echo &quot;SQL Not Found&quot;\n\t\tWScript.Quit\n\tEnd If\n\t\nEnd Sub &#039;BuildSQLCompMgmtWMIsDict", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 137, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3796118374, 
      "hidden_flag": 0, 
      "id": 271, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Database Sizes", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Buffer Hit Ratio\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\n\nDim dictInstances, strInstance, objConnection\n\nSet dictInstances = GetMSSQLInstances()\n\nFor Each strInstance In dictInstances.Keys\n\tDim objRecordSet, objRecordSet2, objConnection2, Record, strDatabase, strDBSize\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  \n\tSet objConnection2 = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  \n\t\n\tOn Error Resume Next\n\tobjConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)\n\t\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\t\n\tOn Error Goto 0\n\t\n\tobjRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  \n\t\n\tFor Each Record In objRecordSet.Properties    \n\t\tstrDatabase = objRecordSet(&quot;name&quot;)    \n\t\tobjConnection2.Open GenMSSQLConnectionStr(strInstance, strDatabase)    \n\t\t\n\t\tIf objConnection2.Errors.Count &gt; 0 Then \n\t\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\t\tExit For\n\t\tEnd If \n\t\t\n\t\tOn Error Goto 0\n\t\t\n\t\tobjRecordSet2.Open &quot;Select cast(size * 8/1024.0 as decimal(18,2)) SpaceUsed_MB From SYS.database_files where type_desc = &#039;ROWS&#039;&quot;, objConnection2, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC       \n\t\tstrDBSize = objRecordSet2(&quot;SpaceUsed_MB&quot;)       \n\t\tWScript.echo strDatabase &amp; &quot; &quot; &amp; strDBSize &amp; &quot;MB&quot; &amp; GetMSSQLSensorInstanceStr(strInstance)\n\t\tobjRecordset2.Close    \n\t\tobjConnection2.Close     \n\t\tObjRecordSet.MoveNext    \n\t\tIf (ObjRecordset.EOF = True) Then       \n\t\t\tobjRecordset.Close       \n\t\t\tExit For    \n\t\tEnd If     \n\tNext \nNext\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 138, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 77425467, 
      "hidden_flag": 0, 
      "id": 273, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Log Sizes", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Log Sizes\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\n\nDim dictInstances, strInstance, objConnection\n\nSet dictInstances = GetMSSQLInstances()\n\nFor Each strInstance In dictInstances.Keys\n\tDim objRecordSet, objRecordSet2, objConnection2, Record, strDatabase, strDBSize\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  \n\tSet objConnection2 = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  \n\tOn Error Resume Next\n\tobjConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)\n\t\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\tOn Error Goto 0\n\n\tobjRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  \n\tFor each Record in objRecordSet.Properties    \n\t\tstrDatabase = objRecordSet(&quot;name&quot;)    \n\t\t&#039;SpaceUsed_MB = 0     \n\t\tobjConnection2.Open GenMSSQLConnectionStr(strInstance, strDatabase) \n\n\t\tIf objConnection.Errors.Count &gt; 0 Then \n\t\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\t\tExit For\n\t\tEnd If \n\t\tOn Error Goto 0\n\n\t\tobjRecordSet2.Open &quot;Select cast(size * 8/1024.0 as decimal(18,2)) SpaceUsed_MB From SYS.database_files where type_desc = &#039;LOG&#039;&quot;, objConnection2, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC       \n\t\tstrDBSize = objRecordSet2(&quot;SpaceUsed_MB&quot;)       \n\t\tWScript.echo StrDatabase &amp; &quot; &quot; &amp; StrDBSize &amp; &quot;MB&quot; &amp; GetMSSQLSensorInstanceStr(strInstance)      \n\t\tobjRecordset2.Close    \n\t\tobjConnection2.Close     \n\t\tobjRecordSet.MoveNext    \n\t\tIf (ObjRecordset.EOF = True) THEN       \n\t\t\tobjRecordset.Close       \n\t\t\tExit For    \n\t\tEnd If     \n\tNext \nNext\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 139, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1240245618, 
      "hidden_flag": 0, 
      "id": 275, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Database Recovery Mode", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Database Recovery Mode\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\nDim dictInstances, strInstance, objConnection\n\nSet dictInstances = GetMSSQLInstances()\n\nFor Each strInstance In dictInstances.Keys\n\tDim objRecordSet, objRecordSet2, Record, strDatabase, strDBRecovery\n\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;) \n\tSet objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  \n\tOn Error Resume Next\n\tobjConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)\n\t\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\t\n\tOn Error Goto 0\n\t\n\tobjRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  \n\tFor Each Record In objRecordSet.Properties    \n\t\tstrDatabase = objRecordSet(&quot;name&quot;)    \n\t\tobjRecordSet2.Open &quot;select databasepropertyex([name],&#039;Recovery&#039;) as [Recovery] from dbo.sysdatabases where name=&quot; &amp; &quot;&#039;&quot; &amp; strDatabase &amp; &quot;&#039;&quot;, _         \n\t\t\tobjConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC       \n\t\tstrDBRecovery = objRecordSet2(&quot;Recovery&quot;)       \n\t\tWScript.echo strDatabase &amp; &quot; &quot; &amp; strDBRecovery &amp; GetMSSQLSensorInstanceStr(strInstance)\n\t\tobjRecordset2.Close     \n\t\tObjRecordSet.MoveNext    \n\t\tIf (ObjRecordset.EOF = True) Then       \n\t\t\tobjRecordset.Close       \n\t\t\tExit For    \n\t\tEnd If     \n\tNext \nNext\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 140, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "A multi-column Sensor that shows processes that have crashed yesterday, including the instance number to capture multiple crashes by the same process.\nExample: firefox.exe | 3", 
      "exclude_from_parse_flag": 1, 
      "hash": 607666494, 
      "hidden_flag": 0, 
      "id": 277, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 43200, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Application Crashes Yesterday", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Application Crashes Yesterday\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\n\nSensorRandomize()\n\nDim strSep\nDim objWMIService, colEvents, objEvent, intCount\nDim dtmStart, dtmEnd\n\nstrSep = &quot;|&quot;\nintCount = 0\n\ndtmStart = GetYesterdayStart\ndtmEnd = GetYesterdayEnd\n\n&#039;Dictionary object used to track duplicate processes\nDim oDic\nSet oDic = CreateObject(&quot;scripting.dictionary&quot;)\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\\\.\\root\\cimv2&quot;) \n\nSet colEvents = objWMIService.ExecQuery _\n    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _\n        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _\n        &amp; &quot;TimeWritten &lt; &#039;&quot; &amp; dtmEnd &amp; &quot;&#039; AND &quot; _\n        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)\n\n\nFor Each objEvent In colEvents\n    Dim strMessage, arrLines, strLine, strApp, strModule, strTime\n    \n    strMessage = objEvent.Message\n    arrLines = Split(strMessage, vbCrLf)\n    \n    Dim strIndex, strIndexXp\n\n\t&#039;just go through first line of log to grab app name\n\tstrLine = arrLines(0)\n\t\n\t&#039;strIndex is for new OSes, strIndexXP for older...\n\tstrIndex = &quot;Faulting application name: &quot;\n\tstrIndexXp = &quot;Faulting application &quot;\n\tIf Left(strLine, Len(strIndex)) = strIndex Then\n\t\tstrApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)\n\tElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then\n\t\tstrApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)\n\tEnd If\n\t\n\tDim intInstance\n\tIf oDic.Exists(strApp) Then\n\t\toDic.Item(strApp) = oDic.Item(strApp) + 1\n\t\tintInstance = oDic.Item(strApp)\n\tElse\n\t\toDic.Item(strApp) = 1\n\t\tintInstance = 1\n\tEnd If\n\t\n    strTime = DatetimeToDate(objEvent.TimeWritten)\n    \t \n\tWScript.Echo strApp &amp; strSep &amp; intInstance\n\tintCount = intCount + 1\n\t&#039;&amp; strSep &amp; strTime \n\t&#039;&amp; strSep &amp; dtmStart &amp; strSep &amp; objEvent.TimeWritten &amp; strSep &amp; dtmEnd\nNext\n\nIf intCount = 0 Then\n\tWScript.Echo &quot;No Application Crashes Found&quot; &amp; strSep\nEnd if\n\nFunction GetYesterdayStart\n\tDim dtmYesterday\n\tdtmYesterday = Date() - 1\n&#039;\tWScript.Echo dtmYesterday\n\t\n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate dtmYesterday, False\n\t \n  \tGetYesterdayStart = dateTime\nEnd Function\n\nFunction GetYesterdayEnd\n\tDim dtmYesterday\n\tdtmYesterday = Date()\n&#039;\tWScript.Echo dtmYesterday\n\t\n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate dtmYesterday, False\n\t \n  \tGetYesterdayEnd = dateTime\nEnd Function\n\nFunction DatetimeToDate(strDate)\n   DatetimeToDate = _\n       CDate(Mid(strDate, 5, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Mid(strDate, 7, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Left(strDate, 4) &amp; _\n       &quot; &quot; &amp; _\n       Mid (strDate, 9, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 11, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 13, 2))\nEnd Function\n\nFunction GetTimeWrittenByDaysOld(days)\n   &#039;subtract &quot;days&quot; days worth of seconds\n\n\tDim epoc, monthAgo   \n   \tepoc = date2epoch(Now()) - days*24*60*60\n   \tmonthAgo = epoch2date(epoc)\n   \n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate monthAgo, True\n\t \n  \tGetTimeWrittenByDaysOld = dateTime\nEnd Function\n\nfunction date2epoch(myDate)\n   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)\nend Function\n\nfunction epoch2date(myEpoch)\n   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)\nend Function\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Instance #", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 141, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the date of the last system crash that occurred.\nExample: 8/2/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 1724798097, 
      "hidden_flag": 0, 
      "id": 279, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Last System Crash", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last System Crash\n&#039;========================================\n\nDim strValueName, strKey\n\nstrValueName = &quot;DumpFile&quot;\nstrDumpsDirName = &quot;MinidumpDir&quot;\n\n&#039;Uses date math - set locale\n\nSetLocale(GetTaniumLocale)\n\nstrKey = &quot;SYSTEM\\CurrentControlSet\\Control\\CrashControl&quot;\n\nSet objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\nConst HKLM = &amp;h80000002\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\n&#039;Get main dump file\nDim mainDumpDate\nIf RegKeyExists(objReg, HKLM, strKey) Then\n\tobjReg.GetExpandedStringValue HKLM, strKey, strValueName, strValue\n\n\tIf fso.FileExists(strValue) Then\n\t\t\n\t\tSet objFile = fso.GetFile(strValue)\n\t\tmainDumpDate = objfile.DateLastModified\n\tEnd If\nElse\n\tWScript.Echo &quot;Error, Dump key not found: HKLM\\SYSTEM\\CurrentControlSet\\Control\\CrashControl&quot;\nEnd If\n\n\n&#039;Examine minidump folder\nDim newestMini\n\nIf RegKeyExists(objReg, HKLM, strKey) Then\n\tobjReg.GetExpandedStringValue HKLM, strKey, strDumpsDirName, strDumpDir\n\n\tIf fso.FolderExists(strDumpDir) Then\n\t\tSet oFolder = fso.GetFolder(strDumpDir)\n\t\tFor Each sFile In oFolder.Files\n\t\t\tIf Right(LCase(sFile.Name), 4) = &quot;.dmp&quot; Then\n\t\t\t    If newestMini = &quot;&quot; Then\n\t\t\t        Set newestMini = sFile\n\t\t\t    Else\n\t\t\t        If newestMini.DateLastModified &lt; sFile.DateLastModified Then\n\t\t\t          Set newestMini = sFile\n\t\t\t        End If\n\t\t\t    End If\n\t\t\tEnd If\n\t\tNext\t\n\tEnd If\nEnd If\n\n\n\nIf newestMini = &quot;&quot; And mainDumpDate = &quot;&quot; Then\n\tWScript.Echo &quot;No system crashes found&quot;\n\tWScript.Quit\nEnd If\n\nDim responseDate\nIf newestMini = &quot;&quot; Then\t\n\tresponseDate = mainDumpDate\nElseIf mainDumpDate = &quot;&quot; Then\n\tresponseDate = newestMini.DateLastModified\nElse\n\tIf newestMini.DateLastModified &lt; mainDumpDate Then\n\t\tresponseDate = mainDumpDate\n\tElse\n\t\tresponseDate = newestMini.DateLastModified\t\n\tEnd If\nEnd If\n\nDim arrTemp\narrTemp = Split(responseDate)\nresponseDate = arrTemp(0)\n\nWScript.Echo responseDate\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 142, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the date at which the last system crash occurred.\nExample:5/2/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 1815821395, 
      "hidden_flag": 0, 
      "id": 281, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Last System Crash in X Days", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query and return system crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"dayThresh\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last System Crash in X Days\n&#039;========================================\n\ndayThresh = LCase(Trim(Unescape(&quot;||dayThresh||&quot;)))\n&#039;dayThresh = LCase(Trim(Unescape(&quot;1&quot;)))\nIf Not IsNumeric(dayThresh) Then \n    WScript.Echo &quot;Parameter Not Number&quot;\n    WScript.Quit\nEnd If \ndayThresh = Cint(dayThresh)\n\nDim strValueName, strKey\n\nstrValueName = &quot;DumpFile&quot;\nstrDumpsDirName = &quot;MinidumpDir&quot;\n\nstrKey = &quot;SYSTEM\\CurrentControlSet\\Control\\CrashControl&quot;\n\nSet objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\nConst HKLM = &amp;h80000002\n\n&#039;Uses date math - set locale\n\nSetLocale(GetTaniumLocale)\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\n&#039;Get main dump file\nDim mainDumpDate\nIf RegKeyExists(objReg, HKLM, strKey) Then\n\tobjReg.GetExpandedStringValue HKLM, strKey, strValueName, strValue\n\n\tIf fso.FileExists(strValue) Then\n\t\t\n\t\tSet objFile = fso.GetFile(strValue)\n\t\tmainDumpDate = objfile.DateLastModified\n\tEnd If\nElse\n\tWScript.Echo &quot;Error, Dump key not found: HKLM\\SYSTEM\\CurrentControlSet\\Control\\CrashControl&quot;\nEnd If\n\n\n&#039;Examine minidump folder\nDim newestMini\n\nIf RegKeyExists(objReg, HKLM, strKey) Then\n\tobjReg.GetExpandedStringValue HKLM, strKey, strDumpsDirName, strDumpDir\n\n\tIf fso.FolderExists(strDumpDir) Then\n\t\tSet oFolder = fso.GetFolder(strDumpDir)\n\t\tFor Each sFile In oFolder.Files\n\t\t    If newestMini = &quot;&quot; Then\n\t\t        Set newestMini = sFile\n\t\t    Else\n\t\t        If newestMini.DateLastModified &lt; sFile.DateLastModified Then\n\t\t          Set newestMini = sFile\n\t\t        End If\n\t\t    End If\n\t\tNext\n\tEnd If\nEnd If\n\n\n\nIf newestMini = &quot;&quot; And mainDumpDate = &quot;&quot; Then\n\tWScript.Echo &quot;No system crashes found&quot;\n\tWScript.Quit\nEnd If\n\nDim responseDate\nIf newestMini = &quot;&quot; Then\t\n\tresponseDate = mainDumpDate\nElseIf mainDumpDate = &quot;&quot; Then\n\tresponseDate = newestMini.DateLastModified\nElse\n\tIf newestMini.DateLastModified &lt; mainDumpDate Then\n\t\tresponseDate = mainDumpDate\n\tElse\n\t\tresponseDate = newestMini.DateLastModified\t\n\tEnd If\nEnd If\n\ncurrent = Now()\ndayDiff = DateDiff(&quot;d&quot;, responseDate, current)\n\nDim arrTemp\nIf dayDiff &lt;= dayThresh Then\n\tarrTemp = Split(responseDate)\n\tresponseDate = arrTemp(0)\n\n\tWScript.Echo responseDate\nElse \n\tWScript.Echo &quot;No system crashes in day range&quot;\nEnd If\t\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||dayThresh||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||dayThresh||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 143, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "A parameterized Sensor that queries for any processes that have crashed in the last X days.\nExample: chrome.exe", 
      "exclude_from_parse_flag": 1, 
      "hash": 1265351278, 
      "hidden_flag": 0, 
      "id": 283, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Application Crashes in Last X Days", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Application Crashes in Last X Days\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\nDim strSep\nDim objWMIService, colEvents, objEvent, intCount\nDim dtmStart\n\nstrSep = &quot;|&quot;\nintCount = 0\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\ndtmStart = GetTimeWrittenByDaysOld(||days||)\n&#039;dtmStart = GetTimeWrittenByDaysOld(7)\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\\\.\\root\\cimv2&quot;) \n\nSet colEvents = objWMIService.ExecQuery _\n    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _\n        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _\n        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)\n\nFor Each objEvent In colEvents\n    Dim strMessage, arrLines, strLine, strApp, strModule, strTime\n    \n    strMessage = objEvent.Message\n    arrLines = Split(strMessage, vbCrLf)\n    \n    Dim strIndex, strIndexXp\n\n\t&#039;just go through first line of log to grab app name\n\tstrLine = arrLines(0)\n\t\n\t&#039;strIndex is for new OSes, strIndexXP for older...\n\tstrIndex = &quot;Faulting application name: &quot;\n\tstrIndexXp = &quot;Faulting application &quot;\n\tIf Left(strLine, Len(strIndex)) = strIndex Then\n\t\tstrApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)\n\tElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then\n\t\tstrApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)\n\tEnd If\n\t\n    strTime = DatetimeToDate(objEvent.TimeWritten)\n    \n    Dim strDate, arrTemp\n    arrTemp = Split(strTime)\n    strDate = arrTemp(0)\n\tWScript.Echo strApp &amp; strSep &amp; strDate\n\tintCount = intCount + 1\nNext\n\nIf intCount = 0 Then\n\tWScript.Echo &quot;No Application Crashes Found&quot; &amp; strSep\nEnd if\n\nFunction DatetimeToDate(strDate)\n   DatetimeToDate = _\n       CDate(Mid(strDate, 5, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Mid(strDate, 7, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Left(strDate, 4) &amp; _\n       &quot; &quot; &amp; _\n       Mid (strDate, 9, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 11, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 13, 2))\nEnd Function\n\nFunction GetTimeWrittenByDaysOld(days)\n   &#039;subtract &quot;days&quot; days worth of seconds\n\n\tDim epoc, monthAgo   \n   \tepoc = date2epoch(Now()) - days*24*60*60\n   \tmonthAgo = epoch2date(epoc)\n   \n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate monthAgo, True\n\t \n  \tGetTimeWrittenByDaysOld = dateTime\nEnd Function\n\nfunction date2epoch(myDate)\n   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)\nend Function\n\nfunction epoch2date(myEpoch)\n   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)\nend Function\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||days||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||days||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Date", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 144, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Returns the SSID name and signal strength of a connected wireless network where signal strength is 0-5.\nExample: linksys|4", 
      "exclude_from_parse_flag": 1, 
      "hash": 99939055, 
      "hidden_flag": 0, 
      "id": 285, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Wireless Network SSID Strength", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Wireless Network SSID Strength\n&#039;========================================\n\n&#039; This sensor uses netsh output to display details about wireless LAN\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n\t\t\t\t\n&#039; This is a multi-column sensor whose output looks like\n&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal\n\nGetWirelessNetworkDetails strSep\n\nFunction GetWirelessNetworkDetails(strSep)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine, strState, strSSID, strSignal, intSignal\n\tDim bPrintLine, bNewInterface\n\t\n\tstrCommand = &quot;netsh wlan show interfaces&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tIf InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then\n\t\t\tbNewInterface = True\t&#039; if there&#039;s a new Name, it&#039;s time to note a new group\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then\n\t\t\tstrState = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then\n\t\t\tstrSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then\n\t\t\tstrSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove the percentage\n\t\t\tintSignal = CInt(CInt(strSignal) / 20)\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewInterface And bPrintLine Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, print\n\t\t\tWScript.Echo strSSID &amp; strSep &amp; intSignal\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetWirelessNetworkDetails", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n# cah\n# Created 20140620\n# Modified\n# looking for wireless network SSIDs actively connected \n# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |\n# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm\n\nAIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;\nRADIO=&quot;unknown&quot;\n\nDEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)\n#echo $DEVID\nDEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)\n\n#Get SSID\nSSID=$(networksetup -getairportnetwork $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039;)\n#echo $SSID\n\nif [ ! &quot;$SSID&quot; ] ; then\n\tSSID=&quot;Not Available&quot;\t\n\tSIGNAL=&quot;Not Available&quot;\nfi\n\nif [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then\n  PWR=$( $AIRPATH/airport -I | awk -F&quot;agrCtlRSSI:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )\n# This is to convert from power to MS dummy gauge\n    if  (( $PWR &lt;= &quot;-100&quot; )) ; then\n  \tSIGNAL=&quot;0&quot;\n   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then\n  \tSIGNAL=&quot;1&quot;\n   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then\n  \tSIGNAL=&quot;2&quot;\n   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then\n  \tSIGNAL=&quot;3&quot;\n   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then\n  \tSIGNAL=&quot;4&quot;\n   else\n  \tSIGNAL=&quot;5&quot;\n  fi  \nelse \n  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )\n  if [ ! &quot;$STATE&quot; ] ; then\n    STATE=&quot;off&quot;\n    echo &quot;$STATE&quot;\n  fi\nfi\n\necho &quot;$SSID | $SIGNAL  ($PWR dB)  &quot;\n\nexit\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "SSID", 
            "value_type": "Numeric"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Strength (0-5)", 
            "value_type": "Numeric"
          }
        ]
      }, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 145, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the currently logged in user, and No User if nobody is logged in.\nExample: Domain\\JDoe", 
      "exclude_from_parse_flag": 1, 
      "hash": 1913997657, 
      "hidden_flag": 0, 
      "id": 287, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Username", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Username\n&#039;========================================\n\nOption Explicit\n\nDim strComputer, objWMIService, colComputer, objComputer\n\nstrComputer = &quot;.&quot;    \nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nSet colComputer = objWMIService.ExecQuery (&quot;Select UserName from Win32_ComputerSystem&quot;)    \n\nFor Each objComputer in colComputer     \n\tif objComputer.UserName &lt;&gt; &quot;&quot; Then     \n\t\tWscript.Echo StripDuplicateDomains(objComputer.UserName)\n\tElse     \n\t\tWscript.Echo &quot;No User&quot;     \n\tEnd If  \nNext    \n\nWScript.Quit\n&#039; End\n\nFunction StripDuplicateDomains(strInput)\n    &#039; Removes duplicate domain prefixes\n    Dim arrWords,strResult\n    strResult = strInput\n    \n    If InStr(strInput,&quot;\\&quot;) Then\n        arrWords = Split(strInput,&quot;\\&quot;)\n        If UBound(arrWords) &gt;= 2 And LCase(arrWords(0)) = LCase(arrWords(1)) Then\n            &#039; Remove duplicate\n            strResult = arrWords(0) &amp; &quot;\\&quot; &amp; arrWords(2)\n    \tEnd If\n    End if\n    \n    StripDuplicateDomains = strResult\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 146, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the SSID (name) of a wireless network a machine is connected to.\nExample: linksys", 
      "exclude_from_parse_flag": 1, 
      "hash": 1466668831, 
      "hidden_flag": 0, 
      "id": 289, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Wireless Network Connected SSID", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Wireless Network Connected SSID\n&#039;========================================\n\n&#039; This sensor uses netsh output to display details about wireless LAN\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n\t\t\t\t\nGetConnectedWirelessNetwork strSep\n\nFunction GetConnectedWirelessNetwork(strSep)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine, strState, strSSID\n\tDim bPrintLine, bNewInterface, bConnected\n\t\n\tstrCommand = &quot;netsh wlan show interfaces&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tbConnected = False &#039;assume no connections\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tIf InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then\n\t\t\tbNewInterface = True\t&#039; if there&#039;s a new Name, it&#039;s time to note a new group\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then\n\t\t\tstrState = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then\n\t\t\tstrSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewInterface And bPrintLine Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, print\n\t\t\tIf InStr(LCase(strState),&quot;connected&quot;) &gt; 0 Then\n\t\t\t\tWScript.Echo strSSID\n\t\t\t\tbConnected = True\n\t\t\tEnd If\n\t\t\tbNewInterface = False\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\tIf Not bConnected Then\n\t\tWScript.Echo &quot;:No Connection:&quot;\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetConnectedWirelessNetwork", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\n/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I | awk &#039;/ SSID/ {print substr($0, index($0, $2))}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 147, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Returns details of all wireless networks a machine can see, whether they are connected or not.  Details include SSID, Network Type, Authentication Method, and Encryption Level.\nExample: hotspotwifi | Infrastructure | WPA2-Personal", 
      "exclude_from_parse_flag": 1, 
      "hash": 2233537498, 
      "hidden_flag": 0, 
      "id": 291, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Wireless Networks Visible", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Wireless Networks Visible\n&#039;========================================\n\n&#039; This sensor uses netsh output to display all visible \n&#039; SSIDs\n\nOption Explicit\n\nDim strSep, strSSIDWhiteList,arrSSIDWhiteList\n\nstrSep = &quot;|&quot;\n&#039; This is a multi-column sensor whose output looks like\n&#039; SSID|Network Type|Authentication|Encryption\n\nstrSSIDWhiteList = &quot;&quot;\n&#039;strSSIDWhiteList = &quot;linksys&quot;\n&#039;strSSIDWhiteList = &quot;ATTNET,ApprovedSSID1,ApprovedSSID2,etc ...&quot;\n\nGetSSIDs strSep, strSSIDWhiteList\n\nFunction GetSSIDs(strSep, strSSIDWhiteList)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine, strSSID, strNetworkType,strAuthentication, strEncryption\n\tDim bPrintLine, bNewSSID\n\t\n\tstrCommand = &quot;netsh wlan show networks&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tIf InStr(strNetshLine,&quot;ssid&quot;) &gt; 0 Then\n\t\t\tbNewSSID = True\t&#039; if there&#039;s SSD, it&#039;s time to note a new group\n\t\t\tstrSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then\n\t\t\tstrNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then\n\t\t\tstrAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;encryption&quot;) &gt; 0 Then\n\t\t\tstrEncryption = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Encryption Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewSSID And bPrintLine And Not InStr(LCase(strSSIDWhiteList), LCase(strSSID)) &gt; 0 Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, print\n\t\t\tWScript.Echo strSSID &amp; strSep &amp; strNetworkType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strEncryption\n\t\t\tbNewSSID = False\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetSSIDs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n# cah\n# Created 20140906\n# Modified\n# looking for SSIDs via airport\n\n/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -s | grep -v &quot;^$&quot; | grep -v &quot;SSID BSSID  &quot; |grep -v &quot;IBSS network&quot;| sed &#039;s/..:..//g&#039; | sed &#039;s/ -..  ... *//g&#039; | sed &#039;s/\\(::\\).*  .. /\\1 /&#039; | sed &#039;s/WPA\\(.*\\) WPA2\\(.*\\)/WPA WPA2 \\1 \\2/g&#039; | sed &#039;s/(/ /g&#039; | sed &#039;s/)/ /g&#039; | sed &#039;s/::/ | |/g&#039; | sed &#039;s/WPA2/WPA2|/&#039; | sed &#039;s/NONE/NONE|NONE|/g&#039; | sed &#039;s/WEP/WEP|WEP/g&#039; | sed &#039;s/WPA \\([^W][^P]\\)/WPA| \\1/g&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "SSID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Network Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Authentication", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Encryption", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 148, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Details of currently active wireless network connection by client machine.  Details include SSID, MAC address, connection state, network type, radio type, authentication, receive rate, transmit rate, and signal strength.\nExample: hotspotwifi | xx-xx-xx-xx-xx-xx | connected | Infrastructure | 802.11g | WPA2-Personal | 54 | 54 | 99%", 
      "exclude_from_parse_flag": 1, 
      "hash": 4267153065, 
      "hidden_flag": 0, 
      "id": 293, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Wireless Network Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Wireless Network Details\n&#039;========================================\n\n&#039; This sensor uses netsh output to display details about wireless LAN\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n\t\t\t\t\n&#039; This is a multi-column sensor whose output looks like\n&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal 0-5\n\nGetWirelessNetworkDetails strSep\n\nFunction GetWirelessNetworkDetails(strSep)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine, strName, strMAC, strState, strSSID\n\tDim strNetworkType, strRadioType, strAuthentication\n\tDim strReceiveRate, strTransmitRate, strSignal, intSignal\n\tDim bPrintLine, bNewInterface\n\t\n\tstrCommand = &quot;netsh wlan show interfaces&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tIf InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then\n\t\t\tbNewInterface = True\t&#039; if there&#039;s a new Name, it&#039;s time to note a new group\n\t\t\tstrName = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then\n\t\t\tstrMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then\n\t\t\tstrState = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then\n\t\t\tstrSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then\n\t\t\tstrNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;radio type&quot;) &gt; 0 Then\n\t\t\tstrRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\t\t\n\t\tIf InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then\n\t\t\tstrAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;receive rate&quot;) &gt; 0 Then\n\t\t\tstrReceiveRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;transmit rate&quot;) &gt; 0 Then\n\t\t\tstrTransmitRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then\n\t\t\tstrSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove %\n\t\t\tintSignal = CInt(CInt(strSignal) / 20)\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewInterface And bPrintLine Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, print\n\t\t\tWScript.Echo strSSID &amp; strSep &amp; strMAC &amp; strSep &amp; strState &amp; strSep &amp; strNetworkType _\n\t\t\t\t&amp; strSep &amp; strRadioType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strReceiveRate &amp; strSep _\n\t\t\t\t&amp; strTransmitRate &amp; strSep &amp; intSignal\n\t\t\tbNewInterface = False\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetWirelessNetworkDetails", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n# cah\n# Created 20140616\n# Modified\n# looking for wireless network SSIDs actively connected \n# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |\n# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm\n\nAIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;\nRADIO=&quot;unknown&quot;\n\nDEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)\n#echo $DEVID\nDEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)\n\n#Get SSID\nSSID=$(networksetup -getairportnetwork $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039;)\n#echo $SSID\n\nif [ ! &quot;$SSID&quot; ] ; then\n\tSSID=&quot;Not Available&quot;\n\tNETWORKTYPE=&quot;Not Available&quot;\n\tAUTHENTICATION=&quot;Not Available&quot;\n\tRECEIVE=&quot;Not Available&quot;\n\tTRANSMIT=&quot;Not Available&quot;\n\tSIGNAL=&quot;Not Available&quot;\nfi\n\nif [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then\n  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )\n  NETWORKTYPE=$( $AIRPATH/airport -I | grep &quot;op mode:&quot; | awk -F&quot;: &quot; &#039;{print $2}&#039; )\n  AUTHENTICATION=$( $AIRPATH/airport -I | grep &quot;link auth&quot; | awk &#039;{print $3}&#039; )\n  RECEIVE=$( $AIRPATH/airport -I | awk -F&quot;lastTxRate:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )\n  TRANSMIT=$RECEIVE\n  PWR=$( $AIRPATH/airport -I | awk -F&quot;agrCtlRSSI:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )\n This is to convert from power to MS dummy gauge\n    if  (( $PWR &lt;= &quot;-100&quot; )) ; then\n  \tSIGNAL=&quot;0&quot;\n   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then\n  \tSIGNAL=&quot;1&quot;\n   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then\n  \tSIGNAL=&quot;2&quot;\n   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then\n  \tSIGNAL=&quot;3&quot;\n   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then\n  \tSIGNAL=&quot;4&quot;\n   else\n  \tSIGNAL=&quot;5&quot;\n  fi  \nelse \n  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )\n  if [ ! &quot;$STATE&quot; ] ; then\n    STATE=&quot;off&quot;\n  fi\nfi\n\n#echo $SSID\n\necho &quot;$SSID | $DEVMAC | $STATE |  $NETWORKTYPE | $RADIO | $AUTHENTICATION | $RECEIVE Mbps | $TRANSMIT Mbps | $SIGNAL  ($PWR dB)  &quot;\n\nexit\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "SSID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "MAC", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "State", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Network Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Radio", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Authentication", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Receive", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "Transmit", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Signal (0-5)", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 149, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Returns the SSID name, the IP Address, and the MAC address of connected wireless networks only if the Tanium Client is using those networks to communicate.\nExample: linksys|192.168.10.5|00D55FED214C1A2C", 
      "exclude_from_parse_flag": 1, 
      "hash": 4206488295, 
      "hidden_flag": 0, 
      "id": 295, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Wireless Network Used by Tanium", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Wireless Network Used by Tanium\n&#039;========================================\n\n&#039; This sensor uses netsh output to display details about wireless LAN\n&#039; if the IP is used by the Tanium Client\n\n\nOption Explicit\n\nDim strSep, strTaniumIPAddress, strTaniumMAC\n\nstrTaniumIPAddress = GetTaniumIPAddress\nIf strTaniumIPAddress = False Then \n\tWScript.Echo &quot;Can&#039;t retrieve Tanium Client&#039;s IP address&quot;\nEnd If\n\nstrTaniumMAC = GetMACByIP(strTaniumIPAddress)\n\nstrSep = &quot;|&quot;\n\t\t\t\n&#039; This is a multi-column sensor whose output looks like\n&#039; SSID|IPAddress|MAC\n\nGetTaniumWirelessNetworkDetailsFromMAC strSep, strTaniumMAC, strTaniumIPAddress\n\nFunction GetTaniumWirelessNetworkDetailsFromMAC(strSep, strMACArg, strIPAddressArg)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine, strState, strSSID, strSignal, intSignal\n\tDim bPrintLine, bNewInterface, strMAC\n\tDim bFoundMAC\n\t\n\tstrCommand = &quot;netsh wlan show interfaces&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tbFoundMAC = False\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tIf InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then\n\t\t\tbNewInterface = True\t&#039; if there&#039;s a new Name, it&#039;s time to note a new group\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then\n\t\t\tstrState = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then\n\t\t\tstrSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\tIf InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then\n\t\t\tstrMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))\n\t\t\tIf LCase(strMAC) = LCase(strMACArg) Then\n\t\t\t\tbFoundMAC = True\n\t\t\tEnd If\n\t\tEnd If\t\t\n\t\tIf InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then\n\t\t\tstrSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove the percentage\n\t\t\tintSignal = CInt(CInt(strSignal) / 20)\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewInterface And bPrintLine And bFoundMAC Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, and we found MAC, print\n\t\t\tstrIPAddressArg = left(strIPAddressArg,len(strIPAddressArg)-4)\n\t\t\tWScript.Echo strSSID &amp; strSep &amp; strIPAddressArg &amp; strSep &amp; intSignal\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\tIf Not bFoundMAC Then\n\t\tWScript.Echo &quot;:Wired:&quot;\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetWirelessNetworkDetailsFromMAC\n\nFunction GetTaniumIPAddress\n&#039; Modified from the ua-scan code to remove the subnet and last octet calculations\n&#039; which are irrelevant for these purposes.\n&#039; Returns the IP address that the client uses for Tanium activity\n&#039; (talking to server and other clients)\n\n\tDim strComputer, objReg, strCommand, objShell, objScriptExec\n\tDim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords\n\tDim strIPAddress, strTaniumPath, strClientAddress\n\tDim strServerName\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\tConst HKLM = &amp;h80000002\n\t\n\t\t\n\t&#039;&#039;###########Get Tanium Key on 64/32bit computers##########\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\t\n\t&#039; if we can pull this from the registry (newer client version), just use that\n\tobjReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\\Status&quot;, &quot;ClientAddress&quot;, strClientAddress\n\tIf strClientAddress &lt;&gt; &quot;&quot; Then\n\t\tstrClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)\n\t\tstrClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))\n\t\t&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;\n\t\tGetTaniumIPAddress = strClientAddress\n\t\t&#039;Cleanup\n\t\tSet objReg = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\t&#039;Otherwise use PathPing to determine client IP used by Tanium\n\n\t&#039;&#039;# Read the ServerName value\n\n\tobjReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName\n\n\tstrCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\tstrResults = objScriptExec.StdOut.ReadAll\n\t\n\tarrPathPingLines = Split(strResults, vbCrLf)\n\tFor Each strPathPingLine In arrPathPingLines\n\t\tarrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)\n\t\tIf UBound(arrPathPingWords) &gt; 0 Then\n\t\t\tIf arrPathPingWords(0) = &quot;0&quot; Then\n\t\t\t\tstrIPAddress = arrPathPingWords(1)\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tEnd If\t\n\tNext\n\t\n\tSet objShell = Nothing\n\tSet objScriptExec = Nothing\n\tSet objReg = Nothing\n\n\tIf Not IsNull(strIPAddress) Then\n\t\tGetTaniumIPAddress = strIPAddress\n\tElse\n\t\tGetTaniumIPAddress = False\n\tEnd If\nEnd Function &#039;GetTaniumIPAddress\n\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction GetMACByIP(strIP)\n\n\tDim strFoundIP, strFoundMAC, bFound\n\tDim objWMIService, colItems, objItem\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration&quot;,,48)\n\t\n\tFor Each objItem in colItems\n\t\tIf Not IsNull(objItem.IPAddress) Then\n\t\t\tFor Each strFoundIP In objItem.IPAddress\n\t\t\t\tIf strIP = strFoundIP Then\n\t\t\t\t\tbFound = True\n\t\t\t\t\tstrFoundMAC = objItem.MACAddress\n\t\t\t\tEnd If\n\t\t\tNext\n\t\tEnd If\n\tNext\n\t\n\tIf bFound Then\n\t\tGetMACByIP = strFoundMAC\n\tElse\n\t\tGetMACByIP = False\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet colItems = Nothing\n\tSet objWMIService = Nothing\n\nEnd Function &#039;GetMACByIP", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n# cah\n# Created 20140620\n# Modified\n# looking for wireless network SSIDs actively used by Tanium client.i&#039;ve \n# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |\n# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm\n\nAIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;\nRADIO=&quot;unknown&quot;\n\nDEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)\n#echo $DEVID\nDEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)\n\nTANIUMIP=$( netstat -atn | grep 17472 | awk &#039;{print $4}&#039;|grep 17472|awk -F\\. &#039;{print $1&quot;.&quot;$2&quot;.&quot;$3&quot;.&quot;$4}&#039; | sort -u )\n\nWIRELESSIP=$( networksetup -getinfo Wi-Fi | grep &quot;IP address&quot; | grep -v &quot;IPv6&quot; | awk &#039;{print $3}&#039; )\n\nif [ &quot;$TANIUMIP&quot;==&quot;$WIRELESSIP&quot; ] ; then\n\n\t#Get SSID\n\tSSID=$(networksetup -getairportnetwork $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039;)\n\n\tif [ ! &quot;$SSID&quot; ] ; then\n\t\tSSID=&quot;Not Available&quot;\t\n\t\tSIGNAL=&quot;Not Available&quot;\n\tfi\n\n\tif [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then\n\t  PWR=$( $AIRPATH/airport -I | awk -F&quot;agrCtlRSSI:&quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot; )\n\t# This is to convert from power to MS dummy gauge\n\t\tif  (( $PWR &lt;= &quot;-100&quot; )) ; then\n\t\tSIGNAL=&quot;0&quot;\n\t   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then\n\t\tSIGNAL=&quot;1&quot;\n\t   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then\n\t\tSIGNAL=&quot;2&quot;\n\t   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then\n\t\tSIGNAL=&quot;3&quot;\n\t   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then\n\t\tSIGNAL=&quot;4&quot;\n\t   else\n\t\tSIGNAL=&quot;5&quot;\n\t  fi\n\t  echo &quot;$SSID | $TANIUMIP | $SIGNAL  ($PWR dB)  &quot;  \n\telse \n\t  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )\n\t  if [ ! &quot;$STATE&quot; ] ; then\n\t\tSTATE=&quot;:Wired:||&quot;\n\t\techo &quot;$STATE&quot;\n\t  fi\n\tfi\n\t\nfi\n\nexit\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "SSID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "IP Address", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Signal Strength", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 150, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns MAC addresses for all IP enabled network connections.\nExample:00:0C:29:68:6A:D8", 
      "exclude_from_parse_flag": 1, 
      "hash": 1208633896, 
      "hidden_flag": 0, 
      "id": 297, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "MAC Address", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select MACAddress from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nifconfig | grep -i -o -e hwaddr.*:.. -e ether.*:.. | grep -o ..:..:..:..:..:.. | while read line\ndo\n\techo ${line}\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "networksetup -listallhardwareports | egrep -A 2 &quot;(: Ethernet|: AirPort|: Wi-Fi)&quot; | grep &quot;Ethernet Address&quot; | cut -f 3- -d &#039; &#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 151, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Whether or not a machine has an network adapter set to DHCP.  Note, a machine may have multiple active adapters and may return multiple lines.  If a machine has multiple adapters on DCHP, TRUE is returned only once.\nExample: TRUE, FALSE", 
      "exclude_from_parse_flag": 1, 
      "hash": 1154425412, 
      "hidden_flag": 0, 
      "id": 299, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "DHCP Enabled?", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select DHCPEnabled from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 152, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the current status of the Windows firewalls.\nExample: DomainProfile enabled", 
      "exclude_from_parse_flag": 1, 
      "hash": 889071797, 
      "hidden_flag": 0, 
      "id": 301, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Firewall Status", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Firewall Status\n&#039;========================================\n\nOn Error Resume Next\n\nconst HKLM = &amp;H80000002\nconst strKeyPath = &quot;SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters\\FirewallPolicy\\&quot;\nconst strValueName = &quot;EnableFirewall&quot;\nstrComputer = &quot;.&quot;\n\nSet oReg=GetObject( _\n   &quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp;_\n   strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nWScript.Echo GetFirewallStatus(strKeyPath, &quot;DomainProfile&quot;, strValueName)\nWScript.Echo GetFirewallStatus(strKeyPath, &quot;PublicProfile&quot;, strValueName)\nWScript.Echo GetFirewallStatus(strKeyPath, &quot;StandardProfile&quot;, strValueName)\n\nFunction GetFirewallStatus(path, policy, valName)\n   oReg.GetDWORDValue HKLM,path &amp; policy, valName, dwValue\n   If Not IsNull(dwValue) Then\n      If dwValue = 0 Then\n         GetFirewallStatus = policy &amp; &quot; disabled&quot;\n      ElseIf dwValue = 1 Then \n         GetFirewallStatus = policy &amp; &quot; enabled&quot;\n      End If\n   Else\n      &#039;Policy not found, ignore\n   End If   \nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsystem_profiler SPFirewallDataType | grep -i &quot;Mode&quot; | grep -v &quot;Stealth Mode&quot; | awk -F&#039;: &#039; &#039; { print $2 } &#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 8, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 153, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Returns a set of columns with details about open shares on a machine.\nExample: name | path | status | type | permissions", 
      "exclude_from_parse_flag": 1, 
      "hash": 93198492, 
      "hidden_flag": 0, 
      "id": 303, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 1800, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Open Share Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Open Share Details\n&#039;========================================\n\nSet dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; Add one line for each admin user that you do not want listed in the sensor output.  \n&#039; dictBlacklist.Add LCase(&quot;NomadSHR&quot;), True\n\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Share where caption != &#039;Default Share&#039; AND caption != &#039;Remote Admin&#039; AND caption != &#039;Remote IPC&#039;&quot;,,48)\n\nstrSep = &quot;|&quot;\n\nhasResults = False\nFor Each objItem in colItems\n\tstrType = &quot;Other&quot;\n\tSelect Case objItem.Type\n\t\tCase 0\n\t\t\tstrType = &quot;Disk Drive&quot;\n\t\tCase 1\t\n\t\t\tstrType = &quot;Print Queue&quot;\n\t\tCase 2\n\t\t\tstrType = &quot;Device&quot;\n\t\tCase 3\n\t\t\tstrType = &quot;IPC&quot;\n\t\tCase else\n\tEnd Select\n\tstrShareName = objItem.Name\n\t&#039;strPerms = GetPerms(strShareName)\n    strResult = strShareName &amp; strSep &amp; objItem.Path &amp; strSep &amp; objItem.Status &amp; strSep &amp; strType &amp; strSep &amp; strPerms &amp; GetPerms(strShareName)\n    \n    bShouldList = True\n    For Each strItem In dictBlacklist.Keys\n        If InStr(LCase(strResult), strItem) &gt; 0 Then \n            bShouldList = False\n        End If\n    Next\n\n    If bShouldList Then \n        WScript.Echo strResult\n        hasResults = True\n    End If \nNext\n\nIf Not hasResults Then\n\tWScript.Echo &quot;No shares&quot;\nEnd If\n\n \nFunction GetPerms(strShareName)\n\t Dim ArrResult()\n\t intSize= 0\n\t ReDim Preserve ArrResult(intSize)\n     &#039;wscript.echo strShareName\n     Dim objWMIService : Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\t \n     Dim colItems : Set colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_LogicalShareSecuritySetting where NAME=&quot; &amp; &quot;&#039;&quot; &amp; strShareName &amp; &quot;&#039;&quot;)\n\t For Each objItem In colItems\n         \n         intRtn = objItem.GetSecurityDescriptor(wmiSecurityDescriptor)\n     \n         colDACLs = wmiSecurityDescriptor.DACL\n         \n         For Each objACE In colDACLs\n\t\t\t \n             Set objUserGroup = objACE.Trustee\n             \n             Select Case objACE.AccessMask\n                 Case 1179817 strPermission = &quot;READ&quot;\n                 Case 1245631 strPermission = &quot;CHANGE&quot;\n                 Case 2032127 strPermission = &quot;FULL CONTROL&quot;\n             End Select\n             ReDim Preserve ArrResult(intSize)\n             &#039;wscript.echo (Ucase(objUserGroup.Name)) &amp; &quot; | &quot; &amp; strPermission\n\t\t\n\t\t ArrResult(intSize) = (Ucase(objUserGroup.Name)) &amp; &quot;-&quot; &amp; strPermission\n\t\t &#039;wscript.echo intSize\n\t\t intSize = intSize + 1\n         Next\n     Next\n\t GetPerms = Join(ArrResult, &quot;\\&quot;)\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Path", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Permissions", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 154, 
      "category": "Security", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Returns various data about a machines externally or locally defined Password Policy.\nExample: maximum age | minimum age | enforced history | minimum length | lockout duration | lockout threshold | lockout observation window", 
      "exclude_from_parse_flag": 1, 
      "hash": 2417208908, 
      "hidden_flag": 0, 
      "id": 305, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Password Policy Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Password Policy Details\n&#039;========================================\n\nOn Error Resume Next\n\nDim objRoot, objDomain, strSep\n&#039;Maximum Password Age | Minimum Password Age | Enforced Password History | Minimum Password Length | Lockout Duration| Lockout Threshold |Lockout Observation Window\nstrSep = &quot;|&quot;\n\nSet objRoot = GETOBJECT(&quot;LDAP://RootDSE&quot;)\nSet objDomain = GETOBJECT(&quot;LDAP://&quot; &amp; objRoot.GET(&quot;defaultNamingContext&quot;))\n\nIf IsEmpty(objDomain) Then\nGetSecPolDetails strSep\nElse\n\nmaximumPasswordAge = int(Int8ToSec(objDomain.GET(&quot;maxPwdAge&quot;)) / 86400) &#039;convert to days\nminimumPasswordAge = Int8ToSec(objDomain.GET(&quot;minPwdAge&quot;)) / 86400  &#039;convert to days\nminimumPasswordLength = objDomain.GET(&quot;minPwdLength&quot;)\naccountLockoutDuration = Int8ToSec(objDomain.GET(&quot;lockoutDuration&quot;)) / 60  &#039;convert to minutes\nlockoutThreshold = objDomain.GET(&quot;lockoutThreshold&quot;) \nlockoutObservationWindow = Int8ToSec(objDomain.GET(&quot;lockoutObservationWindow&quot;)) / 60 &#039;convert to minutes\npasswordHistory = objDomain.GET(&quot;pwdHistoryLength&quot;)\n\nwscript.echo maximumPasswordAge &amp; &quot; days&quot; &amp; strSep &amp; _\n\t     minimumPasswordAge &amp; &quot; days&quot; &amp; strSep &amp; _\n\t     passwordHistory &amp; &quot; passwords remembered&quot; &amp; strSep &amp; _\n\t     minimumPasswordLength &amp; &quot; characters&quot; &amp; strSep &amp; _\n\t     accountLockoutDuration &amp; &quot; minutes&quot; &amp; strSep &amp; _\n\t     lockoutThreshold &amp; &quot; invalid logon attempts&quot; &amp; strSep &amp; _\n\t     lockoutObservationWindow &amp; &quot; minutes&quot;\n\t     \n\nEnd If\n\n\nFUNCTION GetSecPolDetails(strSep)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetAccResults, strNetAccResults\n\tDim strNetAccLine, strMinAge, strMaxAge, strPWDHist, strMinLength\n\tDim strLockDur, strLockThresh, strLockWindow\n\tDim bPrintLine, bNewInterface\n\t\n\tstrCommand = &quot;net accounts&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetAccResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetAccResults = Split(LCase(strNetAccResults),vbCrLf)\n\n\tFor Each strNetAccLine In arrNetAccResults\n\t\tIf InStr(strNetAccLine,&quot;minimum password age&quot;) &gt; 0 Then\n\t\t\tstrMinAge = Trim(Split(strNetAccLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetAccLine, &quot;maximum password&quot;) &gt; 0 Then\n\t\t\tstrMaxAge = Trim(Split(strNetAccLine,&quot;: &quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetAccLine, &quot;minimum password length&quot;) &gt; 0 Then\n\t\t\tstrMinLength = Trim(Split(strNetAccLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetAccLine, &quot;password history&quot;) &gt; 0 Then\n\t\t\tstrPWDHist = Trim(Split(strNetAccLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetAccLine, &quot;password history&quot;) &amp; InStr(strNetAccLine, &quot;none&quot;) Then\n\t\t\tstrPWDHist = &quot;0&quot;\n\t\tEnd If\n\t\tIf InStr(strNetAccLine, &quot;lockout threshold&quot;) &gt; 0 Then\n\t\t\tstrLockThresh = Trim(Split(strNetAccLine,&quot;:&quot;)(1))\n\t\tEnd If\t\n\t\tIf InStr(strNetAccLine, &quot;lockout threshold&quot;) &amp; InStr(strNetAccLine, &quot;never&quot;) Then\n\t\t\tstrLockThresh = &quot;0&quot;\n\t\tEnd If\t\t\n\t\tIf InStr(strNetAccLine,&quot;lockout duration&quot;) &gt; 0 Then\n\t\t\tstrLockDur = Trim(Split(strNetAccLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetAccLine,&quot;lockout observation&quot;) &gt; 0 Then\n\t\t\tstrLockWindow = Trim(Split(strNetAccLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\t\n\tNext\n\t&#039;WScript.Echo strMaxAge &amp; &quot; days&quot; &amp; strSep &amp; strMinAge &amp;  &quot; days&quot; &amp; strSep &amp; strPWDHist &amp; &quot; passwords remembered&quot; &amp;  strSep &amp; strMinLength &amp;  &quot; characters&quot; &amp; strSep &amp; strLockDur &amp;  &quot; minutes&quot; &amp; strSep &amp; strLockThresh &amp;  &quot; invalid logon attempts&quot; &amp; strSep &amp; strLockWindow  &amp; &quot; minutes&quot;\n\n\tWScript.Echo strPWDHist &amp; &quot; passwords remembered&quot; &#039;&amp;  strSep &amp; strMinLength &amp;  &quot; characters&quot; &amp; strSep &amp; strLockDur &amp;  &quot; minutes&quot; &amp; strSep &amp; strLockThresh &amp;  &quot; invalid logon attempts&quot; &amp; strSep &amp; strLockWindow  &amp; &quot; minutes&quot;\n\n\n\n\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEND FUNCTION &#039;GetSecPolDetails\n\nFUNCTION Int8ToSec(BYVAL objInt8)\n        &#039; Function to convert Integer8 attributes from\n        &#039; 64-bit numbers to seconds.\n        DIM lngHigh, lngLow\n        lngHigh = objInt8.HighPart\n        &#039; Account for error in IADsLargeInteger property methods.\n        lngLow = objInt8.LowPart\n        IF lngLow &lt; 0 THEN\n            lngHigh = lngHigh + 1\n        END IF\n        Int8ToSec = -(lngHigh * (2 ^ 32) + lngLow) / (10000000)\nEND FUNCTION", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Maximum Password Age", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Minimum Password Age", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Enforced Password History", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Minimum Password Length", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Lockout Duration", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Lockout Threshold", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Lockout Observation Window", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 155, 
      "category": "Unmanaged Assets", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "IP addresses of machines in the network that do not have the Tanium Client running.  When possible, unmanaged assets will return the IP address, the machine name, and the MAC address\nExample: 192.168.1.2 | my-machine-name | 00-22-9a-3e-91-5f", 
      "exclude_from_parse_flag": 1, 
      "hash": 174166312, 
      "hidden_flag": 0, 
      "id": 307, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Unmanaged Assets", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Unmanaged Applications\n&#039;========================================\n\nOption Explicit\n\n&#039;&#039; ---- Begin Customer Modifiable ----\n&#039; This minutes old threshold will determine how new a file must be\n&#039; in order to have results reported by the sensor. Ideally this would\n&#039; match the reissuance frequency of the scan\nDim intMinutesOldThreshold\nintMinutesOldThreshold = 60\n&#039; ---- End Customer Modifiable ---&#039;\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput\n&#039;ip address|name|mac address\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;uaresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tDim dtmModified,minutesOld\n\tdtmModified = objFSO.GetFile(fn).DateLastModified\n\tIf IsDate(dtmModified) Then\n\t\tminutesOld = GetMinutesOld(dtmModified)\n\t\tIf CDbl(minutesOld) &gt;= intMinutesOldThreshold Then\n\t\t\tWScript.Echo &quot;Results older than &quot; &amp; intMinutesOldThreshold &amp; &quot; - waiting to rescan&quot;\n\t\t\tWScript.Quit(0)\n\t\tEnd If\n\tEnd If\n\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\t\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\thasOutput = True\n\t\tstrLine = objReadFile.ReadLine\n\n\t\tWScript.Echo strLine\n\tLoop\n\tobjReadFile.Close\n\t\n\tIf Not hasOutput Then\n\t\tWScript.Echo &quot;Unmanaged assets not found&quot;\n\tEnd If\nElse\n   Wscript.echo &quot;Unmanaged Asset scan results not found&quot;\nEnd if\nWScript.Quit()\n\n\nFunction GetMinutesOld(strDate)\n\tDim patternDate,today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( now )\n\tGetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)\nEnd Function\n\n\nFunction RegKeyExists(reg, sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "IP Address", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Computer Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "MAC Address", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "MAC Organization", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 156, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns a list of USB storage devices currently plugged in to the client machine.\nExample: USB Mass Storage Device", 
      "exclude_from_parse_flag": 1, 
      "hash": 4284507739, 
      "hidden_flag": 0, 
      "id": 309, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "USB Storage Devices", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; USB Storage Devices\n&#039;========================================\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PnPEntity where (Status=&#039;OK&#039; and Service=&#039;USBSTOR&#039;)&quot;,,48)\n\nhasResults = False\n\nFor Each objItem in colItems\n\thasResults = True\n    Wscript.Echo objItem.Caption\nNext\n\nIf Not hasResults Then\n\tWScript.Echo &quot;No devices&quot;\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nfor udi in $(/usr/bin/hal-find-by-capability --capability storage)\ndo\n    device=$(hal-get-property --udi $udi --key block.device)\n    vendor=$(hal-get-property --udi $udi --key storage.vendor)\n    model=$(hal-get-property --udi $udi --key storage.model)\n    if [[ $(hal-get-property --udi $udi --key storage.bus) = &quot;usb&quot; ]]\n    then\n        parent_udi=$(hal-find-by-property --key block.storage_device --string $udi)\n        mount=$(hal-get-property --udi $parent_udi --key volume.mount_point)\n        label=$(hal-get-property --udi $parent_udi --key volume.label)\n        media_size=$(hal-get-property --udi $udi --key storage.removable.media_size)\n        size=$(( $media_size / ( 1000 * 1000 * 1000 ) ))\n#        printf &quot;$vendor  $model  $device  $mount  $label &quot;${size}GB&quot; \\n&quot;\n        printf &quot;$vendor $model &quot;${size}GB&quot; \\n&quot;\n    fi\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 157, 
      "category": "Security", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the users which have no screen saver password set.\nExample: Domain\\John.Doe", 
      "exclude_from_parse_flag": 1, 
      "hash": 1417112132, 
      "hidden_flag": 0, 
      "id": 311, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "No Screen Saver Password", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; No Screen Saver Password\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(_\n    &quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(_\n    &quot;Select * from Win32_Desktop&quot;)\nFor Each objItem in colItems\n\tIf objItem.ScreenSaverSecure = False Then\n\t\tIf InStr(LCase(objItem.Name), &quot;nt authority&quot;) = 0 Then\n\t\t\tWScript.Echo objItem.Name\n\t\tEnd If\t\n\tEnd If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 158, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Outputs True if USB storage devices connected to the client machine are set to write protected mode and false if not.\nExample: False", 
      "exclude_from_parse_flag": 1, 
      "hash": 3595988712, 
      "hidden_flag": 0, 
      "id": 313, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "USB Write Protected", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; USB Write Protected\n&#039;========================================\n\n&#039; This sensor will output True if USB storage devices are\n&#039; set to write protect mode and false if not\n\nOption Explicit\n\nIf USBWriteProtected Then\n\tWScript.Echo &quot;True&quot;\nElse\n\tWScript.Echo &quot;False&quot;\nEnd If\n\nFunction USBWriteProtected\n&#039; This function will look into the registry to determine if USB storage devices\n&#039; are write protected\n\n\tConst HKLM = &amp;H80000002\n\n\tDim objRegistry, objWMIService\n\tDim strComputer\n\tDim strUSBWriteProtectKey\n\tDim strUSBWriteProtectValueName, dwordWriteProtectValue\n\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;) \n\n\tSet objRegistry = _\n\t\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\t\n\n\tstrUSBWriteProtectKey = &quot;SYSTEM\\CurrentControlSet\\Control\\StorageDevicePolicies&quot;\n\tstrUSBWriteProtectValueName = &quot;WriteProtect&quot; &#039; This is a DWORD value\n\n\tIf Not RegKeyExists(objRegistry, HKLM, strUSBWriteProtectKey) Then\n\t\tUSBWriteProtected = False\n\tEnd If\n\t\n\tobjRegistry.GetDWORDValue HKLM, strUSBWriteProtectKey, strUSBWriteProtectValueName, dwordWriteProtectValue\n\t\n\tIf IsNull(dwordWriteProtectValue) Then\n\t\tUSBWriteProtected = False\n\tElse \n\t\tIf dwordWriteProtectValue = 1 Then\n\t\t\tUSBWriteProtected = True\n\t\tEnd IF\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet objWMIService = Nothing\n\tSet objRegistry = Nothing\n\t\nEnd Function &#039;USBWriteProtected\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 159, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Any established connections currently being made from a process that is not allowed or to a destination that is not allowed.  This multi-column Sensor displays the process responsible for the connection, the display name of the process (if available), and the target IP Address and port.  Processes and IP ranges can be excluded in the Sensor definition.\nExample: chrome.exe | Google Chrome | 173.194.79.99:80", 
      "exclude_from_parse_flag": 1, 
      "hash": 1509255291, 
      "hidden_flag": 0, 
      "id": 315, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Non-Approved Established Connections", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Non-Approved Established Connections\n&#039;========================================\n\nshowProcess = True\nshowPort = True\nshowDNSName = False\n\nDim strcommand, results, excludeProcesses, excludeSubnets, taniumDebug, excludeProcessesFilePath, excludeSubnetsFilePath\nDim strSep : strSep = &quot;|&quot;\nexcludeProcessesFilePath = GetTaniumDir(&quot;Tools\\IR&quot;) &amp; &quot;excluded-processes.dat&quot;\nexcludeSubnetsFilePath = GetTaniumDir(&quot;Tools\\IR&quot;) &amp; &quot;excluded-subnets.dat&quot;\n\n&#039; This is a multi-column sensor that looks like:\n&#039;Process|Name|Target IP\n\nDim objFSO : Set objFSO = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\nIf objFSO.FileExists(excludeProcessesFilePath) Then\n\t&#039;exclude processes file exists - read from file\n\texcludeProcesses = LoadDATFileAsArray(excludeProcessesFilePath)\nElse\n\t&#039;exclude processes file doesn&#039;t exist - specify processes below\n\texcludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;\n\t&#039;excludeProcesses = &quot;chrome.exe&quot;\n\t&#039;excludeProcesses = &quot;iexplore.exe&quot;\n\t&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;\n\t&#039;excludeProcesses = &quot;trillian.exe&quot;\n\texcludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)\nEnd If \n\nIf objFSO.FileExists(excludeSubnetsFilePath) Then\n\t&#039;exclude subnets file exists - read from file\n\texcludeSubnets = LoadDATFileAsArray(excludeSubnetsFilePath)\nElse\n\t&#039;exclude subnets file doesn&#039;t exist - specify subnets below\n\texcludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;\n\t&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;\n\texcludeSubnets = Split(excludeSubnets, &quot;,&quot;)\nEnd If \n\n\ntaniumDebug = False\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nquery = &quot;select name, executablepath, processId from win32_process&quot;\nSet colResults = objWMIService.ExecQuery(query)\n\n&#039;dictionary for process-app pairs\nSet processes = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nFor Each result In colResults \n   processId = CStr(result.ProcessId)\n   processPath = result.ExecutablePath\n   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later\nNext\n\nstrcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; Chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find &quot; &amp; Chr(34) &amp; &quot;ESTABLISHED&quot; &amp; Chr(34)\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrPingResults = LCase(objScriptExec.StdOut.ReadAll)\n\nresults = Split(strPingResults, vbCrLf)\nj = 0\n\nFor Each line In results\n   line = cleanWhitespace(Trim(line))\n   \n   If line &lt;&gt; &quot;&quot; Then \n\t   lineResults = Split(line)\n\t   i = 0\n\t   Dim strPort, strPid, strConnectionType, strForeignIp, strApp\n\t   For Each word In lineResults\n\t      If i = 1 Then\n\t         strPort = word\n\t      ElseIf i = 2 Then\n\t         strForeignIp = word\n\t      ElseIf i = 3 Then\n\t         strConnectionType = word\n\t      ElseIf i = 4 Then\n\t         strPid = word\n\t      End If\n\t      \n\t      i = i + 1\n\t   Next\n\t   \n\t   &#039;DO NOT INCLUDE EXCLUDED APPS\n\t   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path\n\t   arrAppEntry = Split(strAppEntry,&quot;,&quot;)\n\t   strAppExe = arrAppEntry(0)\n\t   strAppPath = arrAppEntry(1)\n\t   \n\t   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))\n\t   \n\t   &#039;DO NOT INCLUDE EXCLUDED SUBNETS\n\t   isNotExcludedSubnet = Not(ContainedInSubnet(strForeignIp, excludeSubnets))\n\t   \n\t   If Not(IsEmpty(strAppExe)) _\n\t      And isNotExcludedApp _ \n\t      And isNotExcludedSubnet Then\n\t\n\t\t  If Not showPort Then \n\t\t  \tarrTemp = Split(strForeignIp, &quot;:&quot;)\n\t\t\tstrForeignIp = arrTemp(0)\n\t\t  End If\n\t\n\t\t\tIf showDNSName Then\n\t\t\t\tarrTemp = Split(strForeignIp, &quot;:&quot;)\n\t\t\t\tstrForeignIp = ReverseDNSLookup(arrTemp(0))\n\t\t\t\tIf UBound(arrTemp) &gt;=1 Then \n\t\t\t\t\tstrForeignIp = strForeignIp &amp; &quot;:&quot; &amp; arrTemp(1)\n\t\t\t\tEnd If\n\t\t\tEnd If \n\t\t\t\n\t      If showProcess Then\n\t      \tresults(j) = strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIp\n\t      Else\n\t        results(j) = strSep &amp; strSep &amp; strForeignIp\n\t      End If\t\n\t   Else\n\t      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp\n\t      results(j) = &quot;&quot;   \n\t   End If \n\t   \n\t   j = j + 1\n\tEnd If\nNext\n\nresults = RemDups(results)\n\nIf UBound(results) &lt; 1 Then\n\tIf GetLocale() &lt;&gt; 1033 Then\n\t\tWScript.Echo &quot;English Language OS Required&quot;\n\tEnd If\nEnd If\n\nFor Each result In results \n   WScript.Echo result\nNext\n\nWScript.Quit\n\nFunction ReverseDNSLookup(strIPAddress)\n\tReverseDNSLookup = strIPAddress\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\tSet objExecCommand = objShell.Exec(&quot;%comspec% /c nslookup &quot; &amp; strIPAddress)\n\t\n\tstrResults = objExecCommand.StdOut.ReadAll\n\t\n\tIf InStr(strResults, &quot;Name:&quot;) Then\n\t\tarrNameTemp = Split(strResults, &quot;Name:&quot;)\n\t\tarrName = Split(Trim(arrNameTemp(1)), Chr(13))\n\t\t\n\t\tReverseDNSLookup = arrName(0)\n\tEnd If\t\nEnd Function\n\nFunction LoadDATFileAsArray(strFilePath)\n\tDim objFSO : Set objFSO = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\tDim responseDict : Set responseDict = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\t\n\tIf objFSO.FileExists(strFilePath) Then\n        Dim objDatFile, strLine\n        Set objDatFile = objFso.OpenTextFile(strFilePath, 1)\n        \n        &#039;read in all entries, one per line\n        Do While objDatFile.AtEndOfStream &lt;&gt; True\n            strLine = LCase(Trim(objDatFile.ReadLine))\n\t\t\tIf strLine &lt;&gt; &quot;&quot; And Left(strLine, 1) &lt;&gt; &quot;&#039;&quot; And Not responseDict.Exists(strLine) Then \n\t\t\t\tresponseDict.Add strLine, True\n\t\t\tEnd If\n        Loop\n    End If\n\tLoadDATFileAsArray = responseDict.Keys\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction ContainedInSubnet(str, arr)\n   Dim strIp, strSubnet, strMask\n   temp = Split(str, &quot;:&quot;)\n   strIp = temp(0)\n\n   For Each item In arr\n      If InStr(item, &quot;-&quot;) Then &#039;Subnet range\n         temp = Split(item, &quot;-&quot;)\n         lower = Split(temp(0), &quot;:&quot;)\n         upper = Split(temp(1), &quot;:&quot;)\n         lowerSubnet = Trim(lower(0))\n         lowerMask = Trim(lower(1))\n         upperSubnet = Trim(upper(0))\n         upperMask = Trim(upper(1))\n         \n         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _\n            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If \n      Else &#039;Single subnet\n         parts = Split(item, &quot;:&quot;)\n         strSubnet = Trim(parts(0))\n         strMask = Trim(parts(1))\n         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If\n      End If \n   Next\n   ContainedInSubnet = False\nEnd Function\n\nFunction ContainedInArray(str, arr)\n   For Each item In arr \n      If str = Trim(item) Then\n         ContainedInArray = True\n         Exit Function\n      End If   \n   Next\n   ContainedInArray = False\nEnd Function\n\nFunction cleanWhitespace(strStarter)\n   intStarter = Len(strStarter)\n\tFor i = intStarter To 2 Step -1\n      strChars = Space(i)\n      strStarter = Replace(strStarter, strChars, &quot; &quot;)\n   Next\n   cleanWhitespace = strStarter\nEnd Function\n\nFunction RemDups(ByVal anArray)\n   Dim d, item, thekeys\n   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)\n   d.removeall\n   d.CompareMode = 0\n   For Each item In anArray\n      If Len(item) &gt; 0 Then\n         If Not d.Exists(item) Then d.Add item, item\n      End If\n   Next\n   thekeys = d.keys\n   Set d = Nothing\n   RemDups = thekeys\nEnd Function\n\nFunction Subnet(strAddress, strMask)\n   intSubnetLength = SubnetLength(strMask)\n   Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))\nEnd Function\n\nFunction SubnetLength(strMask)\n   strMaskBinary = StringToBinary(strMask)\n   SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))\nEnd Function\n\nFunction BinaryToString(strBinary)\n   For intOctetPos = 1 To 4\n      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)\n      intOctet = 0\n      intValue = 1\n      For intBinaryPos = 1 To Len(strOctetBinary)\n         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue\n         intValue = intValue * 2\n      Next\n      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)\n   Next\nEnd Function\n\nFunction StringToBinary(strAddress)\n   objAddress = Split(strAddress, &quot;.&quot;, -1)\n   For Each strOctet In objAddress\n      intOctet = CInt(strOctet)\n      strOctetBinary = &quot;&quot;\n      For x = 1 To 8\n         If intOctet Mod 2 &gt; 0 Then\n            strOctetBinary = &quot;1&quot; &amp; strOctetBinary\n         Else\n            strOctetBinary = &quot;0&quot; &amp; strOctetBinary\n         End If\n         intOctet = Int(intOctet / 2)\n      Next\n      StringToBinary = StringToBinary &amp; strOctetBinary\n   Next\nEnd Function\n\nFunction ProcessNameToApplicationName(strExecutablePath, strExecutableName)\n&#039; This function will return the full application name of a running executable\n\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\n\t\tarrPathParts = Split(strExecutablePath,&quot;\\&quot;)\n\n\t\tIf UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tSet fso = Nothing\n\t\t\tExit Function\n\t\tEnd If\n\t\tstrExecutable = arrPathParts(UBound(arrPathParts))\n\t\t\n\t\tIf fso.FileExists(strExecutablePath) Then\n\t\t\tDim strOutput, fileVersion, fileVersionOutput, fullName\n\t\t\n\t\t\tSet execFile = fso.GetFile(strExecutablePath)\n\t\t\tfullName = GetDescription(execFile.ParentFolder.Path, strExecutable)\n\t\t\tIf Not fullName = &quot;&quot; Then\n\t\t\t\tProcessNameToApplicationName = fullName\n\t\t\tElse\n\t\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tEnd If\n\t\tElse &#039; file doesn&#039;t exist or inaccessible\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\tEnd If\n\nEnd Function &#039;ProcessNameToApplicationName\n\nFunction GetDescription(folderPath, fileName)\n\tdescIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)\n\tIf IsEmpty(descIndex) Then\n\t\tdescIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)\n\tEnd If\n\tGetDescription = GetFileProperty(folderPath, fileName, descIndex)\nEnd Function\n\nFunction GetFileProperty(folderPath, fileName, fileProperty)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tGetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)\nEnd Function\n\nFunction GetAttributeIndex(folderPath, attrTarget)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tFor i = 0 To 50\n\t\tattrName = objFolder.GetDetailsOf(objFolder.Items, i)\n\t\tIf LCase(attrName) = LCase(attrTarget) Then\n\t\t\tGetAttributeIndex = i\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nlsof -iTCP -sTCP:ESTABLISHED -P +c 15 -n|grep -v &quot;COMMAND&quot; |while read line\ndo\n        set -- $line\n        second=`echo $9|cut -d&#039;&gt;&#039; -f 2`\n        echo $1\\|\\|$second\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 120, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Target IP", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 160, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Returns details of ad-hoc wireless networks are hosted in your environment.  Details include SSID, Mode, Max Clients, Auth, Status, BSSID, Radio Type, Channel, and Connections.\nExample: personalwifi | ad-hoc | 1 | Open | active | xx:xx:xx:xx:xx:xx | 802.11g | 11 | 1", 
      "exclude_from_parse_flag": 1, 
      "hash": 3397569679, 
      "hidden_flag": 0, 
      "id": 317, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Hosted Wireless Ad-Hoc Networks", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Hosted Wireless Ad-Hoc Networks\n&#039;========================================\n\n&#039; This sensor uses netsh output to display details about wireless LAN\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n\t\t\t\t\n&#039; This is a multi-column sensor whose output looks like\n&#039; SSID|Mode|Max Clients|Auth|Status|BSSID|Radio Type|Channel|Connections\n\nGetHostedAdHocDetails strSep\n\nFunction GetHostedAdHocDetails(strSep)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine\n\tDim strMode,strHostedSSID,strMaxClients,strAuth\n\tDim strStatus,strBSSID,strRadioType,strChannel,strConnectedClients\n\tDim bPrintLine, bNewHostedNetwork\n\t\n\tstrCommand = &quot;netsh wlan show hostednetwork&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tstrNetshLine = Trim(strNetshLine)\n\t\tIf InStr(strNetshLine,&quot;hosted network settings&quot;) = 1 Then\n\t\t\tbNewHostedNetwork = True\t&#039; if there&#039;s a new hosted network settings entry, it&#039;s time to note a new group\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;mode&quot;) = 1 Then\n\t\t\tstrMode = Trim(Split(strNetshLine,&quot;: &quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;ssid name&quot;) = 1 Then\n\t\t\tstrHostedSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\t\t&#039; ssid is presented in quotes, remove\n\t\t\tstrHostedSSID = RemoveOuterCharacters(strHostedSSID,Chr(34))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;max number of clients&quot;) = 1 Then\n\t\t\tstrMaxClients = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;authentication&quot;) = 1 Then\n\t\t\tstrAuth = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;status&quot;) = 1 Then\n\t\t\tstrStatus = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\t\n\t\tIf InStr(strNetshLine,&quot;bssid&quot;) = 1 Then\n\t\t\tstrBSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;radio type&quot;) = 1 Then\n\t\t\tstrRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;channel&quot;) = 1 Then\n\t\t\tstrChannel = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;number of clients&quot;) = 1 Then &#039; last entry\n\t\t\tstrConnectedClients = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewHostedNetwork And bPrintLine Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, print\n\t\t\tIf strStatus = &quot;started&quot; Then\n\t\t\t\tWScript.Echo strHostedSSID &amp; strSep &amp; strMode &amp; strSep &amp; strMaxClients &amp; strSep &amp; strAuth _\n\t\t\t\t\t&amp; strSep &amp; strStatus &amp; strSep &amp; strBSSID &amp; strSep &amp; strRadioType &amp; strSep _\n\t\t\t\t\t&amp; strChannel &amp; strSep &amp; strConnectedClients\n\t\t\tEnd If\n\t\t\tbNewHostedNetwork = False\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetHostedAdHocDetails\n\nFunction RemoveOuterCharacters(strTemp,strChar)\n\tDim intStrLen\n\t\n\tintStrLen = Len(strTemp)\n\tIf InStr(strTemp,strChar) = 1 Then\n\t\tstrTemp = Right(strTemp,intStrLen - 1)\n\tEnd If\n\tintStrLen = Len(strTemp) &#039; has new length\n\tIf InStr(strTemp,strChar) = intStrLen Then\n\t\tstrTemp = Left(strTemp,intStrLen - 1)\n\tEnd If\n\t\n\tRemoveOuterCharacters = strTemp\n\t\nEnd Function &#039;RemoveOuterCharacters", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n# cah\n# Created 20140621\n# Modified\n# looking for Ad-Hoc networks\n# windows output to try to match: SSID | Mode | Max Clients | Auth | Status | BSSID | Radio Type | Channel | Connections | \n\nAIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;\n\n\n#Get SSID\nIFS=$&#039;\\n&#039; # Set delimiter to IFS\nSSIDArray=(` $AIRPATH/airport -s  `)\n#echo $SSIDArray[1]\n\n\n\ni=0\nfound=false \nANS=()\nfor ssid in &quot;${SSIDArray[@]}&quot;\ndo \n\t:\n\tif [ $found == &quot;true&quot; ] ; then\n\t\t#echo $ssid | grep -v &quot;^$&quot; | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/..:..//g&#039; | sed &#039;s/ -..  ... *//g&#039; | sed &#039;s/\\(::\\).*  .. /\\1 /&#039; | sed &#039;s/WPA\\(.*\\) WPA2\\(.*\\)/WPA WPA2 \\1 \\2/g&#039; | sed &#039;s/(/ /g&#039; | sed &#039;s/)/ /g&#039; | sed &#039;s/::/ | |/g&#039; | sed &#039;s/WPA2/WPA2|/&#039; | sed &#039;s/NONE/NONE|NONE|/g&#039; | sed &#039;s/WEP/WEP|WEP/g&#039; | sed &#039;s/WPA \\([^W][^P]\\)/WPA| \\1/g&#039; | awk &#039;{print $0,&quot;\\n&quot;}&#039;\n\t\tMySSID=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^\\(.*\\) ..:..:..:..:..:.. .*/ \\1 /g&#039; )\n\t\tBSSID=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^.* \\(..:..:..:..:..:..\\) .*/ \\1 /g&#039; )\n\t\tChannel=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^.* ..:..:..:..:..:.. //&#039; | awk &#039;{print $2}&#039; ) \t\n\t\tAuth=$( echo $ssid | grep -v &quot;SSID BSSID  &quot; | sed &#039;s/^.* ..:..:..:..:..:.. //&#039; | awk &#039;{print $5}&#039; ) \n\t\techo &quot;$MySSID|$Mode|$MaxClients|$Auth|$Status|$BSSID|$Radio|$Channel|$Connections&quot; | grep -v &quot;^|||||||$&quot;\n\telse\n\t\tteststring=$(echo $ssid | grep IBSS)\n\t\tMySSID=&quot;&quot;\n\t\tMode=&quot;&quot;\n\t\tMaxClients=&quot;&quot;\n\t\tAuth=&quot;&quot;\n\t\tStatus=&quot;&quot;\n\t\tBSSID=&quot;&quot;\n\t\tRadio=&quot;&quot;\n\t\tChannel=&quot;&quot;\n\t\tConnections=&quot;&quot;\n\t\tif [[ &quot;$teststring&quot; == *IBSS*network* ]] ; then\n\t\t\tfound=true\n\t\tfi\n  \tfi\n  \t((i++))\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "SSID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Mode", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Max Clients", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Auth", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "BSSID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Radio Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "Channel", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Connections", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 161, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Details of currently active wireless network connection using WEP authentication by client machine.  Details include SSID, MAC address, connection state, network type, radio type, authentication, receive rate, transmit rate, and signal strength.\nExample: hotspotwifi | xx-xx-xx-xx-xx-xx | connected | Infrastructure | 802.11g | WEP | 54 | 54 | 99%", 
      "exclude_from_parse_flag": 1, 
      "hash": 3394404860, 
      "hidden_flag": 0, 
      "id": 319, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Wireless Networks Using WEP", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Wireless Networks Using WEP\n&#039;========================================\n\n&#039; This sensor uses netsh output to display details about wireless LAN\n&#039; returns details of those which have &#039;wep&#039; as the encryption type\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n\t\t\t\t\n&#039; This is a multi-column sensor whose output looks like\n&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal 0-5\n\nGetWepEncryptedWirelessNetworkDetails strSep\n\nFunction GetWepEncryptedWirelessNetworkDetails(strSep)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine, strName, strMAC, strState, strSSID\n\tDim strNetworkType, strRadioType, strAuthentication\n\tDim strReceiveRate, strTransmitRate, strSignal, intSignal\n\tDim bPrintLine, bNewInterface\n\t\n\tstrCommand = &quot;netsh wlan show interfaces&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tIf InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then\n\t\t\tbNewInterface = True\t&#039; if there&#039;s a new Name, it&#039;s time to note a new group\n\t\t\tstrName = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then\n\t\t\tstrMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then\n\t\t\tstrState = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then\n\t\t\tstrSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then\n\t\t\tstrNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;radio type&quot;) &gt; 0 Then\n\t\t\tstrRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\t\t\n\t\tIf InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then\n\t\t\tstrAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;receive rate&quot;) &gt; 0 Then\n\t\t\tstrReceiveRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;transmit rate&quot;) &gt; 0 Then\n\t\t\tstrTransmitRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then\n\t\t\tstrSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove %\n\t\t\tintSignal = CInt(CInt(strSignal) / 20)\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewInterface And bPrintLine Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, print\n\t\t\tIf InStr(LCase(strAuthentication),&quot;wep&quot;) &gt; 0 Then\n\t\t\t\tWScript.Echo strSSID &amp; strSep &amp; strMAC &amp; strSep &amp; strState &amp; strSep &amp; strNetworkType _\n\t\t\t\t\t&amp; strSep &amp; strRadioType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strReceiveRate &amp; strSep _\n\t\t\t\t\t&amp; strTransmitRate &amp; strSep &amp; intSignal\n\t\t\tEnd If\n\t\t\tbNewInterface = False\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetWepEncryptedWirelessNetworkDetails", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n# cah\n# Created 20140616\n# Modified\n# looking for wireless networks using WEP and providing their details\n# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |\n# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm\n\nAIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;\nRADIO=&quot;unknown&quot;\n\n#Get the wireless interface and mac address\nDEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)\nDEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)\n\nIFS=$&#039;\\n&#039; # Set delimiter to IFS\nSSIDArray=(` $AIRPATH/airport -s | grep -e &quot;\\sWEP$&quot; | grep -v &quot;^&amp;&quot; | sed &quot;s/ ..:.*$//g&quot; `)\n\ni=0\nANS=()\nfor ssid in &quot;${SSIDArray[@]}&quot;\ndo\n\t:\n\tSSID=&quot;$ssid&quot;\n\t((i++))\n\n\tif [ ! &quot;$SSID&quot; ] ; then\n\t\tSSID=&quot;Not Available&quot;\n\t\tNETWORKTYPE=&quot;Not Available&quot;\n\t\tAUTHENTICATION=&quot;Not Available&quot;\n\t\tRECEIVE=&quot;Not Available&quot;\n\t\tTRANSMIT=&quot;Not Available&quot;\n\t\tSIGNAL=&quot;Not Available&quot;\n\tfi\n\n\tif [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then\n\t  STATE=&quot;visible&quot;\n\t  NETWORKTYPE=&quot;unknown&quot;\n\t  AUTHENTICATION=&quot;WEP&quot;\n\t  RECEIVE=&quot;unknown&quot;\n\t  TRANSMIT=$RECEIVE\n\t  PWR=$( $AIRPATH/airport -s | grep &quot;$SSID&quot; | awk -F&quot;..:..:.. &quot; &#039;{print $2}&#039;| awk &#039;{print $1}&#039;| grep -v &quot;^$&quot; )\n\t #This is to convert from power to MS dummy gauge\n\t\tif  (( $PWR &lt;= &quot;-100&quot; )) ; then\n\t\tSIGNAL=&quot;0&quot;\n\t   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then\n\t\tSIGNAL=&quot;1&quot;\n\t   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then\n\t\tSIGNAL=&quot;2&quot;\n\t   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then\n\t\tSIGNAL=&quot;3&quot;\n\t   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then\n\t\tSIGNAL=&quot;4&quot;\n\t   else\n\t\tSIGNAL=&quot;5&quot;\n\t  fi  \n\telse \n\t  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )\n\t  if [ ! &quot;$STATE&quot; ] ; then\n\t\tSTATE=&quot;off&quot;\n\t  fi\n\tfi\n\n\techo &quot;$SSID , $DEVMAC , $STATE ,  $NETWORKTYPE , $RADIO , $AUTHENTICATION , $RECEIVE , $TRANSMIT , $SIGNAL  ($PWR dB)  &quot;\n\ndone\nexit\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "SSID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "MAC", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "State", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Netwrok Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Radio", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Authentication", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Receive", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "Transmit", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Signal 0-5", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 162, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Details of wireless networks that are currently open and unencrypted.  Details include SSID, MAC address, connection state, network type, radio type, authentication, receive rate, transmit rate, and signal strength.\nExample: hotspotwifi | xx-xx-xx-xx-xx-xx | connected | Infrastructure | 802.11g | WEP | 54 | 54 | 99%", 
      "exclude_from_parse_flag": 1, 
      "hash": 1569955801, 
      "hidden_flag": 0, 
      "id": 321, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Unencrypted Wireless Networks", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Unencrypted Wireless Networks\n&#039;========================================\n\n&#039; This sensor uses netsh output to display details about wireless LAN\n&#039; returns details of those which have &#039;open&#039; as the encryption type\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n\t\t\t\t\n&#039; This is a multi-column sensor whose output looks like\n&#039; SSID|MAC|State|Network Type|Radio|Authentication|Receive|Transmit|Signal 0-5\n\nGetUnencryptedWirelessNetworkDetails strSep\n\nFunction GetUnencryptedWirelessNetworkDetails(strSep)\n\n\tDim objShell,objScriptExec\n\tDim strCommand, arrNetshResults, strNetshResults\n\tDim strNetshLine, strName, strMAC, strState, strSSID\n\tDim strNetworkType, strRadioType, strAuthentication\n\tDim strReceiveRate, strTransmitRate, strSignal, intSignal\n\tDim bPrintLine, bNewInterface\n\t\n\tstrCommand = &quot;netsh wlan show interfaces&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\t\n\tstrNetshResults = LCase(objScriptExec.StdOut.ReadAll)\n\tarrNetshResults = Split(LCase(strNetshResults),vbCrLf)\n\t\n\tFor Each strNetshLine In arrNetshResults\n\t\tIf InStr(strNetshLine,&quot;name&quot;) &gt; 0 Then\n\t\t\tbNewInterface = True\t&#039; if there&#039;s a new Name, it&#039;s time to note a new group\n\t\t\tstrName = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;physical address&quot;) &gt; 0 Then\n\t\t\tstrMAC = Trim(Split(strNetshLine,&quot;: &quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;state&quot;) &gt; 0 Then\n\t\t\tstrState = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;ssid&quot;) &gt; 0 And Not InStr(strNetshLine, &quot;bssid&quot;) &gt; 0 Then\n\t\t\tstrSSID = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;network type&quot;) &gt; 0 Then\n\t\t\tstrNetworkType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine, &quot;radio type&quot;) &gt; 0 Then\n\t\t\tstrRadioType = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\t\t\n\t\tIf InStr(strNetshLine,&quot;authentication&quot;) &gt; 0 Then\n\t\t\tstrAuthentication = Trim(Split(strNetshLine,&quot;:&quot;)(1))\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;receive rate&quot;) &gt; 0 Then\n\t\t\tstrReceiveRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;transmit rate&quot;) &gt; 0 Then\n\t\t\tstrTransmitRate = Trim(Split(strNetshLine,&quot;:&quot;)(1)) &amp; &quot; Mbps&quot;\n\t\tEnd If\n\t\tIf InStr(strNetshLine,&quot;signal&quot;) &gt; 0 Then\n\t\t\tstrSignal = Replace(Trim(Split(strNetshLine,&quot;:&quot;)(1)),&quot;%&quot;,&quot;&quot;) &#039; remove %\n\t\t\tintSignal = CInt(CInt(strSignal) / 20)\n\t\t\tbPrintLine = True &#039; If we&#039;ve found an Signal Value, it&#039;s time to print the line.\n\t\tEnd If\n\t\tIf bNewInterface And bPrintLine Then\n\t\t\t&#039; if it&#039;s a new group, and at last line in the new group, print\n\t\t\tIf LCase(strAuthentication) = &quot;open&quot; Then\n\t\t\t\tWScript.Echo strSSID &amp; strSep &amp; strMAC &amp; strSep &amp; strState &amp; strSep &amp; strNetworkType _\n\t\t\t\t\t&amp; strSep &amp; strRadioType &amp; strSep &amp; strAuthentication &amp; strSep &amp; strReceiveRate &amp; strSep _\n\t\t\t\t\t&amp; strTransmitRate &amp; strSep &amp; intSignal\n\t\t\tEnd If\n\t\t\tbNewInterface = False\n\t\t\tbPrintLine = False\n\t\tEnd If\n\tNext\n\t\n\t&#039;Cleanup\n\tSet objScriptExec = Nothing\n\tSet objShell = Nothing\nEnd Function &#039;GetUnencryptedWirelessNetworkDetails", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n# cah\n# Created 20140616\n# Modified 20140730\n# looking for unencrypted wireless networks and providing their details\n# SSID MAC State NetworkType Radio Authentication Receive Transmit Signal(0-5) , delimiter is |\n# Quality conversions based off of: http://stackoverflow.com/questions/15797920/how-to-convert-wifi-signal-strength-from-quality-percent-to-rssi-dbm\n\nAIRPATH=&quot;/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources&quot;\nRADIO=&quot;unknown&quot;\n\n#Get the wireless interface and mac address\nDEVID=$(networksetup -listallhardwareports | grep -A1 Wi-Fi | awk -F &quot;Device: &quot; &#039;{print $2}&#039; | grep -v &quot;^$&quot;)\nDEVMAC=$(networksetup -getmacaddress $DEVID | awk -F&quot;: &quot; &#039;{print $2}&#039; | awk -F&quot;(&quot; &#039;{print $1}&#039;)\n\nIFS=$&#039;\\n&#039; # Set delimiter to IFS\nSSIDArray=(` $AIRPATH/airport -s | grep -e &quot;\\sNONE$&quot; | grep -v &quot;^&amp;&quot; | sed &quot;s/ ..:.*$//g&quot; `)\n\ni=0\nANS=()\nfor ssid in &quot;${SSIDArray[@]}&quot;\ndo\n\t:\n\tSSID=&quot;$ssid&quot;\n\t((i++))\n\n\tif [ ! &quot;$SSID&quot; ] ; then\n\t\tSSID=&quot;Not Available&quot;\n\t\tNETWORKTYPE=&quot;Not Available&quot;\n\t\tAUTHENTICATION=&quot;Not Available&quot;\n\t\tRECEIVE=&quot;Not Available&quot;\n\t\tTRANSMIT=&quot;Not Available&quot;\n\t\tSIGNAL=&quot;Not Available&quot;\n\tfi\n\n\tif [ &quot;$SSID&quot; != &quot;Not Available&quot; ] ; then\n\t  STATE=&quot;visible&quot;\n\t  NETWORKTYPE=&quot;unknown&quot;\n\t  AUTHENTICATION=&quot;none &quot;\n\t  RECEIVE=&quot;unknown&quot;\n\t  TRANSMIT=$RECEIVE\n\t  PWR=$( $AIRPATH/airport -s | grep &quot;$SSID&quot; | awk -F&quot;..:..:.. &quot; &#039;{print $2}&#039; | awk &#039;{print $1}&#039; )\n\n\t #This is to convert from power to MS dummy gauge\n\t\tif  (( $PWR &lt;= &quot;-100&quot; )) ; then\n\t\tSIGNAL=&quot;0&quot;\n\t   elif (((  $PWR &gt; &quot;-100&quot; ) &amp;&amp; ( $PWR &lt; &quot;-93&quot; ))) ; then\n\t\tSIGNAL=&quot;1&quot;\n\t   elif (((  $PWR &gt;= &quot;-93&quot; ) &amp;&amp; ( $PWR &lt; &quot;-87&quot; ))) ; then\n\t\tSIGNAL=&quot;2&quot;\n\t   elif (((  $PWR &gt;= &quot;-87&quot; ) &amp;&amp; ( $PWR &lt; &quot;-75&quot; ))) ; then\n\t\tSIGNAL=&quot;3&quot;\n\t   elif ((( $PWR &gt;= &quot;-75&quot; ) &amp;&amp; ( $PWR &lt; &quot;-50&quot; ))) ; then\n\t\tSIGNAL=&quot;4&quot;\n\t   else\n\t\tSIGNAL=&quot;5&quot;\n\t  fi  \n\telse \n\t  STATE=$( $AIRPATH/airport -I | grep &quot;state:&quot; | awk &#039;{print $2}&#039; )\n\t  if [ ! &quot;$STATE&quot; ] ; then\n\t\tSTATE=&quot;off&quot;\n\t  fi\n\tfi\n\n\techo &quot;$SSID | $DEVMAC | $STATE |  $NETWORKTYPE | $RADIO | $AUTHENTICATION | $RECEIVE | $TRANSMIT | $SIGNAL  ( $PWR dB)&quot;\n\ndone\nexit\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "SSID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "MAC", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "State", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Network Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Radio", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Authentication", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Receive", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "Transmit", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Signal 0-5", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 163, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Provides the terminal services session information, similar to what is available from the \"query session\" command.\nExample:console|Administrator|1|Active||", 
      "exclude_from_parse_flag": 1, 
      "hash": 75018363, 
      "hidden_flag": 0, 
      "id": 323, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "User Sessions", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; User Sessions\n&#039;========================================\n\n&#039; Returns information about the current sessions on the local machine\n&#039; \n\nOption Explicit\n\nOn error resume next\nDim strValue, myRegExp, objShell, objExec, strLine, objSplit\n\nSet myRegExp = New RegExp\nmyRegExp.IgnoreCase = True\nmyRegExp.Global = True\nmyRegExp.Pattern = &quot;\\s{2,}&quot;\n\nSet objShell = WScript.CreateObject(&quot;WScript.Shell&quot;)\nIf Is64() Then \n\tSet objExec = objshell.exec(&quot;cmd /c c:\\windows\\sysnative\\qwinsta&quot;)\nElse \n\tSet objExec = objshell.exec(&quot;cmd /c qwinsta&quot;)\nEnd If \n\nobjExec.StdOut.ReadLine()\nDo While Not objExec.Stdout.AtEndOfStream\n\tstrLine = myRegExp.Replace(objExec.StdOut.ReadLine(),&quot;|&quot;)\n\n\tIf InStr(strLine,&quot;rdp&quot;) or InStr(strLine,&quot;console&quot;) then\n\t\tIf InStr(strLine,&quot;disc&quot;) then\n\t\t\tstrLine = &quot;|&quot; &amp; strLine\n\t\tEnd If \n\t\tIf InStr(strLine, &quot;console&quot;)&gt;0 And InStr(strLine, &quot;Conn&quot;)&gt;0 Then\n\t\t    &#039; If console line, but no user logged in, add column\n\t\t\tstrLine = Replace(strLine, &quot;console|&quot;, &quot;console||&quot;)\n\t\tEnd If\n\t\tstrLine = replace(strLine,&quot;&gt;&quot;,&quot;&quot;)\n\t\tstrLine = replace(strLine,&quot; &quot;,&quot;&quot;)\n\t\tstrLine = replace(strLine,&quot;rdp-tcp|&quot;,&quot;rdp-tcp||&quot;)\n\t\t\n\t\tobjSplit = Split(strLine, &quot;|&quot;)\n\t\tIf ojbSplit.Count = 4 Then\n\t\t\tstrLine = strLine + &quot;|&quot;\n\t\tEnd If \t\n\t\t\t\n\t\tWScript.echo strLine\n\tEnd if\t\nLoop \n\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\n\tNext\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Session Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "User Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "State", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Device", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 164, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns whether a machine has the application management tools which may be necessary for parameterized actions or sensor-fed actions.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 1688928675, 
      "hidden_flag": 0, 
      "id": 325, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Has Application Management Tools", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Has Application Management Tools\n&#039;========================================\n\nOption Explicit\n\n\n&#039;--------------------\n&#039; Set These Variables\nDim strDesiredVersion\n&#039; a string value which is a verison like\n&#039; 4.1.314.7060\n&#039; which is used to determine whether the files are the correct version\n\nstrDesiredVersion = &quot;6.2.314.8513&quot;\n&#039;----------------------\nDim objFSO\nDim strToolsDir\nDim bHasAllLatestFiles, arrApplicationManagementToolsFiles, strFile\nDim objTextFile, strVersionLine, strFileVersion\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nstrToolsDir = GetTaniumDir(&quot;Tools&quot;)\n\n&#039; This array holds the files to check for\narrApplicationManagementToolsFiles = Array(&quot;taskkill.vbs&quot;,&quot;startservice.vbs&quot;,&quot;stopservice.vbs&quot;)\n\nbHasAllLatestFiles = True &#039; assume OK until checks fail\n\nFor Each strFile In arrApplicationManagementToolsFiles\n\tIf Not objFSO.FileExists(strToolsDir&amp;strFile) Then\n\t\tWScript.Echo &quot;Missing &quot; &amp; strFile\n\t\tbHasAllLatestFiles = False\n\tEnd If\n\tIf objFSO.FileExists(strToolsDir&amp;strFile) Then\n\t\tSet objTextFile = objFSO.OpenTextFile(strToolsDir&amp;strFile)\n\t\tstrVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line\n\t\tIf Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line\n\t\t\tWScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;\n\t\t\tbHasAllLatestFiles = False\n\t\tElse &#039; we have a version number, not split to check\n\t\t\tstrFileVersion = Trim(Split(strVersionLine,&quot;tanium file version:&quot;)(1))\n\t\t\tIf strFileVersion &lt;&gt; strDesiredVersion Then\n\t\t\t\tWScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion\n\t\t\t\tbHasAllLatestFiles = False\n\t\t\tEnd If\n\t\tEnd If\n\t\tobjTextFile.Close\n\tEnd If\nNext\n\nIf bHasAllLatestFiles Then\n\tWScript.Echo &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;No&quot;\nEnd If\n\n&#039;Cleanup\nSet objTextFile = Nothing\nSet objFSO = Nothing\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 14, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 165, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns whether a machine has the hardware tools, which are used to identify specific types of hardware.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 2581054686, 
      "hidden_flag": 0, 
      "id": 327, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Has Hardware Tools", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;Tanium File Version:6.2.314.8513\n&#039; sensor - Has Hardware Tools\n\nOption Explicit\n&#039;--------------------\n&#039; Set These Variables\nDim strDesiredVersion\n&#039; a string value which is a version like\n&#039; 4.1.314.7060\n&#039; which is used to determine whether the files are the correct version\n\nstrDesiredVersion = &quot;6.2.314.8513&quot;\n&#039;----------------------\nDim objFSO\nDim strToolsDir\nDim bHasAllLatestFiles, arrHardwareToolsTextFiles, arrHardwareToolsBinFiles, strFile\nDim objTextFile, strVersionLine, strFileVersion\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nstrToolsDir = GetTaniumDir(&quot;Tools\\Hardware&quot;)\n\n&#039; This array holds the text files to check for\narrHardwareToolsTextFiles = Array()\n    \n&#039; This array holds the binary files to check for\narrHardwareToolsBinFiles = Array(&quot;usb.ids&quot;)\n\nbHasAllLatestFiles = True &#039; assume OK until checks fail\n\nFor Each strFile In arrHardwareToolsTextFiles\n    If Not objFSO.FileExists(strToolsDir&amp;strFile) Then\n        WScript.Echo &quot;Missing &quot; &amp; strFile\n        bHasAllLatestFiles = False\n    End If\n    If objFSO.FileExists(strToolsDir&amp;strFile) Then\n        Set objTextFile = objFSO.OpenTextFile(strToolsDir&amp;strFile)\n        strVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line\n        If Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line\n            WScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;\n            bHasAllLatestFiles = False\n        Else &#039; we have a version number, not split to check\n            strFileVersion = Trim(Split(strVersionLine,&quot;tanium file version:&quot;)(1))\n            If strFileVersion &lt;&gt; strDesiredVersion Then\n                WScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion\n                bHasAllLatestFiles = False\n            End If\n        End If\n        objTextFile.Close\n    End If\nNext\n\nFor Each strFile In arrHardwareToolsBinFiles\n    If Not objFSO.FileExists(strToolsDir&amp;strFile) Then\n        WScript.Echo &quot;Missing &quot; &amp; strFile\n        bHasAllLatestFiles = False\n    End If\nNext\n\n\nIf bHasAllLatestFiles Then\n    WScript.Echo &quot;Yes&quot;\nElse\n    WScript.Echo &quot;No&quot;\nEnd If\n\n&#039;Cleanup\nSet objTextFile = Nothing\nSet objFSO = Nothing\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n    Dim aValueNames, aValueTypes\n    If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n        RegKeyExists = True\n    Else\n        RegKeyExists = False\n    End If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 6, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 166, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns whether a machine has the Tanium Standard Utilities\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 1782389954, 
      "hidden_flag": 0, 
      "id": 329, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Has Tanium Standard Utilities", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Has Tanium Standard Utilities\n&#039;========================================\n\n&#039; this action will look to see if the client has\n&#039; all necessary standard utilities files\n\nOption Explicit\n&#039;--------------------\n&#039; Set These Variables\nDim strDesiredVersion,strDesiredFCIVVersion,strDesiredGrepBinaryVersion\nDim strDesiredGrepDepVersion,strGrepDepFileVersion,strGrepBinaryFileVersion\n\n&#039; a string value which is a version like\n&#039; 4.2.314.7111\n&#039; which is used to determine whether the bundle has the correct version\n&#039; updating the content will cause the bundle number to change and all files will\n&#039; be sent to the endpoint again. This is to handle the case where\n&#039; binary files are not versioned, such as with Yara\n\n&#039; The top line of the version file\n&#039;Tanium File Version: &lt;version string below&gt;\nstrDesiredVersion = &quot;6.2.314.8513&quot;\n\n&#039; -------------------\n&#039; Binaries we can version\nstrDesiredGrepBinaryVersion = &quot;2.5.4.3331&quot;\nstrDesiredGrepDepVersion = &quot;1.12.2872.39125&quot;\n\nDim objFSO\nDim strDirToCheck,objTextFile\nDim bHasAllLatestFiles,arrTextFilesToCheck,strFile,strVersionLine,strFileVersion\nDim strFCIVFile,strFCIVFileVersion,strGrepBinary,strGrepDep,strHandleTool,strListDLLs2\nDim strListDLLs,strStreamsTool,strAutorunsTool\nDim strYara,strYarac\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nstrDirToCheck = GetTaniumDir(&quot;Tools\\StdUtils&quot;)\n\narrTextFilesToCheck = Array(&quot;copy-to-tanium-dir-predist.vbs&quot;,&quot;runas-allusers-wrapper.vbs&quot;,&quot;ver\\bundle.cfg&quot;)\n\n&#039; Grep is required\nstrGrepBinary=strDirToCheck&amp;&quot;grep\\bin\\grep.exe&quot;\nstrGrepDep=strDirToCheck&amp;&quot;grep\\bin\\libiconv2.dll&quot;\n\n&#039;Yara binaries are required\nstrYara=strDirToCheck&amp;&quot;yara\\yara&quot;&amp;GetBitness&amp;&quot;.exe&quot;\nstrYarac=strDirToCheck&amp;&quot;yara\\yarac&quot;&amp;GetBitness&amp;&quot;.exe&quot;\n\nbHasAllLatestFiles = True\nFor Each strFile In arrTextFilesToCheck\n\tIf Not objFSO.FileExists(strDirToCheck&amp;strFile) Then\n\t\tWScript.Echo &quot;Missing &quot; &amp; strFile\n\t\tbHasAllLatestFiles = False\n\tEnd If\n\tIf objFSO.FileExists(strDirToCheck&amp;strFile) Then\n\t\tSet objTextFile = objFSO.OpenTextFile(strDirToCheck&amp;strFile)\n\t\tstrVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line\n\t\tIf Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line\n\t\t\tWScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;\n\t\t\tbHasAllLatestFiles = False\n\t\tElse &#039; we have a version number, not split to check\n\t\t\tstrFileVersion = Split(strVersionLine,&quot;tanium file version:&quot;)(1)\n\t\t\tIf Trim(strFileVersion) &lt;&gt; Trim(strDesiredVersion) Then\n\t\t\t\tWScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion\n\t\t\t\tbHasAllLatestFiles = False\n\t\t\tEnd If\n\t\tEnd If\n\t\tobjTextFile.Close\n\tEnd If\nNext\n\n&#039; check a Grep dependency\nIf Not objFSO.FileExists(strGrepDep) Then\n\tWScript.Echo &quot;Missing &quot; &amp; strGrepDep\n\tbHasAllLatestFiles = False\nEnd If\nIf objFSO.FileExists(strGrepDep) Then\n\n\tstrGrepDepFileVersion = objFSO.GetFileVersion(strGrepDep)\n\tIf Not strGrepDepFileVersion = strDesiredGrepDepVersion Then\n\t\tbHasAllLatestFiles = False\n\t\tWScript.Echo strGrepDep &amp;&quot; version: &quot;&amp;strGrepDepFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredGrepDepVersion\n\tEnd If\nEnd If\n\n\n&#039; check Grep binary\nIf Not objFSO.FileExists(strGrepBinary) Then\n\tWScript.Echo &quot;Missing &quot; &amp; strGrepBinary\n\tbHasAllLatestFiles = False\nEnd If\nIf objFSO.FileExists(strGrepBinary) Then\n\tstrGrepBinaryFileVersion = GetFileVersion(strGrepBinary)\n\tIf Not strGrepBinaryFileVersion = strDesiredGrepBinaryVersion Then\n\t\tbHasAllLatestFiles = False\n\t\tWScript.Echo strGrepBinary &amp;&quot; version: &quot;&amp;strGrepBinaryFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredGrepBinaryVersion\n\tEnd If\nEnd If\n\nIf Not objFSO.FileExists(strYara) Then\n\tbHasAllLatestFiles = False\n\tWScript.Echo &quot;Missing &quot; &amp; strYara\nEnd If\n\nIf Not objFSO.FileExists(strYarac) Then\n\tbHasAllLatestFiles = False\n\tWScript.Echo &quot;Missing &quot; &amp; strYarac\nEnd If\n\nIf bHasAllLatestFiles Then\n\tWScript.Echo &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;No&quot;\nEnd If\n\nFunction GetFileVersion(strPath)\n\tDim objFSO\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tIf objFSO.FileExists(strPath) Then\n\t\tGetFileVersion = objFSO.GetFileVersion(strPath)\n\tElse\n\t\tGetFileVerison = -1\n\tEnd If\nEnd Function &#039;GetFileVersion\n\nFunction GetTaniumDir(strSubDir)\n\tDim strComputer, key32path, key64path, keyPath, reg\n\tDim strPath\n\tstrComputer = &quot;.&quot;\n\tConst HKLM = &amp;h80000002\n    \n\tkey32Path = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkey64Path = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n\tSet reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n    \n\tIf RegKeyExists(reg, HKLM, key64Path) Then\n\t\tkeyPath = key64Path\n\tElseIf RegKeyExists(reg, HKLM, key32Path) Then\n\t\tkeyPath = key32Path\n\tEnd If\n    \n\treg.GetStringValue HKLM,keyPath,&quot;Path&quot;, strPath\n\n\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\tEnd If\t\n\n\tDim fso\n\tSet fso = WScript.CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tIf fso.FolderExists(strPath) Then\n\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\tfso.CreateFolder(strPath &amp; strSubDir)\n\t\tEnd If\n\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\tEnd If\nEnd Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\n\nFunction GetBitness\n\tIf Not Is64 Then\n\t\tGetBitness = &quot;32&quot;\n\tElse\n\t\tGetBitness = &quot;64&quot;\n\tEnd If\nEnd Function &#039;GetBitness\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\n\tNext\nEnd Function &#039; Is64", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 18, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 167, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Determines when the patch cab file is to be considered out of date and, therefore, a machine receives a new copy via the \"Patch Management - Deploy Patch Scan Files\" Scheduled Action.  By default, a machine will get a refreshed copy of the cab file from the ring every 24 hours.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 3197527816, 
      "hidden_flag": 0, 
      "id": 331, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Patch Cab Out of Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patch Cab Out of Date\n&#039;========================================\n\nOption Explicit\n\nDim intAgeThreshold,fso,objFile,minutesOld,strToolsDir,strCabPath\nintAgeThreshold = 60*24       &#039;in minutes\n\nstrToolsDir = GetTaniumDir(&quot;Tools&quot;)\nstrCabPath = strToolsDir &amp; &quot;\\wsusscn2.cab&quot;\n\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nIf fso.FileExists(strCabPath) Then\n\tSet objFile = fso.GetFile(strCabPath)\n\tminutesOld = GetMinutesOld(objFile.DateLastModified)\n\tif cdbl(minutesOld) &gt;= intAgeThreshold Then\n\t  Wscript.echo  &quot;Yes&quot;\n\tElse\n\t  Wscript.echo  &quot;No&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Patch CAB not found&quot;\n\t&#039;WScript.Echo &quot;Yes&quot;\nEnd If\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\n&#039;date format is MM/DD/YYYY \nfunction GetMinutesOld(strDate)\n\tDim patternDate,today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( now )\n\tGetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 6, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 168, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Whether a machine has all patch tools necessary.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 2033984358, 
      "hidden_flag": 0, 
      "id": 333, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Has Patch Tools", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Has Patch Tools\n&#039;========================================\n\nOption Explicit\n\n&#039; sensor - Has Patch Tools\n&#039; this action will look to see if the client has\n&#039; various files related to patching\n&#039; this checks the version string of all related patch files\n&#039; and whether the cab file exists.\n\n&#039;--------------------\n&#039; Set These Variables\nDim strDesiredVersion\n&#039; an string value which is a verison like\n&#039; 4.1.314.7060\n&#039; which is used to determine whether the files are the correct version\n\nstrDesiredVersion = &quot;6.2.314.8513&quot;\n&#039;----------------------\nDim objFSO\nDim strPatchToolsDir\nDim bHasAllLatestFiles, arrPatchToolsFiles, strFile\nDim objTextFile, strVersionLine, strFileVersion\nDim strCabFile\n\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nstrPatchToolsDir = GetTaniumDir(&quot;Tools&quot;)\n\n&#039; This array holds the files to check for\narrPatchToolsFiles = Array(&quot;run-patch-scan.vbs&quot;,&quot;install-patches.vbs&quot;,&quot;uninstall-patch.vbs&quot;,&quot;add-patch-exclusion.vbs&quot;, _\n    &quot;remove-patch-exclusion.vbs&quot;, &quot;delete-queued-patch.vbs&quot;, &quot;add-patch-whitelist-entry.vbs&quot;, &quot;remove-patch-whitelist-entry.vbs&quot;)\nstrCabFile = &quot;Wsusscn2.cab&quot;\n\nbHasAllLatestFiles = True &#039; assume OK until checks fail\n\nFor Each strFile In arrPatchToolsFiles\n\tIf Not objFSO.FileExists(strPatchToolsDir&amp;strFile) Then\n\t\tWScript.Echo &quot;Missing &quot; &amp; strFile\n\t\tbHasAllLatestFiles = False\n\tEnd If\n\tIf objFSO.FileExists(strPatchToolsDir&amp;strFile) Then\n\t\tSet objTextFile = objFSO.OpenTextFile(strPatchToolsDir&amp;strFile)\n\t\tstrVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line\n\t\tIf Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line\n\t\t\tWScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;\n\t\t\tbHasAllLatestFiles = False\n\t\tElse &#039; we have a version number, not split to check\n\t\t\tstrFileVersion = Split(strVersionLine,&quot;tanium file version:&quot;)(1)\n\t\t\tIf strFileVersion &lt;&gt; strDesiredVersion Then\n\t\t\t\tWScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion\n\t\t\t\tbHasAllLatestFiles = False\n\t\t\tEnd If\n\t\tEnd If\n\t\tobjTextFile.Close\n\tEnd If\nNext\n\nIf Not objFSO.FileExists(strPatchToolsDir&amp;strCabFile) Then &#039; if the cab file doesn&#039;t exist, report\n\tWScript.Echo &quot;Missing updates definition file&quot;\n\tbHasAllLatestFiles = False\nEnd If\n\nIf bHasAllLatestFiles Then\n\tWScript.Echo &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;No&quot;\nEnd If\n\n&#039;Cleanup\nSet objTextFile = Nothing\nSet objFSO = Nothing\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 30, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 169, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Sensor that determines if the machine has not been scanned for patches in over 2 days.  If so, scan immediately.  Do not scan if the WUA Agent version is less than the supported version (6.1.0022.4).\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 3369151052, 
      "hidden_flag": 0, 
      "id": 335, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Is Patch Scan Force Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Is Patch Scan Force Time\n&#039;========================================\n\nOption Explicit\n\nDim objFSO,bIsScanForceTime\nDim intDaysThreshold,strScansDir,strResultsPath,objFile,words,daysOld\n\nintDaysThreshold = 2\n&#039; If the patch scan hasn&#039;t occurred on the\n&#039; in the last 2 days, this sensor will be used to \n&#039; force a patch scan in conjunction with a\n&#039; scheduled action\n\nstrScansDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\nstrResultsPath = strScansDir &amp; &quot;\\patchresultsreadable.txt&quot;\n\nbIsScanForceTime = False\n\nSet objFSO = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nIf objFSO.FileExists(strResultsPath) Then\n\tSet objFile = objFSO.GetFile(strResultsPath)\n\twords = Split(objFile.DateLastModified, &quot; &quot;)\n\tdaysOld = GetDaysOld(words(0))\nElse\n\tWScript.Echo &quot;Cannot Find Patch Results&quot;\n\tbIsScanForceTime = True\nEnd If\n\nIf CInt(daysOld) &gt;= intDaysThreshold Then\nWScript.Echo &quot;Patch Results Too Old&quot;\n\tbIsScanForceTime = True\nEnd If\n\n&#039; finally, do not force the scan if the WUA version is too low\nWUAVersionTooLowForScanForceTime bIsScanForceTime\n\nIf bIsScanForceTime Then\n  Wscript.echo  &quot;Yes&quot;\nElse\n  Wscript.echo  &quot;No&quot;\nEnd If\n\n&#039;&#039; --- &#039;&#039;\nFunction WUAVersionTooLowForScanForceTime(ByRef bIsScanForceTime)\n\tDim strOutput, strSysDir, strWuaDll, i\n\tDim strNeededVersion, arrNeededVersion\n\tDim strVersion, arrVersion, intVersionPiece, bOldVersion\n\t\n\t&#039;adjust as required version changes\n\tstrNeededVersion = &quot;6.1.0022.4&quot;\n\tarrNeededVersion = Split(strNeededVersion,&quot;.&quot;)\n\t\n\tstrSysDir = GetSystemDir\t\t\n\tstrWuaDll = strSysDir &amp; &quot;\\wuaueng.dll&quot;\n\tIf objFSO.FileExists(strWuaDll) Then\n\t\tstrVersion = objFSO.GetFileVersion(strWuaDll)\n\t\t&#039; WScript.Echo &quot;Current Version is &quot; &amp; strVersion\n\t\t&#039; WScript.Echo &quot;Required Version is &quot; &amp; strNeededVersion\n\t\tIf strVersion &lt;&gt; strNeededVersion Then\n\t\tarrVersion = Split(strVersion, &quot;.&quot;)\n\t\t&#039; We assume there will be 4 fields, if not throw error\n\t\t\tIf UBound(arrVersion) &lt;&gt; 3 Then\n\t\t\t\tbIsScanForceTime = False\n\t\t\t\tstrOutput = &quot;Error: Cannot determine Windows Update Agent version, does not look like X.X.X.X&quot;\n\t\t\tElse\n\t\t\t\tbOldVersion = False &#039;assume version is good\n\t\t\t\t&#039; loop through each part\n\t\t\t\t&#039; if any individual part is less than its corresponding required part\n\t\t\t\tFor i = 0 To UBound(arrVersion)\n\t\t\t\t\tIf CInt(arrVersion(i)) &lt; CInt(arrNeededVersion(i)) Then\n\t\t\t\t\t\t&#039; WScript.Echo arrVersion(i) &amp; &quot; &lt; &quot; &amp; arrNeededVersion(i)\n\t\t\t\t\t\tbOldVersion = True\n\t\t\t\t\t\tExit For &#039; No further checking necessary, it&#039;s out of date\n\t\t\t\t\tEnd If\n\t\t\t\tNext\n\t\t\t\tIf bOldVersion Then \n\t\t\t\t\tstrOutput = &quot;Error: WUA Version is less than supported version &quot; &amp; strNeededVersion\n\t\t\t\t\tbIsScanForceTime = False\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; versions are the same\n\t\tEnd If\n\tElse \n\t\tstrOutput = &quot;Error - WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;\n\t\tbIsScanForceTime = False\n\tEnd If\n\nEnd Function &#039;WUAVersionTooLowForScanForceTime\n\nFunction GetSystemDir \n\tDim strWinDir,strSysDir\n\t\n\t&#039;Check for 64-bit sysnative directory to avoid win redirect\n\tstrWinDir = objFSO.GetSpecialFolder(0)\n\tstrSysDir = strWinDir &amp; &quot;\\sysnative&quot;\n\t\n\tIf Not objFSO.FolderExists(strSysDir) Then\n\t\tstrSysDir = objFSO.GetSpecialFolder(1)\n\tEnd If\n\tGetSystemDir = strSysDir\nEnd Function &#039; GetSystemDir\n\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tDim patternDate,today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate(FormatDateTime(Date(), 2))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 7, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 170, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Whether a machine has any patch files queued for install.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 679909726, 
      "hidden_flag": 0, 
      "id": 337, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 60, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Has Patch Files", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Has Patch Files\n&#039;========================================\n\nOption Explicit\n\nDim strPatchesDir,fso,folder,files\nstrPatchesDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\nSet fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet folder = fso.GetFolder(strPatchesDir)\nSet files = folder.Files\n\nIf files.Count = 0 Then\n\tWScript.Echo &quot;No&quot;\nElse\n\tWScript.Echo &quot;Yes&quot;\nEnd If\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 171, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "A sensor which can be edited to perform client side calculations on when it's time to scan for patches.  By default, it will always be patch scan time when evaluated as long as the WUA agent version is at least the minimum supported version (6.1.0022.4), and frequency is adjusted via the \"Patch Management - Run Patch Scan\" Scheduled Action.  \nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 3021311021, 
      "hidden_flag": 0, 
      "id": 339, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Is Patch Scan Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Is Patch Scan Time\n&#039;========================================\n\n&#039; This sensor will do client side work to\n&#039; determine when it&#039;s time to scan for patches\n\nOption Explicit\n\nDim bIsScanTime\nbIsScanTime = True\n\n&#039; Global objects the functions may as well use\nDim objFSO,objReg\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nWUAVersionTooLowForScanTime bIsScanTime\n\nIf bIsScanTime Then\n\tWScript.Echo &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;No&quot;\nEnd If\n\n&#039; --- Helper Functions --- &#039;\n\nFunction WUAVersionTooLowForScanTime(ByRef bIsScanTime)\n\tDim strOutput, strSysDir, strWuaDll, i\n\tDim strNeededVersion, arrNeededVersion\n\tDim strVersion, arrVersion, intVersionPiece, bOldVersion\n\t\n\t&#039;adjust as required version changes\n\tstrNeededVersion = &quot;6.1.0022.4&quot;\n\tarrNeededVersion = Split(strNeededVersion,&quot;.&quot;)\n\t\n\tstrSysDir = GetSystemDir\t\t\n\tstrWuaDll = strSysDir &amp; &quot;\\wuaueng.dll&quot;\n\tIf objFSO.FileExists(strWuaDll) Then\n\t\tstrVersion = objFSO.GetFileVersion(strWuaDll)\n\t\t&#039; WScript.Echo &quot;Current Version is &quot; &amp; strVersion\n\t\t&#039; WScript.Echo &quot;Required Version is &quot; &amp; strNeededVersion\n\t\tIf strVersion &lt;&gt; strNeededVersion Then\n\t\tarrVersion = Split(strVersion, &quot;.&quot;)\n\t\t&#039; We assume there will be 4 fields, if not throw error\n\t\t\tIf UBound(arrVersion) &lt;&gt; 3 Then\n\t\t\t\tbIsScanTime = False\n\t\t\t\tstrOutput = &quot;Error: Cannot determine Windows Update Agent version, does not look like X.X.X.X&quot;\n\t\t\tElse\n\t\t\t\tbOldVersion = False &#039;assume version is good\n\t\t\t\t&#039; loop through each part\n\t\t\t\t&#039; if any individual part is less than its corresponding required part\n\t\t\t\tFor i = 0 To UBound(arrVersion)\n\t\t\t\t\tIf CInt(arrVersion(i)) &lt; CInt(arrNeededVersion(i)) Then\n\t\t\t\t\t\tbOldVersion = True\n\t\t\t\t\t\tExit For &#039; No further checking necessary, it&#039;s out of date\n\t\t\t\t\tEnd If\n\t\t\t\tNext\n\t\t\t\tIf bOldVersion Then \n\t\t\t\t\tstrOutput = &quot;Error: WUA Version is less than supported version &quot; &amp; strNeededVersion\n\t\t\t\t\tbIsScanTime = False\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; versions are the same\n\t\tEnd If\n\tElse \n\t\tstrOutput = &quot;Error - WUA DLL (&quot;&amp;strWuaDll&amp;&quot;) not found&quot;\n\t\tbIsScanTime = False\n\tEnd If\n\nEnd Function &#039;WUAVersionTooLowForScanTime\nFunction GetSystemDir \n\tDim strWinDir,strSysDir\n\t\n\t&#039;Check for 64-bit sysnative directory to avoid win redirect\n\tstrWinDir = objFSO.GetSpecialFolder(0)\n\tstrSysDir = strWinDir &amp; &quot;\\sysnative&quot;\n\t\n\tIf Not objFSO.FolderExists(strSysDir) Then\n\t\tstrSysDir = objFSO.GetSpecialFolder(1)\n\tEnd If\n\tGetSystemDir = strSysDir\nEnd Function &#039; GetSystemDir", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 172, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Indicates whether the client machine has temporary files resulting from the install of the Tanium Client by the Client Deploy Tool\nExample: yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 2616273872, 
      "hidden_flag": 0, 
      "id": 341, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Has Tanium Client Install Files", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Has Tanium Client Install Files\n&#039;========================================\n\n&#039; This sensor will report on the existence of any file\n&#039; in the C:\\Tanium directory specified in the array below\n&#039; The accompanying action which uses this sensor as a key will\n&#039; delete the files it finds within\n\nOption Explicit\n\nDim objFSO\nDim strTaniumDir\nDim bHasFilesToDelete,arrFilesToDelete,strFile\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nstrTaniumDir = &quot;C:\\Tanium\\&quot;\n\narrFilesToDelete = Array(&quot;dodeploy.exe&quot;, &quot;dodeploy.log&quot;, &quot;postdeploy.exe&quot;, &quot;postdeploy.log&quot;, _\n\t&quot;predeploy.exe&quot;, &quot;predeploy.log&quot;, &quot;SetupClient.exe&quot;, &quot;tanium.pub&quot;)\n\nbHasFilesToDelete = False\nFor Each strFile In arrFilesToDelete\n\tIf  objFSO.FileExists(strTaniumDir&amp;strFile) Then\n\t\t&#039;WScript.Echo &quot;Should Delete &quot; &amp; strFile\n\t\tbHasFilesToDelete = True\n\tEnd If\nNext\n\nIf bHasFilesToDelete Then\n\tWScript.Echo &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;No&quot;\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 173, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Evaluates whether a machine has stale Tanium Client data - long running processes, old action status/log files, action folders, or sensor output.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 3005061811, 
      "hidden_flag": 0, 
      "id": 343, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Has Stale Tanium Client Data", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Has Stale Tanium Client Data\n&#039;========================================\n&#039; This  sensor  will  return  Yes  if   a\n&#039; machine has processes running from  the\n&#039; Tanium sensor or action directory  that\n&#039; have been running longer than a day,\n&#039; has  stale  action  status or log files \n&#039; older than 4 days, has stale sensor \n&#039; output data older than a day, has old\n&#039; action folders, has stale string /node data\n\nOption Explicit\n\nDim intProcessesThreshold,intSensorDataThreshold,intStaleStatusFilesThreshold,dictDumps,bExtraDumpFiles\nDim intStaleActionFoldersThreshold,intStaleFilesWantedDownloadThreshold,intStaleQNAThreshold,intMaxClientRAMInMB,MIN_CLIENT_STRING_NODE_THRESHOLD\n\nintProcessesThreshold = 1440  &#039; one day in minutes\nintSensorDataThreshold = 1440  &#039; one day in minutes\nintStaleStatusFilesThreshold = 5670 &#039; 4 days in minutes\nintStaleQNAThreshold = 1440 &#039; one day in minutes\nintStaleActionFoldersThreshold = 2880 &#039;two days in minutes\nintStaleFilesWantedDownloadThreshold = 0 &#039;comment out this line and uncomment next to enable\n&#039;intStaleFilesWantedDownloadThreshold = 5670 &#039;4 days in minutes\n&#039; report stale string data when Client RAM is above this value\nintMaxClientRAMInMB = 0 &#039; comment out this line and uncomment next\n&#039; intMaxClientRAMInMB = 200 &#039; Uncomment to check for client &gt; 200\n&#039;set a minimum value which must match the value\n&#039; MIN_CLIENT_MEMORY_RESTART_THRESHOLD\n&#039; in the corresponding Clean Stale Client Data Action\nMIN_CLIENT_STRING_NODE_THRESHOLD = 50\n\nSetLocale(1033) &#039; Uses Date Math which may require us/english to work correctly\n\n&#039; count and remove dump files\nSet dictDumps = CreateObject(&quot;Scripting.Dictionary&quot;)\nPopulateDumpFilesDict dictDumps\nbExtraDumpFiles = HasOldDumpFiles(dictDumps)\n\n\nIf HasStaleProcesses(intProcessesThreshold) Or _\n\t\tHasStaleSensorData(intSensorDataThreshold) Or _\n\t\tHasStaleActionStatusAndLogFiles(intStaleStatusFilesThreshold) Or _ \n\t\tHasStaleActionFolders(intStaleActionFoldersThreshold) Or _\n\t\tHasStaleQNAFiles(intStaleQNAThreshold) Or _ \n\t\tHasStaleFilesWantedDownloads(intStaleFilesWantedDownloadThreshold) Or _\n\t\tClientRAMThresholdHitNoRestart(intMaxClientRAMInMB) Or _\n\t\tbExtraDumpFiles Then\n\tWScript.Echo &quot;Yes&quot;\nElse\n\tWScript.Echo &quot;No&quot;\nEnd If\n\nSub PopulateDumpFilesDict(ByRef dictDump)\n\t&#039; builds a dictionary of dump files\n\n\tDim objFSO,strTaniumDir,objFolder,objFile,strFileName\n\tDim strFilePath,strFileCreated\n\t\n\tstrTaniumDir = GetTaniumDir(&quot;&quot;)\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\tFor Each objFile In objFSO.GetFolder(strTaniumDir).Files\n\t\tstrFileName = objFile.Name\n\t\tIf Mid(strFileName,Len(strFileName) - 3,Len(strFileName)) = &quot;.dmp&quot; Then\n\t\t\tIf Not dictDump.Exists(objFile.Path) Then\n\t\t\t\tdictDump.Add objFile.Path,objFile.DateCreated\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\nEnd Sub &#039;PopulateDumpFilesDict\n\nFunction HasOldDumpFiles(ByRef dictDumps)\n\n\t&#039; keep last dump file\n\tDim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tDim strDumpPath,dtmLatestDate,strLastDumpPath,strDumpDate,intCount\n\t\n\t&#039; which dump file was the latest - do not delete\n\tdtmLatestDate = CDate(&quot;07/06/1978&quot;)\n\tFor Each strDumpPath In dictDumps.Keys\n\t\tstrDumpDate = dictDumps.Item(strDumpPath)\n\t\tIf IsDate(strDumpDate) Then\n\t\t\tIf CDate(strDumpDate) &gt; dtmLatestDate Then\n\t\t\t\tdtmLatestDate = CDate(strDumpDate)\n\t\t\t\tstrLastDumpPath = strDumpPath\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\t\n\tintCount = 0\n\tFor Each strDumpPath In dictDumps.Keys\n\t\tIf Not strDumpPath = strLastDumpPath Then\n\t\t\tintCount = intCount + 1\n\t\tEnd If\n\tNext\n\t\n\tIf intCount &gt; 0 Then\n\t\tHasOldDumpFiles = True\n\t\tWScript.Echo &quot;Unnecessary Dump Files&quot;\n\tElse\n\t\tHasOldDumpFiles = False\n\tEnd If\n\t\nEnd Function &#039;HasOldDumpFiles\n\nFunction HasStaleProcesses(intThreshold)\n\t\n\tDim bHasStaleProcesses,objWMIService,strPID,colItems,objItem\n\tDim intAge,strCmd\n\t\n\tbHasStaleProcesses = False &#039; assume false until tested\n\t&#039; We may get errors getting the age of some system processes\n\tOn Error Resume Next\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\t\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process&quot;,,48)\n\tFor Each objItem In colItems\n\t\tstrCmd = LCase(objItem.CommandLine)\n\t\tIf (InStr(strCmd, &quot;tanium client\\vb\\&quot;) &gt; 0 Or InStr(strCmd, &quot;tanium client\\downloads\\&quot;) &gt; 0) Then\n\t\t\tintAge = GetAgeInMinutesWMI(objItem.CreationDate)\n\t\t\tstrPid = objItem.ProcessId\n\t\t\tIf intAge &gt;= intThreshold Then\n\t\t\t\tbHasStaleProcesses = True\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\tOn Error Goto 0\n\t\n\tIf bHasStaleProcesses Then WScript.Echo &quot;Stale Processes&quot;\n\tHasStaleProcesses = bHasStaleProcesses\n\t\nEnd Function &#039;HasStaleProcesses\n\nFunction HasStaleSensorData(intThreshold)\n\t&#039; returns true or false\n\t\n\tDim bHasStaleSensorData,fso,strVBDir,intAge,objFolder,file\n\t\n\tbHasStaleSensorData = False &#039; assume false until tested\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\tstrVBDir = GetTaniumDir(&quot;VB&quot;)\n\t\n\tIf fso.FolderExists(strVBDir) Then\n\t\tSet objFolder = fso.GetFolder(strVBDir)\n\t\t\n\t\tFor Each file In objFolder.Files\n\t\t\tintAge = GetMinutesOld(file.DateLastModified)\n\t\t\tIf intAge &gt;= intThreshold Then\n\t\t\t\tbHasStaleSensorData = True\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\t\n\tIf bHasStaleSensorData Then WScript.Echo &quot;Stale Sensor Data&quot;\n\tHasStaleSensorData = bHasStaleSensorData\n\t\nEnd Function &#039;HasStaleSensorData\n\nFunction HasStaleActionStatusAndLogFiles(intThreshold)\n\t&#039; returns true or false\n\t\n\tDim bHasStaleActionStatusAndLogFiles,fso,strVBDir,intAge,objFolder,file\n\tDim arrWords1,strExt,arrWords2,strDownloadsDir\n\tbHasStaleActionStatusAndLogFiles = False &#039;assume false until tested\n\t\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tstrDownloadsDir = GetTaniumDir(&quot;Downloads&quot;)\n\t\n\tIf fso.FolderExists(strDownloadsDir) Then\n\t\tSet objFolder = fso.GetFolder(strDownloadsDir)\n\t\t\n\t\tFor Each file In objFolder.Files\n\t\t\tIf Left(file.Name, 6) = &quot;Action&quot; Then\n\t\t\t\tarrWords1 = Split(file.Name, &quot;.&quot;)\n\t\t\t\tstrExt = arrWords1(UBound(arrWords1))\n\t\t\t\tIf LCase(strExt) = &quot;log&quot; Or LCase(strExt) = &quot;status&quot; Then\n\t\t\t\t\tintAge = GetMinutesOld(file.DateLastModified)\n\t\t\t\t\tIf intAge &gt;= intThreshold Then\n\t\t\t\t\t\tbHasStaleActionStatusAndLogFiles = True\n\t\t\t\t\t\tExit For\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\t\n\tIf bHasStaleActionStatusAndLogFiles Then WScript.Echo &quot;Stale Action Status/Log Files&quot;\n\tHasStaleActionStatusAndLogFiles = bHasStaleActionStatusAndLogFiles\n\t\nEnd Function &#039;HasStaleActionStatusAndLogFiles\n\nFunction HasStaleFilesWantedDownloads(intThreshold)\n\t&#039; returns true or false\n\t\t\n\tDim bHasStaleFilesWantedDownloads,fso,strCacheDir,objFolder,objFile\n\tDim strFileName, intAge\n\tbHasStaleFilesWantedDownloads = False &#039;assume false until tested\n\t\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tstrCacheDir = GetTaniumDir(&quot;Downloads\\Cache&quot;)\n\t\n\tIf fso.FolderExists(strCacheDir) And intThreshold &lt;&gt; 0 Then\n\t\tSet objFolder = fso.GetFolder(strCacheDir)\n\t\t\n\t\tFor Each objFile In objFolder.Files\n\t\t\tstrFileName = objFile.Name\n\t\n\t\t\tIf strFileName &lt;&gt; &quot;Catalog&quot; And _\n\t\t\t   strFileName &lt;&gt; &quot;FullCacheFile&quot; And _\n\t\t\t   strFileName &lt;&gt; &quot;HotCacheFile&quot; And _\n\t\t\t   InStr(strFileName, &quot;-&quot;) &gt; 0 Then \t\t\n\t\t\t\tintAge = GetMinutesOld(objFile.DateLastModified)\n\t\t\t\tIf intAge &gt;= intThreshold Then\n\t\t\t\t\tbHasStaleFilesWantedDownloads = True\n\t\t\t\t\tExit For\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\t\n\tIf bHasStaleFilesWantedDownloads Then WScript.Echo &quot;Stalled Downloads&quot;\n\tHasStaleFilesWantedDownloads = bHasStaleFilesWantedDownloads\n\t\nEnd Function &#039;HasStaleFilesWantedDownloads\n\nFunction HasStaleActionFolders(intThreshold)\n&#039; returns true or false\n&#039; threshold value recommended &gt; 2 days for long running actions.\n\tDim intCount,fso,strVBDir,intAge,objFolder,folder\n\tDim arrWords1,strExt,strDownloadsDir,bHasStaleActionStatusAndLogFiles\n\tbHasStaleActionStatusAndLogFiles = False &#039;assume false until tested\n\t\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tstrDownloadsDir = GetTaniumDir(&quot;Downloads&quot;)\n\t\n\tintCount = 0\n\tIf fso.FolderExists(strDownloadsDir) Then\n\t\tSet objFolder = fso.GetFolder(strDownloadsDir)\n\t\tFor Each folder In objFolder.Subfolders\n\t\t\tIf Left(folder.Name, 7) = &quot;Action_&quot; Then\n\t\t\t\tintAge = GetMinutesOld(folder.DateLastModified)\n\t\t\t\tIf intAge &gt;= intThreshold Then\n\t\t\t\t\tbHasStaleActionStatusAndLogFiles = True\n\t\t\t\t\tExit For\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\t\n\tIf bHasStaleActionStatusAndLogFiles Then WScript.Echo &quot;Stale Action Folders&quot;\n\tHasStaleActionFolders = bHasStaleActionStatusAndLogFiles\n\t\t\nEnd Function &#039;HasStaleActionFolders\n\nFunction HasStaleQNAFiles(intThreshold)\n&#039; returns true or false\n\tDim intCount,fso,strVBDir,intAge,objFolder,file\n\tDim strQNADir,strTaniumDir,bHasStaleQNAFiles\n\tbHasStaleQNAFiles = False &#039;assume false until tested\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t&#039; Do not point gettaniumdir at tools\\qna directly or it would create the folder\n\tstrTaniumDir = GetTaniumDir(&quot;&quot;)\n\tstrQNADir = strTaniumDir&amp;&quot;QNA&quot;\n\t\n\tintCount = 0\n\tIf fso.FolderExists(strQNADir) Then\n\t\tSet objFolder = fso.GetFolder(strQNADir)\n\t\tOn Error Resume Next\n\t\tFor Each file In objFolder.Files\n\t\t\tIf Instr(file.name,&quot;.qna&quot;) &gt; 0 Then\n\t\t\t\tintAge = GetMinutesOld(file.DateLastModified)\n\t\t\t\tIf intAge &gt;= intThreshold Then\n\t\t\t\t\tbHasStaleQNAFiles = True\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tNext\n\t\tOn Error Goto 0\n\tEnd If\n\t\n\tIf bHasStaleQNAFiles Then WScript.Echo &quot;Stale QNA Files&quot;\n\tHasStaleQNAFiles = bHasStaleQNAFiles\n\t\nEnd Function &#039;HasStaleQNAFiles\n\nFunction GetAgeInMinutesWMI(strWMI)\n\tDim strProcessStart,strYear,strMonth,strDate,strHours,strMin,strSec\n\tDim dtmProcessStart\n\t\n\tstrYear = Left(strWMI, 4)\n\tstrMonth = Mid(strWmi, 5, 2)\n\tstrDate = Mid(strWMI, 7, 2)\n\tstrHours = Mid(strWMI, 9, 2)\n\tstrMin = Mid(strWMI, 11, 2)\n\tstrSec = Mid(strWMI, 13, 2)\n\tstrProcessStart = \tstrMonth&amp;&quot;/&quot;&amp;strDate&amp;&quot;/&quot;&amp;strYear&amp;&quot; &quot; &amp; _\n\tstrhours&amp;&quot;:&quot;&amp;strMin&amp;&quot;:&quot;&amp;strSec\n\tOn Error Resume Next\n\tdtmProcessStart = FormatDateTime(strProcessStart, 0)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tGetAgeInMinutesWMI = False\n\t\tOn Error Goto 0\n\t\tExit Function\n\tEnd If\n\tOn Error Goto 0\n\tGetAgeInMinutesWMI = DateDiff(&quot;n&quot;, dtmProcessStart, Now())\nEnd Function &#039;GetAgeInMinutesWMI\n\nFunction GetOffset\n\tDim objSWbemServices,colTimeZone,objTimeZone\n\t\n\tSet objSWbemServices = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objSWbemServices.ExecQuery(&quot;SELECT * FROM Win32_TimeZone&quot;)\n\tFor Each objTimeZone In colTimeZone\n\t\tGetOffset = objTimeZone.Bias\n\tNext\t\nEnd Function\n\nFunction GetMinutesOld(strDate)\n\tDim patternDate\n\tOn Error Resume Next\n\tpatternDate = CDate( strDate )\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tGetMinutesOld = False\n\t\tOn Error Goto 0\n\t\tExit Function\n\tEnd If\n\tOn Error Goto 0\t\t\n\tGetMinutesOld = Abs(DateDiff(&quot;n&quot;, patternDate, Now()))\nEnd Function &#039;GetMinutesOld\n\n\nFunction GetTaniumDir(strSubDir)\n\t&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n\t&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n\t\n\t&#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n\tOn Error Resume Next\n\tstrPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n\tOn Error Goto 0\n\t\n\tIf strPath = &quot;&quot; Then\n\t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n\t\tOn Error Resume Next\n\t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n\t\tOn Error Goto 0\n\tEnd If\n\t\n\tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If  \n\t\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\t\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction ClientRAMThresholdHitNoRestart(intMaxClientRAMInMB)\n&#039; Checks the Client RAM and will restart the client\n\n\tIf intMaxClientRAMInMB = 0 Then\n\t\tClientRAMThresholdHitNoRestart = False\n\t\tExit Function\n\tEnd If\n\t\n\tDim objWMIService,colItems,objItem,strProcess,intClientRAMUsedInMB\n\tDim strClientExeName,strMem,strProcessMem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tstrClientExeName = &quot;taniumclient.exe&quot;\n\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process where Caption=&#039;&quot;&amp;strClientExeName&amp;&quot;&#039;&quot;,,48)\n\tstrMem = 0\n\tOn Error Resume Next\n\tFor Each objItem in colItems\n\t\tstrProcessMem = objItem.WorkingSetSize\n\t\tIf Err.Number = 0 Then\n\t\t\tIf IsInteger(strProcessMem) Then\n\t\t\t\tstrMem = strProcessMem + strMem\n\t\t\tEnd If\n\t\tEnd If\n\t\tErr.Clear()\n\tNext\n\tOn Error Goto 0\n\tintClientRAMUsedInMB = 0\n\tstrMem = CLng(strMem)\n\tintClientRAMUsedInMB = Int(strMem / (1024 * 1024))\n\tIf intClientRAMUsedInMB &gt; intMaxClientRAMInMB And intClientRAMUsedInMB &gt; MIN_CLIENT_STRING_NODE_THRESHOLD Then\n\t\tWScript.Echo &quot;Stale String/Node Data&quot;\n\t\tClientRAMThresholdHitNoRestart = True\n\tElse\n\t\tClientRAMThresholdHitNoRestart = False\n\tEnd If\n\t\nEnd Function &#039;ClientRAMThresholdHitNoRestart", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 8, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 174, 
      "category": "Unmanaged Assets", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Determines whether a machine has the unmanaged asset tools.  A \"No\" answer will prompt a tools distribution job to the endpoint.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 1434351235, 
      "hidden_flag": 0, 
      "id": 345, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Unmanaged Asset Scanner Exists", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Unmanaged Asset Scanner Exists\n&#039;========================================\n\nOption Explicit\n\n&#039;--------------------\n&#039; Set These Variables\nDim strDesiredVersion, strDesiredPortTesterVersion\n&#039; a string value which is a verison like\n&#039; 4.2.314.7111\n&#039; which is used to determine whether the files are the correct version\n&#039; The top line of each file should read\n&#039;Tanium File Version: &lt;version string below&gt;\nstrDesiredVersion = &quot;6.2.314.8513&quot;\n&#039; -------------------\n&#039; Treat the PortTester Tool differently, since it&#039;s a build-process item\nstrDesiredPortTesterVersion = &quot;&quot;  &#039; is not versioned today\n\n\nDim objFSO\nDim strToolsDir,objTextFile\nDim bHasAllLatestFiles,arrActionFiles,strFile,strVersionLine,strFileVersion\nDim strPortTesterFile,strPortTesterFileVersion\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nstrToolsDir = GetTaniumDir(&quot;Tools&quot;)\n\narrActionFiles = Array(&quot;run-ua-scan.vbs&quot;)\n\n&#039; PortTester utility is required\nstrPortTesterFile=strToolsDir&amp;&quot;PortTester.exe&quot;\nbHasAllLatestFiles = True\nFor Each strFile In arrActionFiles\n\tIf Not objFSO.FileExists(strToolsDir&amp;strFile) Then\n\t\tWScript.Echo &quot;Missing &quot; &amp; strFile\n\t\tbHasAllLatestFiles = False\n\tEnd If\n\tIf objFSO.FileExists(strToolsDir&amp;strFile) Then\n\t\tSet objTextFile = objFSO.OpenTextFile(strToolsDir&amp;strFile)\n\t\tstrVersionLine = LCase(objTextFile.ReadLine()) &#039; version is at top of line\n\t\tIf Not InStr(strVersionLine,&quot;tanium file version:&quot;) &gt; 0 Then &#039; must have a version number in top line\n\t\t\tWScript.Echo strFile&amp;&quot; is not versioned on line 1&quot;\n\t\t\tbHasAllLatestFiles = False\n\t\tElse &#039; we have a version number, not split to check\n\t\t\tstrFileVersion = Trim(Split(strVersionLine,&quot;tanium file version:&quot;)(1))\n\t\t\tIf strFileVersion &lt;&gt; strDesiredVersion Then\n\t\t\t\tWScript.Echo strFile&amp;&quot; version: &quot;&amp;strFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredVersion\n\t\t\t\tbHasAllLatestFiles = False\n\t\t\tEnd If\n\t\tEnd If\n\t\tobjTextFile.Close\n\tEnd If\nNext\n\n&#039; check the PortTester binary\nIf Not objFSO.FileExists(strPortTesterFile) Then\n\tWScript.Echo &quot;Missing &quot; &amp; strPortTesterFile\n\tbHasAllLatestFiles = False\nEnd If\nIf objFSO.FileExists(strPortTesterFile) Then\n\tstrPortTesterFileVersion = objFSO.GetFileVersion(strPortTesterFile)\n\tIf Not strPortTesterFileVersion = &quot;&quot; Then\n\t\tbHasAllLatestFiles = False\n\t\tWScript.Echo strPortTesterFile&amp;&quot; version: &quot;&amp;strPortTesterFileVersion&amp;&quot;, needs: &quot;&amp;strDesiredPortTesterVersion\n\tEnd If\nEnd If\n\nIf bHasAllLatestFiles Then\n\tWScript.Echo &quot;True&quot;\nElse\n\tWScript.Echo &quot;False&quot;\nEnd If\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 9, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 175, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "The serial number, if available, provided by the computer manufacturer.\nExample: 123ABC1", 
      "exclude_from_parse_flag": 1, 
      "hash": 102224229, 
      "hidden_flag": 0, 
      "id": 347, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Computer Serial Number", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select SerialNumber from win32_BIOS", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s system-serial-number\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsystem_profiler SPHardwareDataType | awk &#039;/Serial Number/ {print $NF}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 7, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 176, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns whether or not the SQL server instance is clustered\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 1039470236, 
      "hidden_flag": 0, 
      "id": 349, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "SQL Clustered", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Clustered\n&#039;========================================\n\nOption Explicit\n\n&#039; Searches for a service called &quot;Cluster Service&quot; and returnes yes if found\n&#039; and SQL Server is also found\n\nDim objWMIService, colServices, objService, strCaption, bSQLServerInstalled, bSQLClusterServiceRunning\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \nSet colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \nFor Each objService In colServices\n    strCaption = objService.Caption\n\n    If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0) Then    \n        &#039; OK -- found SQL Server on this machine\n\t\tbSQLServerInstalled = True\n    End If  \n    \n    If (InStr(strCaption,&quot;Cluster Service&quot;) &lt;&gt; 0 And objService.State = &quot;Running&quot;) Then\n    \tbSQLClusterServiceRunning = True\n    End If \nNext  \n\nIf bSQLServerInstalled Then\n\tIf bSQLClusterServiceRunning Then\n\t\tWScript.Echo &quot;True&quot;\n\tElse \n\t\tWScript.Echo &quot;False&quot;\n\tEnd If\nElse \n\tWScript.Echo &quot;SQL Server Not Installed&quot;\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 177, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the virtual platform or technology used for the virtual machine, if it is a virtual machine.\nExample: VMware", 
      "exclude_from_parse_flag": 1, 
      "hash": 1046354727, 
      "hidden_flag": 0, 
      "id": 351, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Virtual Platform", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Virtual Platform\n&#039;========================================\n\n&#039; This sensor will determine if a machine is a virtual machine or not\n&#039; Comparing values for certain properties against known values.\n&#039; It will need to be updated for some current tech and \n&#039; as new technologies come to market.\n\n\nOption Explicit\n\n\n\nWScript.Echo GetVirtualPlatform\n\n\nFunction GetVirtualPlatform\n\tDim sVMPlatform, sMake, sModel, sBIOSVersion,bIsVM\n\n    &#039; Check the WMI information against known values\n\n    bIsVM = false\n    sVMPlatform = &quot;&quot;\n\n    sMake = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Manufacturer&quot;)\n    sModel = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_ComputerSystem&quot;, &quot;Model&quot;)\n    sBIOSVersion = GetWmiPropertyValue(&quot;root\\cimv2&quot;, &quot;Win32_BIOS&quot;, &quot;Version&quot;)\n\n    &#039;WScript.Echo &quot;Manufacturer=&quot; &amp; sMake\n    &#039;WScript.Echo &quot;Model=&quot; &amp; sModel\n    &#039;WScript.Echo &quot;BIOSVersion=&quot; &amp; sBIOSVersion\n\n    If sModel = &quot;Virtual Machine&quot; then\n\n        &#039; Microsoft virtualization technology detected, assign defaults\n\n        sVMPlatform = &quot;Hyper-V&quot;\n        bIsVM = true\n\n        &#039; Try to determine more specific values\n\n        Select Case sBIOSVersion\n        Case &quot;VRTUAL - 1000831&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 Beta or RC0&quot;\n        Case &quot;VRTUAL - 5000805&quot;, &quot;BIOS Date: 05/05/08 20:35:56  Ver: 08.00.02&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 RTM&quot;\n        Case &quot;VRTUAL - 3000919&quot; \n            bIsVM = true\n            sVMPlatform = &quot;Hyper-V 2008 R2&quot;\n        Case &quot;A M I  - 2000622&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005R2SP1 or VPC2007&quot;\n        Case &quot;A M I  - 9000520&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005R2&quot;\n        Case &quot;A M I  - 9000816&quot;, &quot;A M I  - 6000901&quot;\n            bIsVM = true\n            sVMPlatform = &quot;Windows Virtual PC&quot;\n        Case &quot;A M I  - 8000314&quot;\n            bIsVM = true\n            sVMPlatform = &quot;VS2005 or VPC2004&quot;\n        Case &quot;Xen - 0s&quot;\n        \tbIsVM = True\n        \tsVMPlatform = &quot;Xen&quot;\n        Case &quot;Xen - 0&quot;\n            bIsVM = True\n            sVMPlatform = &quot;Xen&quot;\n        End Select\n\n    ElseIf sModel = &quot;VMware Virtual Platform&quot; then\n\n        &#039; VMware detected\n\n        sVMPlatform = &quot;VMware&quot;\n        bIsVM = true\n\n    ElseIf sModel  = &quot;VirtualBox&quot; then\n\n        &#039; VirtualBox detected\n\n        bIsVM = true\n        sVMPlatform = &quot;VirtualBox&quot;\n\n    Else \n        sVMPlatform = &quot;Not Virtual&quot;\n    End if\n\n    GetVirtualPlatform = sVMPlatform\n\nEnd Function\n\nFunction GetWmiPropertyValue(strNameSpace, strClassName, strPropertyName)\n\tDim strPropertyValue, oWMIClass, oWMIProperties, objWMIService, colItems\n\tDim objItem, objProperty\n\tDim sLine\n\t\n    On Error Resume Next\n\n    strPropertyValue = &quot;&quot;\n    set oWmiClass = getobject(&quot;winmgmts:&quot; &amp; strNameSpace).get(strClassName,&amp;h20000) &#039;amended\n    set oWmiProperties = oWmiClass.Properties_\n\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; &quot;.&quot; &amp; &quot;\\&quot; &amp; strNameSpace)\n    Set colItems = objWMIService.ExecQuery(&quot;Select * from &quot; &amp; strClassName,,48)\n\n    For Each objItem in colItems\n        For Each objProperty in oWmiProperties\n            sLine = &quot;&quot;\n            &#039;WScript.Echo &quot;- &quot; &amp; objProperty.name &amp; &quot;: &quot; &amp; strPropertyName\n\n            If objProperty.Name = strPropertyName Then\n                If objProperty.IsArray = True Then\n                    sLine = &quot;str&quot; &amp; objProperty.Name &amp; &quot; = Join(objItem.&quot; &amp; objProperty.Name &amp; &quot;, &quot; &amp; Chr(34) &amp; &quot;,&quot; &amp; Chr(34) &amp; &quot;)&quot; &amp; vbCrLf\n                    sLine = sLine &amp; &quot;strPropertyValue =  str&quot; &amp; objProperty.Name\n                &#039;ElseIf objProperty.CIMTYPE = 101 Then\n                &#039;    bHasDates = True\n                &#039;    sLine =  &quot;strPropertyValue =  WMIDateStringToDate(objItem.&quot; &amp; objProperty.Name &amp; &quot;)&quot;\n                Else\n                    sLine =  &quot;strPropertyValue =  objItem.&quot; &amp; objProperty.Name\n                End If\n\n                &#039;WScript.Echo sLine\n                Execute sLine\n            End If\n\n        Next\n    Next\n\n    GetWmiPropertyValue = strPropertyValue\n    \n    &#039;Cleanup!\n    set oWmiClass = Nothing\n    set oWmiProperties = Nothing\n\n    Set objWMIService = Nothing\n    Set colItems = Nothing\n\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 178, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the version of the file specified.\nExample: 1.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 112406691, 
      "hidden_flag": 0, 
      "id": 353, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "File Version", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the full drive letter, folder path and file name of the file.\",\"value\":\"\",\"promptText\":\"c:\\\\windows\\\\test.txt\",\"defaultValue\":\"\",\"label\":\"File path and name\",\"maxChars\":0,\"key\":\"file\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; File Version\n&#039;========================================\n\n&#039; TAG: REDIRECTION\n\nfilePath = unescape(&quot;||file||&quot;)\n\nfilePath = FixFileSystemRedirectionForPath(filePath)\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nIf fso.FileExists(filePath) Then \n\tstrVersion = fso.GetFileVersion(filePath)\n\n\tIf strVersion = &quot;&quot; Then\n\t\tWScript.Echo &quot;Version not found&quot;\n\tElse\n\t\tWScript.Echo strVersion\n\tEnd If\t\n&#039;\tIf strVersion\nElse \n\tWScript.Echo &quot;File not found&quot;\nEnd If\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n    \n    Dim objFSO, strSystem32Location,objShell\n    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n    \n    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n        If InStr(strFilePath,strSystem32Location) = 1 Then\n            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n            strFilePath = strNewSystem32Location&amp;strRestOfPath\n        End If\n    End If\n    FixFileSystemRedirectionForPath = strFilePath\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n    Dim objFSO,strSystem32Location,strNewSystem32Location\n    \n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    \n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n    \n    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File path and name&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||file||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File path and name&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||file||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 179, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Hard disk device that the operating system uses to boot from.\nExample: \\\\Device\\\\HarddiskVolume1", 
      "exclude_from_parse_flag": 1, 
      "hash": 1125023461, 
      "hidden_flag": 0, 
      "id": 355, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Boot Device", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select BootDevice from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 180, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns information about shares on a PC.\nExample: SHARENAME", 
      "exclude_from_parse_flag": 1, 
      "hash": 1132013379, 
      "hidden_flag": 0, 
      "id": 357, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Open Shares", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select name from win32_share where caption != &#039;Default Share&#039; AND caption != &#039;Remote Admin&#039; AND caption != &#039;Remote IPC&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsharing -l | awk &#039;BEGIN {i=0} /smb:/ { while (i &lt; 1) { getline; print $0; i++ } i=0}&#039; | awk -F &quot;:\\t&quot; &#039;{print $2}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 181, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns error conditions that would indicate an unhealthy VirusScan Enterprise state on an endpoint.\nexample: Unhealthy", 
      "exclude_from_parse_flag": 1, 
      "hash": 115043288, 
      "hidden_flag": 0, 
      "id": 359, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "VirusScan Enterprise Health", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039; Sensor: VirusScan Enterprise Health\n&#039; Returns any error conditions for VirusScan Enterprise 8.7 or 8.8\n\nOption Explicit\n\nDim strServiceState\n&#039; First get the state of the service\nstrServiceState = ServiceState(&quot;McShield&quot;)\nIf strServiceState = &quot;Not Installed&quot; Then\n\t&#039;No further tests are necessary\n\tWScript.Echo &quot;VirusScan Enterprise Not Installed&quot;\n\tWScript.Quit\nEnd If\n\nSetLocale(1033) &#039; this sensor uses date math, setting to us/english\n\n&#039; Hold whether to report a final error state\nDim bGlobalError : bGlobalError = False\n\n&#039; Global objects the functions may use\nConst HKLM = &amp;h80000002\nDim objFSO,objReg\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet objReg = Getx64RegistryProvider()\n\n\n&#039; Pass the global error flag down each of the functions\n&#039; which will flip it and report their own errors\n\n&#039; do not use parentheses or will not pass ByRef.\n&#039; could use parentheses and use the Call keyword, however\n\nDatTooOld 1, bGlobalError\nServiceIsRunning strServiceState, bGlobalError\nServiceIsNotAuto strServiceState, bGlobalError\nAccessProtectionDisabled bGlobalError\nOnAccessScannerDisabled bGlobalError\n\nIf bGlobalError Then\n\tWScript.Echo &quot;Unhealthy&quot;\nElse\n\tWScript.Echo &quot;Healthy&quot;\nEnd If\n\n&#039; --- Health Check Functions --- &#039;\n\nSub DatTooOld(intThresholdDays,ByRef bHasError)\n\tDim strDatDate,dtmDatDate,arrDatDateBits\n\tDim strRegPath, intDaysOld\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;AVEngine&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetStringValue HKLM,strRegPath,&quot;AVDatDate&quot;,strDatDate\n\t\t\n\t\t&#039;Date is in YYYY/MM/DD format, move to US/English\n\t\tIf InStr(strDatDate,&quot;/&quot;) &gt; 0 Then &#039;valid value\n\t\t\tarrDatDateBits = Split(strDatDate,&quot;/&quot;)\n\t\t\tstrDatDate = arrDatDateBits(1)&amp;&quot;/&quot;&amp;arrDatDateBits(2)&amp;&quot;/&quot;&amp;arrDatDateBits(0)\n\t\t\tIf IsDate(strDatDate) Then\n\t\t\t\tintDaysOld = CInt(GetDaysOld(strDatDate))\n\t\t\t\tIf intDaysOld &gt; CInt(intThresholdDays) Then\n\t\t\t\t\tWScript.Echo &quot;Error: VirusScan Enterprise DAT file greater than &quot; &amp; intThresholdDays &amp; &quot; days old&quot;\n\t\t\t\t\tbHasError = True\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Dat date&quot;\n\t\t\t\tbHasError = True\n\t\t\tEnd If\n\t\tElse &#039; Dat Date has no &quot;/&quot; in it and cannot be parsed or compared\n\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT date&quot;\n\t\t\tbHasError = True\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise DAT date&quot;\n\t\tbHasError = True\n\tEnd If\nEnd Sub &#039;DatTooOld\n\nSub AccessProtectionDisabled(ByRef bHasError)\n&#039; This function determines whether Access Protection feature is disabled\n\tDim intAPEnabled\n\tDim strRegPath\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;SYSTEMCORE&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetDWORDValue HKLM,strRegPath&amp;&quot;\\VSCore\\On Access Scanner\\BehaviourBlocking&quot;,&quot;APEnabled&quot;,intAPEnabled\n\t\tIf Not (IsNull(intAPEnabled) Or intAPEnabled = &quot;&quot; ) And IsNumeric(intAPEnabled) Then\n\t\t\tIf CInt(intAPEnabled) = 0 Then\n\t\t\t\tWScript.Echo &quot;Fixable: VirusScan Enterprise Access Protection is Disabled&quot;\n\t\t\t\tbHasError = True\n\t\t\tEnd If\n\t\tElse\n\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Access Protection Status&quot;\n\t\t\tbHasError = True\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise Access Protection Status&quot;\n\t\tbHasError = True\n\tEnd If\nEnd Sub &#039;AccessProtectionDisabled\n\nSub OnAccessScannerDisabled(ByRef bHasError)\n&#039; This function determines whether On Access Scanner feature is disabled\n\tDim intOASEnabled\n\tDim strRegPath\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;SYSTEMCORE&quot;)\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetDWORDValue HKLM,strRegPath&amp;&quot;\\VSCore\\On Access Scanner\\McShield\\Configuration&quot;,&quot;OASEnabled&quot;,intOASEnabled\n\t\tIf Not (IsNull(intOASEnabled) Or intOASEnabled = &quot;&quot; ) And IsNumeric(intOASEnabled) Then\n\t\t\tIf CInt(intOASEnabled) &lt;&gt; 3 Then\n\t\t\t\tWScript.Echo &quot;Fixable: VirusScan Enterprise On-Access Scanner is Disabled&quot;\n\t\t\t\tbHasError = True\n\t\t\tEnd If\n\t\tElse\n\t\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise On-Access Scanner Status&quot;\n\t\t\tbHasError = True\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot determine VirusScan Enterprise On-Access Scanner Status&quot;\n\t\tbHasError = True\n\tEnd If\nEnd Sub &#039;OnAccessScannerDisabled\n\nSub ServiceIsRunning(strServiceState, ByRef bHasError)\n\tIf InStr(strServiceState,&quot;Stopped&quot;) &gt; 0 Or InStr(strServiceState,&quot;Paused&quot;) &gt; 0 Then\n\t\tWScript.Echo &quot;Fixable: VirusScan Enterprise On-Access Scan Service not Running&quot;\n\t\tbHasError = True\n\tEnd If\nEnd Sub &#039;ServiceIsRunning\n\nSub ServiceIsNotAuto(strServiceState, ByRef bHasError)\n\tIf InStr(strServiceState,&quot;Manual&quot;) &gt; 0 Or InStr(strServiceState,&quot;Disabled&quot;) &gt; 0 Then\n\t\tWScript.Echo &quot;Fixable: VirusScan Enterprise On-Access Scan Service start mode not Automatic&quot;\n\t\tbHasError = True\n\tEnd If\nEnd Sub &#039;ServiceIsNotAuto\n\n&#039; ---- Support Functions ---- &#039;\nFunction ServiceState(strServiceName)\n&#039; This function determines if a service is in a bad state and returns\n&#039; values indicating the state.  Examples: \n&#039; &quot;Stopped&quot;\n&#039; &quot;Stopped Manual&quot;\n&#039; &quot;Running Disabled&quot;\n&#039; &quot;Not Installed&quot;\n\n\tDim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState\n\n\tstrWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;\n\n\tstrState = &quot;&quot;\n\tstrStartMode = &quot;&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(strWMIQuery)\n\t\n\tIf colItems.Count = 0 Then\n\t\tServiceState = &quot;Not Installed&quot;\n\tElse\n\t\tFor Each objItem In colItems\n\t\t\tIf objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then\n\t\t\t\tstrState = objItem.State\n\t\t\tEnd If\n\t\t\tIf objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then\n\t\t\t\tstrStartMode = objItem.StartMode\n\t\t\tEnd If\n\t\t\tServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)\n\t\tNext\n\tEnd If\n\nEnd Function &#039;ServiceState\n\nFunction RegKeyExists(sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function &#039;RegKeyExists\n\nFunction GetMinutesOld(strDate)\n&#039;date format is MM/DD/YYYY \n\tSetLocale(1033)\n\tDim patternDate, today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( now )\n\tGetMinutesOld = DateDiff(&quot;n&quot;, patternDate, today)\nEnd Function &#039;GetMinutesOld\n\nFunction GetDaysOld(strDate)\n&#039;date format is MM/DD/YYYY \n\tSetLocale(1033)\n\tDim patternDate, today\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( now )\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function &#039;GetDaysOld\n\nFunction GetSystemDir \n\tDim strWinDir,strSysDir\n\t\n\t&#039;Check for 64-bit sysnative directory to avoid win redirect\n\tstrWinDir = objFSO.GetSpecialFolder(0)\n\tstrSysDir = strWinDir &amp; &quot;\\sysnative&quot;\n\t\n\tIf Not objFSO.FolderExists(strSysDir) Then\n\t\tstrSysDir = objFSO.GetSpecialFolder(1)\n\tEnd If\n\tGetSystemDir = strSysDir\nEnd Function &#039; GetSystemDir\n\nFunction GetMcAfeeProductRegRootKey(strProductString)\n&#039; Retrieves McAfee key for a product\n&#039; products are passed in and defined in the function\n\n\tDim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey\n\tDim strProductKeyPath\n\n\t&#039; select on input\n\tstrProductString = UCase(strProductString)\n\tSelect Case strProductString\n\t\tCase &quot;AGENT&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\Agent&quot;\t\n\t\tCase &quot;AVENGINE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\AVEngine&quot;\n\t\tCase &quot;DESKTOPPROTECTION&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\DesktopProtection&quot;\n\t\tCase &quot;EPO&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\ePolicy Orchestrator&quot;\n\t\tCase &quot;HIPS&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIP&quot;\n\t\tCase &quot;HIPSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIPSCore&quot;\n\t\tCase &quot;MCTRAY&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\McTray&quot;\t\t\t\t\t\n\t\tCase &quot;SITEADVISOR&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SiteAdvisor Enterprise Plus&quot;\n\t\tCase &quot;SYSTEMCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SystemCore&quot;\n\t\tCase &quot;VSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\VSCore&quot;\n\t\tCase &quot;NAIEPO&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\ePolicy Orchestrator&quot;\n\t\tCase &quot;NAITVD&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\TVD&quot;\n\t\tCase Else\n\t\t\tstrProductSubKey = False\n\tEnd Select\n\t\t\t\n\tConst HKLM = &amp;h80000002\n\t\n    \n\tstrRootSoftwareKeyNative = &quot;Software&quot;\n\tstrRootSoftwareKeyWow64 = &quot;Software\\Wow6432Node&quot;\n    If Not strProductSubKey = False Then\n\t    &#039; Assume not in both places on a 64-bit machine\n\t\tIf RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tEnd If\n\tElse\n\t\tstrProductKeyPath = False\t\t\n\tEnd If\n\t\n\tGetMcAfeeProductRegRootKey = strProductKeyPath\n\nEnd Function &#039;GetMcAfeeProductRegRootKey\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 182, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the SYSVOL size on Domain Controllers\nExample: 2.2 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 1155294592, 
      "hidden_flag": 0, 
      "id": 361, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Domain Controller SYSVOL Size", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Domain Controller SYSVOL Size\n&#039;========================================\n\nOption Explicit\n\nDim strSharePath\n\nstrSharePath = GetPathForShare(&quot;sysvol&quot;)\nIf strSharePath = &quot;&quot; Then WScript.Quit\n\nDim objFSO,objFolder\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nSet objFolder = objFSO.GetFolder(strSharePath)\n\nWScript.Echo GetPrettyFileSize(objFolder.Size)\n\nFunction GetPathForShare(strShareName)\n\n\tDim objWMIService,colItems,objItem,strReturn\n\t\n\tOn Error Resume Next &#039; could be permissions issues\n\tstrReturn = &quot;&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Share&quot;,,48)\n\n\tFor Each objItem in colItems\n\t\tIf LCase(objItem.Name) = LCase(strShareName) Then\n\t\t\tstrReturn = objItem.Path\n\t\tEnd If\n\tNext\n\t\n\tOn Error Goto 0\n\t\n\tGetPathForShare = strReturn\n\t\nEnd Function &#039;GetPathForShare\t\n\n\nFunction GetPrettyFileSize(strSize)\nDim dblSize\n\tdblSize = CDbl(strSize)\n\n\tIf dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;\t\n\tElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;\n\tElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB\n\t\tstrSize = CStr(Round(dblSize / 1024)) &amp; &quot; kB&quot;\n\tElse\n\t\tstrSize = CStr(dblSize) &amp; &quot; B&quot;\t\n\tEnd If\t\n\tGetPrettyFileSize = strSize\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 183, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the current total number of disk IOPS currently occurring\nExample: 86", 
      "exclude_from_parse_flag": 1, 
      "hash": 1156943497, 
      "hidden_flag": 0, 
      "id": 363, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Disk IOPS", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Option Explicit\n\nDim strComputer, objWMIService, objRefresher, objDiskDrive, colDiskDrives, driveName, sampleCount, counter, total\n\nsampleCount = 6 &#039;number of datapoints to use for averaging result\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\nset objRefresher = CreateObject(&quot;WbemScripting.SWbemRefresher&quot;)\nSet colDiskDrives = objRefresher.AddEnum _\n    (objWMIService, &quot;Win32_PerfFormattedData_PerfDisk_LogicalDisk&quot;).objectSet\nobjRefresher.Refresh\n\ntotal = 0\nFor Each objDiskDrive in colDiskDrives\n\tdriveName = objDiskDrive.Name\n\tIf driveName = &quot;_Total&quot; Then\n\t\tFor counter = 1 To sampleCount\n\t\t\tobjRefresher.Refresh\n\t    \ttotal = total + objDiskDrive.DiskTransfersPerSec\n\t    \tWscript.Sleep 500\n\t    Next\n\t    WScript.Echo FormatNumber(total/sampleCount,0)\n    End If \nNext\n\nWScript.Quit", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 184, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Returns the names and speeds of all network connections.\nExample: WAN Miniport (IP) | 10000", 
      "exclude_from_parse_flag": 1, 
      "hash": 1206550580, 
      "hidden_flag": 0, 
      "id": 365, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Network Link Speed", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Network Link Speed\n&#039;========================================\n\nOption Explicit\n\nConst cWMINameSpace = &quot;root/wmi&quot;\nConst cWMIInstance = &quot;MSNdis_LinkSpeed&quot;\nConst strComputerName = &quot;.&quot;\n\nDim strWinMgmts, objWMI, listAdapters, objAdapter,intLinkSpeed,strSep\nstrSep = &quot;|&quot;\n\nstrWinMgMts = &quot;winmgmts:{impersonationLevel=impersonate}!//&quot; &amp; strComputerName &amp; &quot;/&quot; &amp; cWMINameSpace\nSet objWMI = GetObject(strWinMgMts)\n\nIf Err.Number &lt;&gt; 0 Then\nWScript.Echo &quot;ERROR: Unable to connect to the WMI namespace.&quot;\nElse\nSet listAdapters = objWMI.InstancesOf(cWMIInstance)\nIf (listAdapters.count &gt; 0) Then\nFor Each objAdapter in listAdapters\nIf CDbl(objAdapter.NdisLinkSpeed) &lt; 0 Then\n\tintLinkSpeed = Abs(CDbl(objAdapter.NdislinkSpeed))\nElse\n\tintLinkSpeed = CDbl(objAdapter.NdisLinkSpeed)\nEnd If\nWScript.Echo objAdapter.InstanceName &amp; strSep &amp; intLinkSpeed/10000\nNext\nElse\nWScript.Echo &quot;WARNING: No adapters found.&quot;\nEnd If\nEnd IF", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Adapter Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Speed (Mbps)", 
            "value_type": "Numeric"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 185, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the version of the Managed Applications DAT package received from Tanium.\nExample:20121107.01", 
      "exclude_from_parse_flag": 1, 
      "hash": 1211382204, 
      "hidden_flag": 0, 
      "id": 367, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Managed Applications DAT Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Managed Applications DAT Version\n&#039;========================================\n\nOption Explicit\nDim strSep\nstrSep = &quot;|&quot;\nDim objFso, strXml, objFile\nConst ForReading = 1\nSet objFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nDim strDatPath, strCurrentDir, oShell\nstrDatPath = GetTaniumDir(&quot;Tools\\Managed Applications&quot;) &amp; &quot;tanium.dat&quot;\n\nDim isDebug\nisDebug = False \nIf isDebug Then\n\tSet oShell = CreateObject(&quot;WScript.Shell&quot;)\n\tstrCurrentDir = objFso.GetParentFolderName(Wscript.ScriptFullName)\n\tstrDatPath = strCurrentDir &amp; &quot;\\tanium.dat&quot;\n\tWScript.Echo strDatPath\nEnd If \n\nIf Not objFso.FileExists(strDatPath) Then\n\tWScript.Echo &quot;Cannot find DAT file&quot;\n\tWScript.Quit\nEnd If\nSet objFile = objFSO.OpenTextFile(strDatPath, ForReading)\nstrXml = objFile.ReadAll\nobjFile.Close\n\nDim xmlDoc\n\nSet xmlDoc = CreateObject(&quot;Msxml2.DOMDocument&quot;)\nxmlDoc.loadXml(strXml)\n\nDim strVersion\nWScript.echo GetVersion(xmlDoc)\n\nWScript.Quit\n\n\nFunction GetVersion(xmlDoc)\n\tDim objList\n\tSet objList = xmlDoc.getElementsByTagName(&quot;dat-version&quot;)\n\n\tIf objList.length &gt; 0 Then\n\t\tDim objNode, strType\n\t\n\t\t&#039;Find first DAT version definition\n\t\tFor Each objNode In objList\n\t\t\tGetVersion = objNode.text\n\t\tNext\n\tEnd If\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 186, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Indicates the free RAM available to the operating system.\nExample: 1024MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 1260624634, 
      "hidden_flag": 0, 
      "id": 369, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Free Memory", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Free Memory\n&#039;========================================\n\nOption Explicit\n\nDim objWMIService, colItems, objItem, strLineAvailableMemory\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n \n&#039;Gets MEMORY Usage\nSet colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)\nFor Each objItem In colItems  \n strLineAvailableMemory = objItem.AvailableMBytes\n wscript.echo strLineAvailableMemory &amp; &quot; MB&quot;\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nmemLine=$(free -m | grep &quot;Mem&quot;)\nset -- $memLine\necho $4 MB\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nFREE_BLOCKS=$(vm_stat | grep free | awk &#039;{ print $3 }&#039; | sed &#039;s/\\.//&#039;)\nFREE=$((($FREE_BLOCKS+SPECULATIVE_BLOCKS)*4096/1048576))\necho $FREE MB\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 187, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "A list of accounts under which services are configured to run.  This list will not include the default accounts, including LocalSystem, LocalService, and NetworkService.\nExample: .\\\\servuser", 
      "exclude_from_parse_flag": 1, 
      "hash": 1271450145, 
      "hidden_flag": 0, 
      "id": 371, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Service Login Names", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Startname from win32_service where (Startname &lt;&gt; &#039;LocalSystem&#039; AND Startname &lt;&gt; &#039;NT AUTHORITY\\\\LocalService&#039; AND Startname &lt;&gt; &#039;NT AUTHORITY\\\\NetworkService&#039; AND Startname &lt;&gt;  &#039;NT AUTHORITY\\\\LOCAL SERVICE&#039; AND Startname &lt;&gt; &#039;NT AUTHORITY\\\\NETWORK SERVICE&#039;)", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 188, 
      "category": "Windows Event Logs", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Event identifier code for Security log events as shown in the Windows NT Event Viewer tool.\nExample: 4648", 
      "exclude_from_parse_flag": 1, 
      "hash": 1314534715, 
      "hidden_flag": 0, 
      "id": 373, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Security Event Log IDs", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select EventCode from Win32_NTLogEvent where LogFile = &#039;Security&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 189, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Memory in use in MB from client machine.\nExample: 6348 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 1315630323, 
      "hidden_flag": 0, 
      "id": 375, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Used Memory", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Used Memory\n&#039;========================================\n\nOption Explicit\n\nDim objWMIService, colItems, objItem, intTotalMemory, intAvailableMemory\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n \n&#039;Gets total memory\nSet colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_Computersystem &quot;)\nFor Each objItem In colItems  \n intTotalMemory = Int(objItem.TotalPhysicalMemory / 1024 / 1024)\nNext \n&#039;Gets available memory\nSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)\nFor Each objItem In colItems  \n intAvailableMemory = objItem.AvailableMBytes\nNext\n\n&#039; We didn&#039;t use committed bytes here, because that is often bigger than total - available\n\nWScript.Echo intTotalMemory - intAvailableMemory &amp; &quot; MB&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nmemLine=$(free -m | grep &quot;Mem&quot;)\nset -- $memLine\necho $3 MB\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nACTIVE_BLOCKS=$(vm_stat | grep &quot;Pages active&quot; | awk &#039;{ print $3 }&#039; | sed &#039;s/\\.//&#039;)\nACTIVE=$((($ACTIVE_BLOCKS+SPECULATIVE_BLOCKS)*4096/1048576))\necho $ACTIVE MB\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 10, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 190, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns printers connected to a system.\nExample:HP LaserJet 4400c", 
      "exclude_from_parse_flag": 1, 
      "hash": 1348043492, 
      "hidden_flag": 0, 
      "id": 377, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Printers", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select DriverName from Win32_Printer", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 191, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Name of the domain of the most recently logged in user.\nExample: CORP", 
      "exclude_from_parse_flag": 1, 
      "hash": 1348161929, 
      "hidden_flag": 0, 
      "id": 379, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Default Login Domain", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Default Login Domain\n&#039;========================================\n\nDim reg , strComputer\nstrComputer = &quot;.&quot;\nSet reg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nstrKeyPath = GetKeyPath()\n&#039;strKeyPath = &quot;Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot;\nstrValueName = &quot;DefaultDomainName&quot; \n\nconst HKEY_CURRENT_USER = &amp;H80000001\nconst HKEY_LOCAL_MACHINE = &amp;H80000002\n\nOn Error Resume Next\nreg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue\nIf strValue &lt;&gt; &quot;&quot; Then\n\tWscript.Echo strValue\nElse\n\tWscript.Echo &quot;Default Domain Not Set&quot;\nEnd If\n\nFunction GetKeyPath()\n\t\n\tDim key32path, key64path, keyPath\n\tkey32Path = &quot;Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot;\n\tkey64Path = &quot;Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot;\n\n\tIf RegKeyExists(reg , HKEY_LOCAL_MACHINE, key64Path) Then\n\t\tkeyPath = key64Path\n\tElseIf RegKeyExists(reg , HKEY_LOCAL_MACHINE, key32Path) Then\n\t\tkeyPath = key32Path\n\tEnd If\n\tGetKeyPath = keyPath\nEnd Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 192, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Finds the specified folder and provides the full path if the folder exists on the client machine. Takes regular expression to match.\nExample: C:\\WINDOWS\\System32", 
      "exclude_from_parse_flag": 1, 
      "hash": 1374547302, 
      "hidden_flag": 0, 
      "id": 381, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "McAfee"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Folder Name Search with RegEx Match", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the folder name to search for\",\"value\":\"\",\"promptText\":\"e.g Program Files\",\"defaultValue\":\"\",\"label\":\"Search for Folder Name\",\"maxChars\":0,\"key\":\"dirname\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the regular expression to search for.\",\"value\":\"\",\"promptText\":\"e.g. test*.exe\",\"defaultValue\":\"\",\"label\":\"Regular Expression\",\"maxChars\":0,\"key\":\"regexp\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"helpString\":\"Enter Yes/No for case sensitivity of search.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Case sensitive?\",\"key\":\"casesensitive\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"},{\"helpString\":\"Enter Yes/No whether the search is global.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Global\",\"key\":\"global\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Folder Name Search with RegEx Match\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\n\nSensorRandomize()\n\nDim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg\nDim bGlobal,bCaseSensitive\n\nPattern = unescape(&quot;||dirname||&quot;)\nstrRegExp = Trim(Unescape(&quot;||regexp||&quot;))\nstrGlobalArg = Trim(Unescape(&quot;||global||&quot;))\nstrCaseSensitiveArg = Trim(Unescape(&quot;||casesensitive||&quot;))\n\nbGlobal = GetTrueFalseArg(&quot;global&quot;,strGlobalArg)\nbCaseSensitive = GetTrueFalseArg(&quot;casesensitive&quot;,strCaseSensitiveArg)\n\nConst SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1\n\nDim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine\n\nSet FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\nOutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir\n\n&#039; Go through file system, refresh output file for filename\nIf Not FSO.FileExists(OutputFilename) Then\n\t\n\tIf FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename\n\n\t&#039; Get the collection of local drives.\n\tSet Drives = FSO.Drives\n\tFor Each Drive in Drives\n\t\tIf Drive.DriveType = 2 Then &#039; 2 = Fixed drive\n\t\t\t&#039; Run the Dir command that looks for the filename pattern.\n\t\t\tRunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:D /B /S&quot;, OutputFilename, true\n\t\tEnd If\n\tNext\nEnd If\n\n&#039; Open the output file, echo each line, and then close and delete it.\nSet TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)\nDo While Not TextStream.AtEndOfStream\n\tstrLine = TextStream.ReadLine()\n\tIf RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then\n\t\tWScript.Echo strLine\n\tEnd If\nLoop\n\n\nTextStream.Close()\n \nIf FSO.FileExists(OutputFileName) Then\n\tOn Error Resume Next\n\tFSO.DeleteFile OutputFileName, True\n\tOn Error Goto 0\nEnd If\n\nFunction RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)\n\n\tDim re\n\tSet re = New RegExp\n\tWith re\n\t  .Pattern = strPattern\n\t  .Global = bGlobal\n\t  .IgnoreCase = Not bIsCaseSensitive\n\tEnd With\n\t\n\tRegExpMatch = re.Test(strToMatch)\n\nEnd Function &#039;RegExpMatch\n\n\nFunction GetTrueFalseArg(strArgName,strArgValue)\n\t&#039; Checks for valid values, will fail with error message\n\t\n\tDim bArgVal\n\tbArgVal = False\n\tSelect Case LCase(strArgValue)\n\t\tCase &quot;true&quot;\n\t\t\tbArgVal = True\n\t\tCase &quot;yes&quot;\n\t\t\tbArgVal = True\n\t\tCase &quot;false&quot;\n\t\t\tbArgVal = False\n\t\tCase &quot;no&quot;\n\t\t\tbArgVal = False\n\t\tCase Else\n\t\t\tWScript.Echo &quot;Error: Argument &#039;&quot;&amp;strArgName&amp;&quot;&#039; must be True or False, quitting&quot;\n\t\t\tPrintUsage\n\tEnd Select\n\tGetTrueFalseArg = bArgVal\n\nEnd Function &#039;GetTrueFalseArg\n\n\n&#039; Returns the name of a temporary file in the Temp directory.\nFunction TempName()\n\tDim Result\n\tDo\n \t\tResult = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())\n\t\tWScript.Sleep 200 &#039;avoid potential busy loop\n\tLoop While FSO.FileExists(Result)\n\t\n\tTempName = Result\nEnd Function &#039;TempName\n\n&#039; Runs a command with Cmd.exe and redirects its output to a temporary\n&#039; file. The function returns the name of the temporary file that holds\n&#039; the command&#039;s output.\nFunction RunCommand(Command, OutputFilename, b64BitNecessary)\n\t&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32\n\tDim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrDOSCall = &quot;%ComSpec% /C &quot;\n\t\n\t&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection\n\tstrProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\tIf objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64\n\t\tstrDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))\n\tEnd If\n\t\t\n\tCommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)\n\tWshShell.Run CommandLine, 0, True\nEnd Function &#039;RunCommand\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n#||dirname||||regexp||||casesensitive||||global||\necho Windows Only\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n#||dirname||||regexp||||casesensitive||||global||\necho Windows Only\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 193, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "A list of programs configured to automatically run on the client machine.  Also includes the command line entry to run the program.\nExample: Windows Mobile Device Center | C:\\Windows\\WindowsMobile\\wmdc.exe", 
      "exclude_from_parse_flag": 1, 
      "hash": 1404374135, 
      "hidden_flag": 0, 
      "id": 383, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Startup Programs", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Startup Programs\n&#039;========================================\n\n&#039; This sensor will return values from the 32-bit and 64-bit areas of the\n&#039; registry that defines auto-run programs.\n&#039; This is a multi-column sensor that has output that looks like:\n&#039; Name|Command Line\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n\nGetAutoRunPrograms strSep\n\nFunction GetAutoRunPrograms(strSep)\n&#039; This function will output the two values\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strComputer, strStartupRegPath, strStartupWow64RegPath\n\tDim objRegistry, strFinalOutputString\n\t\n\tstrStartupRegPath = &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;\n\tstrStartupWow64RegPath = &quot;Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run&quot;\n\t\n\tstrFinalOutputString = &quot;&quot;\n\tSet objRegistry = Getx64RegistryProvider()\n\tIf RegKeyExists(HKLM, strStartupRegPath, objRegistry) Then\t\n\t\tstrFinalOutputString = GetValues(objRegistry, HKLM, strStartupRegPath)\n\tEnd If\n\tIf Not strFinalOutputString = &quot;&quot; Then\n\t\tstrFinalOutputString = strFinalOutputString &amp; vbCrLf\n\tEnd If\n\tIf RegKeyExists(HKLM, strStartupWow64RegPath, objRegistry) Then\n\t\tstrFinalOutputString = strFinalOutputString _ \n\t\t\t&amp; GetValues(objRegistry, HKLM, strStartupWow64RegPath)\n\tEnd If\n\t\n\tWScript.Echo strFinalOutputString\nEnd Function &#039;GetAutoRunPrograms\n\nFunction GetValues(objRegistry, hiveConst, keyPath)\n\n\tDim arrKeyNames, arrTypes, arrValueNames, strValueName\n\tDim strValueData, i, strOutputString\n\t\t\n\tobjRegistry.EnumValues hiveConst, keyPath, arrValueNames, arrTypes\n\t\n\tIf Not IsArray(arrValueNames) Then\n\t\tarrValueNames = Array(&quot;&quot;)\n\t\tarrTypes = Array(1)\n\tEnd If\n\t\n\tstrOutputString = &quot;&quot;\n\tFor i = LBound(arrValueNames) To UBound(arrValueNames)\n\t\tstrValueName = arrValueNames(i)\n\t\tstrValueData = GetRegValue(objRegistry, hiveConst, keyPath, strValueName, arrTypes(i))\n\t\tIf Not ( IsNull(strValueName) Or IsNull(strValueData) ) Then\n\t\t\tIf i = UBound(arrValueNames) Then\n\t\t\t\tstrOutputString = strOutputString &amp; strValueName &amp; strSep &amp; strValueData\n\t\t\tElse\n\t\t\t\tstrOutputString = strOutputString &amp; strValueName &amp; strSep &amp; strValueData &amp; vbCrLf\n\t\t\tEnd If\n\t\tEnd If\n\tNext\t\n\tGetValues = strOutputString\nEnd Function &#039;GetValues\n\nFunction GetRegValue(objRegistry, hiveConst, keyPath, strValueName, constType)\n\n\tConst REG_SZ        = 1\n\tConst REG_EXPAND_SZ = 2\n\tConst REG_BINARY    = 3\n\tConst REG_DWORD     = 4\n\tConst REG_MULTI_SZ  = 7\n\tConst REG_QWORD     = 11\n\n\tDim strValue, arrBytes, uValue, arrValues\n\n\tSelect Case constType\n\t\tCase REG_SZ  \n\t\t\tobjRegistry.GetStringValue hiveConst, keyPath, strValueName, strValue\n\t\t\tGetRegValue =  strValue\n\t\t\tExit Function\n\t\tCase REG_EXPAND_SZ\n\t\t\tobjRegistry.GetExpandedStringValue hiveConst, keyPath, strValueName, strValue\n\t\t\tGetRegValue =  strValue\n\t\t\tExit Function\n\t\tCase REG_BINARY\n\t\t\tobjRegistry.GetBinaryValue hiveConst, keyPath, strValueName, arrBytes\n\t\t\tstrBytes = &quot;&quot;\n\t\t\tFor Each uByte in arrBytes\n\t\t\t\tstrBytes = strBytes &amp; Hex(uByte) &amp; &quot; &quot;\n\t\t\tNext\n\t\t\tGetRegValue =  strBytes\n\t\t\tExit Function\n\t\tCase REG_DWORD\n\t\t\tobjRegistry.GetDWORDValue hiveConst, keyPath, strValueName, uValue\n\t\t\tGetRegValue =  CStr(uValue)\t\t\t\t  \n\t\t\tExit Function\n\t\tCase REG_QWORD\n\t\t\tobjRegistry.GetQWORDValue hiveConst, keyPath, strValueName, uValue\n\t\t\tGetRegValue =  CStr(uValue)\t\t\t\t  \n\t\t\tExit Function\n\t\tCase REG_MULTI_SZ\n\t\t\tobjRegistry.GetMultiStringValue hiveConst, keyPath, strValueName, arrValues\t\t\t\t  \t\t\t\t\n\t\t\tFor Each strValue in arrValues\n\t\t\t\tGetRegValue =  strValue \n\t\t\tNext\n\t\t\tExit Function\n\tEnd Select\nEnd Function &#039;GetRegValue\n\nFunction RegKeyExists(sHive, sRegKey, objReg)\n\tDim aValueNames, aValueTypes\n\tIf objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Command Line", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 194, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "This sensor will return the version of an activated McAfee Endpoint Encryption install\nExample: 7.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 1450323545, 
      "hidden_flag": 0, 
      "id": 385, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "McAfee Endpoint Encryption Activated Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; McAfee Endpoint Encryption Activated Version\n&#039;========================================\n\n&#039; This sensor will return the version of an\n&#039; activated McAfee Endpoint Encryption install\n&#039; This is a numeric value, a version number\n\nOption Explicit\n\nDim objRegistry,keyPath,key64Path,strSep\nstrSep = &quot;|&quot; &#039; column delimiter\n\nSet objRegistry = Getx64RegistryProvider()\n\nConst HKLM = &amp;H80000002\n\nkeyPath = &quot;SOFTWARE\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\nkey64Path = &quot;SOFTWARE\\Wow6432Node\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If\n\nIf RegKeyExists(HKLM, keyPath) Then\n\tDim strReturn\n\tstrReturn = ReturnStringValueOrEchoError _\n\t\t(objRegistry,HKLM,keyPath,&quot;ActivatedVersion&quot;,&quot;McAfee Endpoint Encryption Activation Version Not Found&quot;)\n\tIf VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error\n\t\tWScript.Echo strReturn\n\tElse\n\t\tWScript.Quit\n\tEnd If\nElse\n\tWScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;\n\tWScript.Quit\nEnd If\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)\n&#039; Return a value or fatal error message and error result\n\tDim intReturn,strValueData\n\tintReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)\n\tIf intReturn = 0 Then\n\t\tReturnStringValueOrEchoError = strValueData\n\tElse\n\t\tReturnStringValueOrEchoError = -1\n\t\tWScript.Echo strErrorMessage\n\tEnd If\nEnd Function \n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 195, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "The addresses of the configured DHCP servers, If a machine is on DHCP.\nExample: 192.168.1.1", 
      "exclude_from_parse_flag": 1, 
      "hash": 1471370561, 
      "hidden_flag": 0, 
      "id": 387, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "DHCP Server", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select DHCPServer from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 196, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the full versions numbers of all installed .NET.", 
      "exclude_from_parse_flag": 1, 
      "hash": 1496471156, 
      "hidden_flag": 0, 
      "id": 389, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 7200, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "NET Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;\n&#039;  .NET Version\n&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;&#039;\n&#039; This sensor returns the highest .NET Version installed on the endpoint\n\nOption Explicit\n\nDim strComputer, strKeyPath10, strKeyPath11, strkeyPath20, strKeyPath30, strKeyPath35, strKeyPath40, strkeyPath4c, strKeyPath45, objRegistry, strValueName, strValue, strNoNET, strValue10, strValue11, strValue20, strValue30, strValue35, strValue40, strValue4C, strValue45, byPass4c, byPass40\nConst HKEY_LOCAL_MACHINE = &amp;H80000002\nstrComputer = &quot;.&quot;\n\nstrKeyPath10 = &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v1.0.3705\\&quot;\nstrKeyPath11 = &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v1.1.4322\\&quot;\nstrKeyPath20 = &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v2.0.50727\\&quot;\nstrKeyPath30 = &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.0\\&quot;\nstrKeyPath35 = &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v3.5\\&quot;\nstrKeyPath40 = &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full\\&quot;\nstrKeyPath4C = &quot;SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Client\\&quot;\nstrKeyPath45 = &quot;Software\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full\\&quot;\n\nSet objRegistry = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nstrValue = NULL\n\n&#039;Find existence of .NET1.0\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath10, strValueName, strValue10\nIf IsNull(strValue10) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tstrValue = strValue10\nEnd If\n\n&#039;Find existence of .NET1.1\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath11, strValueName, strValue11\nIf IsNull(strValue11) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tstrValue = strValue11\nEnd If\n\n&#039;Find existence of .NET2.0\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath20, strValueName, strValue20\nIf IsNull(strValue20) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tstrValue = strValue20\nEnd If\n\n&#039;Find existence of .NET3.0\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath30, strValueName, strValue30\nIf IsNull(strValue30) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tstrValue = strValue30\nEnd If\n\n&#039;Find existence of .NET3.5\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath35, strValueName, strValue35\nIf IsNull(strValue35) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tstrValue = strValue35\nEnd If\n\n&#039;Find existence of .NET4.0 Client Version - but only if .NET4.0 Full Version Not Found\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath4C, strValueName, strValue4C\nIf IsNull(strValue4C) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tstrValue = strValue4C\nEnd If\n\n&#039;Find existence of .NET4.0 and Bypass test for .NET4.0 Client if Found\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath40, strValueName, strValue40\nIf IsNull(strValue40) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tstrValue = strValue40\nEnd If\n\n&#039;Find existence of .NET4.5 Client Version\nstrValueName = &quot;Version&quot;\nobjRegistry.GetStringValue HKEY_LOCAL_MACHINE, strKeyPath45, strValueName, strValue45\nIf IsNull(strValue45) Then\n\tstrNoNet = &quot;.NET not installed&quot;\nElse\n\tIf InStr(strValue45, &quot;4.5.&quot;) &gt; 0 Then\n\t\tstrValue = strValue45\n\tEnd If\nEnd If\n\nIf IsNull(strValue)Then\n\tWScript.Echo strNoNet\nElse\n\tWScript.Echo strValue\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 197, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the name of any device which is built into the motherboard.\nExample: ES1371", 
      "exclude_from_parse_flag": 1, 
      "hash": 151176619, 
      "hidden_flag": 0, 
      "id": 391, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Onboard Devices", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Description from Win32_OnBoardDevice", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 198, 
      "category": "Registry", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns True if the Registry Value exists, False if not.", 
      "exclude_from_parse_flag": 1, 
      "hash": 1512811088, 
      "hidden_flag": 0, 
      "id": 393, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Registry Key Value Exists", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{5}\",\"helpString\":\"Value must be at least 5 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the key path to query\",\"value\":\"\",\"promptText\":\"e.g. HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\",\"defaultValue\":\"\",\"label\":\"Registry Key\",\"maxChars\":0,\"key\":\"strKey\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the key value to query\",\"value\":\"\",\"promptText\":\"e.g. Version\",\"defaultValue\":\"\",\"label\":\"Registry Value\",\"maxChars\":0,\"key\":\"strValue\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Value Exists\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Data | Type | Architecture | KeyPath | Value\n\n&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)\n\nstrKey = unescape(&quot;||strKey||&quot;)\nstrValue = unescape(&quot;||strValue||&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n&#039;strValue = &quot;ServerPort&quot;\n\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n&#039;strValue = &quot;Emailname&quot;\nstrSep = &quot;~~&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = ValueExists(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = ValueExists(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = ValueExists(objReg, objCTX, constHive, strKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\n\t\thasValues64 = ValueExists(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\n\tEnd If\nEnd If\n\nIf (hasAnyResult) Then\n\tWScript.Echo &quot;True&quot;\nElse\n\tWScript.Echo &quot;False&quot;\nEnd If\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction ValueExists(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\tarrTypes = Outparams.Types\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\t\n\t\t\t&#039;if strValue is found, echo\n\t\t\tIf LCase(strValueName) = LCase(strValue) Then\n\t\t\t\tValueExists = True\n\t\t\t\tExit Function\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\tValueExists = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit)\n\tIf intBit = 64 Then\n\t\tstrArch = &quot;64-bit&quot;\n\tElse\n\t\tstrArch = &quot;32-bit&quot;\n\tEnd If\n\t\t\t\n\tGetDisplayString = _\n\t\tstrValue &amp; strSep &amp; _\n\t\tstrType &amp; strSep &amp; _\n\t\tstrArch\nEnd Function\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\\Software\\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  ||strValue||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\\Software\\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  ||strValue||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 199, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Gives the last install time of any patch applied via Tanium.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 151391351, 
      "hidden_flag": 0, 
      "id": 395, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Last Tanium Patch Install Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last Tanium Patch Install Time\n&#039;========================================\n\n&#039; sensor - Last Tanium Patch Install Time\n&#039; This sensor will output the date modified for installresultsreadable.txt\n\nOption Explicit\n\nSetLocale(1033) &#039; Required for RFC822\nDim strBias : strBias = GetRFC822Bias\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, dtmDateModified\nstrSep = &quot;|&quot;\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\installedresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tOn Error Resume Next\n\tdtmDateModified = CDate(objFSO.GetFile(fn).DateLastModified)\n\tWScript.Echo vbTimeToRFC822(CStr(dtmDateModified), strBias)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tWScript.Echo &quot;Error: Could not interpret date format of file&quot;\n\tEnd If\nElse\n   Wscript.echo &quot;Tanium patch install history output not found&quot;\nEnd If\n\nWScript.Quit()\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\n&#039; --- Begin Time Functions --- &#039;\nFunction vbTimeToRFC822(myDate, offset)\n&#039;SetLocale outside of function in global scope\n&#039; must be set so that month is displayed with US/English abbreviations\n&#039; as per the standard\n\n\tIf Not GetLocale = 1033 Then\n\t\tWScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;\n\t\tWScript.Quit\n\tEnd If\n   Dim myDay, myDays, myMonth, myYear\n   Dim myHours, myMinutes, myMonths, mySeconds\n\n   myDate = CDate(myDate)\n   myDay = WeekdayName(Weekday(myDate),true)\n   myDays = zeroPad(Day(myDate), 2)\n   myMonth = MonthName(Month(myDate), true)\n   myYear = Year(myDate)\n   myHours = zeroPad(Hour(myDate), 2)\n   myMinutes = zeroPad(Minute(myDate), 2)\n   mySeconds = zeroPad(Second(myDate), 2)\n\n   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _\n                                  myDays&amp;&quot; &quot;&amp; _\n                                  myMonth&amp;&quot; &quot;&amp; _ \n                                  myYear&amp;&quot; &quot;&amp; _\n                                  myHours&amp;&quot;:&quot;&amp; _\n                                  myMinutes&amp;&quot;:&quot;&amp; _\n                                  mySeconds&amp;&quot; &quot;&amp; _ \n                                  offset\nEnd Function &#039;vbTimeToRFC822\n\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function\n\nFunction GetRFC822Bias\n&#039; This function returns a string which is a \n&#039; timezone bias for RFC822 format\n&#039; considers daylight savings\n&#039; we choose 4 digits and a sign (+ or -)\n\n\tDim objWMIService,colTimeZone,objTimeZone\n\t\n\tDim intTZBiasInMinutes,strSign,strReturnString\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n\t \n\tFor Each objTimeZone in colTimeZone\n\t    intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n\tNext\n\n\t&#039; The offset is explicitly signed\n\tIf intTZBiasInMinutes &lt; 0 Then\n\t\tstrSign = &quot;-&quot;\n\tElse\n\t\tstrSign = &quot;+&quot;\n\tEnd If\n\t\n\tstrReturnString = CStr(Abs(intTZBiasInMinutes))\n\t&#039; no offset is greater than three digits but RFC822 bias seems to\n\t&#039; usually take the form of 1 alpha / 4 digit as described as \n\t&#039; valid in ANSI X3.51-1975\n\n\tstrReturnString = zeroPad(strReturnString,4)\n\n\tGetRFC822Bias = strSign&amp;strReturnString\n\t\n\t&#039;Cleanup\n\tSet colTimeZone = Nothing\n\tSet objWMIService = Nothing\n\t\nEnd Function &#039;GetRFC822Bias\n\n&#039; --- End Time Functions --- &#039;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "BESDate"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 200, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Gives the last Tanium patch scan time.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 3708414887, 
      "hidden_flag": 0, 
      "id": 397, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 60, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Last Tanium Patch Scan Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last Tanium Patch Scan Time\n&#039;========================================\n\n&#039; sensor - Last Tanium Patch Scan Time\n&#039; This sensor will output the date modified for Scanresultsreadable.txt\n\nOption Explicit\n\nSetLocale(1033) &#039; Required for RFC822\nDim strBias : strBias = GetRFC822Bias\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, dtmDateModified\nstrSep = &quot;|&quot;\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tOn Error Resume Next\n\tdtmDateModified = CDate(objFSO.GetFile(fn).DateLastModified)\n\tWScript.Echo vbTimeToRFC822(CStr(dtmDateModified), strBias)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tWScript.Echo &quot;Error: Could not interpret date format of file&quot;\n\tEnd If\nElse\n   Wscript.echo &quot;Tanium patch scan output not found&quot;\nEnd If\n\nWScript.Quit()\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\n&#039; --- Begin Time Functions --- &#039;\nFunction vbTimeToRFC822(myDate, offset)\n&#039;SetLocale outside of function in global scope\n&#039; must be set so that month is displayed with US/English abbreviations\n&#039; as per the standard\n\n\tIf Not GetLocale = 1033 Then\n\t\tWScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;\n\t\tWScript.Quit\n\tEnd If\n   Dim myDay, myDays, myMonth, myYear\n   Dim myHours, myMinutes, myMonths, mySeconds\n\n   myDate = CDate(myDate)\n   myDay = WeekdayName(Weekday(myDate),true)\n   myDays = zeroPad(Day(myDate), 2)\n   myMonth = MonthName(Month(myDate), true)\n   myYear = Year(myDate)\n   myHours = zeroPad(Hour(myDate), 2)\n   myMinutes = zeroPad(Minute(myDate), 2)\n   mySeconds = zeroPad(Second(myDate), 2)\n\n   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _\n                                  myDays&amp;&quot; &quot;&amp; _\n                                  myMonth&amp;&quot; &quot;&amp; _ \n                                  myYear&amp;&quot; &quot;&amp; _\n                                  myHours&amp;&quot;:&quot;&amp; _\n                                  myMinutes&amp;&quot;:&quot;&amp; _\n                                  mySeconds&amp;&quot; &quot;&amp; _ \n                                  offset\nEnd Function &#039;vbTimeToRFC822\n\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function\n\nFunction GetRFC822Bias\n&#039; This function returns a string which is a \n&#039; timezone bias for RFC822 format\n&#039; considers daylight savings\n&#039; we choose 4 digits and a sign (+ or -)\n\n\tDim objWMIService,colTimeZone,objTimeZone\n\t\n\tDim intTZBiasInMinutes,strSign,strReturnString\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n\t \n\tFor Each objTimeZone in colTimeZone\n\t    intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n\tNext\n\n\t&#039; The offset is explicitly signed\n\tIf intTZBiasInMinutes &lt; 0 Then\n\t\tstrSign = &quot;-&quot;\n\tElse\n\t\tstrSign = &quot;+&quot;\n\tEnd If\n\t\n\tstrReturnString = CStr(Abs(intTZBiasInMinutes))\n\t&#039; no offset is greater than three digits but RFC822 bias seems to\n\t&#039; usually take the form of 1 alpha / 4 digit as described as \n\t&#039; valid in ANSI X3.51-1975\n\n\tstrReturnString = zeroPad(strReturnString,4)\n\n\tGetRFC822Bias = strSign&amp;strReturnString\n\t\n\t&#039;Cleanup\n\tSet colTimeZone = Nothing\n\tSet objWMIService = Nothing\n\t\nEnd Function &#039;GetRFC822Bias\n\n&#039; --- End Time Functions --- &#039;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "BESDate"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 201, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Indicates whether a screen saver is enabled on the client machine.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 1526750078, 
      "hidden_flag": 0, 
      "id": 399, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Screen Saver Active", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Screen Saver Active\n&#039;========================================\n\n&#039; This sensor will report on whether the screen saver is active\n\nOption Explicit\n\nWScript.Echo GetScreenSaverActive\n\nFunction GetScreenSaverActive\n\t\n\tDim objWMIService, colDesktops\n\tDim strComputer, objDesktop, bIsActive\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;) \n\n\tSet colDesktops = objWMIService.ExecQuery _ \n\t\t(&quot;Select ScreenSaverActive from Win32_Desktop&quot;) \n\tIf Not IsNull(colDesktops) Then\n\t\tFor Each objDesktop In colDesktops\t\n\t\t\tbIsActive = objDesktop.ScreenSaverActive\n\t\tNext\n\t\tIf bIsActive Then\n\t\t\tGetScreenSaverActive = &quot;True&quot;\n\t\tElse\n\t\t\tGetScreenSaverActive = &quot;False&quot;\n\t\tEnd If\n\tElse\n\t\tGetScreenSaverActive = &quot;WMI Error&quot;\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet colDesktops = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;GetScreenSaverActive", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 202, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": "|", 
      "description": "Any established connections currently being made.  This multi-column Sensor displays the process responsible for the connection, the display name of the process (if available), and the target IP Address and port.  Processes and IP ranges can be excluded in the Sensor definition.\nExample: chrome.exe | Google Chrome | 173.194.79.99:80", 
      "exclude_from_parse_flag": 1, 
      "hash": 1528412180, 
      "hidden_flag": 0, 
      "id": 401, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Established Connections", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Established Connections\n&#039;========================================\n\nshowProcess = True\nshowPort = True\nshowDNSName = False\n\nDim strcommand, results, excludeProcesses, excludeSubnets, taniumDebug\nDim strSep : strSep = &quot;|&quot;\n&#039; This is a multi-column sensor that looks like:\n&#039;Process|Name|Target IP\n\nexcludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;\n&#039;excludeProcesses = &quot;chrome.exe&quot;\n&#039;excludeProcesses = &quot;iexplore.exe&quot;\n&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;\n&#039;excludeProcesses = &quot;trillian.exe&quot;\n\nexcludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;\n&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;\n\ntaniumDebug = False\n\n\nexcludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)\nexcludeSubnets = Split(excludeSubnets, &quot;,&quot;)\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nquery = &quot;select name, executablepath, processId from win32_process&quot;\nSet colResults = objWMIService.ExecQuery(query)\n\n&#039;dictionary for process-app pairs\nSet processes = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nFor Each result In colResults \n\tprocessId = CStr(result.ProcessId)\n\tprocessPath = result.ExecutablePath\n\tprocesses.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later\nNext\n\nstrcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; Chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find &quot; &amp; Chr(34) &amp; &quot;ESTABLISHED&quot; &amp; Chr(34)\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrPingResults = LCase(objScriptExec.StdOut.ReadAll)\n\nresults = Split(strPingResults, vbCrLf)\nj = 0\n\nFor Each line In results\n\tline = cleanWhitespace(Trim(line))\n\t\n\tIf line &lt;&gt; &quot;&quot; Then \n\t\tlineResults = Split(line)\n\t\ti = 0\n\t\tDim strPort, strPid, strConnectionType, strForeignIp, strApp\n\t\tFor Each word In lineResults\n\t\t\tIf i = 1 Then\n\t\t\t\tstrPort = word\n\t\t\tElseIf i = 2 Then\n\t\t\t\tstrForeignIp = word\n\t\t\tElseIf i = 3 Then\n\t\t\t\tstrConnectionType = word\n\t\t\tElseIf i = 4 Then\n\t\t\t\tstrPid = word\n\t\t\tEnd If\n\t\t\t\n\t\t\ti = i + 1\n\t\tNext\n\t\t\n\t\t&#039;DO NOT INCLUDE EXCLUDED APPS\n\t\tstrAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path\n\t\tarrAppEntry = Split(strAppEntry,&quot;,&quot;)\n\t\tstrAppExe = arrAppEntry(0)\n\t\tstrAppPath = arrAppEntry(1)\n\t\t\n\t\tisNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))\n\t\t\n\t\t&#039;DO NOT INCLUDE EXCLUDED SUBNETS\n\t\tisNotExcludedSubnet = Not(ContainedInSubnet(strForeignIp, excludeSubnets))\n\t\t\n\t\tIf Not(IsEmpty(strAppExe)) _\n\t\t\tAnd isNotExcludedApp _ \n\t\t\tAnd isNotExcludedSubnet Then\n\t\t\t\n\t\t\tIf Not showPort Then \n\t\t\t\tarrTemp = Split(strForeignIp, &quot;:&quot;)\n\t\t\t\tstrForeignIp = arrTemp(0)\n\t\t\tEnd If\n\t\t\t\n\t\t\tIf showDNSName Then\n\t\t\t\tarrTemp = Split(strForeignIp, &quot;:&quot;)\n\t\t\t\tstrForeignIp = ReverseDNSLookup(arrTemp(0))\n\t\t\t\tIf UBound(arrTemp) &gt;=1 Then \n\t\t\t\t\tstrForeignIp = strForeignIp &amp; &quot;:&quot; &amp; arrTemp(1)\n\t\t\t\tEnd If\n\t\t\tEnd If \n\t\t\t\n\t\t\tIf showProcess Then\n\t\t\t\tresults(j) = strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIp\n\t\t\tElse\n\t\t\t\tresults(j) = strSep &amp; strSep &amp; strForeignIp\n\t\t\tEnd If\t\n\t\tElse\n\t\t\tIf taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp\n\t\t\tresults(j) = &quot;&quot;   \n\t\tEnd If \n\t\t\n\t\tj = j + 1\n\tEnd If\nNext\n\nresults = RemDups(results)\n\nIf UBound(results) &lt; 1 Then\n\tIf GetLocale() &lt;&gt; 1033 Then\n\t\tWScript.Echo &quot;English Language OS Required&quot;\n\tEnd If\nEnd If\n \nFor Each result In results \n\tWScript.Echo result\nNext\n\nWScript.Quit\n\nFunction ReverseDNSLookup(strIPAddress)\n\tReverseDNSLookup = strIPAddress\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\tSet objExecCommand = objShell.Exec(&quot;%comspec% /c nslookup &quot; &amp; strIPAddress)\n\t\n\tstrResults = objExecCommand.StdOut.ReadAll\n\t\n\tIf InStr(strResults, &quot;Name:&quot;) Then\n\t\tarrNameTemp = Split(strResults, &quot;Name:&quot;)\n\t\tarrName = Split(Trim(arrNameTemp(1)), Chr(13))\n\t\t\n\t\tReverseDNSLookup = arrName(0)\n\tEnd If\t\nEnd Function\n\nFunction ContainedInSubnet(str, arr)\n\tDim strIp, strSubnet, strMask\n\ttemp = Split(str, &quot;:&quot;)\n\tstrIp = temp(0)\n\t\n\tFor Each item In arr\n\t\tIf InStr(item, &quot;-&quot;) Then &#039;Subnet range\n\t\t\ttemp = Split(item, &quot;-&quot;)\n\t\t\tlower = Split(temp(0), &quot;:&quot;)\n\t\t\tupper = Split(temp(1), &quot;:&quot;)\n\t\t\tlowerSubnet = Trim(lower(0))\n\t\t\tlowerMask = Trim(lower(1))\n\t\t\tupperSubnet = Trim(upper(0))\n\t\t\tupperMask = Trim(upper(1))\n\t\t\t\n\t\t\tIf StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _\n\t\t\t\tAnd StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then\n\t\t\t\tContainedInSubnet = True\n\t\t\t\tExit Function\n\t\t\tEnd If \n\t\tElse &#039;Single subnet\n\t\t\tparts = Split(item, &quot;:&quot;)\n\t\t\tstrSubnet = Trim(parts(0))\n\t\t\tstrMask = Trim(parts(1))\n\t\t\tIf Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then\n\t\t\t\tContainedInSubnet = True\n\t\t\t\tExit Function\n\t\t\tEnd If\n\t\tEnd If \n\tNext\n\tContainedInSubnet = False\nEnd Function\n\nFunction ContainedInArray(str, arr)\n\tFor Each item In arr \n\t\tIf str = Trim(item) Then\n\t\t\tContainedInArray = True\n\t\t\tExit Function\n\t\tEnd If   \n\tNext\n\tContainedInArray = False\nEnd Function\n\nFunction cleanWhitespace(strStarter)\n\tintStarter = Len(strStarter)\n\tFor i = intStarter To 2 Step -1\n\t\tstrChars = Space(i)\n\t\tstrStarter = Replace(strStarter, strChars, &quot; &quot;)\n\tNext\n\tcleanWhitespace = strStarter\nEnd Function\n\nFunction RemDups(ByVal anArray)\n\tDim d, item, thekeys\n\tSet d = CreateObject(&quot;Scripting.Dictionary&quot;)\n\td.removeall\n\td.CompareMode = 0\n\tFor Each item In anArray\n\t\tIf Len(item) &gt; 0 Then\n\t\t\tIf Not d.Exists(item) Then d.Add item, item\n\t\tEnd If\n\tNext\n\tthekeys = d.keys\n\tSet d = Nothing\n\tRemDups = thekeys\nEnd Function\n\nFunction Subnet(strAddress, strMask)\n\tintSubnetLength = SubnetLength(strMask)\n\tSubnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))\nEnd Function\n\nFunction SubnetLength(strMask)\n\tstrMaskBinary = StringToBinary(strMask)\n\tSubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))\nEnd Function\n\nFunction BinaryToString(strBinary)\n\tFor intOctetPos = 1 To 4\n\t\tstrOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)\n\t\tintOctet = 0\n\t\tintValue = 1\n\t\tFor intBinaryPos = 1 To Len(strOctetBinary)\n\t\t\tIf Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue\n\t\t\tintValue = intValue * 2\n\t\tNext\n\t\tIf BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)\n\tNext\nEnd Function\n\nFunction StringToBinary(strAddress)\n\tobjAddress = Split(strAddress, &quot;.&quot;, -1)\n\tFor Each strOctet In objAddress\n\t\tintOctet = CInt(strOctet)\n\t\tstrOctetBinary = &quot;&quot;\n\t\tFor x = 1 To 8\n\t\t\tIf intOctet Mod 2 &gt; 0 Then\n\t\t\t\tstrOctetBinary = &quot;1&quot; &amp; strOctetBinary\n\t\t\tElse\n\t\t\t\tstrOctetBinary = &quot;0&quot; &amp; strOctetBinary\n\t\t\tEnd If\n\t\t\tintOctet = Int(intOctet / 2)\n\t\tNext\n\t\tStringToBinary = StringToBinary &amp; strOctetBinary\n\tNext\nEnd Function\n\nFunction ProcessNameToApplicationName(strExecutablePath, strExecutableName)\n\t&#039; This function will return the full application name of a running executable\n\t\n\tDim fso\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tarrPathParts = Split(strExecutablePath,&quot;\\&quot;)\n\t\n\tIf UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process\n\t\tProcessNameToApplicationName = strExecutableName\n\t\tSet fso = Nothing\n\t\tExit Function\n\tEnd If\n\tstrExecutable = arrPathParts(UBound(arrPathParts))\n\t\n\tIf fso.FileExists(strExecutablePath) Then\n\t\tDim strOutput, fileVersion, fileVersionOutput, fullName\n\t\t\n\t\tSet execFile = fso.GetFile(strExecutablePath)\n\t\tfullName = GetDescription(execFile.ParentFolder.Path, strExecutable)\n\t\tIf Not fullName = &quot;&quot; Then\n\t\t\tProcessNameToApplicationName = fullName\n\t\tElse\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\tEnd If\n\tElse &#039; file doesn&#039;t exist or inaccessible\n\t\tProcessNameToApplicationName = strExecutableName\n\tEnd If\n\t\nEnd Function &#039;ProcessNameToApplicationName\n\nFunction GetDescription(folderPath, fileName)\n\tdescIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)\n\tIf IsEmpty(descIndex) Then\n\t\tdescIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)\n\tEnd If\n\tGetDescription = GetFileProperty(folderPath, fileName, descIndex)\nEnd Function\n\nFunction GetFileProperty(folderPath, fileName, fileProperty)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tGetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)\nEnd Function\n\nFunction GetAttributeIndex(folderPath, attrTarget)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tFor i = 0 To 50\n\t\tattrName = objFolder.GetDetailsOf(objFolder.Items, i)\n\t\tIf LCase(attrName) = LCase(attrTarget) Then\n\t\t\tGetAttributeIndex = i\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\ntmpfile=&quot;/tmp/tanium.$$&quot;\nlsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n  &gt; $tmpfile\ncat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($0,index($0,&quot;&gt;&quot;)+1,index($0,&quot; (ESTABLISHED)&quot;)-(index($0,&quot;&gt;&quot;)+1))}&#039;\nrm -f $tmpfile\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\ntmpfile=&quot;/tmp/tanium.$$&quot;\nlsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n  &gt; $tmpfile\ncat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($0,index($0,&quot;&gt;&quot;)+1,index($0,&quot; (ESTABLISHED)&quot;)-(index($0,&quot;&gt;&quot;)+1))}&#039;\nrm -f $tmpfile\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Target IP", 
            "value_type": "IPAddress"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 203, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns the directory the Operating System boots from.\nExample:\\\\Windows", 
      "exclude_from_parse_flag": 1, 
      "hash": 1544486184, 
      "hidden_flag": 0, 
      "id": 403, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "Operating System Boot Directory", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select BootDirectory from win32_BootConfiguration", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 204, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:03", 
      "delimiter": ",", 
      "description": "Returns a list of USB devices currently plugged in to the client machine.\nExample: HID Keyboard Device", 
      "exclude_from_parse_flag": 1, 
      "hash": 15451865, 
      "hidden_flag": 0, 
      "id": 405, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:03", 
      "name": "USB Device", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from Win32_PnPEntity where (Status=&#039;OK&#039; and DeviceID like &#039;%HID%&#039;)", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 205, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Name of sound card in client machine.\nExample: SoundMAX Integrated Digital HD Audio", 
      "exclude_from_parse_flag": 1, 
      "hash": 1579270802, 
      "hidden_flag": 0, 
      "id": 407, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Sound Card", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Name from Win32_SoundDevice", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 206, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Manufacturer or vendor of the BIOS.\nExample: Dell, Inc.", 
      "exclude_from_parse_flag": 1, 
      "hash": 1580351176, 
      "hidden_flag": 0, 
      "id": 409, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "BIOS Vendor", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Manufacturer from win32_BIOS", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s bios-vendor\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 207, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns share names of network shares which are mapped locally.\nExample: \\\\\\\\server\\\\share", 
      "exclude_from_parse_flag": 1, 
      "hash": 1582126011, 
      "hidden_flag": 0, 
      "id": 411, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Mapped Drives", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Mapped Drives\n&#039;========================================\n&#039;\n\nOption Explicit\n\nDim dictBlacklist, objWMIService, colItems, objItem, strProviderName, bShouldList, strItem\n\nSet dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; Add one line for each file share that you do not want listed in the sensor output.  \n&#039;dictBlacklist.Add LCase(&quot;InsertBlacklistPathHere&quot;), True\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;select ProviderName from WIN32_LogicalDisk&quot;)    \nFor Each objItem In colItems\n\tstrProviderName = objItem.ProviderName\n\n\tIf Not IsNull(strProviderName) Then \t\n\t\tbShouldList = True\n\t\n\t\tFor Each strItem In dictBlacklist.Keys\n\t\t\tIf InStr(LCase(strProviderName), strItem) &lt; 0 Then \n\t\t\t\tbShouldList = False\n\t\t\tEnd If\n\t\tNext\n\t\n\t\tIf bShouldList Then \n\t\t\tWScript.Echo strProviderName\n\t\tEnd If \n\tEnd If \nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 208, 
      "category": "Windows Event Logs", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Event codes for Windows event logs of type System and Error.\nExample: 8009", 
      "exclude_from_parse_flag": 1, 
      "hash": 1591480148, 
      "hidden_flag": 0, 
      "id": 413, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "System Event Log IDs", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select EventCode from Win32_NTLogEvent where LogFile = &#039;System&#039; and Type = &#039;Error&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 209, 
      "category": "Registry", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "~~", 
      "description": "Returns the data of a supplied value in a supplied registry key.  If the hive is HKEY_USERS, it will attempt to output the user name associated with the key.  HKEY_CURRENT_USER will only return data for the SYSTEM account which the Tanium Client runs as.\nExample: John | 4.1.314.7020 | REG_SZ|32-bit", 
      "exclude_from_parse_flag": 1, 
      "hash": 1591958393, 
      "hidden_flag": 0, 
      "id": 415, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Registry Value Data", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{5}\",\"helpString\":\"Value must be at least 5 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the key path to query\",\"value\":\"\",\"promptText\":\"e.g. HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\",\"defaultValue\":\"\",\"label\":\"Registry Key\",\"maxChars\":0,\"key\":\"strKey\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the key value to query\",\"value\":\"\",\"promptText\":\"e.g. Version\",\"defaultValue\":\"\",\"label\":\"Registry Value\",\"maxChars\":0,\"key\":\"strValue\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Value Data\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Data | Type | Architecture | KeyPath | Value\n\n&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)\n\nstrKey = unescape(&quot;||strKey||&quot;)\nstrValue = unescape(&quot;||strValue||&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client\n&#039;strValue = &quot;Version&quot;\n\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n&#039;strValue = &quot;Emailname&quot;\nstrSep = &quot;~~&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\n&#039; Do not return second value set in different context unnecessarily\nDim strKeyPrefix,bSkipSecondContextCheck\nbSkipSecondContextCheck = False\nstrKeyPrefix = Split(strKey,&quot;\\&quot;)(0) &#039; Software, for instance, even for HEKY_USERS\n\nSelect Case Ucase(strKeyPrefix)\n\tCase &quot;SOFTWARE&quot;\n\t\tbSkipSecondContextCheck = False\n\tCase Else\n\t\tbSkipSecondContextCheck = True\nEnd Select\n\nIf Is64 And Not bSkipSecondContextCheck Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\n\t\thasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\n\tEnd If\nEnd If\n\nIf Not (hasAnyResult) Then\n\tWScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\tarrTypes = Outparams.Types\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\t\n\t\t\t&#039;if strValue is found, echo\n\t\t\tIf LCase(strValueName) = LCase(strValue) Then\n\t\t\t\tEchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit\n\t\t\t\tCheckValues = True\n\t\t\t\tExit Function\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\tCheckValues = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit)\n\tIf intBit = 64 Then\n\t\tstrArch = &quot;64-bit&quot;\n\tElse\n\t\tstrArch = &quot;32-bit&quot;\n\tEnd If\n\n\tGetDisplayString = _\n\t\tstrValue &amp; strSep &amp; _\n\t\tstrType &amp; strSep &amp; _\n\t\tstrArch\nEnd Function\n\nFunction EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)\n\t&#039; Note the key that was being searched, will be a hidden column\n\tstrOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n\t\n\tDim objInParams, objOutParams\n\tSelect Case constType\n\t\tCase REG_SZ  \n\t\t\tSet objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit) _\n\t\t\t\t&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n\t\tCase REG_EXPAND_SZ\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)\n\t\n\t\t\tWScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit) _\n\t\t\t\t&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n\t\tCase REG_BINARY\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)\n\n\t\t\tstrBytes = &quot;&quot;\n\t\t\tFor Each uByte in objOutParams.uValue\n\t\t\t\tstrTemp = Hex(uByte)\n\t\t\t\tIf Len(strTemp) &lt; 2 Then\n\t\t\t\t\tstrTemp = &quot;0&quot; &amp; strTemp\n\t\t\t\tEnd If\t\n\t\t\t\tstrBytes = strBytes &amp; strTemp &amp; &quot; &quot;\n\t\t\tNext\n\t\t\t\n\t\t\tWScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit) _\n\t\t\t\t&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n\t\tCase REG_DWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit) _\n\t\t\t\t&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n\t\tCase REG_QWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit) _\n\t\t\t\t&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n\t\tCase REG_MULTI_SZ\n\t\t    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tarrValues = objOutParams.sValue\n\t\t\tstrResponse = &quot;&quot;\n\n\t\t\tFor Each strTemp In arrValues\n\t\t\t\tWScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit) _\n\t\t\t\t\t&amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n\t\t\tNext\n\n\tEnd Select\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\\Software\\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  ||strValue||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_LOCAL_MACHINE\\Software\\Microsoft&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the key path to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;},{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strValue&quot;,&quot;promptText&quot;:&quot;e.g. Version&quot;,&quot;label&quot;:&quot;Registry Value&quot;,&quot;helpString&quot;:&quot;Enter the key value to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  ||strValue||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "User", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Data", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Architecture", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "KeyPath", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Value", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 210, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Multi-column sensor that returns details on the type, size, and free space of all partitions on the machine.\nExample:ST3808110AS ATA Device|C:|250G|120G", 
      "exclude_from_parse_flag": 1, 
      "hash": 1652607578, 
      "hidden_flag": 0, 
      "id": 417, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Disk Drive Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039; Sensor:  Disk Drive Details\n&#039; disk-drive-details.vbs\n&#039;\n&#039; Multicolumn sensor that returns all of the drive details on a single line\n\nOption Explicit\n\nDim objWMIService, objDiskDrives, objDiskDrive, objDiskPartitions, objDiskPartition\nDim objLogicalDisks, objLogicalDisk\nDim strEscapedDeviceID\n\nSet objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=Impersonate}!//.&quot;)\nSet objDiskDrives = objWMIService.ExecQuery(&quot;SELECT Caption, DeviceID FROM Win32_DiskDrive&quot;)\n \nFor Each objDiskDrive In objDiskDrives\n    strEscapedDeviceID = _\n        Replace(objDiskDrive.DeviceID, &quot;\\&quot;, &quot;\\\\&quot;, 1, -1, vbTextCompare)\n    Set objDiskPartitions = objWMIService.ExecQuery _\n        (&quot;ASSOCIATORS OF {Win32_DiskDrive.DeviceID=&quot;&quot;&quot; &amp; _\n            strEscapedDeviceID &amp; &quot;&quot;&quot;} WHERE &quot; &amp; _\n                &quot;AssocClass = Win32_DiskDriveToDiskPartition&quot;)\n \n    For Each objDiskPartition In objDiskPartitions\n        Set objLogicalDisks = objWMIService.ExecQuery _\n            (&quot;ASSOCIATORS OF {Win32_DiskPartition.DeviceID=&quot;&quot;&quot; &amp; _\n                objDiskPartition.DeviceID &amp; &quot;&quot;&quot;} WHERE &quot; &amp; _\n                    &quot;AssocClass = Win32_LogicalDiskToPartition&quot;)\n \n        For Each objLogicalDisk In objLogicalDisks\n            WScript.Echo objDiskDrive.Caption &amp; &quot;|&quot; &amp; objLogicalDisk.DeviceID &amp; &quot;|&quot; &amp; _\n            SizeInGB(objLogicalDisk.Size) &amp; &quot;|&quot; &amp; SizeInGB(objLogicalDisk.FreeSpace)\n        Next\n    Next\nNext\n\nFunction SizeInGB(orgSize)\n\tDim dblSize, intSize, strResult\n\tstrResult = &quot;&quot;\n    If Not IsNull(orgSize) Then\n\t    dblSize = CDbl(orgSize)\n\t    dblSize = dblSize / 1024 / 1024 / 1024\n\t    intSize = CInt(dblSize)\n\t\tstrResult = intSize &amp; &quot; GB&quot;\n    End If\n    \n    SizeInGB = strResult\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Drive Letter", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Size", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Free Space", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 211, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Indicates whether the client machine is currently experiencing high utilization of its CPU.\nExample: Under threshold", 
      "exclude_from_parse_flag": 1, 
      "hash": 1670489640, 
      "hidden_flag": 0, 
      "id": 419, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "High CPU Consumption", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; High CPU Consumption\n&#039;========================================\n\nConst HKLM = &amp;H80000002 \nstrComputer = &quot;.&quot;\n\nSet objWMIService = _\n  \tGetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)\n\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)\nFor Each objItem in colProcItems\n\tN1 = objItem.PercentProcessorTime\n\tD1 = objItem.TimeStamp_Sys100NS\nNext\n\nWScript.sleep(3000)\n\t\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;Idle&#039;&quot;)\nFor Each objItem in colProcItems\n\tN2 = objItem.PercentProcessorTime\n\tD2 = objItem.TimeStamp_Sys100NS\nNext\n\nnumLogicalProcessors = 0\n\nSet colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) \nFor Each objItem in colItems \n\tDim intLogicalProcessors \n\tintLogicalProcessors = 1\n\t\n\tOn Error Resume Next\n\tintLogicalProcessors = CInt(objItem.NumberOfLogicalProcessors)\n\tOn Error Goto 0\n\n\tnumLogicalProcessors = numLogicalProcessors + intLogicalProcessors\nNext\n\n&#039; CounterType - PERF_100NSEC_TIMER\n&#039; Formula = ((N2 - N1) / (D2 - D1)) x 100\nIf ( 0 = (D2-D1) ) Or D1 &gt; D2 then\n\tWScript.echo &quot;System Timestamp Error&quot;\nElseIf N1 &gt; N2 Then\n\tWScript.Echo &quot;Performance Counter Error&quot;\nElse\n\tpercentage = Round(100 - ((N2 - N1) / (D2 - D1)) * 100 / numLogicalProcessors, 0)\n\tIf percentage &gt; 80 Then\n\t\tWScript.echo percentage &amp; &quot; %&quot;\n\tElse\n\t\tWScript.echo &quot;Under 80% threshold&quot;\n\tEnd if\nEnd if\n\nSet wmi_service = nothing", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 212, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "This sensor will return all patches uninstalled in the last 7 days", 
      "exclude_from_parse_flag": 0, 
      "hash": 1388814144, 
      "hidden_flag": 0, 
      "id": 421, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Recently Uninstalled Patches", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;==============================\n&#039; Tanium Community Content\n&#039; Script ID: 1380\n&#039; Last Modified: Fri Mar  7, 2014  9:51 PM\n&#039;==============================\n\n&#039;========================================\n&#039;Recently Uninstalled Patches\n&#039;========================================\n\n&#039; This sensor will return all patches uninstalled in the last 7 days\n\nOption Explicit\nDim strSep : strSep = &quot;|&quot;\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\nDim strScanDir,strUninstallLog,strLogLine,strUninstallDate,strSplitLine,strDateOnly,strSplitDate\nstrScanDir = GetTaniumDir(&quot;Tools&quot;) &amp; &quot;Scans\\&quot;\nstrUninstallLog = strScanDir &amp; &quot;uninstalledresultsreadable.txt&quot;\nDim objReadLog : Set objReadLog = fso.OpenTextFile (strUninstallLog,1)\n\t\t\nDo While Not objReadLog.AtEndOfStream\n\tstrLogLine = objReadLog.ReadLine\n\tstrSplitLine = Split(strLogLine,strSep)\n\tstrUninstallDate = strSplitLine(2)\n\tstrSplitDate = Split(strUninstallDate,&quot; &quot;)\n\tstrDateOnly = strSplitDate(0)\n\tIf DateDiff(&quot;d&quot;,strUninstallDate,Now) &lt; 8 Then\n\t\tIf UBound(strSplitLine) &gt; 3 Then\n\t\t\tWScript.Echo strSplitLine(0) &amp; strSep &amp; strSplitLine(1) &amp; strSep &amp; strDateOnly &amp; strSep &amp; strSplitLine(3) &amp; strSep &amp; strSplitLine(4)\n\t\tElse\n\t\t\tWScript.Echo strSplitLine(0) &amp; strSep &amp; strSplitLine(1) &amp; strSep &amp; strDateOnly &amp; strSep &amp; strSplitLine(3)\n\t\tEnd If\n\tEnd If\nLoop\n\n\n&#039;_____________________________________\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n&#039;________________________________________________\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Unique ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Uninstall Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Status", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 213, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Hard drive location hosting system directory on Windows machines.\nExample: C:", 
      "exclude_from_parse_flag": 1, 
      "hash": 170942492, 
      "hidden_flag": 0, 
      "id": 423, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "System Drive", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select SystemDrive from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 214, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Indicates whether the machine is above an acceptable threshold for memory utilization.\nExample: Under threshold", 
      "exclude_from_parse_flag": 1, 
      "hash": 1718946935, 
      "hidden_flag": 0, 
      "id": 425, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "High Memory Consumption", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; High Memory Consumption\n&#039;========================================\n\nSet oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)  \nSet oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)  \nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)     \n&#039;Gets MEMORY Usage  \nSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;Select * FROM Win32_PerfFormattedData_PerfOS_Memory &quot;)  \nFor Each objItem In colItems     \nstrLinePercentCommittedBytesInUse = strLinePercentCommittedBytesInUse &amp; &quot; &quot; &amp; objItem.PercentCommittedBytesInUse  \nNext    \nIf strLinePercentCommittedBytesInUse &gt; 60 THEN  \nwscript.echo strLinePercentCommittedBytesInUse &amp; &quot; percent&quot;  \nElse   \nwscript.echo &quot;Under Threshold&quot;  \nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 215, 
      "category": "Security", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns the last time the password was set for each user account.\nExample:  taniumuser|2013-10-31", 
      "exclude_from_parse_flag": 1, 
      "hash": 1723627713, 
      "hidden_flag": 0, 
      "id": 427, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 60, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Local User Password Change Dates", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Set objNetwork = CreateObject(&quot;Wscript.Network&quot;)\nstrComputer = objNetwork.ComputerName\nSet colAccounts = GetObject(&quot;WinNT://&quot; &amp; strComputer &amp; &quot;&quot;)\ncolAccounts.Filter = Array(&quot;user&quot;)\nFor Each objUser In colAccounts\n  intPasswordAge = objUser.PasswordAge\n  intPasswordAge = intPasswordAge * -1 \n  dtmChangeDate = DateAdd(&quot;s&quot;, intPasswordAge, Now)\n  strChangeDate = Year(dtmChangeDate)\n  strChangeDate = strChangeDate &amp; &quot;-&quot; &amp; Right(&quot;0&quot; &amp; Month(dtmChangeDate), 2)\n  strChangeDate = strChangeDate &amp; &quot;-&quot; &amp; Right(&quot;0&quot; &amp; Day(dtmChangeDate), 2)\n  Wscript.Echo objUser.Name &amp; &quot;|&quot; &amp; strChangeDate\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\nfor TUSER in $( grep -v &quot;/bin/false&quot; /etc/passwd | awk -F &#039;:&#039; &#039;{ print $1 }&#039; ); do\n  TLAST=&quot;$( chage -l &quot;$TUSER&quot; | grep &quot;Last password change&quot; | awk -F &#039;: &#039; &#039;{ print $2 }&#039; )&quot;\n  TDATE=&quot;$( date -d &quot;$TLAST&quot; &quot;+%Y-%m-%d&quot; )&quot;\n  echo &quot;$TUSER|$TDATE&quot;\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nfor TUSER in $( dscl . list /Users | grep -v &quot;^_.*&quot; ); do\n  # exclude daemon, nobody, and root because everything segfaults on them\n  if [ &quot;$TUSER&quot; != &quot;daemon&quot; ] &amp;&amp; [ &quot;$TUSER&quot; != &quot;nobody&quot; ] &amp;&amp; [ &quot;$TUSER&quot; != &quot;root&quot; ]; then\n    dscl . read &quot;/Users/$TUSER&quot; PasswordPolicyOptions | grep -v &quot;PasswordPolicyOptions:&quot; &gt; temp.plist\n    TLAST=&quot;$( /usr/libexec/PlistBuddy -c &#039;print passwordLastSetTime&#039; temp.plist )&quot;\n    TDATE=&quot;$( date -j -f &quot;%a %b %d %T %Z %Y&quot; &quot;$TLAST&quot; &quot;+%Y-%m-%d&quot; )&quot;\n    echo &quot;$TUSER|$TDATE&quot;\n  fi\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "User", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Last Password Set Time", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 216, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the current output throughput, in KB/Sec, of the network interface used to connect to the tanium server.\nExample: 1024 KB/S", 
      "exclude_from_parse_flag": 1, 
      "hash": 1735107559, 
      "hidden_flag": 0, 
      "id": 429, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Network Throughput Outbound", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Network Throughput Outbound\n&#039;========================================\n\n&#039; This sensor will use windows performance counters\n&#039; and attempt to retrieve network traffic information\n&#039; only for the interface being used to connect to the tanium server\n&#039; results are in kilobytes per second\n\nOption Explicit\n\nDim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress\nDim strComputer: strComputer = &quot;.&quot;\n\n\nDim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString\nDim objWMIService, colItems, objItem\n\n&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address\n&#039; out of WMI.  Because Name is the closest thing to match the Description\n&#039; field in the performance counter, but it&#039;s not exact due to how some\n&#039; characters are displayed, we will remove troublesome characters\n&#039; and attempt to match on that\n\n&#039; Since the entire sensor&#039;s output depends on if the two strings match, we\n&#039; can set the one string to something it won&#039;t match on (because _) to be safe\nstrDescriptionToMatch = &quot;_ImpossibleToMatch&quot;\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)\nFor Each objItem In colItems\n\tFor Each strIPAddress In objItem.IPAddress\n\t\tIf strIPAddress = strTaniumIPAddress Then\n\t\t\t&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress\n\t\t\tstrDescriptionToMatch = CleanString(objItem.Description)\n\t\t\t&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch\n\t\tEnd If\n\tNext\nNext\n\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)\n\nFor Each objItem in colItems\n\tstrNameToMatch = CleanString(objItem.Name)\n\t&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch\n\tIf LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then\n\t\t&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch\n\t\t&#039; We can now report bandwidth\n\t\tstrFinalOutputString = FormatNumber(objItem.BytesSentPersec / 1024,0,-1) &amp; &quot; KB/S&quot;\n\tEnd If\nNext\n\nIf strFinalOutputString = &quot;&quot; Then\n\t&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client\n\tWScript.Echo &quot;Cannot determine which adapter to measure&quot;\nElse \n\tWScript.Echo strFinalOutputString\nEnd If\n\n\n&#039; Cleanup\nSet objWMIService = Nothing\nSet colItems = Nothing \nSet objItem = Nothing\n\n&#039;&#039; End Main Line\n\n&#039;&#039; Helper Functions\nFunction CleanString(strInput)\n&#039; This function will remove non-alphanumeric characters\n\tDim objRegEx\n\t\n\tSet objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)\n\t\n\tobjRegEx.Global = True   \n\tobjRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;\n\tCleanString = objRegEx.Replace(strInput, &quot;&quot;)\n\t\n\tSet objRegEx = Nothing\nEnd Function &#039;CleanString\n\nFunction GetTaniumIPAddress\n&#039; Modified from the ua-scan code to remove the subnet and last octet calculations\n&#039; which are irrelevant for these purposes.\n&#039; Returns the IP address that the client uses for Tanium activity\n&#039; (talking to server and other clients)\n\n\tDim strComputer, objReg, strCommand, objShell, objScriptExec\n\tDim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords\n\tDim strIPAddress, strTaniumPath, strClientAddress\n\tDim strServerName\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\tConst HKLM = &amp;h80000002\n\t\n\t\t\n\t&#039;&#039;###########Get Tanium Key on 64/32bit computers##########\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\t\n\t&#039; if we can pull this from the registry (newer client version), just use that\n\tobjReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\\Status&quot;, &quot;ClientAddress&quot;, strClientAddress\n\tIf strClientAddress &lt;&gt; &quot;&quot; Then\n\t\tstrClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)\n\t\tstrClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))\n\t\t&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;\n\t\tGetTaniumIPAddress = strClientAddress\n\t\t&#039;Cleanup\n\t\tSet objReg = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\t&#039;Otherwise use PathPing to determine client IP used by Tanium\n\n\t&#039;&#039;# Read the ServerName value\n\n\tobjReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName\n\n\tstrCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\tstrResults = objScriptExec.StdOut.ReadAll\n\t\n\tarrPathPingLines = Split(strResults, vbCrLf)\n\tFor Each strPathPingLine In arrPathPingLines\n\t\tarrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)\n\t\tIf UBound(arrPathPingWords) &gt; 0 Then\n\t\t\tIf arrPathPingWords(0) = &quot;0&quot; Then\n\t\t\t\tstrIPAddress = arrPathPingWords(1)\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tEnd If\t\n\tNext\n\t\n\tSet objShell = Nothing\n\tSet objScriptExec = Nothing\n\tSet objReg = Nothing\n\n\tIf Not IsNull(strIPAddress) Then\n\t\tGetTaniumIPAddress = strIPAddress\n\tElse\n\t\tGetTaniumIPAddress = False\n\tEnd If\nEnd Function &#039;GetTaniumIPAddress\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction CleanWhitespace(strStarter)\n\tDim intStarter, i, strChars\n\tintStarter = Len(strStarter)\n\tFor i = intStarter to 2 Step -1\n\t\tstrChars = Space(i)\n\t\tstrStarter = Replace(strStarter, strChars, &quot; &quot;)\n\tNext\n\tCleanWhitespace = strStarter\nEnd Function &#039;CleanWhiteSpace", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 217, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the number of empty, unused RAM slots.\nExample:2", 
      "exclude_from_parse_flag": 1, 
      "hash": 1785623864, 
      "hidden_flag": 0, 
      "id": 431, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Ram Slots Unused", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; RAM Slots Unused\n&#039;========================================\n\n&#039; This sensor will return the number of free RAM slots\n\nOption Explicit\n\nFreeRAMSlots\n\nFunction FreeRAMSlots\n&#039; This function returns the number of free RAM slots\n\tDim strComputer\n\tDim objWMIService, colPMAs, objPMA\n\tDim colPMs, objPM\n\t\n\t&#039; How many slots exist\n\tDim intSlots: intSlots = 0\n\t&#039; How many MemoryDevices are present\n\tDim intMemorySticks: intMemorySticks = 0\n\t\t\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\t&#039;Use = 3 is system RAM\n\t&#039; This is the number of slots in the system.\n\tSet colPMAs = objWMIService.ExecQuery(&quot;Select MemoryDevices from Win32_PhysicalMemoryArray where use=&#039;3&#039;&quot;,,48)\n\t\n\tFor Each objPMA In colPMAs\n\t\t&#039; There should be only one\n\t\t&#039; but just in case\n\t\tintSlots = intSlots + objPMA.MemoryDevices\n\t\t&#039; WScript.Echo &quot;objPMA.MemoryDevices is total slots: &quot; &amp; objPMA.MemoryDevices\n\tNext\n\t\n\t&#039; Cleanup\n\tSet colPMAs = Nothing\n\t\n\t&#039; A new query - asking for DeviceLocator where memory type does not \n\t&#039; equal 11 (Flash RAM)\n\t&#039; DeviceLocator is the label of the socket that holds the memory\n\t&#039; So this is the number of sockets in the system\n\tSet colPMs = objWMIService.ExecQuery(&quot;Select DeviceLocator from Win32_PhysicalMemory where MemoryType!=&#039;11&#039;&quot;)\n\t\n\tFor Each objPM In colPMs\n\t\t&#039;Each loop through indicates another slot\n\t\tintMemorySticks = intMemorySticks + 1\n\tNext\n\t\n\t&#039; output is total slots minus memory sticks in use\n\tWScript.Echo intSlots - intMemorySticks\n\t\n\t&#039;Cleanup\n\tSet colPMs = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;FreeRAMSlots", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 218, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns printers which are connected via Network\nExample: HP LaserJet 4400c", 
      "exclude_from_parse_flag": 1, 
      "hash": 1806420230, 
      "hidden_flag": 0, 
      "id": 433, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Network Printers", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select DriverName from Win32_Printer where Network = True", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 219, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Parameterized Sensor that shows which addresses the process is connecting to and over what local port.\nExample: 0.0.0.0:17500", 
      "exclude_from_parse_flag": 1, 
      "hash": 1810333216, 
      "hidden_flag": 0, 
      "id": 435, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Established Ports by Application", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{2}\",\"helpString\":\"Value must be at least 2 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the process name to query\",\"value\":\"\",\"promptText\":\"e.g. svchost.exe\",\"defaultValue\":\"\",\"label\":\"Process Name to examine\",\"maxChars\":0,\"key\":\"app\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Established Ports by Application\n&#039;========================================\n\nDim strcommand,bHasOutput\n\ncheck = Trim(Unescape(&quot;||app||&quot;))\n\nstrComputer = &quot;.&quot;    \nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nquery = &quot;select name, processId from win32_process where name = &#039;&quot; &amp; check &amp; &quot;&#039;&quot;\nSet colResults = objWMIService.ExecQuery(query)\n\nSet processes = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nFor Each result In colResults \n   processId = CStr(result.ProcessId)\n   processes.Add processId, result.Name\nNext\n\nstrcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34)\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrPingResults = LCase(objScriptExec.StdOut.ReadAll)\n\nresults = Split(strPingResults, vbCrLf)\nbHasOutput = False\nfor Each line in results\n   line = cleanWhitespace(Trim(line))\n   lineResults = Split(line)\n   i = 0\n   Dim strPort, strPid, strConnectionType\n   For Each word In lineResults\n      If i = 1 Then\n         strPort = word\n      ElseIf i = 3 Then\n         strConnectionType = word\n      ElseIf i = 4 Then\n         strPid = word\n      End If\n      \n      i = i + 1\n   Next\n   If processes.Exists(strPid) And (strConnectionType = &quot;listening&quot; Or strConnectionType = &quot;established&quot;) Then\n\t\tWScript.echo strPort &amp; &quot; &quot; &amp; processes.Item(strPid)\n\t\tbHasOutput = True\n   End If   \nNext\n\nIf Not bHasOutput Then\n\tIf GetLocale() &lt;&gt; 1033 Then\n\t\tWScript.Echo &quot;English Language OS Required&quot;\n\tEnd If\nEnd If\n\n\nFunction cleanWhitespace(strStarter)\n   intStarter = Len(strStarter)\n   For i = intStarter to 2 Step -1\n      strChars = Space(i)\n      strStarter = Replace(strStarter, strChars, &quot; &quot;)\n   Next\n   cleanWhitespace = strStarter\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\ntmpfile=/tmp/tanium.$$\n\nurldecode() {\n        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\\+/ /g&#039; -e &#039;s/%/\\\\x/g&#039;)\n        printf &#039;%b&#039; &quot;$data&quot;\n}\n\nlsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n &gt; $tmpfile \napplication=$(urldecode &quot;||app||&quot;)\ncat $tmpfile | awk -v app=$application &#039;tolower($1)==tolower(app) {print substr($0,index($0,$9),index($0,&quot;&gt;&quot;)-index($0,$9)-1)}&#039;\nrm -f $tmpfile\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\ntmpfile=/tmp/tanium.$$\n\nurldecode() {\n        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\\+/ /g&#039; -e &#039;s/%/\\\\x/g&#039;)\n        printf &#039;%b&#039; &quot;$data&quot;\n}\n\nlsof -p ^$PPID -iTCP -sTCP:ESTABLISHED -P +c 15 -n &gt; $tmpfile \napplication=$(urldecode &quot;||app||&quot;)\ncat $tmpfile | awk -v app=$application &#039;tolower($1)==tolower(app) {print substr($0,index($0,$9),index($0,&quot;&gt;&quot;)-index($0,$9)-1)}&#039;\nrm -f $tmpfile\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 220, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the McAfee Agent Version\nExample: 4.6.0.2292", 
      "exclude_from_parse_flag": 0, 
      "hash": 1815624605, 
      "hidden_flag": 0, 
      "id": 437, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "McAfee Agent Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039; sensor - McAfee Agent Version\n\nOption Explicit\n\nDim strMcAfeeFrameworkServiceState\n&#039; First get the state of the service\nstrMcAfeeFrameworkServiceState = ServiceState(&quot;McAfeeFramework&quot;)\nIf strMcAfeeFrameworkServiceState = &quot;Not Installed&quot; Then\n\t&#039;No further tests are necessary\n\tWScript.Echo &quot;McAfee Agent Not Installed&quot;\n\tWScript.Quit\nEnd If\n\n\nConst HKLM = &amp;h80000002\nDim objReg\t\nSet objReg = Getx64RegistryProvider()\t\n\nWScript.Echo GetMcAfeeAgentVersion\n\nFunction GetMcAfeeAgentVersion\n\n\tDim intIPSState,intMajorVersion\n\tDim strRegPath,strVersion\n\n\tstrRegPath = GetMcAfeeProductRegRootKey(&quot;NAITVD&quot;)\t\n\tIf Not (IsNull(strRegPath) Or strRegPath = &quot;&quot; ) Then\n\t\tobjReg.GetStringValue HKLM,strRegPath&amp;&quot;\\Shared Components\\Framework&quot;,&quot;Version&quot;,strVersion\n\t\tIf Not (IsNull(strVersion) Or strVersion = &quot;&quot; ) Then\n\t\t\tGetMcAfeeAgentVersion = strVersion\n\t\tElse &#039; no version\n\t\t\tWScript.Echo &quot;Error: Cannot determine McAfee Agent version&quot;\n\t\tEnd If\n\tElse &#039; no way to get to root registry key\n\t\tWScript.Echo &quot;Error: Cannot determine McAfee Agent version&quot;\n\tEnd If\n\nEnd Function &#039;GetMcAfeeAgentVersion\n\n\n\nFunction GetMcAfeeProductRegRootKey(strProductString)\n&#039; Retrieves McAfee key for a product\n&#039; products are passed in and defined in the function\n\n\tDim strRootSoftwareKeyNative,strRootSoftwareKeyWow64,strProductSubKey\n\tDim strProductKeyPath\n\n\t&#039; select on input\n\tstrProductString = UCase(strProductString)\n\tSelect Case strProductString\n\t\tCase &quot;AGENT&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\Agent&quot;\t\n\t\tCase &quot;AVENGINE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\AVEngine&quot;\n\t\tCase &quot;DESKTOPPROTECTION&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\DesktopProtection&quot;\n\t\tCase &quot;EPO&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\ePolicy Orchestrator&quot;\n\t\tCase &quot;HIPS&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIP&quot;\n\t\tCase &quot;HIPSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\HIPSCore&quot;\n\t\tCase &quot;MCTRAY&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\McTray&quot;\t\t\t\t\t\n\t\tCase &quot;SITEADVISOR&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SiteAdvisor Enterprise Plus&quot;\n\t\tCase &quot;SYSTEMCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\SystemCore&quot;\n\t\tCase &quot;VSCORE&quot;\n\t\t\tstrProductSubKey = &quot;McAfee\\VSCore&quot;\n\t\tCase &quot;NAIEPO&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\ePolicy Orchestrator&quot;\n\t\tCase &quot;NAITVD&quot;\n\t\t\tstrProductSubKey = &quot;Network Associates\\TVD&quot;\n\t\tCase Else\n\t\t\tstrProductSubKey = False\n\tEnd Select\n\t\t\t\n\tConst HKLM = &amp;h80000002\n\t\n    \n\tstrRootSoftwareKeyNative = &quot;Software&quot;\n\tstrRootSoftwareKeyWow64 = &quot;Software\\Wow6432Node&quot;\n    If Not strProductSubKey = False Then\n\t    &#039; Assume not in both places on a 64-bit machine\n\t\tIf RegKeyExists(HKLM, strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyWow64&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tElseIf RegKeyExists(HKLM, strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey) Then\n\t\t\tstrProductKeyPath = strRootSoftwareKeyNative&amp;&quot;\\&quot;&amp;strProductSubKey\n\t\tEnd If\n\tElse\n\t\tstrProductKeyPath = False\t\t\n\tEnd If\n\t\n\tGetMcAfeeProductRegRootKey = strProductKeyPath\n\nEnd Function &#039;GetMcAfeeProductRegRootKey\n\nFunction RegKeyExists(sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function &#039;RegKeyExists\n\nFunction ServiceState(strServiceName)\n&#039; This function determines if a service is in a bad state and returns\n&#039; values indicating the state.  Examples: \n&#039; &quot;Stopped&quot;\n&#039; &quot;Stopped Manual&quot;\n&#039; &quot;Running Disabled&quot;\n&#039; &quot;Not Installed&quot;\n\n\tDim objWMIService,strWMIQuery,colItems,objItem,strStartMode,strState\n\n\tstrWMIQuery = &quot;Select * from Win32_Service Where Name = &#039;&quot; &amp; strServiceName &amp; &quot;&#039;&quot;\n\n\tstrState = &quot;&quot;\n\tstrStartMode = &quot;&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(strWMIQuery)\n\t\n\tIf colItems.Count = 0 Then\n\t\tServiceState = &quot;Not Installed&quot;\n\tElse\n\t\tFor Each objItem In colItems\n\t\t\tIf objItem.State = &quot;Stopped&quot; Or objItem.State = &quot;Paused&quot; Then\n\t\t\t\tstrState = objItem.State\n\t\t\tEnd If\n\t\t\tIf objItem.StartMode = &quot;Manual&quot; Or objItem.StartMode = &quot;Disabled&quot; Then\n\t\t\t\tstrStartMode = objItem.StartMode\n\t\t\tEnd If\n\t\t\tServiceState = Trim(strState&amp;&quot; &quot;&amp;strStartMode)\n\t\tNext\n\tEnd If\n\nEnd Function &#039;ServiceState\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 221, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the current throughput, as a percentage of total possible, of the network interface used to connect to the tanium server.\nExample: 50%", 
      "exclude_from_parse_flag": 1, 
      "hash": 1819649983, 
      "hidden_flag": 0, 
      "id": 439, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Network Throughput Percentage", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Network Throughput Percentage\n&#039;========================================\n\n&#039; This sensor will use windows performance counters\n&#039; and attempt to retrieve network traffic information\n&#039; only for the interface being used to connect to the tanium server\n&#039; to show the total througput (in and out) as a percentage of capability\n\nOption Explicit\n\nDim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress\nDim strComputer: strComputer = &quot;.&quot;\n\nDim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString\nDim objWMIService, colItems, objItem, colNAItems, objNAItem, strMaxSpeed\nDim strRawDescription\n\n&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address\n&#039; out of WMI.  Because Name is the closest thing to match the Description\n&#039; field in the performance counter, but it&#039;s not exact due to how some\n&#039; characters are displayed, we will remove troublesome characters\n&#039; and attempt to match on that\n\n&#039; Since the entire sensor&#039;s output depends on if the two strings match, we\n&#039; can set the one string to something it won&#039;t match on (because _) to be safe\nstrDescriptionToMatch = &quot;_ImpossibleToMatch&quot;\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)\nFor Each objItem In colItems\n\tFor Each strIPAddress In objItem.IPAddress\n\t\tIf strIPAddress = strTaniumIPAddress Then\n\t\t\t&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress\n\t\t\tstrDescriptionToMatch = CleanString(objItem.Description)\n\t\t\tstrRawDescription = objItem.Description\n\t\t\t&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch\n\t\tEnd If\n\tNext\nNext\n\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)\n\nFor Each objItem in colItems\n\tstrNameToMatch = CleanString(objItem.Name)\n\t&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch\n\tIf LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then\n\t\t&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch\n\n\t\tIf Not IsNull(strMaxSpeed) Then &#039; must have this value\n\t\t\tstrFinalOutputString = FormatNumber(objItem.BytesTotalPersec / objItem.CurrentBandwidth * 100,0,-1) &amp; &quot;%&quot;\n\t\tEnd If\n\tEnd If\nNext\n\nIf strFinalOutputString = &quot;&quot; Then\n\t&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client\n\tWScript.Echo &quot;Cannot determine which adapter to measure&quot;\nElse \n\tWScript.Echo strFinalOutputString\nEnd If\n\n\n&#039; Cleanup\nSet objWMIService = Nothing\nSet colItems = Nothing \nSet objItem = Nothing\n\n&#039;&#039; End Main Line\n\n&#039;&#039; Helper Functions\nFunction CleanString(strInput)\n&#039; This function will remove non-alphanumeric characters\n\tDim objRegEx\n\t\n\tSet objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)\n\t\n\tobjRegEx.Global = True   \n\tobjRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;\n\tCleanString = objRegEx.Replace(strInput, &quot;&quot;)\n\t\n\tSet objRegEx = Nothing\nEnd Function &#039;CleanString\n\nFunction GetTaniumIPAddress\n&#039; Modified from the ua-scan code to remove the subnet and last octet calculations\n&#039; which are irrelevant for these purposes.\n&#039; Returns the IP address that the client uses for Tanium activity\n&#039; (talking to server and other clients)\n\n\tDim strComputer, objReg, strCommand, objShell, objScriptExec\n\tDim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords\n\tDim strIPAddress, strTaniumPath, strClientAddress\n\tDim strServerName\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\tConst HKLM = &amp;h80000002\n\t\n\t\t\n\t&#039;&#039;###########Get Tanium Key on 64/32bit computers##########\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\t\n\t&#039; if we can pull this from the registry (newer client version), just use that\n\tobjReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\\Status&quot;, &quot;ClientAddress&quot;, strClientAddress\n\tIf strClientAddress &lt;&gt; &quot;&quot; Then\n\t\tstrClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)\n\t\tstrClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))\n\t\t&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;\n\t\tGetTaniumIPAddress = strClientAddress\n\t\t&#039;Cleanup\n\t\tSet objReg = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\t&#039;Otherwise use PathPing to determine client IP used by Tanium\n\n\t&#039;&#039;# Read the ServerName value\n\n\tobjReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName\n\n\tstrCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\tstrResults = objScriptExec.StdOut.ReadAll\n\t\n\tarrPathPingLines = Split(strResults, vbCrLf)\n\tFor Each strPathPingLine In arrPathPingLines\n\t\tarrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)\n\t\tIf UBound(arrPathPingWords) &gt; 0 Then\n\t\t\tIf arrPathPingWords(0) = &quot;0&quot; Then\n\t\t\t\tstrIPAddress = arrPathPingWords(1)\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tEnd If\t\n\tNext\n\t\n\tSet objShell = Nothing\n\tSet objScriptExec = Nothing\n\tSet objReg = Nothing\n\n\tIf Not IsNull(strIPAddress) Then\n\t\tGetTaniumIPAddress = strIPAddress\n\tElse\n\t\tGetTaniumIPAddress = False\n\tEnd If\nEnd Function &#039;GetTaniumIPAddress\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction CleanWhitespace(strStarter)\n\tDim intStarter, i, strChars\n\tintStarter = Len(strStarter)\n\tFor i = intStarter to 2 Step -1\n\t\tstrChars = Space(i)\n\t\tstrStarter = Replace(strStarter, strChars, &quot; &quot;)\n\tNext\n\tCleanWhitespace = strStarter\nEnd Function &#039;CleanWhiteSpace", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 222, 
      "category": "Software", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns the names and dates of the last users to log in.\nExample: John.Doe 7/25/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 182214159, 
      "hidden_flag": 0, 
      "id": 441, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Local User Login Dates", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Local User Login Dates\n&#039;========================================\n\nOption Explicit  \n\n&#039;Uses date math - set locale\n\nSetLocale(GetTaniumLocale)\nDim strSep: strSep = &quot;|&quot;\nDim objNetwork : Set objNetwork = CreateObject(&quot;WScript.Network&quot;) \nDim objGroup : Set objGroup = GetObject(&quot;WinNT://.&quot;) \nobjGroup.Filter = Array(&quot;user&quot;) \nDim objUser \nFor Each objUser In objGroup     \nOn Error Resume Next         \nWScript.Echo objUser.name &amp; strSep &amp; left(GetObject(objUser.adsPath).LastLogin,Instr(GetObject(objUser.adsPath).LastLogin,&quot; &quot;))     \nOn Error GoTo 0 \nNext\n\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Date", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 223, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns the run once keys that define which programs will be started when a user logs in.\nExample:  System|GlobalProtect|\"C:\\Program Files\\Palo Alto Networks\\GlobalProtect\\PanGPA.exe\"", 
      "exclude_from_parse_flag": 1, 
      "hash": 1832324705, 
      "hidden_flag": 0, 
      "id": 443, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Run Once Keys", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Run Once Keys\n&#039;========================================\n\n&#039; returns the system and user keys for a given key\n\nOption Explicit\n\nConst strSep = &quot;|&quot;\n\nDim strKeyPath, strKeyPath32, dictResults, strValue\n\nstrKeyPath = &quot;Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce&quot;\nstrKeyPath32 = &quot;Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce&quot;\n    \nSet dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nAddValuesForKey dictResults, strKeyPath\nAddValuesForKey dictResults, strKeyPath32\n\nFor Each strValue In dictResults.Keys\n    WScript.Echo strValue\nNext\n\nSub AddValuesForKey(dictResults, strKey)\n&#039; This function will output the two values\n\n    Const HKLM = &amp;h80000002\n    Const HKEY_USERS = &amp;H80000003\n    \n    Dim objRegistry\n    Dim arrUserKeys,strUserKey, strUserKeyPath\n    \n    &#039; get System Keys\n    Set objRegistry = Getx64RegistryProvider()\n    If RegKeyExists(HKLM, strKey, objRegistry) Then  \n        GetValues objRegistry, HKLM, strKey, dictResults, &quot;System&quot;\n    End If\n    \n    &#039; get User Keys\n    objRegistry.EnumKey HKEY_USERS, &quot;&quot;,arrUserKeys\n    For Each strUserKey In arrUserKeys\n        If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n            strUserKeyPath = strUserKey &amp; &quot;\\&quot; &amp; strKey\n            If RegKeyExists(HKEY_USERS,strUserKeyPath, objRegistry) Then\n                GetValues objRegistry, HKEY_USERS, strUserKeyPath, dictResults, &quot;User&quot;\n            End If\n         End If \n    Next \nEnd Sub &#039;AddValuesForKey\n\nSub GetValues(objRegistry, hiveConst, keyPath, dictValues, strPrefix)\n    Dim arrKeyNames, arrTypes, arrValueNames, strValueName\n    Dim strValueData, i, strEntry\n        \n    objRegistry.EnumValues hiveConst, keyPath, arrValueNames, arrTypes\n    \n    If Not IsArray(arrValueNames) Then\n        arrValueNames = Array(&quot;&quot;)\n        arrTypes = Array(1)\n    End If\n    \n    For i = LBound(arrValueNames) To UBound(arrValueNames)\n        strValueName = arrValueNames(i)\n        strValueData = GetRegValue(objRegistry, hiveConst, keyPath, strValueName, arrTypes(i))\n        If Not ( IsNull(strValueName) Or IsNull(strValueData) ) Then\n            strEntry = strPrefix &amp; strSep &amp; strValueName &amp; strSep &amp; strValueData\n            If Not dictValues.Exists(strEntry) Then \n                dictValues.Add strEntry, True\n            End If \n        End If\n    Next    \nEnd Sub &#039;GetValues\n\nFunction GetRegValue(objRegistry, hiveConst, keyPath, strValueName, constType)\n\n    Const REG_SZ        = 1\n    Const REG_EXPAND_SZ = 2\n    Const REG_BINARY    = 3\n    Const REG_DWORD     = 4\n    Const REG_MULTI_SZ  = 7\n    Const REG_QWORD     = 11\n\n    Dim strValue, arrBytes, uValue, arrValues\n\n    Select Case constType\n        Case REG_SZ  \n            objRegistry.GetStringValue hiveConst, keyPath, strValueName, strValue\n            GetRegValue =  strValue\n            Exit Function\n        Case REG_EXPAND_SZ\n            objRegistry.GetExpandedStringValue hiveConst, keyPath, strValueName, strValue\n            GetRegValue =  strValue\n            Exit Function\n        Case REG_BINARY\n            objRegistry.GetBinaryValue hiveConst, keyPath, strValueName, arrBytes\n            strBytes = &quot;&quot;\n            For Each uByte in arrBytes\n                strBytes = strBytes &amp; Hex(uByte) &amp; &quot; &quot;\n            Next\n            GetRegValue =  strBytes\n            Exit Function\n        Case REG_DWORD\n            objRegistry.GetDWORDValue hiveConst, keyPath, strValueName, uValue\n            GetRegValue =  CStr(uValue)               \n            Exit Function\n        Case REG_QWORD\n            objRegistry.GetQWORDValue hiveConst, keyPath, strValueName, uValue\n            GetRegValue =  CStr(uValue)               \n            Exit Function\n        Case REG_MULTI_SZ\n            objRegistry.GetMultiStringValue hiveConst, keyPath, strValueName, arrValues                             \n            For Each strValue in arrValues\n                GetRegValue =  strValue \n            Next\n            Exit Function\n    End Select\nEnd Function &#039;GetRegValue\n\nFunction RegKeyExists(sHive, sRegKey, objReg)\n    Dim aValueNames, aValueTypes\n    If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n        RegKeyExists = True\n    Else\n        RegKeyExists = False\n    End If\nEnd Function &#039; RegKeyExists\n\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Command Line", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 224, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Current CPU utilization percentage by SQL Server process on client machine.\nExample: 8%", 
      "exclude_from_parse_flag": 1, 
      "hash": 1845399463, 
      "hidden_flag": 0, 
      "id": 445, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "SQL Server CPU Consumption", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Server CPU Consumption\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\n\nDim dictInstances, strInstance, Process\n\nSet dictInstances = GetMSSQLInstances()\n\nIf dictInstances.Count &gt; 0 Then \n\tFor Each Process In GetObject(&quot;winmgmts:&quot;).ExecQuery(&quot;Select * from Win32_Process where Name = &#039;sqlservr.exe&#039;&quot;)   \n\t\tWScript.echo CPUUSage(Process.Handle) &amp; &quot;%&quot;  \n\tNext  \nEnd If\n\nFunction CPUUSage( ProcID ) \n\tDim objService, objInstance1, objInstance2, N1, N2, D1, D2, Nd, Dd, PercentProcessorTime  \n\tOn Error Resume Next   \n\tSet objService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)     \n\tFor Each objInstance1 In objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;sqlservr&#039;&quot;)        \n\t\tN1 = objInstance1.PercentProcessorTime        \n\t\tD1 = objInstance1.TimeStamp_Sys100NS      \n\t\tExit For    \n\tNext  \n\tWScript.Sleep(2000)     \n\tFor Each objInstance2 In objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;sqlservr&#039;&quot;)        \n\t\tN2 = objInstance2.PercentProcessorTime        \n\t\tD2 = objInstance2.TimeStamp_Sys100NS      \n\t\tExit For    \n\tNext    \n\tOn Error Goto 0\n\t\n\t&#039; CounterType - PERF_100NSEC_TIMER_INV   \n\t&#039; Formula - (1- ((N2 - N1) / (D2 - D1))) x 100     \n\tNd = (N2 - N1)     \n\tDd = (D2 - D1)     \n\tPercentProcessorTime = ( (Nd/Dd))  * 100    \n\tCPUUSage = Round(PercentProcessorTime, 0) \nEnd Function \n\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 225, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "This sensor will return the encryption status of volumes encrypted with McAfee Endpoint Encryption\nExample: C:|Encrypted", 
      "exclude_from_parse_flag": 1, 
      "hash": 1849288420, 
      "hidden_flag": 0, 
      "id": 447, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "McAfee Endpoint Encryption Status", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; McAfee Endpoint Encryption Status\n&#039;========================================\n\n&#039; This sensor will return the encryption status\n&#039; of volumes encrypted with McAfee Endpoint Encryption\n\nOption Explicit\n\nDim objRegistry,keyPath,key64Path,strSep\nstrSep = &quot;|&quot; &#039; column delimiter\n\nSet objRegistry = Getx64RegistryProvider()\n\nConst HKLM = &amp;H80000002 \n\nkeyPath = &quot;SOFTWARE\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\nkey64Path = &quot;SOFTWARE\\Wow6432Node\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If \n\nIf RegKeyExists(HKLM, keyPath) Then\n\tDim strReturn\n\tstrReturn = ReturnStringValueOrEchoError _\n\t\t(objRegistry,HKLM,keyPath,&quot;CryptState&quot;,&quot;McAfee Endpoint Encryption State Not Found&quot;)\n\tIf VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error\n\t\tReturnEEPCEncryptionStatus strReturn\n\tElse\n\t\tWScript.Quit\n\tEnd If\nElse\n\tWScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;\n\tWScript.Quit\nEnd If\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction ReturnEEPCEncryptionStatus(strStatus)\n&#039; output looks like Volume=C:,State=Encrypted;Volume=D:,State=Encrypted;\n\tDim arrInput,strVolumes,strWord,strVolume,strVolumeName,strVolumeState\n\tDim bBadVolume\n\t\n\tarrInput = Split(strStatus,&quot;;&quot;)\n\t\n\tFor Each strVolume In arrInput\n\t\tbBadVolume = False\n\t\tIf InStr(1,strVolume,&quot;volume=&quot;,1) &gt; 0 And InStr(1,strVolume,&quot;state=&quot;,1) &gt; 0 Then\t\n\t\t\tOn Error Resume Next\n\t\t\tstrVolumeName = Split(Split(strVolume,&quot;volume=&quot;,-1,1)(1),&quot;,&quot;)(0)\n\t\t\tstrVolumeState = Split(Split(strVolume,&quot;state=&quot;,-1,1)(1),&quot;,&quot;)(0)\n\t\t\tOn Error Goto 0\n\t\t\tIf strVolumeName = &quot;&quot; Or strVolumeState = &quot;&quot; Then\n\t\t\t\tbBadVolume = True\n\t\t\tElse\n\t\t\t\tWScript.Echo strVolumeName&amp;strSep&amp;strVolumeState\n\t\t\tEnd If\n\t\tEnd If\n\t\tIf bBadVolume Then WScript.Echo &quot;Invalid Volume Information: &quot; &amp; strVolume\n\tNext\nEnd Function &#039;ReturnEEPCEncryptionStatus\n\nFunction ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)\n&#039; Return a value or fatal error message and error result\n\tDim intReturn,strValueData\n\tintReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)\n\tIf intReturn = 0 Then\n\t\tReturnStringValueOrEchoError = strValueData\n\tElse\n\t\tReturnStringValueOrEchoError = -1\n\t\tWScript.Echo strErrorMessage\n\tEnd If\nEnd Function \n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Volume Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Encryption Status", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 226, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Retrieves the Tanium Server Name List from the Client's Registry\nExample: server.domain.com,server1.domain.com", 
      "exclude_from_parse_flag": 1, 
      "hash": 1865193433, 
      "hidden_flag": 0, 
      "id": 449, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Tanium Server Name List", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Server Name List\n&#039;========================================\n\n\nOption Explicit\n\nConst HKLM = &amp;h80000002\n\nDim objReg\nDim strTaniumRegPath, strCurrentTaniumServerNameListValue\nDim strComputer\n\nstrComputer = &quot;.&quot;\n\nSet objReg = _ \n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nstrTaniumRegPath = GetTaniumRegistryPath()\n&#039;retrieve current server name value\nobjReg.GetStringValue HKLM, strTaniumRegPath, &quot;ServerNameList&quot;, strCurrentTaniumServerNameListValue\n\nIf Not IsNull(strCurrentTaniumServerNameListValue) Then \n\tWScript.Echo strCurrentTaniumServerNameListValue\nElse \n\tWScript.Echo &quot;Not Set&quot;\nEnd If \n\n&#039;Cleanup\nSet objReg = Nothing\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 227, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Description of the onboard audio controller for the computer.\nExample: Intel(R) High Definition Audio Controller", 
      "exclude_from_parse_flag": 1, 
      "hash": 189860887, 
      "hidden_flag": 0, 
      "id": 451, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Audio Controller", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Description from win32_onboarddevice where DeviceType=7", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\nlspci | grep &#039;audio controller&#039; | awk -F&#039;audio controller: &#039; &#039;{print $2}&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsystem_profiler SPAudioDataType | grep -w -A2 &quot;^Audio:&quot; | tail -1 | sed -e &#039;s/^ *//&#039; -e &#039;s/:$//&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 228, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The number of buffered messages currently queued to be processed by the Tanium client on each client machine.\nExample: 2", 
      "exclude_from_parse_flag": 1, 
      "hash": 191451006, 
      "hidden_flag": 0, 
      "id": 453, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Tanium Buffer Count", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Buffer Count \n&#039;========================================\n\nstrKeyPath = &quot;SOFTWARE\\Tanium\\Tanium Client\\Status&quot;\nstrValueName = &quot;BufferCount&quot; \n\nconst HKEY_CURRENT_USER = &amp;H80000001\nconst HKEY_LOCAL_MACHINE = &amp;H80000002\nstrComputer = &quot;.&quot;\n\nSet oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp;_\n strComputer &amp; &quot;\\root\\default:StdRegProv&quot;) \n\nOn Error Resume Next\n\n  oReg.GetDWORDValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue\n\n  Wscript.Echo strValue\n\nOn Error Goto 0", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 229, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "All hardware devices currently in use by a computer.\nExample: Microsoft PS/2 Mouse", 
      "exclude_from_parse_flag": 1, 
      "hash": 1927765752, 
      "hidden_flag": 0, 
      "id": 455, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Active Devices", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Active Devices\n&#039;========================================\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PnPEntity where status = &#039;OK&#039; and service is not null and service &lt;&gt; &#039;pci&#039;&quot;,,48)\nFor Each objItem in colItems\n\tIf Not Left(objItem.PNPDeviceId, Len(&quot;ROOT&quot;)) = &quot;ROOT&quot; Then\n\t    Wscript.Echo objItem.Caption\n\tEnd If \nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 230, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns the date that each application was last launched on.\nExample: Notepad | 9/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 1927941770, 
      "hidden_flag": 0, 
      "id": 457, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Last Application Launch Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last Application Launch Date\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nConst HKLM = &amp;h80000002\nSet reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nstrKeyPath = GetTaniumRegistryPath() &amp; &quot;\\Sensor Data\\Applications&quot;\n\nIf RegKeyExists(reg, HKLM, strKeyPath) Then\n\treg.EnumKey HKLM, strKeyPath, arrSubKeys\n\tIf IsArray(arrSubKeys) Then\n\t\tFor Each Subkey In arrSubKeys\n\t\t\t&#039;Wscript.Echo Subkey\n\t\t\tnewKeyPath = strKeyPath &amp; &quot;\\&quot; &amp; Subkey\n\t\t\t\n\t\t\treg.GetStringValue HKLM, newKeyPath, &quot;Last Start&quot;, strLastStart\n\t\t\treg.GetStringValue HKLM, newKeyPath, &quot;Description&quot;, strDescription\n\t\t\tWScript.Echo strDescription &amp; &quot;|&quot; &amp; strLastStart\n\t\tNext\n\tElse\t\n\t\tWScript.Echo &quot;Application data not initialized&quot;\n\tEnd If\nElse\t\n\tWScript.Echo &quot;Application data not initialized&quot;\nEnd If\n\nFunction GetTaniumRegistryPath\n\t&#039;GetTaniumRegistryPath works in x64 or x32\n\t&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n\t\n\t&#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n\tOn Error Resume Next\n\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n\tOn Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n\t\n\tIf strPath = &quot;&quot; Then\n\t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n\t\tOn Error Resume Next\n\t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n\t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n\tEnd If\n\t\n\tIf Not strPath = &quot;&quot; Then\n\t\tGetTaniumRegistryPath = strFoundTaniumRegistryPath\n\tElse\n\t\tGetTaniumRegistryPath = False\n\t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n\tEnd If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Application Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Date", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 231, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the currently defined system variables\nExample:  windir=c:\\Windows", 
      "exclude_from_parse_flag": 1, 
      "hash": 1978207968, 
      "hidden_flag": 0, 
      "id": 459, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "System Environment Variables", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; System Environment Variables\n&#039;========================================\n\nOption Explicit\n\nConst EXPAND_VARS = False\n\nDim wshShell, wshSysEnv, strItem\n\nSet wshShell = CreateObject( &quot;WScript.Shell&quot; )\nSet wshSysEnv = wshShell.Environment( &quot;SYSTEM&quot; )\nFor Each strItem In wshSysEnv\n\tIf EXPAND_VARS Then \n\t\tWScript.Echo wshShell.ExpandEnvironmentStrings( strItem )\n\tElse \n\t\tWScript.Echo strItem\n\tEnd If\nNext\nSet wshSysEnv = Nothing\nSet wshShell = Nothing", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 232, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "List of user accounts on a linux client machine.\nExample: webadmin", 
      "exclude_from_parse_flag": 1, 
      "hash": 1988427982, 
      "hidden_flag": 0, 
      "id": 461, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "User Accounts", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ncat /etc/passwd | grep -v &quot;sbin/nologin&quot; | cut -d: -f1\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 233, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The currently specified time zone for the client machine.\nExample: (UTC-08:00) Pacific Time (US & Canada)", 
      "exclude_from_parse_flag": 1, 
      "hash": 2006202074, 
      "hidden_flag": 0, 
      "id": 463, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Time Zone", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select Description from Win32_TimeZone", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 234, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Finds the specified file and provides the full path if the file exists on the client machine.\nExample: C:\\WINDOWS\\System32\\Notepad.exe", 
      "exclude_from_parse_flag": 1, 
      "hash": 2054092310, 
      "hidden_flag": 0, 
      "id": 465, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "File Name Search", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the file name only to search for.\",\"value\":\"\",\"promptText\":\"e.g. test.txt\",\"defaultValue\":\"\",\"label\":\"File name to search for\",\"maxChars\":0,\"key\":\"filename\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; File Name Search\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\n\nSensorRandomize()\n\nDim Pattern\n\nPattern = Trim(unescape(&quot;||filename||&quot;))\n\nConst SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1\n\nDim FSO, WshShell, Drives, Drive, TextStream, OutputFilename\n\nSet FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\nOutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir\n\n&#039; Go through file system, refresh output file for filename\nIf Not FSO.FileExists(OutputFilename) Then\n\t\n\tIf FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename\n\n\t&#039; Get the collection of local drives.\n\tSet Drives = FSO.Drives\n\tFor Each Drive in Drives\n\t\tIf Drive.DriveType = 2 Then &#039; 2 = Fixed drive\n\t\t\t&#039; Run the Dir command that looks for the filename pattern.\n\t\t\tRunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:-d /b /s&quot;, OutputFilename, true\n\t\tEnd If\n\tNext\nEnd If\n\n&#039; Open the output file, echo each line, and then close and delete it.\nSet TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)\nDo While Not TextStream.AtEndOfStream\n\tWScript.Echo TextStream.ReadLine()\nLoop\n\nTextStream.Close()\n \nIf FSO.FileExists(OutputFileName) Then\n\tOn Error Resume Next\n\tFSO.DeleteFile OutputFileName, True\n\tOn Error Goto 0\nEnd If\n\n&#039; Returns the name of a temporary file in the Temp directory.\nFunction TempName()\n\tDim Result\n\tDo\n \t\tResult = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())\n\t\tWScript.Sleep 200 &#039;avoid potential busy loop\n\tLoop While FSO.FileExists(Result)\n\t\n\tTempName = Result\nEnd Function &#039;TempName\n\n&#039; Runs a command with Cmd.exe and redirects its output to a temporary\n&#039; file. The function returns the name of the temporary file that holds\n&#039; the command&#039;s output.\nFunction RunCommand(Command, OutputFilename, b64BitNecessary)\n\t&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32\n\tDim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrDOSCall = &quot;%ComSpec% /C &quot;\n\t\n\t&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection\n\tstrProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\tIf objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64\n\t\tstrDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))\n\tEnd If\n\t\t\n\tCommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)\n\tWshShell.Run CommandLine, 0, True\nEnd Function &#039;RunCommand\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 235, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns users (but not groups) who are members of the Local Administrators group on Windows.  Will not list the individual members of groups in the Local Administrators group.\nExample: Administrator", 
      "exclude_from_parse_flag": 1, 
      "hash": 2060254274, 
      "hidden_flag": 0, 
      "id": 467, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Local Administrators Without Groups", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Local Administrators Without Groups\n&#039;========================================\n\n&#039; output of membership (individual users but no groups) of Local Administrators\n&#039; will not list members of sub-groups\n\nOption Explicit\n\nDim strMember\n\nFor Each strMember In GetLocalAdminAccountsMinusGroups\n\tWScript.Echo strMember\nNext\n\nFunction GetLocalAdminAccountsMinusGroups\n    Dim objWMIService,strLocalAdminQuery,colItems,objItem,strMembers,strComputerName,arrReturn,i\n    Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n    \n\t&#039; Get Computer Name\n    Set colItems = objWMIService.ExecQuery( &quot;Select * from Win32_ComputerSystem&quot;, , 48 )\n    For Each objItem in colItems\n        strComputerName = objItem.Name\n    Next\t    \n    \n    strLocalAdminQuery = &quot;select * from Win32_GroupUser where GroupComponent = &quot; &amp; chr(34) &amp; &quot;Win32_Group.Domain=&#039;&quot; &amp; strComputerName &amp; &quot;&#039;,Name=&#039;Administrators&#039;&quot; &amp; Chr(34)\n    \n    Set ColItems = objWMIService.ExecQuery(strLocalAdminQuery)\n    strMembers = &quot;&quot;\n    arrReturn = Array() &#039; set up return array\n    i = 0\n    For Each objItem In colItems\n    \ti = i + 1\n    \tIf Not InStr(LCase(objItem.PartComponent),&quot;win32_group.domain&quot;) &gt; 0 Then\t\t\t\n\t        Dim strMemberName, NamesArray, strDomainName, DomainNameArray\n\t        NamesArray = Split(objItem.PartComponent,&quot;,&quot;)\n\t        strMemberName = Replace(Replace(NamesArray(1),Chr(34),&quot;&quot;),&quot;Name=&quot;,&quot;&quot;)\n\t        DomainNameArray = Split(NamesArray(0),&quot;=&quot;)\n\t        strDomainName = Replace(DomainNameArray(1),Chr(34),&quot;&quot;)\n\t        If strDomainName &lt;&gt; strComputerName Then\n\t            strMemberName = strDomainName &amp; &quot;\\&quot; &amp; strMemberName\n\t        End If\n\t        ReDim Preserve arrReturn(UBound(arrReturn) + 1) &#039; increase array by one\n\t        arrReturn(UBound(arrReturn)) = strMemberName\n\t\tEnd If\n    Next\n    \n    GetLocalAdminAccountsMinusGroups = arrReturn\nEnd Function &#039;GetLocalAdminAccountsMinusGroups", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 236, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns any recently closed connection, ie those connection currently in CLOSED_WAIT or TIME_WAIT.  If the process that owned the connection can be determined, it will be included.\nExample: Google Chrome | 173.194.79.99:80", 
      "exclude_from_parse_flag": 1, 
      "hash": 2074877994, 
      "hidden_flag": 0, 
      "id": 469, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Recently Closed Connections", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Recently Closed Connections\n&#039;========================================\n\n&#039; Returns all of the connections which are currently in timewait or closewait\n\nOption Explicit\n\nDim showPort : showPort = True\nDim taniumDebug : taniumDebug = False\nDim strSep : strSep = &quot;|&quot;\n\nDim excludeProcesses, excludePorts, excludeSubnets\n\nDim strcommand, results, objWMIService, query, colResults, processes, result, processId\nDim processPath, objShell, objScriptExec, strNetStatResults, line, lineResults, j, i, word\nDim strAppEntry, arrAppEntry, strAppExe, strAppPath, Item\n\nexcludeProcesses = Array(&quot;taniumclient.exe&quot;,&quot;taniumreceiver.exe&quot;)\nexcludePorts = Array(&quot;17472&quot;)\nexcludeSubnets = Array(&quot;127.0.0.0:255.255.255.0&quot;)\n\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \nquery = &quot;select name, executablepath, processId from win32_process&quot;\nSet colResults = objWMIService.ExecQuery(query)\n\n&#039;dictionary for process-app pairs\nSet processes = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nFor Each result In colResults \n   processId = CStr(result.ProcessId)\n   processPath = result.ExecutablePath\n   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later\nNext\n\nstrcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find /V &quot; &amp; Chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34) &amp; &quot; | find /V &quot; &amp; Chr(34) &amp; &quot;ESTABLISHED&quot; &amp; Chr(34)\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrNetStatResults = LCase(objScriptExec.StdOut.ReadAll)\n\nresults = Split(strNetStatResults, vbCrLf)\n\nj = 0\nFor Each line in results\n   line = cleanWhitespace(Trim(line))\n   \n   lineResults = Split(line)\n   i = 0\n   Dim strPort, strPid, strConnectionType, strForeignIp, arrForeignIp, strIp, strApp\n   Dim strLocalIp, arrLocalIp, strLocalPort\n   Dim isNotExcludedApp, isNotExcludedSubnet,isNotClientPortUsage\n   For Each word In lineResults\n      If i = 1 Then\n         strLocalIp = word\n      ElseIf i = 2 Then\n         strForeignIp = word\n      ElseIf i = 3 Then\n         strConnectionType = word\n      ElseIf i = 4 Then\n         strPid = word\n      End If\n      \n      i = i + 1\n   Next\n   \n   &#039;DO NOT INCLUDE EXCLUDED APPS\n   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path\n   arrAppEntry = Split(strAppEntry,&quot;,&quot;)\n   strAppExe = arrAppEntry(0)\n   strAppPath = arrAppEntry(1)\n   \n   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))\n   \n   &#039;DO NOT INCLUDE EXCLUDED SUBNETS\n   arrForeignIp = Split(strForeignIp, &quot;:&quot;)\n   strIp = arrForeignIp(0)\n   strPort = arrForeignIp(1)\n\n   isNotExcludedSubnet = Not(ContainedInSubnet(strIp, excludeSubnets))\n\n   arrLocalIp = Split(strLocalIp, &quot;:&quot;)\n   strLocalPort = arrLocalIp(1)\n\n   isNotClientPortUsage = Not(ContainedInArray(strLocalPort, excludePorts)) And Not(ContainedInArray(strPort, excludePorts))\n   \n   If Not(IsEmpty(strAppExe)) _\n      And isNotExcludedApp _ \n      And isNotExcludedSubnet _\n      And isNotClientPortUsage Then\n\t  If Not showPort Then \n\t\tstrForeignIp = strIp\n\t  End If\n\n\t  If strPid = &quot;0&quot; Then \n      \t  results(j) = &quot;Unknown&quot; &amp; strSep &amp; strForeignIp\n      Else \n      \t  results(j) = ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIp\n      End If \n   Else\n      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp\n      results(j) = &quot;&quot;   \n   End If \n   \n   j = j + 1\nNext\n\nresults = RemDups(results)\n\nIf UBound(results) &lt; 1 Then\n\tIf GetLocale() &lt;&gt; 1033 Then\n\t\tWScript.Echo &quot;English Language OS Required&quot;\n\tEnd If\nEnd If\n\nFor Each result In results \n   WScript.Echo result\nNext\n\nWScript.Quit\n\nFunction ContainedInSubnet(strIp, arr)\n   Dim strSubnet, strMask, temp, parts\n\n   For Each item In arr\n      If InStr(item, &quot;-&quot;) Then &#039;Subnet range\n         temp = Split(item, &quot;-&quot;)\n         lower = Split(temp(0), &quot;:&quot;)\n         upper = Split(temp(1), &quot;:&quot;)\n         lowerSubnet = Trim(lower(0))\n         lowerMask = Trim(lower(1))\n         upperSubnet = Trim(upper(0))\n         upperMask = Trim(upper(1))\n         \n         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _\n            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If \n      Else &#039;Single subnet\n         parts = Split(item, &quot;:&quot;)\n         strSubnet = Trim(parts(0))\n         strMask = Trim(parts(1))\n         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If\n      End If \n   Next\n   ContainedInSubnet = False\nEnd Function\n\nFunction ContainedInArray(str, arr)\n\tDim strItem\n   \tFor Each strItem In arr \n      If str = strItem Then\n         ContainedInArray = True\n         Exit Function\n      End If   \n   Next\n   ContainedInArray = False\nEnd Function\n\nFunction ContainedInDict(str, dict)\n\tContainedInDict = dict.Exists(str)\nEnd Function\n\nFunction cleanWhitespace(strStarter)\n\tDim intStarter, i, strChars\n   \tintStarter = Len(strStarter)\n   \tFor i = intStarter to 2 Step -1\n      \tstrChars = Space(i)\n      \tstrStarter = Replace(strStarter, strChars, &quot; &quot;)\n   \tNext\n   \tcleanWhitespace = strStarter\nEnd Function\n\nFunction RemDups(ByVal anArray)\n   Dim d, item, thekeys\n   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)\n   d.removeall\n   d.CompareMode = 0\n   For Each item In anArray\n      If Len(item) &gt; 0 Then\n         If Not d.Exists(item) Then d.Add item, item\n      End If\n   Next\n   thekeys = d.keys\n   Set d = Nothing\n   RemDups = thekeys\nEnd Function\n\nFunction Subnet(strAddress, strMask)\n\tDim intSubnetLength\n   \tintSubnetLength = SubnetLength(strMask)\n   \tSubnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))\nEnd Function\n\nFunction SubnetLength(strMask)\n\tDim strMaskBinary\n   \tstrMaskBinary = StringToBinary(strMask)\n   \tSubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))\nEnd Function\n\nFunction BinaryToString(strBinary)\n\tDim intOctetPos, strOctetBinary, intOctet, intValue, intBinaryPos\n   For intOctetPos = 1 To 4\n      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)\n      intOctet = 0\n      intValue = 1\n      For intBinaryPos = 1 To Len(strOctetBinary)\n         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue\n         intValue = intValue * 2\n      Next\n      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)\n   Next\nEnd Function\n\nFunction StringToBinary(strAddress)\n\tDim objAddress, strOctet, intOctet, strOctetBinary, x\n   \tobjAddress = Split(strAddress, &quot;.&quot;, -1)\n   \tFor Each strOctet In objAddress\n      \tintOctet = CInt(strOctet)\n      \tstrOctetBinary = &quot;&quot;\n      \tFor x = 1 To 8\n         \tIf intOctet Mod 2 &gt; 0 Then\n            \tstrOctetBinary = &quot;1&quot; &amp; strOctetBinary\n         \tElse\n            \tstrOctetBinary = &quot;0&quot; &amp; strOctetBinary\n         \tEnd If\n         \tintOctet = Int(intOctet / 2)\n      \tNext\n      \tStringToBinary = StringToBinary &amp; strOctetBinary\n   \tNext\nEnd Function\n\nFunction ProcessNameToApplicationName(strExecutablePath, strExecutableName)\n&#039; This function will return the full application name of a running executable\n\n\t\tDim fso, arrPathParts, strExecutable\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\n\t\tarrPathParts = Split(strExecutablePath,&quot;\\&quot;)\n\n\t\tIf UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tSet fso = Nothing\n\t\t\tExit Function\n\t\tEnd If\n\t\tstrExecutable = arrPathParts(UBound(arrPathParts))\n\t\t\n\t\tIf fso.FileExists(strExecutablePath) Then\n\t\t\tDim execFile, strOutput, fileVersion, fileVersionOutput, fullName\n\t\t\n\t\t\tSet execFile = fso.GetFile(strExecutablePath)\n\t\t\tfullName = GetDescription(execFile.ParentFolder.Path, strExecutable)\n\t\t\tIf Not fullName = &quot;&quot; Then\n\t\t\t\tProcessNameToApplicationName = fullName\n\t\t\tElse\n\t\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tEnd If\n\t\tElse &#039; file doesn&#039;t exist or inaccessible\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\tEnd If\n\nEnd Function &#039;ProcessNameToApplicationName\n\nFunction GetDescription(folderPath, fileName)\n\tDim descIndex\n\tdescIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)\n\tIf IsEmpty(descIndex) Then\n\t\tdescIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)\n\tEnd If\n\tGetDescription = GetFileProperty(folderPath, fileName, descIndex)\nEnd Function\n\nFunction GetFileProperty(folderPath, fileName, fileProperty)\n\tDim objShell, objFolder\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tGetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)\nEnd Function\n\nFunction GetAttributeIndex(folderPath, attrTarget)\n\tDim objShell, objFolder, i, attrName\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tFor i = 0 to 50\n\t\tattrName = objFolder.GetDetailsOf(objFolder.Items, i)\n\t\tIf LCase(attrName) = LCase(attrTarget) Then\n\t\t\tGetAttributeIndex = i\n\t\t\tExit Function\n\t\tEnd If\n\tNext\nEnd Function\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;GetTaniumRegistryPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Target IP", 
            "value_type": "IPAddress"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 237, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Last user name entered in the \"Log On to Windows\" dialog box.\nExample: tanium_admin", 
      "exclude_from_parse_flag": 1, 
      "hash": 2095666087, 
      "hidden_flag": 0, 
      "id": 471, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Default Login UserID", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Default Login UserID\n&#039;========================================\n\nDim reg , strComputer\nstrComputer = &quot;.&quot;\nSet reg = Getx64RegistryProvider()\n\nstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot;\nstrValueName = &quot;DefaultUserName&quot; \n\nconst HKEY_CURRENT_USER = &amp;H80000001\nconst HKEY_LOCAL_MACHINE = &amp;H80000002\nstrComputer = &quot;.&quot;\n\nreg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue\nIf strValue &lt;&gt; &quot;&quot; Then\n\tWscript.Echo strValue\nElse\n\tWscript.Echo &quot;Default Login User Not Set&quot;\nEnd If\n  \nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 238, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Provides various properties for users which are currently logged into the machine.\nExample: CORP\\john.doe | John Doe | john.doe@organization.com", 
      "exclude_from_parse_flag": 1, 
      "hash": 2106396979, 
      "hidden_flag": 0, 
      "id": 473, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Logged in User Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Logged In User Details\n&#039;========================================\n\n&#039; This sensor will retrieve various properties of all users which are currently logged in\n\nOption Explicit\n\nDim intRandomWaitInMilliseconds\nintRandomWaitInMilliseconds = 10000\n&#039; each client will wait up to 10 seconds to retrieve information from AD to stagger the load\n\nRandomWait(intRandomWaitInMilliseconds)\n\nDim strSep : strSep = &quot;|&quot;\n\nDim strReturnedAttribute1 : strReturnedAttribute1 = Trim(Unescape(&quot;givenName&quot;)) &#039; first name\nDim strReturnedAttribute2 : strReturnedAttribute2 = Trim(Unescape(&quot;sn&quot;)) &#039; last name\nDim strReturnedAttribute3 : strReturnedAttribute3 = Trim(Unescape(&quot;proxyAddresses&quot;)) &#039; email addresses as array\n\n&#039;Get the NETBIOS name of the domain\nDim objSystemInfo,strDomain\nSet objSystemInfo = CREATEOBJECT(&quot;ADSystemInfo&quot;)\n\nOn Error Resume Next\nstrDomain = objSystemInfo.DomainShortName\nOn Error Goto 0\n\n\n&#039; List all users currently logged in\n\nDim objWMIService,colItems,objItem,strUser,strUserDomain,i\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;) \nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process Where Name=&#039;explorer.exe&#039;&quot;,,48)\n\ni = 0\nFor Each objItem in colItems\n    objItem.GetOwner strUser, strUserDomain\n    i = i + 1\n    GetDetails strUser,strUserDomain\nNext\n\nIf i = 0 Then\n    Wscript.Echo &quot;No users logged in&quot;\nEnd If\n\n\n&#039;&#039; --- helper functions --- &#039;&#039;\n\nSub GetDetails(strUser,strUserDomain)\n&#039; Echo output with attributes\n    Dim strDN,emails,strEmail,strPrimaryEmail,strBackupEmail,strOutEmail\n    Dim strProperty1,strProperty2\n    strDN = getUserDN(strUser,strUserDomain)\n    emails = GetAttribute(strDN,strReturnedAttribute3)\n    If IsArray(emails) Then &#039; loop through all entries, try to pick primary\n        strPrimaryEmail = &quot;&quot;\n        strBackupEmail = &quot;&quot;\n        strOutEmail = &quot;&quot;\n        For Each strEmail In emails\n            &#039; primary has SMTP in capital letters\n            strBackupEmail = Mid(strEmail,6,Len(strEmail))\n            If InStr(strEmail,&quot;SMTP&quot;) = 1 Then\n                strPrimaryEmail = Mid(strEmail,6,Len(strEmail))\n            End If\n        Next\n        If strPrimaryEmail &lt;&gt; &quot;&quot; Then\n            strOutEmail = strPrimaryEmail\n        Else\n            strOutEmail = strBackupEmail\n        End If\n    Else &#039;single entry\n        strOutEmail = GetAttribute(strDN,strReturnedAttribute3)\n    End If\n    \n    If strOutEmail = &quot;&quot; Then strOutEmail = &quot;Unknown or Local User&quot;\n    strProperty1 = &quot;&quot;\n    strProperty2 = &quot;&quot;\n    strProperty1 = GetAttribute(strDN,strReturnedAttribute1)\n    \n    If strProperty1 = &quot;&quot; Then \n        strProperty1 = &quot;Unknown or Local&quot;\n        strProperty2 = &quot;User&quot;\n    Else\n        strProperty2 = GetAttribute(strDN,strReturnedAttribute2)\n    End If\n        \n    WScript.Echo strUserDomain&amp;&quot;\\&quot;&amp;strUser&amp;strSep&amp;strProperty1 _\n        &amp;&quot; &quot;&amp;strProperty2&amp;strSep&amp;strOutEmail\n        \nEnd Sub &#039;GetDetails\n\nFunction RandomWait(intWaitTimeInMilliseconds)\n&#039; waits a random amount of time\n    \n    Randomize(TaniumRandomSeed)\n    intWaitTimeInMilliseconds = Int( ( intWaitTimeInMilliseconds + 1 ) * Rnd )\n    WScript.Sleep(intWaitTimeInMilliseconds)\n    \nEnd Function &#039;RandomWait\n\nFunction GetAttribute(strDn,strAttribute)\n&#039; Returns the AD attribute of a DN\n    \n    Const E_ADS_PROPERTY_NOT_FOUND  = &amp;h8000500D\n    Dim objADObj,attribute\n    \n    On Error Resume Next\n    Set objADObj = GetObject _\n        (&quot;LDAP://&quot; &amp; strDn)\n    If Err.Number &lt;&gt; 0 Then\n        &#039; WScript.Echo &quot;Error: &quot; &amp; Err.Description &amp; &quot; - cannot bind to AD&quot;\n    End If\n    \n    attribute = objADObj.Get(strAttribute)\n     \n    If Err.Number = E_ADS_PROPERTY_NOT_FOUND Then\n        &#039; WScript.Echo &quot;The &quot; &amp; strAttribute &amp; &quot; attribute is not set in AD.&quot;\n    Else\n        GetAttribute = attribute\n    End If\n    \n    On Error Goto 0\n    \nEnd Function &#039;GetAttribute\n\nFunction getUserDN(BYVAL strUser,BYVAL strUserDomain)\n   &#039; Function to get the distinguished name of a user\n   &#039; from the older domain format (domain\\user) using\n   &#039; name translate\n   \n    On Error Resume Next\n    CONST ADS_NAME_INITTYPE_GC = 3\n    CONST ADS_NAME_TYPE_NT4 = 3\n    Const ADS_NAME_TYPE_1779 = 1\n   \n    Dim objTrans\n    \n    SET objTrans = CREATEOBJECT(&quot;NameTranslate&quot;)\n    &#039; Initialize name translate using global catalog\n    objTrans.Init ADS_NAME_INITTYPE_GC, &quot;&quot;\n    &#039; Input computer name (NT Format)\n    objTrans.SET ADS_NAME_TYPE_NT4, strUserDomain &amp; &quot;\\&quot; &amp; strUser\n    &#039; Get Distinguished Name.\n    getUserDN = objTrans.GET(ADS_NAME_TYPE_1779)\n    On Error Goto 0\nEnd Function &#039;GetUserDN\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction TaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n    Dim timerNum\n    timerNum = Timer()\n    If timerNum &lt; 1 Then\n        TaniumRandomSeed = (GetTaniumComputerID / Timer() * 10 )\n    Else\n        TaniumRandomSeed = GetTaniumComputerID / Timer\n    End If\nEnd Function &#039;TaniumRandomSeed\n\nFunction GetTaniumComputerID\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n    Const HKEY_LOCAL_MACHINE = &amp;H80000002\n    \n    Dim objReg\n    Dim intClientID,strID,strKeyPath,strValueName,dwValue\n    \n    \n    Set objReg=GetObject( _\n        &quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp;_ \n        &quot;.\\root\\default:StdRegProv&quot;)\n    strKeyPath = GetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    \n    objReg.GetDWORDValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,dwValue\n    GetTaniumComputerID = ReinterpretSignedAsUnsigned(dwValue)\n    \nEnd Function &#039;GetTaniumComputerID\n\nFunction ReinterpretSignedAsUnsigned(ByVal x)\n      If x &lt; 0 Then x = x + 2^32\n      ReinterpretSignedAsUnsigned = x\nEnd Function &#039;ReinterpretSignedAsUnsigned", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Userid", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Full Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Email Address", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 239, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the share path of network shares the host is connected to.\nExample: \\\\\\\\server\\\\share", 
      "exclude_from_parse_flag": 1, 
      "hash": 2114351169, 
      "hidden_flag": 0, 
      "id": 475, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Network Drives Accessed", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select RemotePath from Win32_NetworkConnection", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 240, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The manufacturer of the CPU.\nExample: GenuineIntel", 
      "exclude_from_parse_flag": 1, 
      "hash": 2130080578, 
      "hidden_flag": 0, 
      "id": 477, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "CPU Manufacturer", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select Manufacturer from Win32_Processor", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ngrep -m 1 -i &quot;vendor_id&quot; /proc/cpuinfo | awk -F&quot;: &quot; &#039;{print $2}&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ncpu=$(system_profiler SPHardwareDataType | grep &#039;Processor Name&#039; | awk -F&#039;:&#039;  &#039;{split($2,a,&quot; &quot;); print a[1]}&#039;)\nif [ &quot;&quot; = &quot;$cpu&quot; ]\nthen\n\techo &quot;Unknown&quot;\nelse\n\techo &quot;$cpu&quot;\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 241, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Finds the specified folder and provides the full path if the folder exists on the client machine.\nExample: C:\\WINDOWS\\System32", 
      "exclude_from_parse_flag": 1, 
      "hash": 214691664, 
      "hidden_flag": 0, 
      "id": 479, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Folder Name Search", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the folder name only to search for.\",\"value\":\"\",\"promptText\":\"e.g. Program Files\",\"defaultValue\":\"\",\"label\":\"Folder name to search for\",\"maxChars\":0,\"key\":\"dirname\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Folder Name Search\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\n\nSensorRandomize()\n\nDim Pattern\n\nPattern = unescape(&quot;||dirname||&quot;)\n\nConst SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1\n\nDim FSO, WshShell, Drives, Drive, TextStream, OutputFilename\n\nSet FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\nOutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir\n\n&#039; Go through file system, refresh output file for filename\nIf Not FSO.FileExists(OutputFilename) Then\n\t\n\tIf FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename\n\n\t&#039; Get the collection of local drives.\n\tSet Drives = FSO.Drives\n\tFor Each Drive in Drives\n\t\tIf Drive.DriveType = 2 Then &#039; 2 = Fixed drive\n\t\t\t&#039; Run the Dir command that looks for the filename pattern.\n\t\t\tRunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:D /B /S&quot;, OutputFilename,true\n\t\tEnd If\n\tNext\nEnd If\n\n&#039; Open the output file, echo each line, and then close and delete it.\nSet TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)\nDo While Not TextStream.AtEndOfStream\n\tWScript.Echo TextStream.ReadLine()\nLoop\n\nTextStream.Close()\n \nIf FSO.FileExists(OutputFileName) Then\n\tOn Error Resume Next\n\tFSO.DeleteFile OutputFileName, True\n\tOn Error Goto 0\nEnd If\n\n&#039; Returns the name of a temporary file in the Temp directory.\nFunction TempName()\n\tDim Result\n\tDo\n \t\tResult = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())\n\t\tWScript.Sleep 200 &#039;avoid potential busy loop\n\tLoop While FSO.FileExists(Result)\n\t\n\tTempName = Result\nEnd Function &#039;TempName\n\n&#039; Runs a command with Cmd.exe and redirects its output to a temporary\n&#039; file. The function returns the name of the temporary file that holds\n&#039; the command&#039;s output.\nFunction RunCommand(Command, OutputFilename, b64BitNecessary)\n\t&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32\n\tDim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrDOSCall = &quot;%ComSpec% /C &quot;\n\t\n\t&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection\n\tstrProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\tIf objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64\n\t\tstrDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))\n\tEnd If\n\t\t\n\tCommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)\n\tWshShell.Run CommandLine, 0, True\nEnd Function &#039;RunCommand\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;dirname&quot;,&quot;promptText&quot;:&quot;e.g. Program Files&quot;,&quot;label&quot;:&quot;Folder name to search for&quot;,&quot;helpString&quot;:&quot;Enter the folder name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||dirname||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;dirname&quot;,&quot;promptText&quot;:&quot;e.g. Program Files&quot;,&quot;label&quot;:&quot;Folder name to search for&quot;,&quot;helpString&quot;:&quot;Enter the folder name only to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||dirname||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 242, 
      "category": "Office", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the version of Microsoft Office Outlook installed.\nExample: Outlook 2003, Version: 11.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 2154864096, 
      "hidden_flag": 0, 
      "id": 481, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Outlook Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Outlook Version\n&#039;========================================\n\nstrExe = &quot;outlook.exe&quot;\n\nEchoOutlookVersion(&quot;Software\\Microsoft\\Office&quot;)\n\nWScript.Echo &quot;Outlook not found&quot;\n\nFunction PrintVersionString(strVersion)\n\tSelect Case (Left(strVersion,4))\n\t\tCase &quot;10.0&quot;\n\t\t\tWScript.echo &quot;Outlook 2002, Version:&quot; &amp; strVersion\n\t\t\tExit Function\n\t\tCase &quot;11.0&quot;\n\t\t\tWScript.echo &quot;Outlook 2003, Version:&quot; &amp; strVersion\n\t\t\tExit Function\n\t\tCase &quot;12.0&quot; \n\t\t\tWScript.echo &quot;Outlook 2007, Version:&quot; &amp; strVersion\n\t\t\tExit Function\n\t\tCase &quot;14.0&quot; \n\t\t\twscript.echo &quot;Outlook 2010, Version:&quot; &amp; strVersion\n\t\t\tExit Function\n\t\tCase &quot;15.0&quot; \n\t\t\twscript.echo &quot;Outlook 2013, Version:&quot; &amp; strVersion\n\t\t\tExit Function\t\t\t\n\tEnd Select\n\tWScript.Echo &quot;Unknown Outlook, Version: &quot; &amp; strVersion\nEnd Function\n\nFunction EchoOutlookVersion(strKey)\n\tDim fso\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tConst HKLM = &amp;h80000002\n\tstrComputer = &quot;.&quot;\n\tSet reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\t\n\tIf RegKeyExists(reg, HKLM, strKey) Then\n&#039;\t\tWScript.Echo &quot;Office Found, attempt to get path&quot;\n\t\t\n\t\treg.enumKey HKLM, strKey, subKeys\n\t\t\n\t\tFor Each subKey In subKeys\n\t\t\tIf RegKeyExists(reg, HKLM, strKey &amp; &quot;\\&quot; &amp; subKey &amp; &quot;\\Common\\InstallRoot&quot;) Then\n\t\t\t\treg.getStringValue HKLM, strKey &amp; &quot;\\&quot; &amp; subKey &amp; &quot;\\Common\\InstallRoot&quot;, &quot;Path&quot;, strPath\n\t\t\t\tIf Not IsNull(strPath) Then\n\t\t\t\t\tIf fso.FolderExists(strPath) Then\n\t\t\t\t\t\tIf fso.FileExists(strPath &amp; &quot;outlook.exe&quot;) Then\n\t\t\t\t\t\t\tPrintVersionString(fso.GetFileVersion(strPath&amp;&quot;outlook.exe&quot;))\n\t\t\t\t\t\t\tWScript.Quit\n\t\t\t\t\t\tEnd If\t\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tNext\n\tEnd If\nEnd Function\n\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 243, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns details about last logins on systems.\nExample: user.name      pts/1    192.168.1.2  Thu Nov  8 22:07:30 -0800 2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 2177412849, 
      "hidden_flag": 0, 
      "id": 483, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Last Logins", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nlastlog | tail -n +2 | grep -v &quot;**Never&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 244, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the gobal temp directory of the Operating System.\nExample: C:\\Temp", 
      "exclude_from_parse_flag": 1, 
      "hash": 2222730558, 
      "hidden_flag": 0, 
      "id": 485, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Operating System Temp Directory", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select TempDirectory from win32_BootConfiguration", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 245, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns details about connected displays.\nExample:1024 by 768 pixels, True Color, 60 Hertz", 
      "exclude_from_parse_flag": 1, 
      "hash": 2265461905, 
      "hidden_flag": 0, 
      "id": 487, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Monitor Resolution", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select VideoMode from win32_DisplayControllerConfiguration", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Resolution", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Color Mode", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Refresh Rate", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 246, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the short, NetBIOS name of a machine's domain.\nExample: CORP", 
      "exclude_from_parse_flag": 1, 
      "hash": 2322714946, 
      "hidden_flag": 0, 
      "id": 489, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "AD Short Domain", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; AD Short Domain\n&#039;========================================\n\nOption Explicit\nOn Error Resume Next \nDim objSysInfo\nSet objSysInfo = CreateObject(&quot;ADSystemInfo&quot;) \n\nIf IsNull(objSysInfo.DomainShortName) Then\n\tWScript.Echo &quot;N/A&quot;\nElse\n\tWScript.Echo objSysInfo.DomainShortName\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 247, 
      "category": "Software", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "List of database names from SQL Server on client machines.\nExample: tanium", 
      "exclude_from_parse_flag": 1, 
      "hash": 2344747808, 
      "hidden_flag": 0, 
      "id": 491, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "SQL Server Databases", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Server Databases\n&#039;========================================\n\nConst adOpenStatic = 3\n Const adLockOptimistic = 3\n Set objConnection = CreateObject(&quot;ADODB.Connection&quot;) \n Set objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)  \n objConnection.Open _     \n &quot;Provider=SQLOLEDB;Data Source=.;&quot; &amp; _         \n &quot;Trusted_Connection=Yes;Initial Catalog=master;&quot;  \n objRecordSet.Open &quot;select name from master..sysdatabases&quot;, _         \n objConnection, adOpenStatic, adLockOptimistic  \n ObjRecordSet.MoveFirst  \n for each Record in objRecordSet.Properties    \n strValue = objRecordSet(&quot;name&quot;)    \n wscript.echo strValue    \n ObjRecordSet.MoveNext    \n If (ObjRecordset.EOF = True) THEN       \n objRecordset.Close       \n Exit For    \nEnd If \nnext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 248, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns drives and the S.M.A.R.T. status of the drives on machines which have a failing drive reporting through S.M.A.R.T.\nExample: Drive | SMART Report", 
      "exclude_from_parse_flag": 1, 
      "hash": 2357545787, 
      "hidden_flag": 0, 
      "id": 493, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Predicted Disk Failures", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Predicted Disk Failures\n&#039;========================================\n\nOption Explicit\n\nDim strSep\n\nstrSep = &quot;|&quot;\n&#039; Output is \n&#039; Drive | S.M.A.R.T. Report\n\n\nShowSmartAlerts(strSep)\n\n&#039;----------End Main-------------&#039;\nFunction ShowSmartAlerts(strSep)\n\tDim strComputer\n    dim objWMI, objInstance, objStatus, strStatus\n    \n    &#039;Because this could bomb out\n    On Error Resume Next\n\n\tstrComputer = &quot;.&quot;\n    Set objWMI = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\WMI&quot;)\n\n    Set objStatus = objWMI.InstancesOf(&quot;MSStorageDriver_FailurePredictStatus&quot;,48)\n        For Each objDriveReport in objStatus\n        \tIf objDriveReport.PredictFailure Then\n                   WScript.Echo objDriveReport.InstanceName &amp; strSep &amp; objDriveReport.Reason\n            End If\n        Next\n\n    On Error Goto 0\n    \n    &#039;Cleanup\n    Set objStatus = Nothing\n    Set objWMI = Nothing\nEnd Function &#039;ShowSmartAlerts", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Drive", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "S.M.A.R.T. Report", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 249, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the average CPU load on a Mac or Linux system \nExample: 0.00 0.03 0.10", 
      "exclude_from_parse_flag": 1, 
      "hash": 2361722934, 
      "hidden_flag": 0, 
      "id": 495, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Load Average", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nline=$(cat /proc/loadavg)\nset -- $line\necho $1 $2 $3\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nuptime | awk -F&#039;: &#039; &#039; /load averages:/ { print $2 } &#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 250, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The local time on the managed client.\nExample: 5:17:44 PM", 
      "exclude_from_parse_flag": 1, 
      "hash": 2370758491, 
      "hidden_flag": 0, 
      "id": 497, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Client Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Client Time\n&#039;========================================\n\n&#039; This sensor will return the Time the client thinks it is\n\nOption Explicit\n\nSetLocale(GetTaniumLocale())\n\nWScript.Echo FormatDateTime((Time), 3)\n\nFunction GetTaniumLocale() \n    Dim objWshShell, intLocaleID\n    \n    intLocaleID = &quot;&quot;\n    \n    Set objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intLocaleID = objWshShell.RegRead(&quot;HKLM\\&quot; &amp; GetTaniumRegistryPath() &amp; &quot;\\LocaleID&quot;)\n    On Error Goto 0\n    If intLocaleID = &quot;&quot; Then\n        GetTaniumLocale = 1033 &#039; default to us/English\n    Else\n        GetTaniumLocale = intLocaleID\n    End If\n\n    Set objWshShell = Nothing\nEnd Function &#039; GetTaniumLocale\n\n&#039; get-tanium-regpath.vbs\n\n&#039; Updated to always generate path so that GetTaniumDir can take multiple folder arguments\n&#039; Updated to always look for the Path string value and not assume a bogus entry\n&#039; in the wrong area is valid.  A valid entry will always have a Path string value\n&#039; uses objshell registry reads which should be faster and more reliable\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\ndate &quot;+%r&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\ndate &quot;+%r&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 251, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The version string of applications which match the parameter given.\nExample:  11.5.502.146", 
      "exclude_from_parse_flag": 1, 
      "hash": 2387001299, 
      "hidden_flag": 0, 
      "id": 499, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Installed Application Version", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the application name to search for\",\"value\":\"\",\"promptText\":\"e.g. Adobe Flash Player\",\"defaultValue\":\"\",\"label\":\"Application Name\",\"maxChars\":0,\"key\":\"application\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Installed Application Version\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039; This sensor will return information in the uninstall areas of the registry.\n&#039; it is parameterized and will output the version string for an application that\n&#039; matches\n\nSensorRandomize()\n\nstrApplicationMatchString = LCase(Trim(Unescape(&quot;||application||&quot;)))\n\nSet objRegistry = Getx64RegistryProvider()\nkeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;\nkey64Path = &quot;SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;\n\nConst HKLM = &amp;H80000002\nConst HKEY_USERS = &amp;H80000003\n\n&#039; list out 32-bit applications on a 64-bit system\nIf RegKeyExists(HKLM, key64Path) Then\n\tobjRegistry.EnumKey HKLM, key64Path, arrSubKeys\n\tGetApplications HKLM,key64path,arrSubKeys\nEnd If\n\n&#039; list out 32-bit applications on a 32-bit system, or 64-bit applications\n&#039; on a 64-bit system.\nIf RegKeyExists(HKLM, keyPath) Then\n\tobjRegistry.EnumKey HKLM, keypath, arrSubKeys\n\tGetApplications HKLM,keypath,arrSubKeys\nEnd If\n\n&#039; Also list out applications installed to HKEY_Users areas\n&#039; which will be appended to the arrSubKeys\n\nobjRegistry.EnumKey HKEY_USERS, &quot;&quot;, arrUserKeys\nFor Each strSIDkey In arrUserKeys\n\tIf RegKeyExists(HKEY_USERS, strSIDKEY&amp;&quot;\\&quot;&amp;keyPath) Then\n\t\tobjRegistry.EnumKey HKEY_USERS, strSIDkey&amp;&quot;\\&quot;&amp;keyPath, arrSubKeys\n\t\tGetApplications HKEY_USERS,strSIDKey&amp;&quot;\\&quot;&amp;keyPath,arrSubKeys\n\tEnd If\nNext\n\n\nFunction GetApplications(HIVE, keypath,arrSubKeys)\n\tSet applications = CreateObject(&quot;Scripting.Dictionary&quot;)\n\tOn Error Resume Next\n\tFor Each key in arrSubKeys\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;DisplayName&quot;, displayName\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;DisplayVersion&quot;, version\n\t\tobjRegistry.GetDWORDValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;SystemComponent&quot;, systemComponent\t\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;UninstallString&quot;, uninstallString\t\n\t\tobjRegistry.GetStringValue HIVE,keyPath &amp; &quot;\\&quot; &amp; key,&quot;ParentKeyName&quot;, parentKey\t\n\t\n\t\t&#039; assume it&#039;s not uninstallable\n\t\tbUninstallable = &quot;Not Uninstallable&quot;\n\t\t\t\t\n\t\tIf displayName &lt;&gt; &quot;&quot; _\n\t\t\tAnd Not IsNull(uninstallString) _ \n\t\t\tAnd IsNull(parentKey) _\n\t\t\tAnd InStr(displayName, &quot;Hotfix&quot;) = 0 _\n\t\t\tAnd InStr(displayName, &quot;Update for&quot;) = 0 _\n\t \t\tAnd InStr(displayName, &quot;Security Update for&quot;) = 0 _\n\t \tThen \n\t \t\tIf InStr(LCase(uninstallString), &quot;msiexec&quot;) Then\n\t \t\t\t&#039; replace any /I with /X and add silent flags\n\t \t\t\tuninstallString = Replace(uninstallString,&quot;/I&quot;,&quot;/X&quot;) &amp; &quot; /qn /noreboot&quot; \n\t  \t\t\tbUninstallable = &quot;Is Uninstallable&quot;\n\t  \t\tEnd If\n\t \t\tIf IsNull(systemComponent) Or systemComponent = 0 Then\n\t\t\t\tIf IsNull(version) Then\n\t\t\t\t\tversion = GetVersionInString(displayName)\n\t\t\t\tEnd If\n\t\t\t\t&#039; This is a multi-column sensor.  Last two columns are hidden.\n\t\t\t\tIf InStr(LCase(displayName),strApplicationMatchString) &gt; 0 Then\n\t\t\t\t\tdisplayString = version\n\t\t\t\t\tIf Not applications.Exists(displayString) Then\n\t\t\t\t\t\tapplications.Add displayString, &quot;&quot;\n\t\t\t\t\tEnd If \t\t\t\t\t\t\n\t\t\t\tEnd If\n\t\t\tEnd If \t\n\t\tEnd If \n\tNext\n\tOn Error Goto 0\n\t\n\tSortDictionary applications, 1 &#039; This calls a sorting function specific to dictionaries\n\tarrApplicationsKeys = applications.Keys\n\tFor Each application In arrApplicationsKeys\n\t\t&#039; final output of the sensor\n\t\tWScript.Echo application\n\tNext\nEnd Function &#039;GetApplications\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction SortDictionary(objDict, intSort)\n &#039;   objDict - the dictionary to sort\n &#039;   intSort - the field to sort (1=key, 2=item)\n \n   &#039; declare constants\n   Const dictKey  = 1\n   Const dictItem = 2\n \n   &#039; declare our variables\n   Dim strDict()\n   Dim objKey\n   Dim strKey,strItem\n   Dim X,Y,Z\n \n   &#039; get the dictionary count\n   Z = objDict.Count\n \n   &#039; we need more than one item to warrant sorting\n   If Z &gt; 1 Then\n     &#039; create an array to store dictionary information\n     ReDim strDict(Z,2)\n     X = 0\n     &#039; populate the string array\n     For Each objKey In objDict\n         strDict(X,dictKey)  = CStr(objKey)\n         strDict(X,dictItem) = CStr(objDict(objKey))\n         X = X + 1\n     Next\n \n     &#039; perform a a shell sort of the string array\n     For X = 0 To (Z - 2)\n       For Y = X To (Z - 1)\n         If StrComp(strDict(X,intSort),strDict(Y,intSort),vbTextCompare) &gt; 0 Then\n             strKey  = strDict(X,dictKey)\n             strItem = strDict(X,dictItem)\n             strDict(X,dictKey)  = strDict(Y,dictKey)\n             strDict(X,dictItem) = strDict(Y,dictItem)\n             strDict(Y,dictKey)  = strKey\n             strDict(Y,dictItem) = strItem\n         End If\n       Next\n     Next\n \n     &#039; erase the contents of the dictionary object\n     objDict.RemoveAll\n \n     &#039; repopulate the dictionary with the sorted information\n     For X = 0 To (Z - 1)\n       objDict.Add strDict(X,dictKey), strDict(X,dictItem)\n     Next\n \n   End If\n End Function &#039;SortDictionary\n\nFunction GetVersionInString(ByVal strTemp)\n&#039; examines a string and returns a version string at the end of it\n\tDim strOut\n\tstrOut = &quot;&quot;\n\tIf Not IsNull(strTemp) Then\n\t\tstrTemp = StrReverse(strTemp)\n\t\tDim strLookAtChar,intCurPos\n\t\tDim bNumbersStartMarked : bNumbersStartMarked = False\n\n\t\tFor intCurPos = 1 To Len(strTemp)\t\t\n\t\t\tstrLookAtChar = Mid(strTemp,intCurPos,1)\n\t\t\tIf IsNumeric(strLookAtChar) Or strLookAtChar = &quot;.&quot; Or strLookAtChar = &quot;-&quot; Then\n\t\t\t\tbNumbersStartMarked = True\n\t\t\t\tstrOut = strOut &amp; strLookAtChar\n\t\t\tEnd If\n\t\tIf bNumbersStartMarked And ( (Not IsNumeric(strLookAtChar) And strLookAtChar &lt;&gt; &quot;.&quot; And strLookAtChar &lt;&gt; &quot;-&quot;) ) Then\n\t\t\tExit For\n\t\tEnd If\t\n\t\tNext\n\t\tstrOut = StrReverse(strOut)\n\tElse\n\t\tstrOut = &quot;&quot;\n\tEnd If\n\t\n\tIf Len(strOut) = 0 Then strOut = &quot;N/A&quot;\n\t\n\tGetVersionInString = strOut\n\t\nEnd Function &#039;GetVersionInString\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n############################################\n## Script Name: application_version.sh\t            ##\n## Created: 16 MAR 2014\t\t\t            ##\n## Author: James Hoscheit - Tanium                      ##\n##              &lt;james.hoscheit@tanium.com&gt;\t            ##\n##              Egon Rinderer - Tanium                          ##\n##              &lt;egon.rinderer@tanium.com&gt;               ##\n## Purpose: To query an application version on   ##\n##                  a Linux system.\t                          ##\n############################################\n\n\nfile=&quot;||application||&quot;\n\n#if [ &quot;$#&quot; -eq &quot;0&quot; ]\n#then\n#\texit 1\n#else\n#\tfile=$1\n#fi\n\nif [ -f /bin/rpm ] #rpm based solutions\nthen\n\tinstalledPkg=`rpm -q $file`\n\tif [ `echo $installedPkg | grep -v &#039;not installed&#039; | grep -c $file` -gt 0 ]\n\tthen\n\t\techo $installedPkg | awk -F&#039;el&#039; &#039;{print $1}&#039; | awk -F&#039;-&#039; &#039;{print $2}&#039;\n\telse\n\t\techo &quot;not installed&quot;\n\tfi\n\nelif [ -f /usr/bin/apt-get ] #.deb based solutions\nthen\n\tinstalledPkg=`dpkg -l $file 2&gt;/dev/null`\n\tinstalledPkg2=`echo $installedPkg | sed &#039;s/^.*=== /ii.*$/&#039;`\n\tif [ `echo $installedPkg2 | egrep -c &#039;^ii&#039;` -gt 0 ]\n\tthen\n\t\techo $installedPkg2 | egrep &#039;^ii&#039; | awk &#039;{print $3}&#039;\n\telse\n\t\techo &quot;not installed&quot;\n\tfi\nelse\n\techo &quot;unknown Linux installed&quot;\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n############################################\n## Script Name: application_version.sh\t            ##\n## Created: 16 MAR 2014\t\t\t            ##\n## Author: James Hoscheit - Tanium                      ##\n##              &lt;james.hoscheit@tanium.com&gt;\t            ##\n##              Egon Rinderer - Tanium                          ##\n##              &lt;egon.rinderer@tanium.com&gt;               ##\n## Purpose: To query an application version on   ##\n##                  a Mac system.\t                          ##\n############################################\n\nversion=`system_profiler SPApplicationsDataType | grep -i -A2 &quot;||application||&quot; | grep &quot;^ *Version&quot; | awk -F&#039;: &#039; &#039;{print $2}&#039;`\n\nif [ ${#version} -eq 0 ]\nthen\n     echo &quot;Not installed&quot;\nelse\n     echo $version\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 252, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Describes the architecture of the CPU/processor.\nExample: i386, X86-based PC", 
      "exclude_from_parse_flag": 1, 
      "hash": 2463256440, 
      "hidden_flag": 0, 
      "id": 501, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "CPU Architecture", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select SystemType from Win32_ComputerSystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\narch\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\narch\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 253, 
      "category": "Registry", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns True if the Registry Key exists, False if not.", 
      "exclude_from_parse_flag": 1, 
      "hash": 2490353155, 
      "hidden_flag": 0, 
      "id": 503, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Registry Key Exists", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{5}\",\"helpString\":\"Value must be at least 5 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the registry key to query\",\"value\":\"\",\"promptText\":\"e.g. HKEY_USERS\\\\Software\\\\Key\",\"defaultValue\":\"\",\"label\":\"Registry Key\",\"maxChars\":0,\"key\":\"strKey\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Key Exists\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Subkey Name | Architecture | KeyPath\n\nstrKey = unescape(&quot;||strKey||&quot;)\n\n&#039;strKey = &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Tanium\\Tanium Server&quot;\n&#039;strKey = &quot;HKEY_CURRENT_USER\\Software\\TortoiseSVN&quot;\n\nstrSep = &quot;|&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = RegKeyExists(objReg, constHive, strFullUserKey)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = RegKeyExists(objReg, constHive, strKey)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = RegKeyExists(objReg, constHive, strFullUserKey)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\t\n\t\thasValues64 = RegKeyExists(objReg, constHive, strKey)\n\t\tIf hasValues64 Then hasAnyResult = True\t\n\tEnd If\nEnd If\n\nIf (hasAnyResult) Then\n\tWScript.Echo &quot;True&quot;\nElse\n\tWScript.Echo &quot;False&quot;\nEnd If\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\\Software\\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\\Software\\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 254, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Name of the default printer.\nExample: HP Color LaserJet 3500", 
      "exclude_from_parse_flag": 1, 
      "hash": 2505938414, 
      "hidden_flag": 0, 
      "id": 505, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Default Printer", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select DriverName from Win32_Printer Where Default = True", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 255, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The full Active Directory distinguished name for the computer\nExample: CN=Win8-test5,CN=Computers,DC=corp,DC=com", 
      "exclude_from_parse_flag": 1, 
      "hash": 2513829483, 
      "hidden_flag": 0, 
      "id": 507, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "AD Distinguished Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; AD Distinguished Name\n&#039;========================================\n\n\n&#039; Returns a single column value\n&#039; Only checks a single registry context\n\nConst GPKey = &quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy&quot;\nDim strSubKey,strValue,strSep,strKey,words,strHive,constHive,hasValues32,hasAnyResult\nDim hasValues64,strUserKey,strFullUserKey,bEchoOnlyValue\nDim objCtx,objReg,bSkipSecondCheckOverride\n\nbEchoOnlyValue = True\nbSkipSecondCheckOverride = True &#039; Check in one place\nstrSubKey = &quot;\\DataStore\\Machine\\0&quot;\nstrValue = &quot;DNName&quot;\nstrSep = &quot;~~&quot;\n\nstrKey = GPKey&amp;strSubKey\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n   For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n         strUserName = GetUserForSIDLocal(objReg,strUserKey)\n         If strUserName = False Then strUserName = strUserKey\n         strFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n         hasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n         If hasValues32 Then hasAnyResult = True\n      End If\n   Next\nElse &#039; was another hive\n   hasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n   If hasValues32 Then hasAnyResult = True\nEnd If\n\n&#039; Do not return second value set in different context unnecessarily\nDim strKeyPrefix,bSkipSecondContextCheck\nbSkipSecondContextCheck = False\nstrKeyPrefix = Split(strKey,&quot;\\&quot;)(0) &#039; Software, for instance, even for HEKY_USERS\n\nSelect Case Ucase(strKeyPrefix)\n   Case &quot;SOFTWARE&quot;\n      If bSkipSecondCheckOverride Then\n         bSkipSecondContextCheck = True\n      Else\n         bSkipSecondContextCheck = False\n      End If\n   Case Else\n      bSkipSecondContextCheck = True\nEnd Select\n\nIf Is64 And Not bSkipSecondContextCheck Then\n   Set objCtx = GetObjCtx(64)\n   Set objReg = GetObjReg(objCtx)\n   If strHive = &quot;HKEY_USERS&quot; Then\n   &#039; go through each User&#039;s hive in 64-bit context\n      For Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n      If Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n            strUserName = GetUserForSIDLocal(objReg,strUserKey)\n            If strUserName = False Then strUserName = strUserKey\n            strFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n            hasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n            If hasValues64 Then hasAnyResult = True   \n         End If\n      Next\n   Else &#039; was another hive\n      hasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n      If hasValues64 Then hasAnyResult = True\n   End If\nEnd If\n\nIf Not (hasAnyResult) Then\n   WScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n   Dim Inparams, Outparams,arrNames,arrTypes,i,strValueName\n   Set Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n   Inparams.Hdefkey = constHive\n   Inparams.sSubkeyname = strKey\n   Set Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n   \n   arrNames = Outparams.sNames\n   arrTypes = Outparams.Types\n\n   If Not IsNull(arrNames) Then\n      For i = LBound(arrNames) To UBound(arrNames)\n         strValueName = arrNames(i)\n         \n         &#039;if strValue is found, echo\n         If LCase(strValueName) = LCase(strValue) Then\n            EchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit, bEchoOnlyValue\n            CheckValues = True\n            Exit Function\n         End If\n      Next\n   End If\n   CheckValues = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit, bEchoOnlyValue)\n   Dim strArch\n   If intBit = 64 Then\n      strArch = &quot;64-bit&quot;\n   Else\n      strArch = &quot;32-bit&quot;\n   End If\n   If bEchoOnlyValue Then\n      GetDisplayString = strValue\n   Else\n      GetDisplayString = _\n         strValue &amp; strSep &amp; _\n         strType &amp; strSep &amp; _\n         strArch\n   End If\nEnd Function\n\nFunction EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit, bOnlyValueData)\n   &#039; Note the key that was being searched, will be a hidden column\n   Dim strOutputKey\n   strOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n   \n   Dim objInParams, objOutParams\n   Select Case constType\n      Case REG_SZ  \n         Set objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters\n         objInParams.hDefKey = constHive\n         objInParams.sSubKeyName = strKey\n         objInParams.sValueName = strValue         \n         Set objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            WScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)\n         Else\n            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_EXPAND_SZ\n         Set objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters\n         objInParams.hDefKey = constHive\n         objInParams.sSubKeyName = strKey\n         objInParams.sValueName = strValue         \n         Set objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            WScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData)\n         Else  \n            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit, bOnlyValueData) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_BINARY\n         Set objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters\n         objInParams.hDefKey = constHive\n         objInParams.sSubKeyName = strKey\n         objInParams.sValueName = strValue         \n         Set objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)\n\n         strBytes = &quot;&quot;\n         For Each uByte in objOutParams.uValue\n            strTemp = Hex(uByte)\n            If Len(strTemp) &lt; 2 Then\n               strTemp = &quot;0&quot; &amp; strTemp\n            End If   \n            strBytes = strBytes &amp; strTemp &amp; &quot; &quot;\n         Next\n         If bOnlyValueData Then\n            WScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)\n         Else\n            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit, bOnlyValueData) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If         \n      Case REG_DWORD\n          Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n          objInParams.hDefKey = constHive\n          objInParams.sSubKeyName = strKey\n          objInParams.sValueName = strValue\n          Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            WScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)\n         Else     \n            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_QWORD\n          Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters\n          objInParams.hDefKey = constHive\n          objInParams.sSubKeyName = strKey\n          objInParams.sValueName = strValue\n          Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)\n         If bOnlyValueData Then\n            WScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit, bOnlyValueData)\n         Else     \n            WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit) _\n               &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n         End If\n      Case REG_MULTI_SZ\n          Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters\n          objInParams.hDefKey = constHive\n          objInParams.sSubKeyName = strKey\n          objInParams.sValueName = strValue\n          Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)\n      \n         arrValues = objOutParams.sValue\n         strResponse = &quot;&quot;\n\n         For Each strTemp In arrValues\n            If bOnlyValueData Then\n               WScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit, bOnlyValueData)\n            Else\n               WScript.Echo strUserName &amp; strSep &amp; GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strTemp, intBit) _\n                  &amp; strSep &amp; strOutputKey &amp; strSep &amp; strValue\n            End If\n         Next\n\n   End Select\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n   Dim objCtx\n   Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n   objCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n   objCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n   Set GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n   Dim objLocator, objServices\n   Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n   Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n   Set GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n   Dim Inparams, Outparams\n   Set Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n   Inparams.Hdefkey = constHive\n   Inparams.sSubkeyname = strKey\n   Set Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n   GetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n   Dim objWMIService, colItems, objItem\n   Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n   Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n   For Each objItem In colItems\n      If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n         Is64 = True\n      Else\n         Is64 = False\n      End If      \n   Next\nEnd Function\n\n\nFunction GetHiveConst(hive)\n   Const HKEY_CLASSES_ROOT   = &amp;H80000000\n   Const HKEY_CURRENT_USER   = &amp;H80000001\n   Const HKEY_LOCAL_MACHINE  = &amp;H80000002\n   Const HKEY_USERS          = &amp;H80000003\n\n   Select Case UCase(hive)\n      Case &quot;HKLM&quot;\n         GetHiveConst = HKEY_LOCAL_MACHINE\n      Case &quot;HKEY_LOCAL_MACHINE&quot;\n         GetHiveConst = HKEY_LOCAL_MACHINE\n      Case &quot;HKCR&quot;\n         GetHiveConst = HKEY_CLASSES_ROOT\n      Case &quot;HKEY_CLASSES_ROOT&quot;\n         GetHiveConst = HKEY_CLASSES_ROOT\n      Case &quot;HKEY_CURRENT_USER&quot;\n         GetHiveConst = HKEY_CURRENT_USER\n      Case &quot;HKEY_USERS&quot;\n         GetHiveConst = HKEY_USERS\n   End Select\n   \n   If IsEmpty(GetHiveConst) Then\n      WScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n      WScript.Quit\n   End If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n   Const HKLM = &amp;h80000002\n   \n   Dim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n   \n   strHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n   objReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n   If Not IsNull(strUserData) Then\n   &#039; strUserData would look like\n   &#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n      intDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n      &#039; strip off the dat file\n      If intDatPos &gt; 0 Then &#039; must be in string\n         strUserData = Left(strUserData,intDatPos - 1)\n         &#039; find last backslash\n         intFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n         &#039; get right from that pos\n         strUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n         GetUserForSIDLocal = strUserData\n      Else\n         strUserData = False\n      End If\n   Else\n      GetUserForSIDLocal = False\n   End If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 256, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns System or Motherboard manufacturer (OS Dependent).\nExample: Apple", 
      "exclude_from_parse_flag": 1, 
      "hash": 2542613392, 
      "hidden_flag": 0, 
      "id": 509, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Manufacturer", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Manufacturer from win32_baseboard", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s system-manufacturer\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\necho Apple\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 257, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns a list of hotfixes that have previously been applied to the client machine.\nExample: Microsoft National Language Support Downlevel APIs", 
      "exclude_from_parse_flag": 1, 
      "hash": 254407409, 
      "hidden_flag": 0, 
      "id": 511, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Installed HotFixes", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select Description from Win32_QuickFixEngineering", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 258, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "A parameterized Sensor that allows an operator to search for a particular string in the Windows application event logs.\nExample: The Apache service reported the following error: [Tue Jan 01 17:14:24 2010] [warn] PassEnv variable CommonProgramFiles(x86) was undefined", 
      "exclude_from_parse_flag": 1, 
      "hash": 2574398281, 
      "hidden_flag": 0, 
      "id": 513, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Application Event Log Search", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the event string to search for\",\"value\":\"\",\"promptText\":\"e.g. terminated unexpectedly\",\"defaultValue\":\"\",\"label\":\"Event string to search for\",\"maxChars\":0,\"key\":\"EVENT\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Message from Win32_NTLogEvent where LogFile = &#039;Application&#039; and Message like &#039;%||EVENT||%&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$432000$$&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;EVENT&quot;,&quot;promptText&quot;:&quot;e.g. terminated unexpectedly&quot;,&quot;label&quot;:&quot;Event string to search for&quot;,&quot;helpString&quot;:&quot;Enter the event string to search for&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||EVENT||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 3 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{3}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;EVENT&quot;,&quot;promptText&quot;:&quot;e.g. terminated unexpectedly&quot;,&quot;label&quot;:&quot;Event string to search for&quot;,&quot;helpString&quot;:&quot;Enter the event string to search for&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||EVENT||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 259, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the motherboard product name of a system.\nExample: 440BX Desktop Reference Platform", 
      "exclude_from_parse_flag": 1, 
      "hash": 2595849133, 
      "hidden_flag": 0, 
      "id": 515, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Motherboard Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Product from win32_baseboard", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s baseboard-product-name\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 260, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Indicates the time in days since the last time the Forefront client signatures were checked by Forefront.\nExample: 2", 
      "exclude_from_parse_flag": 1, 
      "hash": 2606734477, 
      "hidden_flag": 0, 
      "id": 517, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Forefront Client Signatures Last Checked Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signatures Last Checked Days Old\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\twords = Split(BinaryToDate(binValue))\n\t\tWScript.Echo GetDaysOld(words(0))\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nEnd If\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 261, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Amount of RAM in the video card in the client machine.\nExample: 256MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 2607823237, 
      "hidden_flag": 0, 
      "id": 519, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Video Graphics Card RAM", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Video Graphics Card RAM\n&#039;========================================\n\n&#039; This sensor will return the amount of video RAM a machine \n&#039; has in each card, in Megabytes\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_VideoController&quot;,,48)\n\nFor Each objItem in colItems\n\tIf Not isNull(objItem.AdapterRAM) Then\n\t\tWScript.Echo CLng((objItem.AdapterRAM /1024)/1024) &amp; &quot;MB&quot;\n\tEnd If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 262, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns Enabled or Disabled based on the status of Windows User Access Control on the client machine.\nExample: Enabled", 
      "exclude_from_parse_flag": 1, 
      "hash": 2614767778, 
      "hidden_flag": 0, 
      "id": 521, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "UAC Status", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; UAC Status\n&#039;========================================\n&#039; This will determine whether UAC is on or off\n\nOption Explicit\n\nWScript.Echo GetUACStatus\n\nFunction GetUACStatus\n&#039; This function uses the correct way to access 64-bit registry\n&#039; in a 32-bit context to query a single registry value and\n&#039; Determine if UAC is on\n\t\n\tDim objReg, objCtx\n\tDim strUACRegKey, strUACRegVal, strUACStatus\n\t\n\tConst HKLM = &amp;H80000002\n\t\n\tIf Is64 Then\n\t\tSet objCtx = GetObjCtx(64)\n\t\tSet objReg = GetObjReg(objCtx)\n\tElse\n\t\tSet objCtx = GetObjCtx(32)\n\t\tSet objReg = GetObjReg(objCtx)\n\tEnd If\n\n\tstrUACRegKey = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\\&quot;\n\tstrUACRegVal = &quot;EnableLua&quot;\n\t\n\t\t&#039;RegKeyExists Example\n\tIf RegKeyExists(objReg, HKLM, strUACRegKey) Then\n\t\tstrUACStatus = CStr(GetDwordValue(objReg, HKLM, strUACRegKey, strUACRegVal))\n\t\t\n\t\tIf strUACStatus = &quot;1&quot; Then \n\t\t\tGetUACStatus = &quot;Enabled&quot;\n\t\tElseIf strUACStatus = &quot;0&quot; Then\n\t\t\tGetUACStatus = &quot;Disabled&quot;\n\t\tElse\n\t\t\tGetUACStatus = &quot;UAC Not Applicable to this OS&quot;\n\t\tEnd If\t\t\n\tElse\n\t\tGetUACStatus = &quot;Pre-UAC OS&quot;\n\tEnd If\n\t\n\t&#039; Cleanup\n\tSet objReg = Nothing\n\tSet objCtx = Nothing\nEnd Function &#039;GetUACStatus\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\n\t&#039; Cleanup\n\tSet objWMIService = Nothing\n\tSet colItems = Nothing\nEnd Function &#039;Is64\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function &#039;GetObjCtx\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function &#039;GetObjReg\n\nFunction RegKeyExists(objReg, constHive, strKey)\n\tDim objNames, objTypes, objValues, Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams)\n\t\n\tIf Outparams.ReturnValue = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\n\t&#039; Cleanup\n\tSet Inparams = Nothing\n\tSet Outparams = Nothing\t\t\nEnd Function &#039;RegKeyExists\n\nFunction GetDWordValue(objReg, constHive, strKey, strValue)\n\tDim objInParams, objOutParams\n    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n    objInParams.hDefKey = constHive\n    objInParams.sSubKeyName = strKey\n    objInParams.sValueName = strValue\n    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams)\n\tIf Not IsNull(objOutParams) Then\n\t\tIf Not IsNull(objOutParams.uValue) Then\n\t\t\tGetDWordValue = CStr(objOutParams.uValue)\n\t\tEnd If\n\tEnd If\n\t&#039; Cleanup\n\tSet objInParams = Nothing\n\tSet objOutParams = Nothing\nEnd Function &#039;GetDWordValue", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 263, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns true if the machine is part of an Active Directory domain.\nExample: TRUE, FALSE", 
      "exclude_from_parse_flag": 1, 
      "hash": 2620257697, 
      "hidden_flag": 0, 
      "id": 523, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Domain Member", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select PartofDomain from win32_ComputerSystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 264, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the current total throughput, in KB/Sec, of the network interface used to connect to the tanium server.\nExample: 2048 KB/S", 
      "exclude_from_parse_flag": 1, 
      "hash": 2623590847, 
      "hidden_flag": 0, 
      "id": 525, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Network Throughput Total", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Network Throughput Total\n&#039;========================================\n\n&#039; This sensor will use windows performance counters\n&#039; and attempt to retrieve network traffic information\n&#039; only for the interface being used to connect to the tanium server\n&#039; results are in kilobytes per second\n\nOption Explicit\n\nDim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress\nDim strComputer: strComputer = &quot;.&quot;\n\n\nDim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString\nDim objWMIService, colItems, objItem\n\n&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address\n&#039; out of WMI.  Because Name is the closest thing to match the Description\n&#039; field in the performance counter, but it&#039;s not exact due to how some\n&#039; characters are displayed, we will remove troublesome characters\n&#039; and attempt to match on that\n\n&#039; Since the entire sensor&#039;s output depends on if the two strings match, we\n&#039; can set the one string to something it won&#039;t match on (because _) to be safe\nstrDescriptionToMatch = &quot;_ImpossibleToMatch&quot;\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)\nFor Each objItem In colItems\n\tFor Each strIPAddress In objItem.IPAddress\n\t\tIf strIPAddress = strTaniumIPAddress Then\n\t\t\t&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress\n\t\t\tstrDescriptionToMatch = CleanString(objItem.Description)\n\t\t\t&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch\n\t\tEnd If\n\tNext\nNext\n\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)\n\nFor Each objItem in colItems\n\tstrNameToMatch = CleanString(objItem.Name)\n\t&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch\n\tIf LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then\n\t\t&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch\n\t\t&#039; We can now report bandwidth\n\t\tstrFinalOutputString = FormatNumber(objItem.BytesTotalPersec / 1024,0,-1) &amp; &quot; KB/S&quot;\n\tEnd If\nNext\n\nIf strFinalOutputString = &quot;&quot; Then\n\t&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client\n\tWScript.Echo &quot;Cannot determine which adapter to measure&quot;\nElse \n\tWScript.Echo strFinalOutputString\nEnd If\n\n\n&#039; Cleanup\nSet objWMIService = Nothing\nSet colItems = Nothing \nSet objItem = Nothing\n\n&#039;&#039; End Main Line\n\n&#039;&#039; Helper Functions\nFunction CleanString(strInput)\n&#039; This function will remove non-alphanumeric characters\n\tDim objRegEx\n\t\n\tSet objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)\n\t\n\tobjRegEx.Global = True   \n\tobjRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;\n\tCleanString = objRegEx.Replace(strInput, &quot;&quot;)\n\t\n\tSet objRegEx = Nothing\nEnd Function &#039;CleanString\n\nFunction GetTaniumIPAddress\n&#039; Modified from the ua-scan code to remove the subnet and last octet calculations\n&#039; which are irrelevant for these purposes.\n&#039; Returns the IP address that the client uses for Tanium activity\n&#039; (talking to server and other clients)\n\n\tDim strComputer, objReg, strCommand, objShell, objScriptExec\n\tDim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords\n\tDim strIPAddress, strTaniumPath, strClientAddress\n\tDim strServerName\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\tConst HKLM = &amp;h80000002\n\t\n\t\t\n\t&#039;&#039;###########Get Tanium Key on 64/32bit computers##########\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\t\n\t&#039; if we can pull this from the registry (newer client version), just use that\n\tobjReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\\Status&quot;, &quot;ClientAddress&quot;, strClientAddress\n\tIf strClientAddress &lt;&gt; &quot;&quot; Then\n\t\tstrClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)\n\t\tstrClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))\n\t\t&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;\n\t\tGetTaniumIPAddress = strClientAddress\n\t\t&#039;Cleanup\n\t\tSet objReg = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\t&#039;Otherwise use PathPing to determine client IP used by Tanium\n\n\t&#039;&#039;# Read the ServerName value\n\n\tobjReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName\n\n\tstrCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\tstrResults = objScriptExec.StdOut.ReadAll\n\t\n\tarrPathPingLines = Split(strResults, vbCrLf)\n\tFor Each strPathPingLine In arrPathPingLines\n\t\tarrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)\n\t\tIf UBound(arrPathPingWords) &gt; 0 Then\n\t\t\tIf arrPathPingWords(0) = &quot;0&quot; Then\n\t\t\t\tstrIPAddress = arrPathPingWords(1)\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tEnd If\t\n\tNext\n\t\n\tSet objShell = Nothing\n\tSet objScriptExec = Nothing\n\tSet objReg = Nothing\n\n\tIf Not IsNull(strIPAddress) Then\n\t\tGetTaniumIPAddress = strIPAddress\n\tElse\n\t\tGetTaniumIPAddress = False\n\tEnd If\nEnd Function &#039;GetTaniumIPAddress\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction CleanWhitespace(strStarter)\n\tDim intStarter, i, strChars\n\tintStarter = Len(strStarter)\n\tFor i = intStarter to 2 Step -1\n\t\tstrChars = Space(i)\n\t\tstrStarter = Replace(strStarter, strChars, &quot; &quot;)\n\tNext\n\tCleanWhitespace = strStarter\nEnd Function &#039;CleanWhiteSpace", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 265, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns data about percent of packet loss on Windows machines.\nExample: 5 %", 
      "exclude_from_parse_flag": 1, 
      "hash": 2648511780, 
      "hidden_flag": 0, 
      "id": 527, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Packet Loss", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Packet Loss\n&#039;========================================\n\n&#039; This sensor looks at TCP-level performance counters and\n&#039; does some basic math to determine a packet loss percentage\n\n\nOption Explicit\n\nDim objWMIService,colItems\nDim objItem,strFinalOutputString\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_TCPv4&quot;,,48)\n\nFor Each objItem in colItems\n\tIf (objItem.SegmentsRetransmittedPersec &gt; 0 AND objItem.SegmentsPerSec &gt; 0) Then\n\t\tstrFinalOutputString = FormatNumber(objItem.SegmentsRetransmittedPersec / objItem.SegmentsPerSec * 100,0,-1) &amp; &quot; %&quot;\n\t\tWScript.Echo strFinalOutputString\n\tElse\n\t\tWScript.Echo &quot;Cannot determine packet loss&quot;\n\tEnd If\n\t\nNext\n\n&#039; Cleanup\nSet objWMIService = Nothing\nSet colItems = Nothing \nSet objItem = Nothing", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 266, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns local accounts and number of days ago that the password was changed.\nExample:\nuser.name|19", 
      "exclude_from_parse_flag": 1, 
      "hash": 2680423840, 
      "hidden_flag": 0, 
      "id": 529, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Local Account Last Password Change Days Ago", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Local Account Last Password Change Days Ago\n&#039;========================================\n\n\nOption Explicit\n\nDim objAccounts,objUser,dtmLastPasswordChangeDate,intDaysSince\nDim strChangeDate,strSep\n\n\nstrSep = &quot;|&quot;\n&#039; Multi-column output\n&#039; Account Name|Days Since Last Password Change\nSetLocale(1033) &#039;Uses RFC822, requires US/English\n\nOn Error Resume Next\n\nSet objAccounts = GetObject(&quot;WinNT://.&quot;)\nobjAccounts.Filter = Array(&quot;User&quot;)\n\nFor Each objUser In objAccounts\n\tOn Error Resume Next\n\tdtmLastPasswordChangeDate = GetObject(&quot;WinNT://./&quot;&amp;objUser.Name).PasswordAge\n\tIf IsNull(objUser.PasswordAge) Then\n\t\tWscript.Echo objUser.Name&amp;strSep&amp;&quot;N/A&quot;\n\tElse\n\t\tdtmLastPasswordChangeDate = DateAdd(&quot;s&quot;, -objUser.PasswordAge, Now())\n\t\tintDaysSince = Abs(DateDiff(&quot;d&quot;,Now(),dtmLastPasswordChangeDate))\n\t\tstrChangeDate = vbTimeToRFC822(dtmLastPasswordChangeDate,GetRFC822Bias)\n\t\tOn Error Resume Next\n\t\tIf objUser.PasswordAge = 0 Then\n\t\t\tintDaysSince = &quot;Never&quot;\n\t\tEnd If\n\t\tOn Error Goto 0\n\t\tWscript.Echo objUser.Name&amp;strSep&amp;intDaysSince\n\tEnd If\nNext\n\n\n\nFunction vbTimeToRFC822(myDate, offset)\n&#039;SetLocale outside of function in global scope\n&#039; must be set so that month is displayed with US/English abbreviations\n&#039; as per the standard\n\n\tIf Not GetLocale = 1033 Then\n\t\tWScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;\n\t\tWScript.Quit\n\tEnd If\n   Dim myDay, myDays, myMonth, myYear\n   Dim myHours, myMinutes, myMonths, mySeconds\n\n   myDate = CDate(myDate)\n   myDay = WeekdayName(Weekday(myDate),true)\n   myDays = zeroPad(Day(myDate), 2)\n   myMonth = MonthName(Month(myDate), true)\n   myYear = Year(myDate)\n   myHours = zeroPad(Hour(myDate), 2)\n   myMinutes = zeroPad(Minute(myDate), 2)\n   mySeconds = zeroPad(Second(myDate), 2)\n\n   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _\n                                  myDays&amp;&quot; &quot;&amp; _\n                                  myMonth&amp;&quot; &quot;&amp; _ \n                                  myYear&amp;&quot; &quot;&amp; _\n                                  myHours&amp;&quot;:&quot;&amp; _\n                                  myMinutes&amp;&quot;:&quot;&amp; _\n                                  mySeconds&amp;&quot; &quot;&amp; _ \n                                  offset\nEnd Function &#039;vbTimeToRFC822\n\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function\n\nFunction GetRFC822Bias\n&#039; This function returns a string which is a \n&#039; timezone bias for RFC822 format\n&#039; considers daylight savings\n&#039; we choose 4 digits and a sign (+ or -)\n\n\tDim objWMIService,colTimeZone,objTimeZone\n\t\n\tDim intTZBiasInMinutes,strSign,strReturnString\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n\t \n\tFor Each objTimeZone in colTimeZone\n\t    intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n\tNext\n\n\t&#039; The offset is explicitly signed\n\tIf intTZBiasInMinutes &lt; 0 Then\n\t\tstrSign = &quot;-&quot;\n\tElse\n\t\tstrSign = &quot;+&quot;\n\tEnd If\n\t\n\tstrReturnString = CStr(Abs(intTZBiasInMinutes))\n\t&#039; no offset is greater than three digits but RFC822 bias seems to\n\t&#039; usually take the form of 1 alpha / 4 digit as described as \n\t&#039; valid in ANSI X3.51-1975\n\n\tstrReturnString = zeroPad(strReturnString,4)\n\n\tGetRFC822Bias = strSign&amp;strReturnString\n\t\n\t&#039;Cleanup\n\tSet colTimeZone = Nothing\n\tSet objWMIService = Nothing\n\t\nEnd Function &#039;GetRFC822Bias", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Account Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Days Since Last Password Change", 
            "value_type": "NumericInteger"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 267, 
      "category": "PowerShell", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the version(s) of PowerShell installed on a system\nExample: 2.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 2704923764, 
      "hidden_flag": 0, 
      "id": 531, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "PowerShell Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; PowerShell Version\n&#039;========================================\n\nOption Explicit\n\nConst HKEY_LOCAL_MACHINE = &amp;H80000002 \nDim objReg\nDim strKeyPath,arrValueNames,arrValueTypes,i,strValue,strValue3,strKey3Path\nDim bV1orV2NotFound, bV3NotFound\n\nSet objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp;_  \n\t&quot;.\\root\\default:StdRegProv&quot;)\nstrKeyPath = &quot;Software\\Microsoft\\PowerShell\\1\\PowerShellEngine&quot;\nstrKey3Path = &quot;Software\\Microsoft\\PowerShell\\3\\PowerShellEngine&quot;\n\n&#039; for powershell 1 or 2\nobjReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,&quot;PowerShellVersion&quot;,strValue\nbV1orV2NotFound = False\nIf Not IsNull(strValue) Then\n\tSelect Case strValue\n\t\tCase &quot;1.0&quot;\n\t\t\tWScript.Echo strValue\n\t\tCase &quot;2.0&quot;\n\t\t\tWScript.Echo strValue \n\t\tCase Else\n\t\t\tbV1orV2NotFound = True\n\tEnd Select\nEnd If\n\nbV3NotFound = False\n&#039; for powershell 3.0\nobjReg.GetStringValue HKEY_LOCAL_MACHINE,strKey3Path,&quot;PowerShellVersion&quot;,strValue3\nIf Not IsNull(strValue3) Then\n\tSelect Case strValue3\n\t\tCase &quot;3.0&quot;\n\t\t\tWScript.Echo strValue3\n\t\tCase Else\n\t\t\tbV3NotFound = True\n\tEnd Select\nEnd If\n\t \nIf (bV1orV2NotFound And bV3NotFound) Or ( IsNull(strValue) And IsNull(strValue3) ) Then \n\tWScript.Echo &quot;PowerShell Not Installed&quot;\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 268, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns printers which are not connected via Network\nExample: HP LaserJet 4400c", 
      "exclude_from_parse_flag": 1, 
      "hash": 2706539957, 
      "hidden_flag": 0, 
      "id": 533, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Local Printers", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select DriverName from Win32_Printer where Network = False", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 269, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns the Forward Peers and Backwards Peers returned by the server with which the client should communicate.\nExample: 10.0.0.1:17472, 10.0.02:17472 | 10.0.0.10:17472", 
      "exclude_from_parse_flag": 1, 
      "hash": 2735360016, 
      "hidden_flag": 0, 
      "id": 535, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Tanium Client Neighborhood", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Neighborhood List\n&#039;========================================\n\nOption Explicit\n\nConst INCLUDE_PORTS = False\n\nDim strClientIPAddress, strNeighborhoodList\nDim arrIPs, strIP, strPort, bReachedMe, strBackwards, strForwards\n\nstrClientIPAddress = Trim(GetClientIPAddress())\nstrNeighborhoodList = Trim(GetNeighborhoodList())\n\nIf(strClientIPAddress = &quot;&quot;) Then \n\tWScript.Echo &quot;Error:  Client IP Address Not Found&quot;\n\tWScript.Quit\nEnd If\n\nIf(strNeighborhoodList = &quot;&quot;) Then \n\tWScript.Echo &quot;Error:  Neighborhood List Not Found&quot;\n\tWScript.Quit\nEnd If\n\narrIPs = Split(strNeighborhoodList, &quot;,&quot;)\nstrBackwards = &quot;&quot;\nstrForwards = &quot;&quot;\nbReachedMe = False\nFor Each strIP In arrIPs\n\tstrIP = Trim(strIP)\n\tstrPort = GetIPPort(strIP)\n\tIf strIP = strClientIPAddress Then \n\t\tbReachedMe = True\n\tElseIf strPort &lt;&gt; &quot;0&quot; Then \t\n\t\tIf Not bReachedMe Then \n\t\t\tstrBackwards = strBackwards &amp; GetReadableIPs(strIP) &amp; &quot; &quot;\n\t\tElseIf bReachedMe Then \n\t\t\tstrForwards = strForwards &amp; GetReadableIPs(strIP) &amp; &quot; &quot;\n\t\tEnd If\n\tEnd If\nNext\n\nstrBackwards = Replace(Trim(strBackwards), &quot; &quot;, &quot;,&quot;)\nstrForwards = Replace(Trim(strForwards), &quot; &quot; , &quot;,&quot;)\n\n\nWScript.Echo strBackwards &amp; &quot;|&quot; &amp; strForwards\n\n&#039;----------End Main Line-----------&#039;\n\nFunction GetReadableIPs(strIPs)\n\tDim arrFront, arrIPInfo, strPort, strResult\n\tarrFront = Split(strIPs,&quot;_&quot;)\n\tarrIPInfo = Split(arrFront(0), &quot;:&quot;)\n\tstrPort = arrIPInfo(1)\n\t\n\tIf INCLUDE_PORTS Then \n\t\tstrResult = arrIPInfo(2) &amp; &quot;:&quot; &amp; strPort\n\tElse \n\t\tstrResult = arrIPInfo(2)\n\tEnd If \n\n\tGetReadableIPs = strResult\nEnd Function &#039; GetReadableIPs\n\nFunction GetIPPort(strIPs)\n\tDim arrFront, arrIPInfo, strPort\n\tarrFront = Split(strIPs,&quot;_&quot;)\n\tarrIPInfo = Split(arrFront(0), &quot;:&quot;)\n\tstrPort = arrIPInfo(1)\n\t\n\tGetIPPort = strPort\nEnd Function &#039; GetIPPort\n\nFunction GetClientIPAddress()\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strTaniumRegistryKey, strComputer, strClientIPAddress\n\tDim objReg\n\t\n\t&#039; Set up access to registry via WMI\n\tstrComputer = &quot;.&quot;\n\t\n\tSet objReg = _\n\t\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\n\tstrTaniumRegistryKey = GetTaniumRegistryPath() &amp; &quot;\\Status&quot;\n\n\tobjReg.GetStringValue HKLM, strTaniumRegistryKey, &quot;ClientAddress&quot;, strClientIPAddress\n\t\n\tIf Not IsNull(strClientIPAddress) Then\n\t\tGetClientIPAddress = strClientIPAddress\n\tElse\n\t\tGetClientIPAddress = &quot;&quot;\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objReg = Nothing\n\n\nEnd Function &#039; GetClientIPAddress\n\nFunction GetNeighborhoodList()\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strTaniumRegistryKey, strComputer, strNeighborhoodList\n\tDim objReg\n\t\n\t&#039; Set up access to registry via WMI\n\tstrComputer = &quot;.&quot;\n\t\n\tSet objReg = _\n\t\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\n\tstrTaniumRegistryKey = GetTaniumRegistryPath() &amp; &quot;\\Status&quot;\n\n\tobjReg.GetStringValue HKLM, strTaniumRegistryKey, &quot;NeighborhoodList&quot;, strNeighborhoodList\n\t\n\tIf Not IsNull(strNeighborhoodList) Then\n\t\tGetNeighborhoodList = strNeighborhoodList\n\tElse\n\t\tGetNeighborhoodList = &quot;&quot;\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objReg = Nothing\nEnd Function &#039;GetLogLevel\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Backwards", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Forwards", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 270, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the name of the Primary System Owner on Windows.  This  is set at OS install time.\nExample: John Doe", 
      "exclude_from_parse_flag": 1, 
      "hash": 2753029185, 
      "hidden_flag": 0, 
      "id": 537, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Primary Owner Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select PrimaryOwnerName from win32_ComputerSystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 271, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Currently configured language for the BIOS.\nExample: en|US|iso8859-1", 
      "exclude_from_parse_flag": 1, 
      "hash": 2759217311, 
      "hidden_flag": 0, 
      "id": 539, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "BIOS Current Language", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select CurrentLanguage from win32_BIOS", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 272, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the maximum amount of memory, in Kilobytes, that a process can use.  This may be free physical RAM and virtual RAM combined, or may be an arbitrary upper ceiling.\nExample: 2097024", 
      "exclude_from_parse_flag": 1, 
      "hash": 276664624, 
      "hidden_flag": 0, 
      "id": 541, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Maximum Process Memory Size", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select MaxProcessMemorySize from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 273, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The number of seconds it took to download and complete the Action once a Client first sees the Action.\nExample: 300 seconds", 
      "exclude_from_parse_flag": 0, 
      "hash": 2758038984, 
      "hidden_flag": 0, 
      "id": 543, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 60, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Tanium Client Action Timing", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\d+\",\"helpString\":\"Numbers only\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the Action ID number as seen in the Action History\",\"value\":\"\",\"promptText\":\"e.g. 1234\",\"defaultValue\":\"\",\"label\":\"Action ID number\",\"maxChars\":0,\"key\":\"strId\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Action Timing\n&#039;========================================\n\nstrId = unescape(&quot;||strId||&quot;)\n\nstrDownloadPath =  GetTaniumDir(&quot;Downloads&quot;)\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nstrActionLog = strDownloadPath &amp; &quot;action_&quot; &amp; strId &amp; &quot;.log&quot;\n\nConst ForReading = 1\n\n\nIf fso.FileExists(strActionLog) Then\n\tSet objReadLog = fso.OpenTextFile(strActionLog, ForReading)\n\n\tdim strLine\n\n\tDo Until objReadLog.AtEndOfStream\n\t    strLine = objReadLog.ReadLine\n\tLoop\n\n\tobjReadLog.Close\n\n\tif instr(strLine, &quot;Command Completed&quot;) &gt; 0 Then\n\t\tSet objLog = fso.GetFile(strActionLog)\n\t\tdCreated = objLog.DateCreated\n\t\tdModified = objLog.DateLastModified\n\t\tWscript.echo DateDiff(&quot;s&quot;, dCreated, dModified) &amp; &quot; seconds&quot;\n\telse\n\t\tWscript.echo &quot;Action in process&quot;\n\tEnd if\nElse\n\tWscript.echo &quot;Action does not exist&quot;\nEnd If\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;strId&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\d+&quot;,&quot;helpString&quot;:&quot;Numbers only&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter the Action ID number as seen in the Action History&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strId||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;strId&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\d+&quot;,&quot;helpString&quot;:&quot;Numbers only&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter the Action ID number as seen in the Action History&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strId||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 274, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "A sensor to return patch history for a certain number of days prior.\nExample: GUID|Operation|Result|Exception|Install Date|Publish Date|Title|First Needed Date|Severity|MS ID|KB|CVE ID|Size", 
      "exclude_from_parse_flag": 1, 
      "hash": 2779050471, 
      "hidden_flag": 0, 
      "id": 545, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Patch History Details", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to show patch history for.\",\"value\":\"7\",\"defaultValue\":\"7\",\"snapInterval\":1,\"label\":\"Show past days\",\"minimum\":1,\"key\":\"DaysOldLimit\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"},{\"helpString\":\"Choose whether to show the patch history in local time or not (UTC time)\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Show Local Install Time (not UTC)\",\"key\":\"ShowInLocalTime\",\"values\":[\"Yes\",\"No\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patch History Details\n&#039;========================================\n\n&#039; sensor: patch history details\n&#039; this will show the full patch history of a machine\n&#039; This is a multi-column sensor whose output looks like:\n&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|Tanium Unique ID|Patched By\n\nOption Explicit\n\nConst FORREADING = 1\n\nDim objFSO,objTextFile\nDim strToolsDir,strScanDir,intDaysOldLimit,strDaysOldLimit\nDim strHistoryTextReadableFilePath,strShowInLocalTime\nDim strSep : strSep = &quot;|&quot;\nDim strSep2 : strSep2 = &quot;&amp;&amp;&quot;\nDim strLine,arrLine,strColumn2,dtmInstallDateLocal,intDaysOld\nDim bShowInLocalTime,bUTCDateTime,bMalformedLines,intLineCount\nDim dictInstalledResultsData,intHoursThresholdToConsiderMatched\n\nSetLocale(GetTaniumLocale) &#039; uses date math\n\n&#039; This value is used to determine whether an entry in the API history matches\n&#039; a similar entry in the tanium installed by. If the times are within this range\n&#039; we consider the update performed by tanium in this history printout.\nintHoursThresholdToConsiderMatched = 2\n&#039; days old parameter\nstrDaysOldLimit=Trim(Unescape(&quot;||DaysOldLimit||&quot;))\n\nIf IsNumeric(strDaysOldLimit) Then\n\tintDaysOldLimit = CInt(strDaysOldLimit)\nElse\n\tWScript.Echo &quot;Error: Days Old Limit parameter must be a number&quot;\n\tWScript.Quit\nEnd If\n\n&#039; show local time parameter\n&#039; a customer may want UTC display\nstrShowInLocalTime=Trim(Unescape(&quot;||ShowInLocalTime||&quot;))\n\nSelect Case LCase(strShowInLocalTime)\n\tCase &quot;yes&quot;\n\t\tbShowInLocalTime = True\n\tCase &quot;true&quot;\n\t\tbShowInLocalTime = True\n\tCase &quot;no&quot;\n\t\tbShowInLocalTime = False\n\tCase &quot;false&quot;\n\t\tbShowInLocalTime = False\n\tCase &quot;&quot;\n\t\tbShowInLocalTime = True\n\tCase Else\n\t\tWScript.Echo &quot;Error: Show Local Time Parameter must be Yes or No&quot;\n\t\tWScript.Quit\nEnd Select\n\nbMalformedLines = False\nSet objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)\nstrToolsDir = GetTaniumDir(&quot;Tools&quot;)\nstrScanDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\n\nstrHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;\n\nIf Not objFSO.FileExists(strHistoryTextReadableFilePath) Then\n\tWScript.Echo &quot;Cannot find History file&quot;\n\tSet objFSO = Nothing\n\tWScript.Quit\nEnd If\n\nSet dictInstalledResultsData = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nGetInstalledResultsData dictInstalledResultsData\n\nintLineCount = 0\n&#039; read History into dictionary\nSet objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)\nWhile objTextFile.AtEndOfStream = False\n\tstrLine = objTextFile.ReadLine\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t&#039; 15 History Columns\n\t&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|Tanium Unique ID|Applied By\n\tarrLine = Split(strLine,strSep)\n\t\tIf IsArray(arrLine) Then\n\t\t\tIf UBound(arrLine) &gt; 10 Then\n\t\t\t\tOn Error Resume Next\n\t\t\t\tbUTCDateTime = arrLine(4)\n\t\t\t\tdtmInstallDateLocal = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)\n\t\t\t\tIf bShowInLocalTime Then\t\t\t\n\t\t\t\t&#039; Convert from UTC to Local replace the line\t\t\t\t\t\t\n\t\t\t\t\tstrLine = Replace(strLine,arrLine(4),dtmInstallDateLocal)\n\t\t\t\t\tOn Error Goto 0\n\t\t\t\tEnd If\n\t\t\t\t&#039; Ignore first needed and superseded lines\n\t\t\t\tstrColumn2 = Trim(LCase(arrLine(1)))\n\t\t\t\tIf Not (strColumn2 = &quot;firstneeded&quot; Or strColumn2 = &quot;superseded&quot;) Then\n\t\t\t\t\tintLineCount = intLineCount + 1\n\t\t\t\t\t&#039; do not echo if the days old is older than the max days on input\n\t\t\t\t\tintDaysOld = Abs(DateDiff(&quot;d&quot;,Now(),dtmInstallDateLocal))\n\t\t\t\t\tIf intDaysOld &lt; intDaysOldLimit Then\n\t\t\t\t\t\tDim strInstallResultsTime\n\t\t\t\t\t\t&#039; we have a value to write, check if it was our update\n\t\t\t\t\t\tIf dictInstalledResultsData.Exists(arrLine(0)) Then\n\t\t\t\t\t\t\t&#039; GUID on history line matched an install result\n\t\t\t\t\t\t\t&#039; each guid in the install result may not be unique, so lines\n\t\t\t\t\t\t\t&#039; are concatenated into the single dictionary entry\n\t\t\t\t\t\t\tDim strInstallHistoryEntry,arrInstallHistoryLine\n\t\t\t\t\t\t\tFor Each strInstallHistoryEntry In Split(dictInstalledResultsData.Item(arrLine(0)),strSep2)\n\t\t\t\t\t\t\t\tarrInstallHistoryLine = Split(strInstallHistoryEntry,strSep)\n\t\t\t\t\t\t\t\tIf arrLine(1) = &quot;Installation&quot; Then\n\t\t\t\t\t\t\t\t\tDim strDateFromInstallHistory\n\t\t\t\t\t\t\t\t\tstrDateFromInstallHistory = arrInstallHistoryLine(1)\n\t\t\t\t\t\t\t\t\tIf IsDate(strDateFromInstallHistory) And IsDate(arrLine(4)) Then\n\t\t\t\t\t\t\t\t\t\tIf Abs(DateDiff(&quot;h&quot;,strDateFromInstallHistory,arrLine(4))) &lt;= intHoursThresholdToConsiderMatched Then\n\t\t\t\t\t\t\t\t\t\t\tbTanium = True\n\t\t\t\t\t\t\t\t\t\tEnd If\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tElse\n\t\t\t\t\t\t\t\t\t\t&#039; WScript.Echo &quot;No possible date match - &quot; &amp; strDateFromInstallHistory &amp;&quot; - &quot; &amp; arrLine(4)\n\t\t\t\t\t\t\t\t\tEnd If\n\t\t\t\t\t\t\t\tEnd If\n\t\t\t\t\t\t\tNext\n\t\t\t\t\t\t\tWScript.Echo strLine&amp;strSep&amp;&quot;Tanium&quot;\n\t\t\t\t\t\t\tbTanium = False\n\t\t\t\t\t\tElse\n\t\t\t\t\t\t\tWScript.Echo strLine&amp;strSep&amp;&quot;Unsure&quot;\n\t\t\t\t\t\tEnd If\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\tbMalformedLines = True\n\t\t\t\t&#039;WScript.Echo &quot;History Line malformed - needs 11 fields&quot;\n\t\t\tEnd If\n\t\tElse\n\t\t\tbMalformedLines = True\n\t\t\t&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable\n\t\tEnd If\n\tEnd If\nWend\nIf intLineCount = 0 Then WScript.Echo &quot;No patch actions in history&quot;\n\n&#039; If bMalformedLines Then WScript.Echo &quot;History file had malformed line(s)&quot;\n\nobjTextFile.Close\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale\n\nFunction GetTZBias\n&#039; This functiong returns the number of minutes\n&#039; (positive or negative) to add to current time to get UTC\n&#039; considers daylight savings\n\n\tDim objLocalTimeZone, intTZBiasInMinutes\n\n\n\tFor Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)\n\t\tintTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone\n\tNext\n\n\tGetTZBias = intTZBiasInMinutes\n\t\t\nEnd Function &#039;GetTZBias\n\nSub GetInstalledResultsData(ByRef dictInstalledResultsData)\n\t&#039; build patch install results, by GUID\n\tDim strInstalledResultsTextReadablePath,objResultsFile\n\tDim strLine,arrLine,objFSO\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\tstrInstalledResultsTextReadablePath = strScanDir&amp;&quot;installedresultsreadable.txt&quot;\n\tIf objFSO.FileExists(strInstalledResultsTextReadablePath) Then\n\t\tSet objResultsFile = objFSO.OpenTextFile(strInstalledResultsTextReadablePath,1,False) &#039; do not create\n\t\tDo Until objResultsFile.AtEndOfStream = True\n\t\t\tstrLine = objResultsFile.ReadLine\n\t\t\tarrLine = Split(strLine,strSep)\n\t\t\tIf IsArray(arrLine) Then\n\t\t\t\tIf UBound(arrLine) &gt; 0 Then\n\t\t\t\t\t&#039; GUID is first entry, result is final entry\n\t\t\t\t\tIf Not dictInstalledResultsData.Exists(arrLine(0)) Then\n\t\t\t\t\t\tdictInstalledResultsData.Add arrLine(0),Replace(strLine,arrLine(0)&amp;strSep,&quot;&quot;)\n\t\t\t\t\tElse\n\t\t\t\t\t\t&#039; duplicate entry\n\t\t\t\t\t\tstrLine = strLine&amp;strSep2&amp;dictInstalledResultsData.Item(arrLine(0))\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tLoop\n\tEnd If\n\tobjResultsFile.Close\n\t\nEnd Sub &#039;GetInstalledResultsData", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;DaysOldLimit&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to show patch history for.&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Show past days&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;key&quot;:&quot;ShowInLocalTime&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Choose whether to show the patch history in local time or not (UTC time)&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Local Install Time (not UTC)&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||ShowInLocalTime||  ||DaysOldLimit||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;DaysOldLimit&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to show patch history for.&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Show past days&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;key&quot;:&quot;ShowInLocalTime&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Choose whether to show the patch history in local time or not (UTC time)&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Local Install Time (not UTC)&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||ShowInLocalTime||  ||DaysOldLimit||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "GUID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Operation", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Result", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Exception", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Install Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Publish Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 7, 
            "name": "First Needed Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 8, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 9, 
            "name": "MS ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 10, 
            "name": "KB", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 11, 
            "name": "CVE ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 12, 
            "name": "Size", 
            "value_type": "DataSize"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 13, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 14, 
            "name": "Patched By", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 275, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the names of network adapters that are active.\nExample: VMware Accelerated AMD PCNet Adapter", 
      "exclude_from_parse_flag": 1, 
      "hash": 2783988057, 
      "hidden_flag": 0, 
      "id": 547, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Network Adapter Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Name from win32_networkadapter where NetConnectionStatus=2", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\nlspci | grep Ethernet | awk -F&#039;Ethernet controller: &#039; &#039;{print $2}&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 276, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns whether the machine is a Mac.  True if so, False if not.\nExample: True", 
      "exclude_from_parse_flag": 0, 
      "hash": 2800817874, 
      "hidden_flag": 0, 
      "id": 549, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Is Mac", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Is Mac\n&#039;========================================\n\nWscript.echo &quot;False&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\necho False\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\necho True\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 277, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the time the last reboot occurred.\nExample: 2012-12-11 09:01", 
      "exclude_from_parse_flag": 1, 
      "hash": 2811135310, 
      "hidden_flag": 0, 
      "id": 551, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Last Reboot", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last Reboot\n&#039; (See also OS Boot Time)\n&#039;========================================\n\n&#039; This sensor will return the time the OS booted up\n\nOption Explicit\n\nDim dateBootTime, strFinalOutputString, strSep\n&#039; Force output in a specific time format\nSetLocale(1033)\n\nstrSep = &quot;|&quot;\ndateBootTime = GetBootTime\n\nWScript.Echo Year(dateBootTime) &amp; &quot;-&quot; &amp; zeroPad(Month(dateBootTime),2) &amp; &quot;-&quot; &amp; zeroPad(Day(dateBootTime),2) &amp; &quot; &quot; &amp; FormatDateTime(dateBootTime,vbShortTime)\n\n&#039;-----------End Main-------------&#039;\n\nFunction zeroPad(m, t)\n\tzeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function &#039;zeroPad\n  \nFunction GetBootTime\n&#039; Retrieves a nicely formatted bootup time\n    Dim objSWbemDateTime\n    Dim objWMIService\n    Dim colOperatingSystems\n    Dim objOperatingSystem\n    Dim strComputer\n    Dim colTimeZone\n    Dim objTimeZone\n    Dim intTZBiasInMinutes\n    Dim dateBootTime\n    \n    strComputer = &quot;.&quot;\n    \n    Set objSWbemDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n    Set colOperatingSystems = objWMIService.ExecQuery (&quot;Select * from Win32_OperatingSystem&quot;)\n     \n    For Each objOperatingSystem in colOperatingSystems\n        objSWbemDateTime.Value = objOperatingSystem.LastBootUpTime\n        dateBootTime = CDate(objSWbemDateTime.GetVarDate(False))\n    Next\n\n    &#039; Now to correct for time zones \n    Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n     \n    For Each objTimeZone in colTimeZone\n        intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n        dateBootTime = DateAdd(&quot;n&quot;, intTZBiasInMinutes, dateBootTime)\n    Next\n\n    \n    &#039;return result\n    GetBootTime = dateBootTime\n    \n    &#039;Cleanup\n    Set objSWbemDateTime = Nothing\n    Set objWMIService = Nothing\n    Set colOperatingSystems = Nothing\n    Set colTimeZone = Nothing\n\nEnd Function &#039;GetBootTime", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nline=$(who -b)\nset -- $line\necho ${line#*&quot;boot&quot;}\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ntemp=$(who -b | awk -F&#039;~ &#039; &#039; /reboot/ { print $2 } &#039;)\necho $temp\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 278, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the time offset in minutes. Example: -0700", 
      "exclude_from_parse_flag": 0, 
      "hash": 2811171321, 
      "hidden_flag": 0, 
      "id": 553, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Time Zone Offset", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Time Zone Offset\n&#039;========================================\n\nOption Explicit\n\nWScript.Echo GetRFC822Bias\n\nFunction GetRFC822Bias\n&#039; This function returns a string which is a \n&#039; timezone bias for RFC822 format\n&#039; considers daylight savings\n&#039; we choose 4 digits and a sign (+ or -)\n\n\tDim objWMIService,colTimeZone,objTimeZone\n\t\n\tDim intTZBiasInMinutes,strSign,strReturnString\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n\t \n\tFor Each objTimeZone in colTimeZone\n\t    intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n\tNext\n\n\t&#039; The offset is explicitly signed\n\tIf intTZBiasInMinutes &lt; 0 Then\n\t\tstrSign = &quot;-&quot;\n\tElse\n\t\tstrSign = &quot;+&quot;\n\tEnd If\n\t\n\tstrReturnString = CStr(Abs(intTZBiasInMinutes))\n\t&#039; no offset is greater than three digits but RFC822 bias seems to\n\t&#039; usually take the form of 1 alpha / 4 digit as described as \n\t&#039; valid in ANSI X3.51-1975\n\n\tstrReturnString = zeroPad(strReturnString,4)\n\n\tGetRFC822Bias = strSign&amp;strReturnString\n\t\n\t&#039;Cleanup\n\tSet colTimeZone = Nothing\n\tSet objWMIService = Nothing\n\t\nEnd Function &#039;GetRFC822Bias\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\necho `date +%z`\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\necho `date +%z`\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 279, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the creation date of the file specified by the parameter.\nExample: 12-12-2014 18:00", 
      "exclude_from_parse_flag": 1, 
      "hash": 2812601404, 
      "hidden_flag": 0, 
      "id": 555, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "File Creation Date", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the file path and name to search for.\",\"value\":\"\",\"promptText\":\"e.g. c:\\\\windows\\\\test.txt\",\"defaultValue\":\"\",\"label\":\"File path and name to search for\",\"maxChars\":0,\"key\":\"filename\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; File Creation Date\n&#039;========================================\n\nOption Explicit\n\nSetLocale(1033)\n\nDim filesys, filename, file, createdate \n\nfilename = unescape(&quot;||filename||&quot;)\n&#039;filename = &quot;c:\\windows\\regedit.exe&quot;\n\nfilename = FixFileSystemRedirectionForPath(filename)\n\nSet filesys = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nIf filesys.FileExists(filename) Then\n   Set file = filesys.GetFile(filename)\n   createdate = file.DateCreated\n   WScript.Echo FormatDateTime(createdate, vbShortDate) &amp; &quot; &quot; &amp; FormatDateTime(createdate, vbShortTime)\nElse\n   WScript.Echo &quot;File &quot; &amp; filename &amp; &quot; not found.&quot;\nEnd If\n\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n    \n    Dim objFSO, strSystem32Location,objShell\n    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n    \n    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n        If InStr(strFilePath,strSystem32Location) = 1 Then\n            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n            strFilePath = strNewSystem32Location&amp;strRestOfPath\n        End If\n    End If\n    FixFileSystemRedirectionForPath = strFilePath\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n    Dim objFSO,strSystem32Location,strNewSystem32Location\n    \n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    \n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n    \n    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "BESDate"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 280, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns the protocol, local address / port, process name, application name, remote port, and connection state for all active IP connections on an endpoint.\nExample: tcp|192.168.95.186:51866|explorer.exe|Windows Explorer|165.254.58.66:80|established", 
      "exclude_from_parse_flag": 1, 
      "hash": 2819106613, 
      "hidden_flag": 0, 
      "id": 557, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "IP Connections", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; IP Connections\n&#039;========================================\n\n&#039;Option Explicit\n\nDim showProcess, showPort, showRemoteConnection\n\nshowProcess = True\nshowPort = True\nshowRemoteConnection = True\n\nDim strcommand, results, excludeProcesses, excludeSubnets, excludeListenPorts, excludeRemotePorts, taniumDebug\nDim strSep : strSep = &quot;|&quot;\n&#039; This is a multi-column sensor that looks like:\n&#039;Process|Name|Target IP\n\nexcludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;\n&#039;excludeProcesses = &quot;chrome.exe&quot;\n&#039;excludeProcesses = &quot;iexplore.exe&quot;\n&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;\n&#039;excludeProcesses = &quot;trillian.exe&quot;\n\nexcludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;\n&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;\n\nexcludeListenPorts = &quot;17472&quot;\n&#039; excludeListenPorts = &quot;17472,80,443&quot;\n\nexcludeRemotePorts = &quot;17472&quot;\n&#039; excludeRemotePorts = &quot;17472,80,443&quot;\n\ntaniumDebug = False\n\n\nexcludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)\nexcludeSubnets = Split(excludeSubnets, &quot;,&quot;)\nexcludeListenPorts = Split(excludeListenPorts, &quot;,&quot;)\nexcludeRemotePorts = Split(excludeRemotePorts, &quot;,&quot;)\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nquery = &quot;select name, executablepath, processId from win32_process&quot;\nSet colResults = objWMIService.ExecQuery(query)\n\n&#039;dictionary for process-app pairs\nSet processes = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nFor Each result In colResults \n   processId = CStr(result.ProcessId)\n   processPath = result.ExecutablePath\n   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later\nNext\n\n&#039; unlike established connections, shows connections in all states\nstrcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34)\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrNSResults = LCase(objScriptExec.StdOut.ReadAll)\n\nresults = Split(strNSResults, vbCrLf)\nj = 0\n\nFor Each line in results\n   line = cleanWhitespace(Trim(line))\n   \n   lineResults = Split(line)\n   i = 0\n   Dim strPort, strPid, strConnectionState, strForeignIP, strApp\n   For Each word In lineResults\n      If i = 0 Then\n         strProtocol = word   \n      ElseIf i = 1 Then\n         strLocalIP = word\n      ElseIf i = 2 Then\n         strForeignIP = word\n      ElseIf i = 3 Then\n         strConnectionState = word\n      ElseIf i = 4 Then\n         strPid = word\n      End If\n      \n      i = i + 1\n   Next\n   \n   &#039;DO NOT INCLUDE EXCLUDED APPS\n   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path\n   arrAppEntry = Split(strAppEntry,&quot;,&quot;)\n   strAppExe = arrAppEntry(0)\n   strAppPath = arrAppEntry(1)\n   \n   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))\n   \n   &#039;DO NOT INCLUDE EXCLUDED SUBNETS\n   isNotExcludedSubnet = Not(ContainedInSubnet(strForeignIP, excludeSubnets))\n   \n   &#039;DO NOT INCLUDE EXCLUDED LISTEN PORTS\n   isNotExcludedListenPort = Not(ContainedInArray(Split(strLocalIP, &quot;:&quot;)(1), excludeListenPorts))\n   \n   &#039;DO NOT INCLUDE EXCLUDED REMOTE PORTS\n   isNotExcludedRemotePort = Not(ContainedInArray(Split(strForeignIP, &quot;:&quot;)(1), excludeRemotePorts))\n   \n   If Not(IsEmpty(strAppExe)) _\n      And isNotExcludedApp _ \n      And isNotExcludedSubnet _\n      And isNotExcludedListenPort _\n      And IsNotExcludedRemotePort Then\n\n\t  If Not showPort Then \n\t  \tarrTemp = Split(strForeignIP, &quot;:&quot;)\n\t\tstrForeignIP = arrTemp(0)\n\t  End If\n   \n      If showProcess Then\n      \tresults(j) = strProtocol &amp; strSep &amp; strLocalIP &amp; strSep &amp; strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strForeignIP &amp; strSep &amp; strConnectionState\n      Else\n        results(j) = strProtocol &amp; strSep &amp; strLocalIP &amp; strSep &amp; strSep &amp; strForeignIP &amp; strSep &amp; strConnectionState\n      End If\t\n   Else\n      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIP\n      results(j) = &quot;&quot;   \n   End If \n   \n   j = j + 1\nNext\n\nresults = RemDups(results)\n\nIf UBound(results) &lt; 1 Then\n\tIf GetLocale() &lt;&gt; 1033 Then\n\t\tWScript.Echo &quot;English Language OS Required&quot;\n\tEnd If\nEnd If\n\nFor Each result In results \n   WScript.Echo result\nNext\n\nWScript.Quit\n\nFunction ContainedInSubnet(str, arr)\n   Dim strIp, strSubnet, strMask\n   temp = Split(str, &quot;:&quot;)\n   strIp = temp(0)\n\n   For Each item In arr\n      If InStr(item, &quot;-&quot;) Then &#039;Subnet range\n         temp = Split(item, &quot;-&quot;)\n         lower = Split(temp(0), &quot;:&quot;)\n         upper = Split(temp(1), &quot;:&quot;)\n         lowerSubnet = Trim(lower(0))\n         lowerMask = Trim(lower(1))\n         upperSubnet = Trim(upper(0))\n         upperMask = Trim(upper(1))\n         \n         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _\n            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If \n      Else &#039;Single subnet\n         parts = Split(item, &quot;:&quot;)\n         strSubnet = Trim(parts(0))\n         strMask = Trim(parts(1))\n         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If\n      End If \n   Next\n   ContainedInSubnet = False\nEnd Function\n\nFunction ContainedInArray(str, arr)\n   For Each item In arr \n      If str = Trim(item) Then\n         ContainedInArray = True\n         Exit Function\n      End If   \n   Next\n   ContainedInArray = False\nEnd Function\n\nFunction cleanWhitespace(strStarter)\n   intStarter = Len(strStarter)\n   For i = intStarter to 2 Step -1\n      strChars = Space(i)\n      strStarter = Replace(strStarter, strChars, &quot; &quot;)\n   Next\n   cleanWhitespace = strStarter\nEnd Function\n\nFunction RemDups(ByVal anArray)\n   Dim d, item, thekeys\n   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)\n   d.removeall\n   d.CompareMode = 0\n   For Each item In anArray\n      If Len(item) &gt; 0 Then\n         If Not d.Exists(item) Then d.Add item, item\n      End If\n   Next\n   thekeys = d.keys\n   Set d = Nothing\n   RemDups = thekeys\nEnd Function\n\nFunction Subnet(strAddress, strMask)\n   intSubnetLength = SubnetLength(strMask)\n   Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))\nEnd Function\n\nFunction SubnetLength(strMask)\n   strMaskBinary = StringToBinary(strMask)\n   SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))\nEnd Function\n\nFunction BinaryToString(strBinary)\n   For intOctetPos = 1 To 4\n      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)\n      intOctet = 0\n      intValue = 1\n      For intBinaryPos = 1 To Len(strOctetBinary)\n         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue\n         intValue = intValue * 2\n      Next\n      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)\n   Next\nEnd Function\n\nFunction StringToBinary(strAddress)\n   objAddress = Split(strAddress, &quot;.&quot;, -1)\n   For Each strOctet In objAddress\n      intOctet = CInt(strOctet)\n      strOctetBinary = &quot;&quot;\n      For x = 1 To 8\n         If intOctet Mod 2 &gt; 0 Then\n            strOctetBinary = &quot;1&quot; &amp; strOctetBinary\n         Else\n            strOctetBinary = &quot;0&quot; &amp; strOctetBinary\n         End If\n         intOctet = Int(intOctet / 2)\n      Next\n      StringToBinary = StringToBinary &amp; strOctetBinary\n   Next\nEnd Function\n\nFunction ProcessNameToApplicationName(strExecutablePath, strExecutableName)\n&#039; This function will return the full application name of a running executable\n\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\n\t\tarrPathParts = Split(strExecutablePath,&quot;\\&quot;)\n\n\t\tIf UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tSet fso = Nothing\n\t\t\tExit Function\n\t\tEnd If\n\t\tstrExecutable = arrPathParts(UBound(arrPathParts))\n\t\t\n\t\tIf fso.FileExists(strExecutablePath) Then\n\t\t\tDim strOutput, fileVersion, fileVersionOutput, fullName\n\t\t\n\t\t\tSet execFile = fso.GetFile(strExecutablePath)\n\t\t\tfullName = GetDescription(execFile.ParentFolder.Path, strExecutable)\n\t\t\tIf Not fullName = &quot;&quot; Then\n\t\t\t\tProcessNameToApplicationName = fullName\n\t\t\tElse\n\t\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tEnd If\n\t\tElse &#039; file doesn&#039;t exist or inaccessible\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\tEnd If\n\nEnd Function &#039;ProcessNameToApplicationName\n\nFunction GetDescription(folderPath, fileName)\n\tdescIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)\n\tIf IsEmpty(descIndex) Then\n\t\tdescIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)\n\tEnd If\n\tGetDescription = GetFileProperty(folderPath, fileName, descIndex)\nEnd Function\n\nFunction GetFileProperty(folderPath, fileName, fileProperty)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tGetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)\nEnd Function\n\nFunction GetAttributeIndex(folderPath, attrTarget)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tFor i = 0 to 50\n\t\tattrName = objFolder.GetDetailsOf(objFolder.Items, i)\n\t\tIf LCase(attrName) = LCase(attrTarget) Then\n\t\t\tGetAttributeIndex = i\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Protocol", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Local IP and Port", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Application", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Remote IP and Port", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Connection State", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 281, 
      "category": "Software", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns True if client machine is a guest VM in VMware.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 2823285829, 
      "hidden_flag": 0, 
      "id": 559, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "VMware Guest", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; WMware Guest\n&#039;========================================\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;,,48)\nFor Each objItem in colItems\n\tIf objItem.Model = &quot;VMware Virtual Platform&quot; Then WScript.Echo &quot;True&quot;\n\tWScript.Quit\nNext\n\nSet colItems = objWMIService.ExecQuery _\n(&quot;Select * From Win32_NetworkAdapterConfiguration Where IPEnabled = True&quot;)\nFor Each objItem in colItems\n\tIf Left(objItem.MACAddress, 8) = &quot;00:0C:29&quot; Then WScript.Echo &quot;True&quot;\n\tWScript.Quit\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\ncommout=&quot;&#039;dmidecode | awk &#039;VMware Virtual Platform/ {print $3,$4,$5}&#039; 2&gt; /dev/null&#039;&quot;\n\nif [[ &quot;$commout&quot; == *&quot;Virtual&quot;* ]]\n then\n   echo &quot;True&quot;\nelse\n   echo &quot;False&quot;\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 282, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the current inbound throughput, in KB/Sec, of the network interface used to connect to the tanium server.\nExample: 1024 KB/S", 
      "exclude_from_parse_flag": 1, 
      "hash": 2845896284, 
      "hidden_flag": 0, 
      "id": 561, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Network Throughput Inbound", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Network Throughput Inbound\n&#039;========================================\n\n&#039; This sensor will use windows performance counters\n&#039; and attempt to retrieve network traffic information\n&#039; only for the interface being used to connect to the tanium server\n&#039; results are in kilobytes per second\n\nOption Explicit\n\nDim strTaniumIPAddress: strTaniumIPAddress = GetTaniumIPAddress\nDim strComputer: strComputer = &quot;.&quot;\n\nDim strDescriptionToMatch, strNameToMatch, strIPAddress, strFinalOutputString\nDim objWMIService, colItems, objItem\n\n&#039; First we get the &quot;Name&quot; property of the adapter with our target IP address\n&#039; out of WMI.  Because Name is the closest thing to match the Description\n&#039; field in the performance counter, but it&#039;s not exact due to how some\n&#039; characters are displayed, we will remove troublesome characters\n&#039; and attempt to match on that\n\n&#039; Since the entire sensor&#039;s output depends on if the two strings match, we\n&#039; can set the one string to something it won&#039;t match on (because _) to be safe\nstrDescriptionToMatch = &quot;_ImpossibleToMatch&quot;\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_NetworkAdapterConfiguration where IPEnabled = True&quot;,,48)\nFor Each objItem In colItems\n\tFor Each strIPAddress In objItem.IPAddress\n\t\tIf strIPAddress = strTaniumIPAddress Then\n\t\t\t&#039; WScript.Echo &quot;IP Address Tanium is using: &quot; &amp; strIPAddress\n\t\t\tstrDescriptionToMatch = CleanString(objItem.Description)\n\t\t\t&#039; WScript.Echo &quot;Description to be matched: &quot; &amp; strDescriptionToMatch\n\t\tEnd If\n\tNext\nNext\n\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_Tcpip_NetworkInterface&quot;,,48)\n\nFor Each objItem in colItems\n\tstrNameToMatch = CleanString(objItem.Name)\n\t&#039; WScript.Echo &quot;Name: &quot; &amp; strNameToMatch\n\tIf LCase(strNameToMatch) = LCase(strDescriptionToMatch) Then\n\t\t&#039; WScript.Echo &quot;I have matched &quot; &amp; strNameToMatch &amp; &quot; and &quot; &amp; strDescriptionToMatch\n\t\t&#039; We can now report bandwidth\n\t\tstrFinalOutputString = FormatNumber(objItem.BytesReceivedPersec / 1024,0,-1) &amp; &quot; KB/S&quot;\n\tEnd If\nNext\n\nIf strFinalOutputString = &quot;&quot; Then\n\t&#039; The two names are too dissimilar, or can&#039;t get IP address for tanium client\n\tWScript.Echo &quot;Cannot determine which adapter to measure&quot;\nElse \n\tWScript.Echo strFinalOutputString\nEnd If\n\n\n&#039; Cleanup\nSet objWMIService = Nothing\nSet colItems = Nothing \nSet objItem = Nothing\n\n&#039;&#039; End Main Line\n\n&#039;&#039; Helper Functions\nFunction CleanString(strInput)\n&#039; This function will remove non-alphanumeric characters\n\tDim objRegEx\n\t\n\tSet objRegEx = CreateObject(&quot;VBScript.RegExp&quot;)\n\t\n\tobjRegEx.Global = True   \n\tobjRegEx.Pattern = &quot;[^A-Za-z0-9]&quot;\n\tCleanString = objRegEx.Replace(strInput, &quot;&quot;)\n\t\n\tSet objRegEx = Nothing\nEnd Function &#039;CleanString\n\nFunction GetTaniumIPAddress\n&#039; Modified from the ua-scan code to remove the subnet and last octet calculations\n&#039; which are irrelevant for these purposes.\n&#039; Returns the IP address that the client uses for Tanium activity\n&#039; (talking to server and other clients)\n\n\tDim strComputer, objReg, strCommand, objShell, objScriptExec\n\tDim strResults, arrPathPingLines, strPathPingLine, arrPathPingWords\n\tDim strIPAddress, strTaniumPath, strClientAddress\n\tDim strServerName\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\tConst HKLM = &amp;h80000002\n\t\n\t\t\n\t&#039;&#039;###########Get Tanium Key on 64/32bit computers##########\n\t\n\tstrTaniumPath = GetTaniumRegistryPath()\n\t\n\t\n\t&#039; if we can pull this from the registry (newer client version), just use that\n\tobjReg.GetStringValue HKLM, strTaniumPath &amp; &quot;\\Status&quot;, &quot;ClientAddress&quot;, strClientAddress\n\tIf strClientAddress &lt;&gt; &quot;&quot; Then\n\t\tstrClientAddress = Left(strClientAddress,InStr(strClientAddress,&quot;_&quot;)-1)\n\t\tstrClientAddress = Right(strClientAddress,len(strClientAddress)-InStrRev(strClientAddress,&quot;:&quot;))\n\t\t&#039; WScript.Echo &quot;Found &quot; &amp; strClientAddress &amp; &quot; in Registry&quot;\n\t\tGetTaniumIPAddress = strClientAddress\n\t\t&#039;Cleanup\n\t\tSet objReg = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\t&#039;Otherwise use PathPing to determine client IP used by Tanium\n\n\t&#039;&#039;# Read the ServerName value\n\n\tobjReg.GetStringValue HKLM, strTaniumPath, &quot;ServerName&quot;, strServerName\n\n\tstrCommand = &quot;pathping -4 -q 1 -w 1 -n &quot; &amp; strServerName\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objScriptExec = objShell.Exec (strCommand)\n\tstrResults = objScriptExec.StdOut.ReadAll\n\t\n\tarrPathPingLines = Split(strResults, vbCrLf)\n\tFor Each strPathPingLine In arrPathPingLines\n\t\tarrPathPingWords = Split(CleanWhitespace(Trim(strPathPingLine)), &quot; &quot;)\n\t\tIf UBound(arrPathPingWords) &gt; 0 Then\n\t\t\tIf arrPathPingWords(0) = &quot;0&quot; Then\n\t\t\t\tstrIPAddress = arrPathPingWords(1)\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tEnd If\t\n\tNext\n\t\n\tSet objShell = Nothing\n\tSet objScriptExec = Nothing\n\tSet objReg = Nothing\n\n\tIf Not IsNull(strIPAddress) Then\n\t\tGetTaniumIPAddress = strIPAddress\n\tElse\n\t\tGetTaniumIPAddress = False\n\tEnd If\nEnd Function &#039;GetTaniumIPAddress\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\n\nFunction CleanWhitespace(strStarter)\n\tDim intStarter, i, strChars\n\tintStarter = Len(strStarter)\n\tFor i = intStarter to 2 Step -1\n\t\tstrChars = Space(i)\n\t\tstrStarter = Replace(strStarter, strChars, &quot; &quot;)\n\tNext\n\tCleanWhitespace = strStarter\nEnd Function &#039;CleanWhiteSpace", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 283, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Description of the CPU.\nExample: Intel(R) Core(TM) i5-2500 CPU @ 3.30GHz", 
      "exclude_from_parse_flag": 1, 
      "hash": 2853143977, 
      "hidden_flag": 0, 
      "id": 563, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "CPU", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CPU\n&#039;========================================\n\nOption Explicit\n\nDim objWMIService, colProcessors, objProcessor\nDim strProcessorName, intProcessorSpeed\n\nSet objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\nSet colProcessors = objWMIService.ExecQuery(&quot;select Name,MaxClockSpeed from win32_processor&quot;)\n\nFor Each objProcessor in colProcessors\n\tstrProcessorName = objProcessor.Name\n\tintProcessorSpeed = CInt(objProcessor.MaxClockSpeed)\n\tIf InStr(strProcessorName, &quot;Intel Pentium III&quot;) &gt;0 And _\n\t\tLeft(GetOSMajorVersion(), 1) = &quot;5&quot; And _\n\t\tintProcessorSpeed &gt; 1000 Then \n\t\t&#039; Work around for this problem on Windows XP / Windows 2003 machines, where\n\t\t&#039; wrong value is reported for the processor type:\n\t\t&#039; http://support.microsoft.com/kb/953955\n\t\t\n\t\tstrProcessorName = &quot;Intel(R) Core(TM)2 Duo CPU&quot;\n\tEnd If \n\tWScript.Echo Trim(strProcessorName)\nNext\n\nFunction GetOSMajorVersion\n&#039; Returns the OS Major Version\n&#039; A different way to examine the OS instead of by name\n\n\tDim objWMIService,colItems,objItem\n\tDim strVersion\n\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    \n\tFor Each objItem In colItems\n\t\tstrVersion = objItem.Version &#039; like 6.2.9200\n\t\tstrVersion = Left(strVersion,Len(strVersion) - 5)\n\tNext\n\t\n\tGetOSMajorVersion = strVersion\n\t\nEnd Function &#039;GetOSMajorVersion", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nline=$(cat /proc/cpuinfo | grep &quot;model name&quot;)\nset -- $line\necho ${line#*:}\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nname=$( system_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Processor Name:/ { print $2 } &#039; )\nspeed=$( system_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Processor Speed:/ { print $2 } &#039; )\n\necho $name $speed\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 284, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Finds the specified file and provides the full path if the file exists on the client machine. Takes regular expression to match.\nExample: C:\\WINDOWS\\System32\\Notepad.exe", 
      "exclude_from_parse_flag": 1, 
      "hash": 2884431352, 
      "hidden_flag": 0, 
      "id": 565, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "McAfee"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "File Name Search with RegEx Match", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the file name only to search for\",\"value\":\"\",\"promptText\":\"e.g test.txt\",\"defaultValue\":\"\",\"label\":\"File Name\",\"maxChars\":0,\"key\":\"filename\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"restrict\":null,\"validationExpressions\":[],\"helpString\":\"Enter the regular expression to search for.\",\"value\":\"\",\"promptText\":\"e.g. test*.exe\",\"defaultValue\":\"\",\"label\":\"Regular Expression\",\"maxChars\":0,\"key\":\"regexp\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"helpString\":\"Enter Yes/No for case sensitivity of search.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Case sensitive?\",\"key\":\"casesensitive\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"},{\"helpString\":\"Enter Yes/No whether the search is global.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Global\",\"key\":\"global\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; File Name Search with RegEx Match\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\n\nSensorRandomize()\n\nDim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg\nDim bGlobal,bCaseSensitive\n\nPattern = unescape(&quot;||filename||&quot;)\nstrRegExp = Trim(Unescape(&quot;||regexp||&quot;))\nstrGlobalArg = Trim(Unescape(&quot;||global||&quot;))\nstrCaseSensitiveArg = Trim(Unescape(&quot;||casesensitive||&quot;))\n\nbGlobal = GetTrueFalseArg(&quot;global&quot;,strGlobalArg)\nbCaseSensitive = GetTrueFalseArg(&quot;casesensitive&quot;,strCaseSensitiveArg)\n\nConst SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1\n\nDim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine\n\nSet FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\nOutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir\n\n&#039; Go through file system, refresh output file for filename\nIf Not FSO.FileExists(OutputFilename) Then\n\t\n\tIf FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename\n\n\t&#039; Get the collection of local drives.\n\tSet Drives = FSO.Drives\n\tFor Each Drive in Drives\n\t\tIf Drive.DriveType = 2 Then &#039; 2 = Fixed drive\n\t\t\t&#039; Run the Dir command that looks for the filename pattern.\n\t\t\tRunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:-d /b /s&quot;, OutputFilename, true\n\t\tEnd If\n\tNext\nEnd If\n\n&#039; Open the output file, echo each line, and then close and delete it.\nSet TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)\nDo While Not TextStream.AtEndOfStream\n\tstrLine = TextStream.ReadLine()\n\tIf RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then\n\t\tWScript.Echo strLine\n\tEnd If\nLoop\n\nTextStream.Close()\n \nIf FSO.FileExists(OutputFileName) Then\n\tOn Error Resume Next\n\tFSO.DeleteFile OutputFileName, True\n\tOn Error Goto 0\nEnd If\n\nFunction RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)\n\n\tDim re\n\tSet re = New RegExp\n\tWith re\n\t  .Pattern = strPattern\n\t  .Global = bGlobal\n\t  .IgnoreCase = Not bIsCaseSensitive\n\tEnd With\n\t\n\tRegExpMatch = re.Test(strToMatch)\n\nEnd Function &#039;RegExpMatch\n\n\nFunction GetTrueFalseArg(strArgName,strArgValue)\n\t&#039; Checks for valid values, will fail with error message\n\t\n\tDim bArgVal\n\tbArgVal = False\n\tSelect Case LCase(strArgValue)\n\t\tCase &quot;true&quot;\n\t\t\tbArgVal = True\n\t\tCase &quot;yes&quot;\n\t\t\tbArgVal = True\n\t\tCase &quot;false&quot;\n\t\t\tbArgVal = False\n\t\tCase &quot;no&quot;\n\t\t\tbArgVal = False\n\t\tCase Else\n\t\t\tWScript.Echo &quot;Error: Argument &#039;&quot;&amp;strArgName&amp;&quot;&#039; must be True or False, quitting&quot;\n\t\t\tPrintUsage\n\tEnd Select\n\tGetTrueFalseArg = bArgVal\n\nEnd Function &#039;GetTrueFalseArg\n\n\n&#039; Returns the name of a temporary file in the Temp directory.\nFunction TempName()\n\tDim Result\n\tDo\n \t\tResult = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())\n\t\tWScript.Sleep 200 &#039;avoid potential busy loop\n\tLoop While FSO.FileExists(Result)\n\t\n\tTempName = Result\nEnd Function &#039;TempName\n\n&#039; Runs a command with Cmd.exe and redirects its output to a temporary\n&#039; file. The function returns the name of the temporary file that holds\n&#039; the command&#039;s output.\nFunction RunCommand(Command, OutputFilename, b64BitNecessary)\n\t&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32\n\tDim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrDOSCall = &quot;%ComSpec% /C &quot;\n\t\n\t&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection\n\tstrProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\tIf objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64\n\t\tstrDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))\n\tEnd If\n\t\t\n\tCommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)\n\tWshShell.Run CommandLine, 0, True\nEnd Function &#039;RunCommand\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n#||filename||||regexp||||casesensitive||||global||\necho Windows Only\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n#||filename||||regexp||||casesensitive||||global||\necho Windows Only\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 285, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Default web browser for new users.  Note that this can be changed per user.\nExample: Internet Explorer", 
      "exclude_from_parse_flag": 1, 
      "hash": 2932384540, 
      "hidden_flag": 0, 
      "id": 567, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Default Web Browser", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Default Web Browser\n&#039;========================================\n\n&#039; This sensor will return the name and version of the default web browser\n&#039; This is a multi-column sensor that looks like:\n&#039; Browser|Version\nOption Explicit\n\n&#039; TAG: REDIRECTION\n\nDim strSep\nstrSep = &quot;|&quot;\n\nGetDefaultWebBrowser strSep\n\nFunction GetDefaultWebBrowser(strSep)\n\n\t\n\tDim objShell, objRE, objFSO\n\tDim strComputer, strDefaultBrowserDetectionPath\n\tDim strBrowserFolder, strDefaultBrowserExecutable, objMatch\n\tDim strPrunedDefaultBrowserExecutable, strBrowserFileName\n\tDim strDescription, strVersion, strCleanDefaultBrowserExecutable\n\tDim arrBrowserCommand\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tSet objRE = New RegExp\n\n\tWith objRE\n\t    .Pattern    = Chr(34)&amp;&quot;([^&quot;&amp;Chr(34)&amp;&quot;\\r\\n]*)&quot;&amp;Chr(34) &#039; matches anything between first set of quotes\n\t    .Global     = False\n\tEnd With\n\t&#039; The default browser executable is stored in this location in the registry\t\n\t&#039; Note that this location is the same in 32 and 64 bit registry providers\n\tstrDefaultBrowserExecutable = objShell.RegRead(&quot;HKEY_CLASSES_ROOT\\http\\shell\\open\\command\\&quot;)\n\t\n\tSet objMatch = objRE.Execute(strDefaultBrowserExecutable)\n\tIf objMatch.Count = 1 Then\n\t\tstrPrunedDefaultBrowserExecutable = objMatch.Item(0)\n\tEnd If\n\t&#039; Catch case where the browser is specified without quotes and with progra~1\n\t&#039; notation\n\t&#039; The regex would have failed to produce a valid file.  Check file exists\n\t&#039; and if not, assume it&#039;s the progra~1 notation without quotes\n\t &#039;strDefaultBrowserExecutable = &quot;C:\\PROGRA~1\\MOZILL~1\\FIREFOX.EXE -requestPending -osint -url &quot; &amp; Chr(34) &amp; &quot;%1&quot; &amp; Chr(34)\n\tIf Not Left(strDefaultBrowserExecutable,1) = Chr(34) Then &#039; if it doesn&#039;t start with a quote\n\t\t&#039; WScript.Echo &quot;Found an ugly Command: &quot; &amp; strCleanDefaultBrowserExecutable\n\t\tarrBrowserCommand = Split(strDefaultBrowserExecutable, &quot; &quot; )\n\t\tstrCleanDefaultBrowserExecutable = arrBrowserCommand(0)\n\t\t&#039; WScript.Echo strCleanDefaultBrowserExecutable &amp; &quot; after split&quot;\n\tElse\n\t\tstrCleanDefaultBrowserExecutable = objRE.Replace(strPrunedDefaultBrowserExecutable, &quot;$1&quot;)\n\tEnd If\n\t\n\n\t\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\t\n\t&#039; Pass the folder and file name into GetFileDetails to find description and version\n\tstrBrowserFolder = objFSO.GetParentFolderName(strCleanDefaultBrowserExecutable)\n\tstrBrowserFileName = objFSO.GetFileName(strCleanDefaultBrowserExecutable)\n&#039; WScript.Echo strBrowserFolder &amp; &quot; Is folder&quot;\n&#039; WScript.Echo strBrowserFileName &amp; &quot; Is File Name&quot;\n\tstrDescription = GetFileDescription(strBrowserFolder, strBrowserFileName)\n\tstrVersion = GetFileVersion(strBrowserFolder, strBrowserFileName)\n\t\n\tWScript.Echo strDescription &amp; strSep &amp; strVersion\n\t\nEnd Function &#039;GetDefaultWebBrowser\n\nFunction GetFileVersion(folderName,fileName)\n        On Error Resume Next\n        Dim objShell\n        Dim objFolder\n        Dim HeaderInfoArray(250), i\n        \n        Set objShell = CreateObject(&quot;Shell.Application&quot;)\n        Set objFolder = objShell.NameSpace(folderName)\n\n        If (not objFolder is nothing) Then\n            For i = 0 to 250  \n                HeaderInfoArray(i) = objFolder.GetDetailsOf(objFolder.Items, i)\n            Next\n            Dim objFolderItem\n\n            Set objFolderItem = objFolder.ParseName(fileName)\n\n            If (not objFolderItem Is Nothing) then\n                Dim objInfo\n                For i = 0 To 250        \n                    objInfo = objFolder.GetDetailsOf(objFolderItem, i)\n \t\t\t\t\t&#039; WScript.Echo HeaderInfoArray(i) &amp; &quot; &quot; &amp; objFolder.GetDetailsOf(objFolderItem, i)\n                    If LCase(HeaderInfoArray(i)) = &quot;file version&quot; Then\n                    \tGetFileVersion = objFolder.GetDetailsOf(objFolderItem, i)\n                    \tExit Function\n                    End If\n                Next\n            End If\n            \n            Set objFolderItem = Nothing\n        End If\n        \n        Set objFolder = Nothing\n        Set objShell = Nothing\n        On Error Goto 0\nEnd Function &#039;GetFileVersion\n\nFunction GetFileDescription(folderName,fileName)\n        On Error Resume Next\n        Dim objShell\n        Dim objFolder\n        Dim HeaderInfoArray(250), i\n        \n        Set objShell = CreateObject(&quot;Shell.Application&quot;)\n        Set objFolder = objShell.NameSpace(folderName)\n\n        If (not objFolder is nothing) Then\n            For i = 0 to 250  \n                HeaderInfoArray(i) = objFolder.GetDetailsOf(objFolder.Items, i)\n            Next\n            Dim objFolderItem\n\n            Set objFolderItem = objFolder.ParseName(fileName)\n\n            If (not objFolderItem Is Nothing) then\n                Dim objInfo\n                For i = 0 To 250        \n                    objInfo = objFolder.GetDetailsOf(objFolderItem, i)\n                     &#039; WScript.Echo HeaderInfoArray(i) &amp; &quot; &quot; &amp; objFolder.GetDetailsOf(objFolderItem, i)\n                    If LCase(HeaderInfoArray(i)) = &quot;description&quot; Or LCase(HeaderInfoArray(i)) = &quot;file description&quot; Then\n                    \tGetFileDescription = objFolder.GetDetailsOf(objFolderItem, i)\n                    \tExit Function\n                    End If\n                Next\n            End If\n            \n            Set objFolderItem = Nothing\n        End If\n        \n        Set objFolder = Nothing\n        Set objShell = Nothing\n        On Error Goto 0\nEnd Function &#039;GetFileDescription\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Browser", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Version", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 286, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns disk drives which have less than 2 gigabytes free.\nExample: C:", 
      "exclude_from_parse_flag": 1, 
      "hash": 2939169480, 
      "hidden_flag": 0, 
      "id": 569, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Low Disk Space", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from Win32_logicaldisk where (FreeSpace &lt; 2000000000 AND Description=&#039;Local Fixed Disk&#039;)", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 287, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the number of user sessions for which the operating system is storing state.  This may differ from the number of interactively logged in users.\nExample:3", 
      "exclude_from_parse_flag": 1, 
      "hash": 2950466201, 
      "hidden_flag": 0, 
      "id": 571, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Number Of Users", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select NumberOfUsers from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 288, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the Model of a system.\nExample: Precision T1600", 
      "exclude_from_parse_flag": 1, 
      "hash": 2961425050, 
      "hidden_flag": 0, 
      "id": 573, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Model", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Model from win32_ComputerSystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s system-product-name\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsystem_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Model Name:/ { print $2 } &#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 289, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "A list of all of the configured subnet masks for the network adapters of the client machine.\nExample: 255.255.0.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 2977419696, 
      "hidden_flag": 0, 
      "id": 575, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Subnet Mask", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select IPSubnet from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 290, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the Language Code (LCID) of the Operating System.  This differs from the Locale Code returned in the Locale Code sensor.\nExample: 1033", 
      "exclude_from_parse_flag": 1, 
      "hash": 2997757654, 
      "hidden_flag": 0, 
      "id": 577, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Operating System Language Code", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select OSLanguage from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 291, 
      "category": "Software", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the currently installed roles on a Windows Server.\nExample:  File Server", 
      "exclude_from_parse_flag": 1, 
      "hash": 3057103978, 
      "hidden_flag": 0, 
      "id": 579, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Windows Server Installed Roles", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Windows Server Installed Roles\n&#039;========================================\n\nOption Explicit\n\nIf Not IsWindowsServer() Then\n\tWScript.Echo &quot;Not Windows Server&quot;\nElse\n\tIf Left(GetOSMajorVersion(), 1) = &quot;5&quot; Then\n\t\tWScript.Echo &quot;Windows 2003 Server - Roles Not Available&quot;\n\tElse \n\t\tEchoInstalledRolesUsingWMI()\n\tEnd If\nEnd If\n\nFunction EchoInstalledRolesUsingWMI()\n\tDim objWMIService, colItems, objItem\n\t\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_ServerFeature&quot;,,48)\n\tFor Each objItem in colItems\n\t    Wscript.Echo objItem.Name\n\tNext\nEnd Function &#039; EchoInstalledRolesUsingWMI\n\nFunction IsWindowsServer()\n\tDim bResult\n\tbResult = False\n\n\tSelect Case (LCase(GetProductType))\n\t\t&#039; Workstations will always output WinNT\n\t\tCase &quot;servernt&quot;\n\t\t\tbResult = True\n\t\tCase &quot;lanmannt&quot;\n\t\t\tbResult = True\t\t\n\tEnd Select\n\t\n\tIsWindowsServer = bResult\nEnd Function &#039; IsWindowsServer\n\t\nFunction GetProductType\n\n\tDim objShell\n\tDim keyPath, strPath, strFoundPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyPath = &quot;SYSTEM\\CurrentControlSet\\Control\\ProductOptions&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyPath&amp;&quot;\\ProductType&quot;)\n    On Error Goto 0\n\tstrFoundPath = strPath\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetProductType = strFoundPath\n  \tElse\n  \t\tGetProductType = False\n  \t\tWScript.Echo &quot;Error: Cannot determine OS type&quot;\n  \t\tWScript.Quit\n  \tEnd If\nEnd Function &#039;GetProductType\n\nFunction GetOSMajorVersion\n&#039; Returns the OS Major Version\n&#039; A different way to examine the OS instead of by name\n\n\tDim objWMIService,colItems,objItem\n\tDim strVersion\n\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    \n\tFor Each objItem In colItems\n\t\tstrVersion = objItem.Version &#039; like 6.2.9200\n\t\tstrVersion = Left(strVersion,Len(strVersion) - 5)\n\tNext\n\t\n\tGetOSMajorVersion = strVersion\n\t\nEnd Function &#039;GetOSMajorVersion", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 292, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the number of processor cores in all installed processors.  Not supported on all OS patch levels.\nExample:2", 
      "exclude_from_parse_flag": 1, 
      "hash": 3083322981, 
      "hidden_flag": 0, 
      "id": 581, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Number of Processor Cores", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Number of Processor Cores\n&#039;========================================\n\nOn Error Resume Next\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Processor&quot;,,48)\n\nintNumCores = 0\n\nFor Each objItem in colItems\n\tintNumCores = intNumCores + objItem.NumberOfCores\n\tIf intNumCores = 0 Then &#039; machine does not support counting cores\n\t\tstrOs = GetOS\n\t\t&#039;Windows 2000 isn&#039;t supported for core count, can&#039;t determine hyperthreading\n\t\tIf InStr(strOs, &quot;2000&quot;) &gt; 0 Then\n\t\t\tWScript.Echo &quot;Windows 2000 - Cannot determine&quot;\n\t\tElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then\n\t\t\tWScript.Echo &quot;XP SP3 Required to determine&quot;\n\t\tElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then\n\t\t\t&#039;For Win Server 2003 SEE KB 932370\n\t\t\t&#039;http://support.microsoft.com/kb/932370/\n\t\t\tWScript.Echo &quot;KB932370 Required to determine&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;N/A&quot;\n\t\tEnd If\n\tEnd If\nNext\n\nIf Not intNumCores = 0 Then\n\tWScript.Echo intNumCores\nEnd If\n\n\nFunction GetOS\n\tSet oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    \n\tSet oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    \n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)    \n\tSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    \n\tFor Each objItem In colItems       \n\tstrStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   \n\t&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   \n\tif Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   \n\tstrOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   \n\tElse   \n\tstrOS = strStrip1\n\tEnd IF   \n\tGetOS = Trim(strOS)\n\tNext\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 293, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns if sensor execution is randomized on an endpoint, for better distribution on VDI / VM environments.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 3103658637, 
      "hidden_flag": 0, 
      "id": 583, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Tanium Sensor Randomization Enabled", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Sensor Randomization Enabled\n&#039;========================================\n\n\nOption Explicit\n\nConst HKLM = &amp;h80000002\n\nDim objReg\nDim strTaniumRegPath, strSensorRandomizationEnabledValue\nDim strComputer\n\nstrComputer = &quot;.&quot;\n\nSet objReg = _ \n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nstrTaniumRegPath = GetTaniumRegistryPath()\n&#039;retrieve registry entry for Sensor Randomization\nobjReg.GetDWordValue HKLM, strTaniumRegPath, &quot;RandomSensorDelayInSeconds&quot;, strSensorRandomizationEnabledValue\n\nIf Not IsNull(strSensorRandomizationEnabledValue) Then\n\tIf strSensorRandomizationEnabledValue &gt; 0 Then\n\t\tWScript.Echo &quot;Yes&quot;\n\t\tWScript.Echo strSensorRandomizationEnabledValue\n\tElse\n\t\tWScript.Echo &quot;No&quot;\n\tEnd If\nElse \n\tWScript.Echo &quot;No&quot;\nEnd If \n\n&#039;Cleanup\nSet objReg = Nothing\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 294, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "List of add-ons to Internet Explorer and indicates whether they are a Toolbar, Extension, or Browser Helper Objects.\nExample: Java(tm) Plug-In SSV Helper|BHO", 
      "exclude_from_parse_flag": 1, 
      "hash": 3114455387, 
      "hidden_flag": 0, 
      "id": 585, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Internet Explorer Add-Ons", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Internet Explorer Add-Ons\n&#039;========================================\n\nOption Explicit\n\n&#039; WSHVersionOK &#039;call if necessary\n&#039; SetLocale(GetTaniumLocale) &#039;call if necessary\n\nDim is64bitmachine\n\nis64bitmachine = Is64\n\n&#039;// BHOs\n&#039;HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\explorer\\Browser Helper Objects \n&#039;// IE toolbars\n&#039;HKLM\\Software\\Microsoft\\Internet Explorer\\Toolbar\n&#039;// IE extensions\n&#039;HKLM\\Software\\Microsoft\\Internet Explorer\\Extensions\n&#039;// ActiveX\n&#039;HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Ext\\Stats\n\nDim reg, strComputer, bShowInProcServer\nConst HKCR = &amp;H80000000\nConst HKLM = &amp;H80000002\nConst HKU = &amp;H80000003\n\nstrComputer = &quot;.&quot;\nSet reg = Getx64RegistryProvider()\n\nListBHOs\nListToolbars\nListExtensions\nListActiveXControls\n\nFunction LookupClassName(clsid)\n\tDim strKeyPath, value, inProc, rootErrorCheck, inProcErrorCheck\n\tstrKeyPath = &quot;CLSID\\&quot;&amp;clsid\n\trootErrorCheck = reg.GetStringValue(HKCR, strKeyPath,&quot;&quot;,value)\n\tIf (rootErrorCheck=0 And Not IsNull(value)) Then\n\t\tinProcErrorCheck = reg.GetStringValue(HKCR, strKeyPath&amp;&quot;\\InProcServer32&quot;,&quot;&quot;,inProc)\n\t\tIf inProcErrorCheck = 0 Then \n\t\t\tvalue = inProc&amp;&quot;|&quot;&amp;value\n\t\tElse\n\t\t\tvalue = &quot;Unknown&quot;&amp;&quot;|&quot;&amp;value\n\t\tEnd If\n        LookupClassName = value\n    Else\n    \tstrKeyPath = &quot;Wow6432Node\\CLSID\\&quot;&amp;clsid\n\t\trootErrorCheck = reg.GetStringValue(HKCR, strKeyPath,&quot;&quot;,value)\n\t\tIf (rootErrorCheck=0 And Not IsNull(value)) Then\n\t\t\tinProcErrorCheck = reg.GetStringValue(HKCR, strKeyPath&amp;&quot;\\InProcServer32&quot;,&quot;&quot;,inProc)\n\t\t\tIf inProcErrorCheck = 0 Then \n\t\t\t\tvalue = inProc&amp;&quot;|&quot;&amp;value\n\t\t\tElse\n\t\t\t\tvalue = &quot;Unknown&quot;&amp;&quot;|&quot;&amp;value\n\t\t\tEnd If\n        \tLookupClassName = value\t\t\t\n        Else &#039; cannot pull registry value, cannot look up class name\n   \t\t\tLookupClassName = &quot;Unknown&quot;&amp;&quot;|&quot;&amp;clsid\n    \tEnd If\n\tEnd If\nEnd Function\n\nFunction LookupExtensionName(clsid)\n\tDim strKeyPath, value, rootErrorCheck, inProc, inProcErrorCheck\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Internet Explorer\\Extensions\\&quot;&amp;clsid\n\trootErrorCheck = reg.GetStringValue(HKLM, strKeyPath,&quot;MenuText&quot;,value)\n\tIf (rootErrorCheck=0 And Not IsNull(value)) Then\n\t\tvalue = &quot;N/A&quot;&amp;&quot;|&quot;&amp;value &#039; no InProcServer file name for an extension\n        LookupExtensionName = value\n    Else\n    \tstrKeyPath = &quot;SOFTWARE\\wow6432node\\Microsoft\\Internet Explorer\\Extensions&quot;&amp;clsid\n\t\trootErrorCheck = reg.GetStringValue(HKLM, strKeyPath,&quot;MenuText&quot;,value)\n\t\tIf (rootErrorCheck=0 And Not IsNull(value)) Then\n\t\t\tvalue = &quot;N/A&quot;&amp;&quot;|&quot;&amp;value &#039; no InProcServer file name for an extension\n        \tLookupExtensionName = value\n        Else\n    \t\tLookupExtensionName = &quot;N/A&quot;&amp;&quot;|&quot;&amp;clsid &#039; no InProcServer file name for an extension\n    \tEnd If\n\tEnd If\nEnd Function\n\nFunction ListBHOs\n\t&#039;WScript.Echo &quot;Listing BHOs&quot;\n\tDim strKeyPath, arrSubKeys, errorCheck, subkey\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\explorer\\Browser Helper Objects&quot;\n\t\n\terrorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)\n\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n        For Each subkey In arrSubKeys\n        \tWScript.Echo LookupClassName(subkey) &amp; &quot;|BHO&quot;\n        Next\n    End If\n    \n    If is64bitmachine Then\n    \tstrKeyPath = &quot;SOFTWARE\\wow6432node\\Microsoft\\Windows\\CurrentVersion\\explorer\\Browser Helper Objects&quot;\n\t\n\t\terrorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)\n\t\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n\t        For Each subkey In arrSubKeys\n\t        \tWScript.Echo LookupClassName(subkey) &amp; &quot;|BHO&quot;\n\t        Next\n\t    End If\n    End If\n\t\nEnd Function\n\nFunction ListToolbars\n\t&#039;WScript.Echo &quot;Listing Toolbars&quot;\n\tDim strKeyPath, arrValues, errorCheck, value\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Internet Explorer\\Toolbar&quot;\n\t\n\terrorCheck = reg.EnumValues(HKLM, strKeyPath, arrValues)\n\tIf (errorCheck=0 and IsArray(arrValues)) then\n        For Each value In arrValues\n        \tWScript.Echo LookupClassName(value)&amp; &quot;|Toolbar&quot;\n        Next\n    End If\n    \n    If is64bitmachine Then\n    \tstrKeyPath = &quot;SOFTWARE\\wow6432node\\Microsoft\\Internet Explorer\\Toolbar&quot;\n    \t\n\t\terrorCheck = reg.EnumValues(HKLM, strKeyPath, arrValues)\n\t\tIf (errorCheck=0 and IsArray(arrValues)) then\n\t        For Each value In arrValues\n\t        \tWScript.Echo LookupClassName(value)&amp; &quot;|Toolbar&quot;\n\t        Next\n\t    End If\n    End If\nEnd Function\n\nFunction ListExtensions\n\t&#039;WScript.Echo &quot;Listing Extensions&quot;\n\tDim strKeyPath, arrSubKeys, errorCheck, subkey\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Internet Explorer\\Extensions&quot;\n\t\n\terrorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)\n\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n        For Each subkey In arrSubKeys\n        \tWScript.Echo LookupExtensionName(subkey)&amp; &quot;|Extension&quot;\n        Next\n    End If\n    \n    If is64bitmachine Then\n    \tstrKeyPath = &quot;SOFTWARE\\wow6432node\\Microsoft\\Internet Explorer\\Extensions&quot;\n\t\n\t\terrorCheck = reg.EnumKey(HKLM, strKeyPath, arrSubKeys)\n\t\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n\t        For Each subkey In arrSubKeys\n\t        \tWScript.Echo LookupExtensionName(subkey)&amp; &quot;|Extension&quot;\n\t        Next\n\t    End If\n    End If\nEnd Function\n\nFunction ListActiveXControls\n\tDim errorCheck, subkey, arrSubKeys, strKeyPath\n\t\n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Ext&quot;\n\terrorCheck = reg.EnumKey(HKU, &quot;&quot;, arrSubKeys)\n\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n\t\tFor Each subkey In arrSubKeys\n\t\t\t&#039;WScript.Echo &quot;Looking in subkey: &quot;&amp;subkey\n\t\t\tListActiveXControlsForUser subkey\n\t\tNext\n\tEnd If\n\t\nEnd Function\n\nFunction ListActiveXControlsForUser(userkey)\n\t&#039;WScript.Echo &quot;Listing ActiveXControls&quot;\n\tDim strKeyPath, arrSubKeys, errorCheck, subkey\n\t\n\tstrKeyPath = userkey&amp;&quot;\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Ext\\Settings&quot;\t\n\terrorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)\n\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n        For Each subkey In arrSubKeys\n        \tWScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;\n        Next\n    End If\n    \n    If is64bitmachine Then\n    \tstrKeyPath = userkey&amp;&quot;\\SOFTWARE\\wow6432node\\Microsoft\\Windows\\CurrentVersion\\Ext\\Settings&quot;\n\t\terrorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)\n\t\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n\t        For Each subkey In arrSubKeys\n\t        \tWScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;\n\t        Next\n\t    End If\n    End If\n\t\n\tstrKeyPath = userkey&amp;&quot;\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Ext\\Stats&quot;\t\n\terrorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)\n\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n        For Each subkey In arrSubKeys\n        \tWScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;\n        Next\n    End If\n    \n    If is64bitmachine Then\t\n    \tstrKeyPath = userkey&amp;&quot;\\SOFTWARE\\wow6432node\\Microsoft\\Windows\\CurrentVersion\\Ext\\Stats&quot;\n\t\terrorCheck = reg.EnumKey(HKU, strKeyPath, arrSubKeys)\n\t\tIf (errorCheck=0 and IsArray(arrSubKeys)) then\n\t        For Each subkey In arrSubKeys\n\t        \tWScript.Echo LookupClassName(subkey) &amp; &quot;|ActiveX&quot;\n\t        Next\n\t    End If\n    End If\n\t\nEnd Function\n\n\n&#039;&#039; -- standard help functions -- &#039;&#039;\nSub WSHVersionOK\n\tIf Not CDbl(WScript.Version) &gt;= 5.6 Then\n\t\tWScript.Echo &quot;Unsupported WSH version: &quot; &amp; WScript.Version\n\t\tWScript.Quit\n\tEnd If\nEnd Sub &#039;WSHVersionOK\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Add-On File", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Add-On Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Add-On Type", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 295, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the Version of a motherboard.\nExample:9230", 
      "exclude_from_parse_flag": 1, 
      "hash": 3133617106, 
      "hidden_flag": 0, 
      "id": 587, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Motherboard Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Motherboard Version\n&#039;========================================\n\nSet objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\nSet colMB = objWMIService.ExecQuery(&quot;Select * from Win32_BaseBoard&quot;)\nFor Each mb In colMB\nmbVersion = mb.Version\nWScript.Echo mbVersion\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s baseboard-version\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 296, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the revision number of installed CPUs.\nExample: 5898", 
      "exclude_from_parse_flag": 1, 
      "hash": 3133620839, 
      "hidden_flag": 0, 
      "id": 589, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Revision of CPU", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Revision from win32_processor", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 297, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns of details of attached USB devices, including Description, vendor ID, and product ID.\nExample:  Generic USB Hub|VMware, Inc.|Virtual USB Hub", 
      "exclude_from_parse_flag": 1, 
      "hash": 314220795, 
      "hidden_flag": 0, 
      "id": 591, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "USB Device Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; USB Device Details\n&#039;========================================\n\nOption Explicit\n\nConst HARDWARE_TOOLS = &quot;Tools\\Hardware&quot;\nConst USB_ID_FILE = &quot;usb.ids&quot;\nConst VIEWABLE_NAME = &quot;VIEWABLE_NAME&quot;\n\n\nDim objFSO, strToolsDir, strUSBIDs, dictVendors\nDim objWMIService, colItems, objItem\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nstrToolsDir = GetTaniumDir(HARDWARE_TOOLS)\nstrUSBIDs = strToolsDir &amp; USB_ID_FILE\n\ndictVendors = Null\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;) \nSet colItems = objWMIService.ExecQuery( _\n    &quot;SELECT * FROM Win32_USBHub&quot;,,48) \nFor Each objItem in colItems \n\tDim strDevId, strPid, strVid\n\tstrDevId = &quot;&quot;\n\tstrPid = &quot;&quot;\n\tstrVid = &quot;&quot;\n\t\n\tstrDevId = objItem.DeviceID\n\tIf(InStr(strDevId,&quot;VID_&quot;)&lt;&gt;0) Then\n\t\tstrVid = Mid(strDevId,InStr(strDevId,&quot;VID_&quot;)+4,4)\n\tEnd If\n\tIf(InStr(strDevId,&quot;PID_&quot;)&lt;&gt;0) Then\n\t\tstrPid = Mid(strDevId,InStr(strDevId,&quot;PID_&quot;)+4,4)\n\tEnd If\n\t\n\tIf(strDevId&lt;&gt;&quot;&quot; And strPid&lt;&gt;&quot;&quot; And strVid&lt;&gt;&quot;&quot;) Then\n\t\t&#039; ok, only take on reading the in the usb.ids file if we have at least one device\n\t\tIf(objFSO.FileExists(strUSBIDs) And IsNull(dictVendors)) Then \n\t\t\tSet dictVendors = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\t\tLoadVendorProductMap dictVendors, strUSBIDs\n\t\tEnd If\n\t\n\t\tWScript.Echo GenOutputString(objItem.Description, strVid, strPid, dictVendors)\n\tEnd If\nNext\n\nFunction GenOutputString(strDescription, strVid, strPid, dictVendors) \n\tDim strVidName, strPidName, dictVendor\n\tstrVidName = strVid\n\tstrPidName = strPid\n\t\n\tIf Not IsNull(dictVendors) Then \n\t\tIf dictVendors.Exists(LCase(strVid)) Then \n\t\t\tSet dictVendor = dictVendors.Item(LCase(strVid))\n\t\t\t\n\t\t\tstrVidName = dictVendor.Item(VIEWABLE_NAME)\n\t\t\tIf dictVendor.Exists(LCase(strPid)) Then \n\t\t\t\tstrPidName = dictVendor.Item(LCase(strPid))\n\t\t\tEnd If\n\t\tEnd if\n\tEnd If\n\n\tGenOutputString = strDescription &amp; &quot;|&quot; &amp; strVidName &amp; &quot;|&quot; &amp; strPidName\nEnd Function &#039; GenOutputString\n\n\nSub LoadVendorProductMap(dictVendors, strFile)\n\tDim objFSO, objReadFile, bStopReading, strLine, dictCurrentVendor\n\tDim strWords, strKey, strValue\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\n\tSet objReadFile = objFSO.OpenTextFile(strFile, 1, False)\n\t\n\tbStopReading = False\n\n\tDo While Not objReadFile.AtEndOfStream And Not bStopReading\n\t\tstrLine = objReadFile.ReadLine\n\t\t\n\t\tIf InStr(strLine, &quot;# List of known device classes, subclasses and protocols&quot;) &gt; 0 Then \n\t\t\t&#039; this is our signal to stop -- after this are no more vendors\n\t\t\tbStopReading = True\n\t\tElseIf Left(strLine, 1) = &quot;#&quot; Or Trim(strLine) = &quot;&quot; Then \n\t\t\t&#039; do nothing - this is a skip\n\t\tElseIf Left(strLine, 1) = vbTab Then \n\t\t\tstrLine = Right(strLine, Len(strLine) - 1)\n\t\t\tstrWords = Split(strLine, &quot; &quot;, 2)\n\t\t\tstrKey = strWords(0)\n\t\t\tstrValue = Trim(strWords(1))\n\t\t\tdictCurrentVendor.Add LCase(strKey), strValue\t\t\n\t\tElse \n\t\t\tstrWords = Split(strLine, &quot; &quot;, 2)\n\t\t\tstrKey = strWords(0)\n\t\t\tstrValue = Trim(strWords(1))\n\t\t\tSet dictCurrentVendor = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\t\tIf Not dictVendors.Exists(strKey) Then \n\t\t\t\tdictVendors.Add LCase(strKey), dictCurrentVendor\n\t\t\tEnd If \n\t\t\tdictCurrentVendor.Add VIEWABLE_NAME, strValue\n\t\tEnd If\n\tLoop\n\tobjReadFile.Close\n\nEnd Sub &#039; LoadVendorProductMap\n\n\t\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Description", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Vendor ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Product ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 298, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Provides errors codes for hardware devices that failed to load correctly at last boot.\nExample: none", 
      "exclude_from_parse_flag": 1, 
      "hash": 3145690673, 
      "hidden_flag": 0, 
      "id": 593, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Hardware Device Failed to Load", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select * from Win32_PnPEntity WHERE ConfigManagerErrorCode &lt;&gt; 0", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 299, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns database name and recovery mode for that database from all databases in SQL Server on client machine.\nExample: ReportServer SIMPLE", 
      "exclude_from_parse_flag": 1, 
      "hash": 3147407985, 
      "hidden_flag": 0, 
      "id": 595, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "SQL Recovery Mode", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Recovery Mode\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\n\nDim dictInstances, strInstance, objConnection\n\nSet dictInstances = GetMSSQLInstances()\n\nFor Each strInstance In dictInstances.Keys\n\tDim objRecordSet, Record, objRecordSet2, strDatabase, strDBRecovery\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;) \n\tSet objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  \n\n\tOn Error Resume Next\n\tobjConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)\n\t\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\tOn Error Goto 0\n\n\tobjRecordSet.Open &quot;SELECT name FROM sys.databases&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  \n\tFor each Record in objRecordSet.Properties    \n\t\tstrDatabase = objRecordSet(&quot;name&quot;)    \n\t\tobjRecordSet2.Open &quot;select databasepropertyex([name],&#039;Recovery&#039;) as [Recovery] from dbo.sysdatabases where name=&quot; &amp; &quot;&#039;&quot; &amp; strDatabase &amp; &quot;&#039;&quot;, _         \n\t\t\tobjConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC        \n\t\tstrDBRecovery = objRecordSet2(&quot;Recovery&quot;)       \n\t\tWScript.echo strDatabase &amp; &quot; &quot; &amp; strDBRecovery &amp; GetMSSQLSensorInstanceStr(strInstance)    \n\t\tobjRecordset2.Close     \n\t\tobjRecordSet.MoveNext    \n\t\tIf (objRecordset.EOF = True) THEN       \n\t\t\tobjRecordset.Close       \n\t\t\tExit For    \n\t\tEnd If     \n\tNext \nNext\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 300, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Total swap space configured by client machine.\nExample: 4000 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 3147580256, 
      "hidden_flag": 0, 
      "id": 597, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Total Swap", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nmemLine=$(free -m | grep &quot;Swap&quot;)\nset -- $memLine\necho $2 MB\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 301, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns the path to and size of the Tanium Client \"Downloads\" directory.  This is the directory to which Tanium Package files are downloaded.  It is considered temporary space and will clean itself out periodically.\nExample: C:\\Program Files (x86)\\Tanium\\Tanium Client\\Downloads|139.4 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 3157180652, 
      "hidden_flag": 0, 
      "id": 599, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Tanium Client Downloads Directory Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Downloads Directory Details\n&#039;========================================\n\n&#039;Script will return path and size of Tanium Downloads directory\n\nOption Explicit\n\nSetLocale(GetTaniumLocale)\n\nConst HKLM = &amp;H80000002\nDim objRegistry,strTaniumClientKey\nDim objFSO,objFolder,strTaniumClientPath,strTaniumClientDownloadsPath\nDim strSize,strSep\n\nstrSep = &quot;|&quot;\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nSet objRegistry=GetObject(&quot;winmgmts:\\\\.\\root\\default:StdRegProv&quot;)\n\nstrTaniumClientKey = GetTaniumRegistryPath()\nIf Not strTaniumClientKey = &quot;&quot; Then\n\tobjRegistry.GetStringValue HKLM,strTaniumClientKey,&quot;Path&quot;,strTaniumClientPath\nEnd If\n\nIf ( IsNull(strTaniumClientPath) Or strTaniumClientPath = &quot;&quot;) Or ( Not objFSO.FolderExists(strTaniumClientPath)) Then\n\tWScript.Echo &quot;Tanium Client Directory Not Found&quot;\nElse\n\tstrTaniumClientDownloadsPath = strTaniumClientPath&amp;&quot;\\Downloads&quot;\n\tSet objFolder = objFSO.GetFolder(strTaniumClientDownloadsPath)\n\tstrSize = GetAccessibleFolderSize(strTaniumClientDownloadsPath)\n\tstrSize = GetPrettyFileSize(strSize)\n\tWscript.Echo strTaniumClientDownloadsPath &amp; strSep &amp; strSize\nEnd If\n\n&#039; --- end main --- &#039;\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction GetPrettyFileSize(strSize)\nDim dblSize\n\tdblSize = CDbl(strSize)\n\n\tIf dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;\t\n\tElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;\n\tElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB\n\t\tstrSize = CStr(Round(dblSize / 1024)) &amp; &quot; kB&quot;\n\tElse\n\t\tstrSize = CStr(dblSize) &amp; &quot; B&quot;\t\n\tEnd If\t\n\tGetPrettyFileSize = strSize\nEnd Function &#039;GetPrettyFileSize\n\n\nFunction GetAccessibleFolderSize(strFolderPath)\n&#039; Gets the folder sizes that it is able to\n&#039; and skips those it has no rights to see\n    On Error Resume Next &#039; Permissions Errors potentially\n\n\tDim objFSO\n    Dim objFolder,objSubfolder,intSize,bHasSubfolders\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t    \n    bHasSubfolders = False\n\n    Set objFolder = objFSO.GetFolder(strFolderPath)\n    Err.Clear\n    intSize = objFolder.Size\n    If Err.Number &lt;&gt; 0 Then\n        For Each objSubfolder in objFolder.SubFolders\n            intSize = intSize + GetAccessibleFolderSize(objSubfolder.Path)\n            bHasSubfolders = True\n        Next\n\n        If Not bHasSubfolders Then\n            intSize = objFolder.Size\n        End If\n    End If\n\n    GetAccessibleFolderSize = intSize\n    \n    On Error Goto 0\n\nEnd Function &#039;GetAccessibleFolderSize\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Path", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Size", 
            "value_type": "DataSize"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 302, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "The total physical memory installed in the client machine.\nExample: 8000 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 316030016, 
      "hidden_flag": 0, 
      "id": 601, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Total Memory", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Total Memory\n&#039;========================================\n\nOption Explicit\n\nDim objWMIService, colItems, objItem, strTotalMemory\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n \n&#039;Gets total memory\nSet colItems = objWMIService.ExecQuery(&quot;Select * FROM Win32_Computersystem &quot;)\nFor Each objItem In colItems  \n strTotalMemory = Int(objItem.TotalPhysicalMemory / 1024 / 1024)\n wscript.echo strTotalMemory &amp; &quot; MB&quot;\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nmemLine=$(free -m | grep &quot;Mem&quot;)\nset -- $memLine\necho $2 MB\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsystem_profiler SPHardwareDataType | awk -F&#039;: &#039; &#039; /Memory:/ { print $2 } &#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 6, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 303, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the names of PCI devices in the system.\nExample:Intel(R) 82371AB/EB PCI Bus Master IDE Controller", 
      "exclude_from_parse_flag": 1, 
      "hash": 3170446499, 
      "hidden_flag": 0, 
      "id": 603, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "PCI Device", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from Win32_PnPEntity where (Status=&#039;OK&#039; and DeviceID like &#039;%PCI%&#039;)", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 304, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the number of interactively logged in users.  On Windows, this will include Remote Desktop sessions.\nExample: 2", 
      "exclude_from_parse_flag": 1, 
      "hash": 3170496172, 
      "hidden_flag": 0, 
      "id": 605, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Number of Logged In Users", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Number of Logged In Users\n&#039;========================================\n\nOption Explicit\n\nDim objWMIService,colItems,objItem,i\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;) \nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process Where Name=&#039;explorer.exe&#039;&quot;,,48)\n\ni = 0\nFor Each objItem in colItems\n\ti = i + 1\nNext\n\nWScript.Echo i", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nwho -q | grep &quot;users=&quot; | cut -d= -f2\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 305, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": ",", 
      "description": "Returns the OS Locale Code from the installed operating system.  This differs from the LCID returned in the OS language sensor.\nExample:0409", 
      "exclude_from_parse_flag": 1, 
      "hash": 3177804004, 
      "hidden_flag": 0, 
      "id": 607, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Locale Code", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Locale from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 306, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:04", 
      "delimiter": "|", 
      "description": "Returns all running processes along with the memory each process uses.  This is the process's working set.\nExample: lsass.exe|23 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 319662655, 
      "hidden_flag": 0, 
      "id": 609, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:04", 
      "name": "Running Processes Memory Usage", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Running Processes Memory Usage\n&#039;========================================\n\nDim objWMIService,colItems,objItem,strSep,strMem,strProcess\n\nstrSep = &quot;|&quot;\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Process&quot;,,48)\n\nOn Error Resume Next\nFor Each objItem in colItems\n\tstrProcess = objItem.Caption\n\tIf Err.Number &lt;&gt; 0 Then strProcess = &quot;Unknown&quot;\n\t\n\tstrMem = objItem.WorkingSetSize\n\tIf Err.Number &lt;&gt; 0 Then strMem = &quot;Unknown&quot;\n\t\n\tWScript.Echo strProcess &amp; strSep &amp; PrettyFileSize(strMem)\nNext\nOn Error Goto 0\n\nFunction PrettyFileSize(strSize)\n\t\n\tstrSize = CStr(strSize) &#039; convert all input to string\n\t\n\tDim strOut,intKB,intMB,intGB,intSize\n\t\n\tIf Not IsNumeric(strSize) Then\n\t\tstrOut = &quot;Unknown&quot;\n\t\tPrettyFileSize = strOut\n\t\tExit Function\n\tElse\n\t\tIf Not CStr(CLng(strSize)) = strSize Then\n\t\t\t&#039;not an integer\n\t\t\tstrOut = &quot;Unknown&quot;\n\t\t\tPrettyFileSize = strOut\n\t\t\tExit Function\n\t\tEnd If\n\tEnd If\n\t\n\tintSize = CLng(strSize)\n\tintKB = 1024\n\tintMB = 1024*1024\n\tintGB = 1024*1024*1024\n\t\n\tIf intSize &gt; intGB Then\n\t\tstrOut = Int(intSize / intGB) &amp; &quot; GB&quot;\n\tElseIf intSize &gt; intMB Then\n\t\tstrOut = Int(intSize / intMB) &amp; &quot; MB&quot;\n\tElseIf intSize &gt; intKB Then\n\t\tstrOut = Int(intSize / intKB) &amp; &quot; KB&quot;\n\tElse\n\t\tstrOut = intSize &amp; &quot; B&quot;\n\tEnd If\n\t\n\tPrettyFileSize = strOut\nEnd Function &#039;PrettyFileSize", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Memory Used", 
            "value_type": "DataSize"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 307, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns information network-aware processes and the ports they have bound to.\nExample: googletalkplugin.exe Google Talk Plugin :60042", 
      "exclude_from_parse_flag": 1, 
      "hash": 3200371050, 
      "hidden_flag": 0, 
      "id": 611, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Listen Ports", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Listen Ports\n&#039;========================================\n\nshowProcess = True\nshowPort = True\n\nDim strcommand, results, excludeProcesses, excludeSubnets, taniumDebug\nDim strSep : strSep = &quot;|&quot;\n&#039; This is a multi-column sensor that looks like:\n&#039;Process|Name|Target IP\n\nexcludeProcesses = &quot;TaniumClient.exe,TaniumReceiver.exe&quot;\n&#039;excludeProcesses = &quot;chrome.exe&quot;\n&#039;excludeProcesses = &quot;iexplore.exe&quot;\n&#039;excludeProcesses = &quot;chrome.exe, iexplore.exe&quot;\n&#039;excludeProcesses = &quot;trillian.exe&quot;\n\nexcludeSubnets = &quot;127.0.0.0:255.255.255.0&quot;\n&#039;excludeSubnets = &quot;72.14.213.0:255.255.255.0, 74.125.223.0:255.255.255.0-74.125.225.0:255.255.255.0&quot;\n\ntaniumDebug = False\n\n\nexcludeProcesses = Split(LCase(excludeProcesses), &quot;,&quot;)\nexcludeSubnets = Split(excludeSubnets, &quot;,&quot;)\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nquery = &quot;select name, executablepath, processId from win32_process&quot;\nSet colResults = objWMIService.ExecQuery(query)\n\n&#039;dictionary for process-app pairs\nSet processes = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nFor Each result In colResults \n   processId = CStr(result.ProcessId)\n   processPath = result.ExecutablePath\n   processes.Add processId, result.Name &amp; &quot;,&quot; &amp; processPath &#039; tie IDs to exes,path - split later\nNext\n\nstrcommand = &quot;cmd /c netstat -aon -p TCP | find &quot; &amp; chr(34) &amp; &quot;TCP&quot; &amp; Chr(34) &amp; &quot; | find &quot; &amp; chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34)\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrPingResults = LCase(objScriptExec.StdOut.ReadAll)\n\nresults = Split(strPingResults, vbCrLf)\nj = 0\n\nFor Each line in results\n   line = cleanWhitespace(Trim(line))\n   \n   lineResults = Split(line)\n   i = 0\n   Dim strPort, strPid, strConnectionType, strForeignIp, strApp\n   For Each word In lineResults\n      If i = 1 Then\n         strPort = word\n         strPort = Right(strPort, Len(strPort) - InStr(strPort, &quot;:&quot;) + 1)\n      ElseIf i = 2 Then\n         strForeignIp = word\n      ElseIf i = 3 Then\n         strConnectionType = word\n      ElseIf i = 4 Then\n         strPid = word\n      End If\n      \n      i = i + 1\n   Next\n   \n   &#039;DO NOT INCLUDE EXCLUDED APPS\n   strAppEntry = processes.Item(strPid) &#039; looks like process.exe, Process Path\n   arrAppEntry = Split(strAppEntry,&quot;,&quot;)\n   strAppExe = arrAppEntry(0)\n   strAppPath = arrAppEntry(1)\n   \n   isNotExcludedApp = Not(ContainedInArray(LCase(strAppExe), excludeProcesses))\n   \n   &#039;DO NOT INCLUDE EXCLUDED SUBNETS\n   isNotExcludedSubnet = Not(ContainedInSubnet(strForeignIp, excludeSubnets))\n   \n   If Not(IsEmpty(strAppExe)) _\n      And isNotExcludedApp _ \n      And isNotExcludedSubnet Then\n\n\t  If Not showPort Then \n\t  \tarrTemp = Split(strForeignIp, &quot;:&quot;)\n\t\tstrForeignIp = arrTemp(0)\n\t  End If\n\n      If showProcess Then\n      \tresults(j) = strAppExe &amp; strSep &amp; ProcessNameToApplicationName(strAppPath,strAppExe) &amp; strSep &amp; strPort\n      Else\n        results(j) = strSep &amp; strSep &amp; strForeignIp\n      End If\t\n   Else\n      If taniumDebug Then WScript.Echo &quot;      excluded: &quot; &amp; strApp &amp; &quot; &quot; &amp; strForeignIp\n      results(j) = &quot;&quot;   \n   End If \n   \n   j = j + 1\nNext\n\nresults = RemDups(results)\n\nIf UBound(results) &lt; 1 Then\n\tIf GetLocale() &lt;&gt; 1033 Then\n\t\tWScript.Echo &quot;English Language OS Required&quot;\n\tEnd If\nEnd If\n\nFor Each result In results \n   WScript.Echo result\nNext\n\nWScript.Quit\n\nFunction ContainedInSubnet(str, arr)\n   Dim strIp, strSubnet, strMask\n   temp = Split(str, &quot;:&quot;)\n   strIp = temp(0)\n\n   For Each item In arr\n      If InStr(item, &quot;-&quot;) Then &#039;Subnet range\n         temp = Split(item, &quot;-&quot;)\n         lower = Split(temp(0), &quot;:&quot;)\n         upper = Split(temp(1), &quot;:&quot;)\n         lowerSubnet = Trim(lower(0))\n         lowerMask = Trim(lower(1))\n         upperSubnet = Trim(upper(0))\n         upperMask = Trim(upper(1))\n         \n         If StringToBinary(strIp) &gt; StringToBinary(Subnet(lowerSubnet, lowerMask)) _\n            And StringToBinary(strIp) &lt; StringToBinary(Subnet(upperSubnet, upperMask)) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If \n      Else &#039;Single subnet\n         parts = Split(item, &quot;:&quot;)\n         strSubnet = Trim(parts(0))\n         strMask = Trim(parts(1))\n         If Subnet(strIp, strMask) = Subnet(strSubnet, strMask) Then\n            ContainedInSubnet = True\n            Exit Function\n         End If\n      End If \n   Next\n   ContainedInSubnet = False\nEnd Function\n\nFunction ContainedInArray(str, arr)\n   For Each item In arr \n      If str = Trim(item) Then\n         ContainedInArray = True\n         Exit Function\n      End If   \n   Next\n   ContainedInArray = False\nEnd Function\n\nFunction cleanWhitespace(strStarter)\n   intStarter = Len(strStarter)\n   For i = intStarter to 2 Step -1\n      strChars = Space(i)\n      strStarter = Replace(strStarter, strChars, &quot; &quot;)\n   Next\n   cleanWhitespace = strStarter\nEnd Function\n\nFunction RemDups(ByVal anArray)\n   Dim d, item, thekeys\n   Set d = CreateObject(&quot;Scripting.Dictionary&quot;)\n   d.removeall\n   d.CompareMode = 0\n   For Each item In anArray\n      If Len(item) &gt; 0 Then\n         If Not d.Exists(item) Then d.Add item, item\n      End If\n   Next\n   thekeys = d.keys\n   Set d = Nothing\n   RemDups = thekeys\nEnd Function\n\nFunction Subnet(strAddress, strMask)\n   intSubnetLength = SubnetLength(strMask)\n   Subnet = BinaryToString(Left(StringToBinary(strAddress), intSubnetLength) &amp; String(32 - intSubnetLength, &quot;0&quot;))\nEnd Function\n\nFunction SubnetLength(strMask)\n   strMaskBinary = StringToBinary(strMask)\n   SubnetLength = Len(Left(strMaskBinary, InStr(strMaskBinary, &quot;0&quot;) - 1))\nEnd Function\n\nFunction BinaryToString(strBinary)\n   For intOctetPos = 1 To 4\n      strOctetBinary = Right(Left(strBinary, intOctetPos * 8), 8)\n      intOctet = 0\n      intValue = 1\n      For intBinaryPos = 1 To Len(strOctetBinary)\n         If Left(Right(strOctetBinary, intBinaryPos), 1) = &quot;1&quot; Then intOctet = intOctet + intValue\n         intValue = intValue * 2\n      Next\n      If BinaryToString = Empty Then BinaryToString = CStr(intOctet) Else BinaryToString = BinaryToString &amp; &quot;.&quot; &amp; CStr(intOctet)\n   Next\nEnd Function\n\nFunction StringToBinary(strAddress)\n   objAddress = Split(strAddress, &quot;.&quot;, -1)\n   For Each strOctet In objAddress\n      intOctet = CInt(strOctet)\n      strOctetBinary = &quot;&quot;\n      For x = 1 To 8\n         If intOctet Mod 2 &gt; 0 Then\n            strOctetBinary = &quot;1&quot; &amp; strOctetBinary\n         Else\n            strOctetBinary = &quot;0&quot; &amp; strOctetBinary\n         End If\n         intOctet = Int(intOctet / 2)\n      Next\n      StringToBinary = StringToBinary &amp; strOctetBinary\n   Next\nEnd Function\n\nFunction ProcessNameToApplicationName(strExecutablePath, strExecutableName)\n&#039; This function will return the full application name of a running executable\n\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\n\t\tarrPathParts = Split(strExecutablePath,&quot;\\&quot;)\n\n\t\tIf UBound(arrPathParts) &lt; 0 Then &#039;can be -1 for no split, such as the System process\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tSet fso = Nothing\n\t\t\tExit Function\n\t\tEnd If\n\t\tstrExecutable = arrPathParts(UBound(arrPathParts))\n\t\t\n\t\tIf fso.FileExists(strExecutablePath) Then\n\t\t\tDim strOutput, fileVersion, fileVersionOutput, fullName\n\t\t\n\t\t\tSet execFile = fso.GetFile(strExecutablePath)\n\t\t\tfullName = GetDescription(execFile.ParentFolder.Path, strExecutable)\n\t\t\tIf Not fullName = &quot;&quot; Then\n\t\t\t\tProcessNameToApplicationName = fullName\n\t\t\tElse\n\t\t\t\tProcessNameToApplicationName = strExecutableName\n\t\t\tEnd If\n\t\tElse &#039; file doesn&#039;t exist or inaccessible\n\t\t\tProcessNameToApplicationName = strExecutableName\n\t\tEnd If\n\nEnd Function &#039;ProcessNameToApplicationName\n\nFunction GetDescription(folderPath, fileName)\n\tdescIndex = GetAttributeIndex(folderPath, &quot;File description&quot;)\n\tIf IsEmpty(descIndex) Then\n\t\tdescIndex = GetAttributeIndex(folderPath, &quot;Description&quot;)\n\tEnd If\n\tGetDescription = GetFileProperty(folderPath, fileName, descIndex)\nEnd Function\n\nFunction GetFileProperty(folderPath, fileName, fileProperty)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tGetFileProperty = objFolder.GetDetailsOf(objFolder.Parsename(fileName), fileProperty)\nEnd Function\n\nFunction GetAttributeIndex(folderPath, attrTarget)\n\tSet objShell = CreateObject(&quot;Shell.Application&quot;)\n\tSet objFolder = objShell.Namespace(folderPath)\n\tFor i = 0 to 50\n\t\tattrName = objFolder.GetDetailsOf(objFolder.Items, i)\n\t\tIf LCase(attrName) = LCase(attrTarget) Then\n\t\t\tGetAttributeIndex = i\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\ntmpfile=&quot;/tmp/tanium.$$&quot;\nlsof -p ^$PPID -iTCP -sTCP:LISTEN -P +c 15 -n &gt; $tmpfile\ncat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($9,index($9,&quot;:&quot;))}&#039;\nrm -f $tmpfile\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\ntmpfile=&quot;/tmp/tanium.$$&quot;\nlsof -p ^$PPID -iTCP -sTCP:LISTEN -P +c 15 -n &gt; $tmpfile\ncat $tmpfile | awk &#039;$1 != &quot;COMMAND&quot; { print $1&quot;|&quot;$1&quot;|&quot;substr($9,index($9,&quot;:&quot;))}&#039;\nrm -f $tmpfile\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Local Port", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 308, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns the Date and Time that the OS last booted.  This is a multi-column sensor.\nExample: 12/10/2012 18:41", 
      "exclude_from_parse_flag": 1, 
      "hash": 3226581166, 
      "hidden_flag": 0, 
      "id": 613, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "OS Boot Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; OS Boot Time\n&#039;========================================\n\n&#039; This sensor will return the time the OS booted up\n&#039; it is a multi-column sensor and should have the format\n&#039; Date | Time\n\nDim dateBootTime, strFinalOutputString, strSep\nSetLocale(GetTaniumLocale)\n\nstrSep = &quot;|&quot;\ndateBootTime = GetBootTime\n\nWScript.Echo FormatDateTime(dateBootTime,vbShortDate) &amp; &quot;|&quot; &amp; FormatDateTime(dateBootTime,vbShortTime)\n\n&#039;-----------End Main-------------&#039;\nFunction GetBootTime\n&#039; Retrieves a nicely formatted bootup time\n\tDim objSWbemDateTime\n\tDim objWMIService\n\tDim colOperatingSystems\n\tDim strComputer\n\tDim dateBootTime\n\t\n\tstrComputer = &quot;.&quot;\n\t\n\tSet objSWbemDateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\tSet colOperatingSystems = objWMIService.ExecQuery (&quot;Select * from Win32_OperatingSystem&quot;)\n\t \n\tFor Each objOperatingSystem in colOperatingSystems\n\t\tobjSWbemDateTime.Value = objOperatingSystem.LastBootUpTime\n\t\tdateBootTime = CDate(objSWbemDateTime.GetVarDate(False))\n\tNext\n\n    &#039; Now to correct for time zones \n    Set colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n     \n    For Each objTimeZone in colTimeZone\n        intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n        dateBootTime = DateAdd(&quot;n&quot;, intTZBiasInMinutes, dateBootTime)\n    Next\n\t\n\t&#039;return result\n\tGetBootTime = dateBootTime\n\t\n\t&#039;Cleanup\n\tSet objSWbemDateTime = Nothing\n\tSet objWMIService = Nothing\n\tSet colOperatingSystems = Nothing\n\tSet colTimeZone = Nothing\n\nEnd Function &#039;GetBootTime\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Time", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 309, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the names of the network connections which are active.\nExample: Local Area Connection", 
      "exclude_from_parse_flag": 1, 
      "hash": 3276808962, 
      "hidden_flag": 0, 
      "id": 615, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Network Adapter Type", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select NetConnectionID from Win32_NetworkAdapter where (NetConnectionStatus = 2)", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 310, 
      "category": "Registry", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns all subkeys of a supplied key.  If the hive is HKEY_USERS, it will attempt to output the user name associated with the key.  HKEY_CURRENT_USER will only return data for the SYSTEM account which the Tanium Client runs as.\nExample: John |Sensor Data | 32-bit", 
      "exclude_from_parse_flag": 1, 
      "hash": 3285711879, 
      "hidden_flag": 0, 
      "id": 617, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Registry Key Subkeys", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{5}\",\"helpString\":\"Value must be at least 5 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the registry key to query\",\"value\":\"\",\"promptText\":\"e.g. HKEY_USERS\\\\Software\\\\Key\",\"defaultValue\":\"\",\"label\":\"Registry Key\",\"maxChars\":0,\"key\":\"strKey\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Key Subkeys\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Subkey Name | Architecture | KeyPath\n\nstrKey = unescape(&quot;||strKey||&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n\nstrSep = &quot;|&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\t\n\t\thasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\t\n\tEnd If\nEnd If\n\nIf Not (hasAnyResult) Then\n\tWScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\t&#039; Note the key that was being searched, will be a hidden column\n\tstrOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n\t\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\tWScript.Echo strUserName &amp; strSep &amp; strValueName &amp; strSep &amp; intBit &amp; &quot;-bit&quot; _\n\t\t\t\t&amp; strSep &amp; strOutputKey &amp; &quot;\\&quot; &amp; strValueName\n\t\tNext\n\t\tCheckValues = True\n\n\tElse\n\t\tCheckValues = False\n\tEnd If\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\\Software\\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\\Software\\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "User", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Subkey Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Architecture", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "KeyPath", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 311, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the number of physical processors on a system.  This may differ from the number of cores or number of logical processors.\nExample:1", 
      "exclude_from_parse_flag": 1, 
      "hash": 3320877330, 
      "hidden_flag": 0, 
      "id": 619, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Number of Processors", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select NumberofProcessors from win32_ComputerSystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ncat /proc/cpuinfo | grep processor | wc -l\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsystem_profiler SPHardwareDataType | grep -i &quot;Number of Processors&quot; | awk -F&#039;: &#039; &#039; { print $2 } &#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 312, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the Organization defined at OS install time.\nExample: YourCorp", 
      "exclude_from_parse_flag": 1, 
      "hash": 3369713834, 
      "hidden_flag": 0, 
      "id": 621, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Organization", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Organization from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 313, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns applications that have been launched in the last number of days supplied.\nExample: Microsoft Excel", 
      "exclude_from_parse_flag": 1, 
      "hash": 341438855, 
      "hidden_flag": 0, 
      "id": 623, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Recently Run Applications", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of previous days to search\",\"value\":\"7\",\"defaultValue\":\"7\",\"snapInterval\":1,\"label\":\"Number of Previous Days to Search\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"},{\"helpString\":\"Enter True or False whether to show the date.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Show Date?\",\"key\":\"showDate\",\"values\":[\"True\",\"False\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Recently Run Applications\n&#039;========================================\n\ndays = unescape(&quot;||days||&quot;)\nIf Not IsNumeric(days) Then \n\tWScript.Echo &quot;Parameter Not Number&quot;\n\tWScript.Quit\nEnd If \ndays = CInt(days)\n\nshowDate = unescape(&quot;||showDate||&quot;)\nshowDate=LCase(showDate)\nIf showDate = &quot;yes&quot; Or showDate = &quot;true&quot; Then \n\tbShowDate = True\nElse \n\tbShowDate = False\nEnd If \n\nstrComputer = &quot;.&quot;\nConst HKLM = &amp;h80000002\nSet reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKeyPath = GetTaniumRegistryPath() &amp; &quot;\\Sensor Data\\Applications&quot;\n\nIf RegKeyExists(reg, HKLM, strKeyPath) Then\n\treg.EnumKey HKLM, strKeyPath, arrSubKeys\n\tIf IsArray(arrSubKeys) Then\n\tFor Each Subkey in arrSubKeys\n\t\t&#039;Wscript.Echo Subkey\n\t\tnewKeyPath = strKeyPath &amp; &quot;\\&quot; &amp; Subkey\n\t\t\n\t\treg.GetStringValue HKLM, newKeyPath, &quot;Last Start&quot;, strLastStart\n\t\treg.GetStringValue HKLM, newKeyPath, &quot;Description&quot;, strDescription\n\n\t\tIf Not IsNull(strLastStart) Then\n\t\t\tIf GetDaysOld(strLastStart) &lt; days Then\n\t\t\t\tDim strOutput\n\t\t\t\tstrOutput = strDescription\n\t\t\t\t\n\t\t\t\tIf bShowDate Then\n\t\t\t\t\tstrOutput = strOutput &amp; &quot; - &quot; &amp; strLastStart\n\t\t\t\tEnd If\n\t\t\t\tWScript.Echo strOutput\n\t\t\tEnd If\n\t\tEnd If\t\n\tNext\n\tEnd If\nElse\t\n\tWScript.Echo &quot;Application data not initialized&quot;\nEnd If\n\nfunction GetDaysOld(strDate)\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, strDate, today)\nEnd Function\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of previous days to search&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Number of Previous Days to Search&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;True&quot;,&quot;False&quot;],&quot;key&quot;:&quot;showDate&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Enter True or False whether to show the date.&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Date?&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||showDate||  ||days||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of previous days to search&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;7&quot;,&quot;value&quot;:&quot;7&quot;,&quot;label&quot;:&quot;Number of Previous Days to Search&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;},{&quot;values&quot;:[&quot;True&quot;,&quot;False&quot;],&quot;key&quot;:&quot;showDate&quot;,&quot;promptText&quot;:&quot;&quot;,&quot;helpString&quot;:&quot;Enter True or False whether to show the date.&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;label&quot;:&quot;Show Date?&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||showDate||  ||days||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 314, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The date on which the currently installed Tanium Client was installed on each client machine.\nExample: Wed, 13 Nov 2013 00:00:00 -0480", 
      "exclude_from_parse_flag": 1, 
      "hash": 3418227220, 
      "hidden_flag": 0, 
      "id": 625, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Client Installation Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Install Date\n&#039;========================================\n\nstrComputer = &quot;.&quot;\n    Set objRegistry = _\n       GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _\n       &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\n    Const HKLM = &amp;H80000002\n\n    keyPath = &quot;Software\\Tanium\\Tanium Client&quot;\n    key64Path = &quot;Software\\WOW6432Node\\Tanium\\Tanium Client&quot;\n\n    If Not RegKeyExists(HKLM, keyPath) Then\n       keyPath = key64Path\n\n       If Not RegKeyExists(HKLM, keyPath) Then\n          WScript.Echo &quot;Not installed&quot;\n          WScript.Quit\n       End If\n    End If\n\n    objRegistry.GetStringValue HKLM, keyPath, &quot;FirstInstall&quot;, strFirstInstall\n\n\tIf Not IsNull(strFirstInstall) Then\n\t\tstrFirstInstall = FormatDateTime(strFirstInstall, 2)\n\t\tWScript.Echo VBTimeToRFC822(strFirstInstall,GetRFC822Bias)\n\t\tWScript.Quit\n\tElse   \n\t\tWScript.Echo &quot;Not installed&quot;\n\tEnd If  \n\n    Function RegKeyExists(sHive, sRegKey)\n       Dim aValueNames, aValueTypes\n       If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n          RegKeyExists = True\n       Else\n          RegKeyExists = False\n       End If\n    End Function\n\t\n\nFunction vbTimeToRFC822(myDate, offset)\n&#039;SetLocale outside of function in global scope\n&#039; must be set so that month is displayed with US/English abbreviations\n&#039; as per the standard\n\n\tIf Not GetLocale = 1033 Then\n\t\tWScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;\n\t\tWScript.Quit\n\tEnd If\n   Dim myDay, myDays, myMonth, myYear\n   Dim myHours, myMinutes, myMonths, mySeconds\n\n   myDate = CDate(myDate)\n   myDay = WeekdayName(Weekday(myDate),true)\n   myDays = zeroPad(Day(myDate), 2)\n   myMonth = MonthName(Month(myDate), true)\n   myYear = Year(myDate)\n   myHours = zeroPad(Hour(myDate), 2)\n   myMinutes = zeroPad(Minute(myDate), 2)\n   mySeconds = zeroPad(Second(myDate), 2)\n\n   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _\n                                  myDays&amp;&quot; &quot;&amp; _\n                                  myMonth&amp;&quot; &quot;&amp; _ \n                                  myYear&amp;&quot; &quot;&amp; _\n                                  myHours&amp;&quot;:&quot;&amp; _\n                                  myMinutes&amp;&quot;:&quot;&amp; _\n                                  mySeconds&amp;&quot; &quot;&amp; _ \n                                  offset\nEnd Function &#039;vbTimeToRFC822\n\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function\n\nFunction GetRFC822Bias\n&#039; This function returns a string which is a \n&#039; timezone bias for RFC822 format\n&#039; considers daylight savings\n&#039; we choose 4 digits and a sign (+ or -)\n\n\tDim objWMIService,colTimeZone,objTimeZone\n\t\n\tDim intTZBiasInMinutes,strSign,strReturnString\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n\t \n\tFor Each objTimeZone in colTimeZone\n\t    intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n\tNext\n\n\t&#039; The offset is explicitly signed\n\tIf intTZBiasInMinutes &lt; 0 Then\n\t\tstrSign = &quot;-&quot;\n\tElse\n\t\tstrSign = &quot;+&quot;\n\tEnd If\n\t\n\tstrReturnString = CStr(Abs(intTZBiasInMinutes))\n\t&#039; no offset is greater than three digits but RFC822 bias seems to\n\t&#039; usually take the form of 1 alpha / 4 digit as described as \n\t&#039; valid in ANSI X3.51-1975\n\n\tstrReturnString = zeroPad(strReturnString,4)\n\n\tGetRFC822Bias = strSign&amp;strReturnString\n\t\n\t&#039;Cleanup\n\tSet colTimeZone = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;GetRFC822Bias", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nmdls -name kMDItemFSCreationDate /Library/Tanium/TaniumClient | awk &#039;{print $3}&#039; | awk -F &#039;-&#039;  &#039;{print $2&quot;-&quot;$3&quot;-&quot;$1}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "BESDate"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 315, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns local accounts and days until they expire. Accounts which have no expiration date return \"N/A\"\nExample:\nuser.name|19", 
      "exclude_from_parse_flag": 1, 
      "hash": 3418263806, 
      "hidden_flag": 0, 
      "id": 627, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Local Account Expiration Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Local Account Expiration Details\n&#039;========================================\n\n\nOption Explicit\n\nDim objAccounts,objUser,dtmExpirationDate,intDaysUntil,strSep\n\nstrSep = &quot;|&quot;\n&#039; Multi-column output\n&#039; Account Name|Days Until Expiration\nSetLocale(1033) &#039;Uses RFC822, requires US/English\n\nOn Error Resume Next\n\nSet objAccounts = GetObject(&quot;WinNT://.&quot;)\nobjAccounts.Filter = Array(&quot;User&quot;)\n\nFor Each objUser In objAccounts\n\tIf IsNull(objUser.AccountExpirationDate) Then\n\t\tWscript.Echo objUser.Name &amp; strSep &amp; &quot;N/A&quot;\n\tElse\n\t\tdtmExpirationDate = objUser.AccountExpirationDate\n\t\tintDaysUntil = Abs(DateDiff(&quot;d&quot;,Now(),dtmExpirationDate))\n\t\tWscript.Echo objUser.Name&amp;intDaysUntil\n\tEnd If\nNext\n\n\n\nFunction vbTimeToRFC822(myDate, offset)\n&#039;SetLocale outside of function in global scope\n&#039; must be set so that month is displayed with US/English abbreviations\n&#039; as per the standard\n\n\tIf Not GetLocale = 1033 Then\n\t\tWScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;\n\t\tWScript.Quit\n\tEnd If\n   Dim myDay, myDays, myMonth, myYear\n   Dim myHours, myMinutes, myMonths, mySeconds\n\n   myDate = CDate(myDate)\n   myDay = WeekdayName(Weekday(myDate),true)\n   myDays = zeroPad(Day(myDate), 2)\n   myMonth = MonthName(Month(myDate), true)\n   myYear = Year(myDate)\n   myHours = zeroPad(Hour(myDate), 2)\n   myMinutes = zeroPad(Minute(myDate), 2)\n   mySeconds = zeroPad(Second(myDate), 2)\n\n   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _\n                                  myDays&amp;&quot; &quot;&amp; _\n                                  myMonth&amp;&quot; &quot;&amp; _ \n                                  myYear&amp;&quot; &quot;&amp; _\n                                  myHours&amp;&quot;:&quot;&amp; _\n                                  myMinutes&amp;&quot;:&quot;&amp; _\n                                  mySeconds&amp;&quot; &quot;&amp; _ \n                                  offset\nEnd Function &#039;vbTimeToRFC822\n\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function\n\nFunction GetRFC822Bias\n&#039; This function returns a string which is a \n&#039; timezone bias for RFC822 format\n&#039; considers daylight savings\n&#039; we choose 4 digits and a sign (+ or -)\n\n\tDim objWMIService,colTimeZone,objTimeZone\n\t\n\tDim intTZBiasInMinutes,strSign,strReturnString\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n\t \n\tFor Each objTimeZone in colTimeZone\n\t    intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n\tNext\n\n\t&#039; The offset is explicitly signed\n\tIf intTZBiasInMinutes &lt; 0 Then\n\t\tstrSign = &quot;-&quot;\n\tElse\n\t\tstrSign = &quot;+&quot;\n\tEnd If\n\t\n\tstrReturnString = CStr(Abs(intTZBiasInMinutes))\n\t&#039; no offset is greater than three digits but RFC822 bias seems to\n\t&#039; usually take the form of 1 alpha / 4 digit as described as \n\t&#039; valid in ANSI X3.51-1975\n\n\tstrReturnString = zeroPad(strReturnString,4)\n\n\tGetRFC822Bias = strSign&amp;strReturnString\n\t\n\t&#039;Cleanup\n\tSet colTimeZone = Nothing\n\tSet objWMIService = Nothing\n\t\nEnd Function &#039;GetRFC822Bias", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Account Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Days Until Expiration", 
            "value_type": "NumericInteger"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 316, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The date and time on which the currently installed Tanium Client was installed on each client machine.\nExample: Wed, 13 Nov 2013 08:18:00 -0480", 
      "exclude_from_parse_flag": 1, 
      "hash": 3479253433, 
      "hidden_flag": 0, 
      "id": 629, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 1800, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Client Installation Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client Installation Time\n&#039;========================================\n\nstrComputer = &quot;.&quot;\n    Set objRegistry = _\n       GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _\n       &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\n    Const HKLM = &amp;H80000002\n\n    keyPath = &quot;Software\\Tanium\\Tanium Client&quot;\n    key64Path = &quot;Software\\WOW6432Node\\Tanium\\Tanium Client&quot;\n\n    If Not RegKeyExists(HKLM, keyPath) Then\n       keyPath = key64Path\n\n       If Not RegKeyExists(HKLM, keyPath) Then\n          WScript.Echo &quot;Not installed&quot;\n          WScript.Quit\n       End If\n    End If\n\n    objRegistry.GetStringValue HKLM, keyPath, &quot;FirstInstall&quot;, strFirstInstall\n\n\tIf Not IsNull(strFirstInstall) Then\n\t\tWScript.Echo VBTimeToRFC822(strFirstInstall,GetRFC822Bias)\n\t\tWScript.Quit\n\tElse   \n\t\tWScript.Echo &quot;Not installed&quot;\n\tEnd If  \n\n    Function RegKeyExists(sHive, sRegKey)\n       Dim aValueNames, aValueTypes\n       If objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n          RegKeyExists = True\n       Else\n          RegKeyExists = False\n       End If\n    End Function\n\t\n\nFunction vbTimeToRFC822(myDate, offset)\n&#039;SetLocale outside of function in global scope\n&#039; must be set so that month is displayed with US/English abbreviations\n&#039; as per the standard\n\n\tIf Not GetLocale = 1033 Then\n\t\tWScript.Echo &quot;Locale Code must be 1033, use SetLocale&quot;\n\t\tWScript.Quit\n\tEnd If\n   Dim myDay, myDays, myMonth, myYear\n   Dim myHours, myMinutes, myMonths, mySeconds\n\n   myDate = CDate(myDate)\n   myDay = WeekdayName(Weekday(myDate),true)\n   myDays = zeroPad(Day(myDate), 2)\n   myMonth = MonthName(Month(myDate), true)\n   myYear = Year(myDate)\n   myHours = zeroPad(Hour(myDate), 2)\n   myMinutes = zeroPad(Minute(myDate), 2)\n   mySeconds = zeroPad(Second(myDate), 2)\n\n   vbTimeToRFC822 = myDay&amp;&quot;, &quot;&amp; _\n                                  myDays&amp;&quot; &quot;&amp; _\n                                  myMonth&amp;&quot; &quot;&amp; _ \n                                  myYear&amp;&quot; &quot;&amp; _\n                                  myHours&amp;&quot;:&quot;&amp; _\n                                  myMinutes&amp;&quot;:&quot;&amp; _\n                                  mySeconds&amp;&quot; &quot;&amp; _ \n                                  offset\nEnd Function &#039;vbTimeToRFC822\n\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function\n\nFunction GetRFC822Bias\n&#039; This function returns a string which is a \n&#039; timezone bias for RFC822 format\n&#039; considers daylight savings\n&#039; we choose 4 digits and a sign (+ or -)\n\n\tDim objWMIService,colTimeZone,objTimeZone\n\t\n\tDim intTZBiasInMinutes,strSign,strReturnString\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t    &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\tSet colTimeZone = objWMIService.ExecQuery(&quot;Select * from Win32_ComputerSystem&quot;)\n\t \n\tFor Each objTimeZone in colTimeZone\n\t    intTZBiasInMinutes = objTimeZone.CurrentTimeZone\n\tNext\n\n\t&#039; The offset is explicitly signed\n\tIf intTZBiasInMinutes &lt; 0 Then\n\t\tstrSign = &quot;-&quot;\n\tElse\n\t\tstrSign = &quot;+&quot;\n\tEnd If\n\t\n\tstrReturnString = CStr(Abs(intTZBiasInMinutes))\n\t&#039; no offset is greater than three digits but RFC822 bias seems to\n\t&#039; usually take the form of 1 alpha / 4 digit as described as \n\t&#039; valid in ANSI X3.51-1975\n\n\tstrReturnString = zeroPad(strReturnString,4)\n\n\tGetRFC822Bias = strSign&amp;strReturnString\n\t\n\t&#039;Cleanup\n\tSet colTimeZone = Nothing\n\tSet objWMIService = Nothing\n\t\nEnd Function &#039;GetRFC822Bias", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nmdls -name kMDItemFSCreationDate /Library/Tanium/TaniumClient | awk &#039;{print $4}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "BESDate"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 317, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The location of the system directory on Windows machines.\nExample: C:\\\\Windows\\\\system32", 
      "exclude_from_parse_flag": 1, 
      "hash": 3482410175, 
      "hidden_flag": 0, 
      "id": 631, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "System Directory", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select SystemDirectory from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 318, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Details on patches which Tanium has installed.\nExample: Title | Install date (UTC) | Result", 
      "exclude_from_parse_flag": 1, 
      "hash": 3487549512, 
      "hidden_flag": 0, 
      "id": 633, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Patches Installed by Tanium", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patches Installed By Tanium\n&#039;========================================\n\n&#039; sensor - Patches Installed by Tanium\n&#039; This sensor will list patches that the tanium patch installer logs\n&#039; this may differ than the list of installed patches\n&#039; which may have been installed through any workable technology\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput\nstrSep = &quot;|&quot;\n\n\n&#039;Title|Install Date (UTC)|Result|Tanium Patch ID\n\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\installedresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine,words,bBadLine,strOut\n\n\tbBadline = False\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\t\twords = Split(strLine, strSep)\t\n\t\t&#039; only output 4 column data\n\t\tIf UBound(words) = 3 Then \n\t\t\tstrOut = words(1)&amp;strSep&amp;words(2)&amp;strSep&amp;words(3)\n\t\tElseIf UBound(words) = 4 Then\n\t\t\tstrOut = words(1)&amp;strSep&amp;words(2)&amp;strSep&amp;words(3)&amp;strSep&amp;words(4)\n\t\tElse\n\t\t\tbBadLine = True\n\t\tEnd If\n\t\tWScript.Echo strOut\n\tLoop\n\n\tobjReadFile.close\nElse\n   Wscript.echo &quot;Error: Tanium patch install history output not found&quot;\nEnd If\n\nIf bBadLine Then WScript.Echo &quot;Error: A Bad Line was detected and not displayed&quot;\n\nWScript.Quit()\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Install Date (UTC)", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Result", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 319, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Indicates how many days ago a new AV signature was applied.\nExample: 8", 
      "exclude_from_parse_flag": 1, 
      "hash": 3494644520, 
      "hidden_flag": 0, 
      "id": 635, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Forefront Client Signature Applied Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signature Applied Days Old\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\twords = Split(BinaryToDate(binValue))\n\t\tWScript.Echo GetDaysOld(words(0))\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nEnd If\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetDaysOld = DateDiff(&quot;d&quot;, patternDate, today)\nEnd Function\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 320, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Provides a list of hosts file entries for the local operating system.\nExample: myserver.com , 192.168.1.100", 
      "exclude_from_parse_flag": 0, 
      "hash": 3518770446, 
      "hidden_flag": 0, 
      "id": 637, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 300, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Hosts File Entries", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Option Explicit\nClass std_host_file\n\tPrivate Sub Class_Initialize()\n\t\tSet m_lines = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\tSet m_ip_map = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\tSet m_alias_map = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\tm_alias_map.CompareMode = vbTextCompare\n\tEnd Sub\n\tPrivate sub Class_Terminate()\n\t\tSet m_lines = Nothing\n\t\tSet m_ip_map = Nothing\n\t\tSet m_alias_map = Nothing\n\tEnd Sub\n\t&#039; Function returns the ip and data\n\tPrivate Sub parse_line( ByVal line , ByRef comment , ByRef ip , ByRef aliases  ) \n\t\tDim rx : Set rx = New RegExp\n\t\tDim r\n\t\trx.Global = False\n\t\trx.IgnoreCase = True\n\t\trx.Pattern = &quot;\\s*(#.*)\\s*&quot;\n\t\t&#039; Parse Comment\n\t\tIf rx.Test( line ) Then\n\t\t\tSet r = rx.Execute( line )\n\t\t\tcomment = r.Item(0).subMatches.Item(0)\n\t\t\tline = rx.Replace( line , &quot;&quot; )\n\t\tEnd If\t\t\n\t\trx.Pattern = &quot;\\s*((\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b)|(\\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*))\\s*&quot;\n\t\t&#039; Parse IP\n\t\tIf rx.Test( line ) Then\n\t\t\tSet r = rx.Execute( line )\n\t\t\tip = r.Item(0).subMatches.Item(0)\n\t\t\taliases = rx.Replace( line , &quot;&quot; )\n\t\tEnd If\n\tEnd Sub\n\t&#039; Function returns the ip and data\n\tPrivate Function getip( ByRef str , ByRef ip  ) \n\t\tgetip = False \n\t\tDim rx_ip : Set rx_ip = New RegExp\n\t\trx_ip.Global = False\n\t\trx_ip.IgnoreCase = True\n\t\trx_ip.Pattern = &quot;\\s*((\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b)|(\\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*))\\s*&quot;\n\t\tIf rx_ip.Test( str ) Then\n\t\t\tDim r : Set r = rx_ip.Execute( str )\n\t\t\tip = r.Item(0).subMatches.Item(0)\n\t\t\tstr = rx_ip.Replace( str , &quot;&quot; )\n\t\t\tgetip = True\n\t\tEnd If\n\tEnd Function\n\t&#039; Internal function used to validate IPV4 addresses\n\tPrivate Function isipv4( ByVal ip )\n\t\tDim rx_ipv4 : Set rx_ipv4 = New RegExp\n\t\trx_ipv4.Global = false\n\t\trx_ipv4.IgnoreCase = True\n\t\trx_ipv4.Pattern = &quot;^\\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b$&quot;\n\t\tisipv4 = rx_ipv4.Test( ip )\n\tEnd Function\n\t&#039; Internal function used to validate IPV6 addresses\n\tPrivate Function isipv6( ip )\n\t\tDim rx_ipv6 : Set rx_ipv6 = New RegExp\n\t\trx_ipv6.Global = false\n\t\trx_ipv6.IgnoreCase = True\n\t\trx_ipv6.Pattern = &quot;^\\s*((([0-9A-F]{1,4}:){7}([0-9A-F]{1,4}|:))|(([0-9A-F]{1,4}:){6}(:[0-9A-F]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){5}(((:[0-9A-F]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-F]{1,4}:){4}(((:[0-9A-F]{1,4}){1,3})|((:[0-9A-F]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){3}(((:[0-9A-F]{1,4}){1,4})|((:[0-9A-F]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){2}(((:[0-9A-F]{1,4}){1,5})|((:[0-9A-F]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-F]{1,4}:){1}(((:[0-9A-F]{1,4}){1,6})|((:[0-9A-F]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-F]{1,4}){1,7})|((:[0-9A-F]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$&quot;\t\t\t\n\t\tIsIPV6 = rx_ipv6.Test( ip )\n\tEnd Function\n\t&#039; Internal function used to generate unique IDs\n\tPrivate Function genguid()\n\t\tDim guidgen : Set guidgen = CreateObject(&quot;Scriptlet.TypeLib&quot;) \n\t\tgenguid = Mid(guidgen.Guid, 2, 36)\n\tEnd Function\n\t&#039; Function returns true on success, otherwise false if the ip doesn&#039;t exist\n\tPublic Function GetHostEntryAliases( ByVal ip , ByRef aliases )\n\t\tGetHostEntryAliases = False\n\t\taliases = Array\n\t\tIf m_ip_map.Exists( ip ) Then \n\t\t\taliases = m_lines.Item( m_ip_map.Item(ip) )(1).Keys\n\t\t\tGetHostEntryAliases = True\n\t\tEnd If\n\tEnd Function \n\t&#039; Function returns true on success, otherwise false if alias doesn&#039;t exist\n\tPublic Function GetHostEntryAliasAddresses( ByVal alias , ByRef ips )\n\t\tGetHostEntryAliasAddresses = False\n\t\tips = Array\n\t\tIf m_alias_map.Exists( alias ) Then \n\t\t\tips = m_alias_map.Item( alias ).Keys\n\t\t\tGetHostEntryAliasAddresses = True\n\t\tEnd If\n\tEnd Function \n\t&#039; Removes a host entry by IPV4 or IPV6 address, return true\n\t&#039; on success, otherwise false if the IP is doesn&#039;t exist\n\tPublic Function DeleteHostEntry( ByVal ip )\n\t\tDeleteHostEntry = False\n\t\tIf m_ip_map.Exists( ip ) Then \n\t\t\tDim a\n\t\t\tDim uid : uid = m_ip_map.Item(ip)\n\t\t\t&#039; Remove the ip&#039;s from the associated aliases\n\t\t\tFor Each a In m_lines.Item(uid)(1).Keys \n\t\t\t\tIf m_alias_map.Item( a ).Exists( ip ) Then\n\t\t\t\t\tm_alias_map.Item( a ).Remove( ip )\n\t\t\t\tEnd If\n\t\t\t\t&#039; If there are no more assoicated IPs remove the alias\n\t\t\t\tIf m_alias_map.Item(a).Count = 0 Then\n\t\t\t\t\tm_alias_map.Remove( a )\n\t\t\t\tEnd If \n\t\t\tNext\n\t\t\t&#039; This *should* exist since we manage the entries and mappings\n\t\t\tm_lines.Remove( uid )\n\t\t\tm_ip_map.Remove( ip )\n\t\t\tDeleteHostEntry = True\n\t\tEnd If\n\tEnd Function\n\t&#039; Removes a host alias by IPV4 or IPV6 address\n\tPublic Function DeleteHostEntryAlias( ByVal ip , ByVal alias )\n\t\tDeleteHostEntryAlias = False\n\t\t&#039; If the IP is valid\n\t\tIf m_ip_map.Exists( ip ) Then\n\t\t\tDim uid : uid = m_ip_map.Item(ip)\t\t\n\t\t\t&#039; If the alias exists remove the ip and if no more ip&#039;s are mapped to the alias remove the alias\t\n\t\t\tIf m_alias_map.Exists( alias ) Then\n\t\t\t\tIf m_alias_map.Item( alias ).Exists( ip ) Then\n\t\t\t\t\tm_alias_map.Item( alias ).Remove( ip )\n\t\t\t\tEnd If\n\t\t\t\tIf m_alias_map.Item(alias).Count = 0 Then\n\t\t\t\t\tm_alias_map.Remove( alias )\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\t\t&#039; If IP no longer has aliases associated with it remove it\n\t\t\tCall delalias( uid , alias )\n\t\t\tIf m_lines.Item( uid )(1).Count = 0 Then\n\t\t\t\tm_lines.Remove( uid )\n\t\t\t\tm_ip_map.Remove( ip )\n\t\t\tEnd If\n\t\t\tDeleteHostEntryAlias = True\n\t\tEnd If\n\tEnd Function\n\t&#039; Adds a host entry by IPV4 or IPV6 address, alias should be \n\t&#039; the text alias for the address. Returns true on success\n\tPublic Function AddHostEntry( ByVal ip , ByVal alias )\t\t\n\t\t\tAddHostEntry = False \t\t\n\t\t\tDim rx : Set rx = New RegExp\n\t\t\trx.Global = true\n\t\t\trx.IgnoreCase = True\n\t\t\trx.Pattern = &quot;\\s*&quot;\n\t\t\talias = rx.Replace( alias , &quot;&quot; )\n\t\t\tip = rx.Replace( ip , &quot;&quot; )\n\t\t\t&#039; Validate IP\n\t\t\tIf isipv6( ip ) Or isipv4( ip ) Then \n\t\t\t\t&#039; Check for alias in the alias mapping\n\t\t\t\tIf Not m_alias_map.Exists( alias ) Then\tCall m_alias_map.Add( alias , CreateObject(&quot;Scripting.Dictionary&quot;) )\n\t\t\t\tIf Not m_alias_map.Item( alias ).Exists( ip ) Then Call m_alias_map.Item( alias ).Add( ip , &quot;&quot; )\n\t\t\t\t&#039; Map IP -&gt; alias \n\t\t\t\tIf m_ip_map.Exists( ip ) Then \n\t\t\t\t\t&#039; Lookup the index by ip then add aliases\n\t\t\t\t\tCall addalias( m_ip_map.Item(ip) , alias )\n\t\t\t\tElse\n\t\t\t\t\t&#039; Store File Line\n\t\t\t\t\tDim uid : uid = genguid\n\t\t\t\t\tCall m_lines.Add( uid , Array( ip , CreateObject(&quot;Scripting.Dictionary&quot;) , vbNullString ) )\n\t\t\t\t\tCall addalias( uid , alias )\n\t\t\t\t\tCall m_ip_map.Add( ip , uid )\n\t\t\t\tEnd If\n\t\t\t\tAddHostEntry = True\n\t\t\tEnd If\t\n\tEnd Function\n\t&#039; Should be used for debugging the data\n\tPublic Sub DumpData( )\n\t\tDim id, a, ip, a_map\n\t\t&#039; Debug dump host file out to text\n\t\t\n\t\tFor Each ip In m_ip_map.Keys\n\t\t\tFor Each a In m_lines.Item( m_ip_map.Item(ip) )(1).Keys\n&#039;\t\t\t\tWScript.Echo &quot;IP [&quot; &amp; ip &amp; &quot;] ID Map {&quot; &amp; m_ip_map.Item(ip)\t&amp; &quot;} --&gt; alias [&quot; &amp; a &amp; &quot;]&quot;\n\t\t\t\tIf m_alias_map.Exists( a ) Then \n\t\t\t\t\tFor Each a_map In m_alias_map.Item( a ).Keys\n\t\t\t\t\t\tWScript.Echo a &amp; &quot;,&quot; &amp; a_map\n\t\t\t\t\tNext\n\t\t\t\tEnd If\n\t\t\tNext\n\t\tNext\t \n\tEnd Sub \n\t&#039; Internal formattig function for padding host data\n\tPrivate Function lpad ( str , padch , padlen ) \n\t\tIf padlen - Len(str) &gt;= 0 Then \n\t\t\tLpad = String(padlen - Len(str),padch) &amp; str \n\t\tElse\n\t\t\tLpad = str\t\n\t\tEnd If \t\n\tEnd Function\n\t&#039; Returns all the IP addresses defined in the host file\n\t&#039; Returns true on success, otherwise false\n\tPublic Function GetAllHostEntryAddresses( ByRef ips )\n\t\tGetAllHostEntryAddresses = False\n\t\tips = Array\n\t\tIf m_ip_map.Count &gt; 0 Then \n\t\t\tips = m_ip_map.Keys\n\t\t\tGetAllHostEntryAddresses = True\n\t\tEnd If\n\tEnd Function\n\t&#039; Returns all the aliases defined in the host file\n\t&#039; Returns true on success, otherwise false\n\tPublic Function GetAllHostEntryAliases( ByRef aliases )\n\t\tGetAllHostEntryAliases = False\n\t\taliases = Array\n\t\tIf m_alias_map.Count &gt; 0 Then \n\t\t\taliases = m_alias_map.Keys\n\t\t\tGetAllHostEntryAliases = True\n\t\tEnd If\n\tEnd Function\n\t\n\t&#039; Write host file returns true if file could be opened for writing\n\tPublic Function Save( ByVal hostfile )\t\t\n\t\tOn Error Resume Next\n\t\tSave = False\n\t\tDim id, a\n\t\tDim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\tDim oFile : Set oFile = Nothing\n\t\tSet oFile = objFSO.OpenTextFile( hostfile , 2 , True )\n\t\tIf Not oFile Is Nothing Then \n\t\t\tFor Each id In m_lines.Keys\n\t\t\t\tIf TypeName( m_lines.Item(id) ) = &quot;String&quot; Then\n\t\t\t\t\tCall oFile.WriteLine( m_lines.Item(id) )\n\t\t\t\tElseIf TypeName( m_lines.Item(id) ) = &quot;Variant()&quot; Then\n\t\t\t\t\tCall oFile.Write( lpad( m_lines.Item(id)(0) &amp; &quot;&quot; , &quot; &quot; , 16 )  &amp; Space(8) )\n\t\t\t\t\tFor Each a In m_lines.Item(id)(1).Keys\n\t\t\t\t\t\tCall oFile.Write( a &amp; &quot; &quot; )\n\t\t\t\t\tNext\n\t\t\t\t\tCall oFile.Write( m_lines.Item(id)(2) &amp; vbCrLf )\n\t\t\t\tEnd If \n\t\t\tNext\n\t\t\tSave = True\n\t\tEnd If\n\t\tSet objFSO = Nothing\n\tEnd Function\n\t\n\t&#039; Write host file returns true if file could be opened for reading\n\tPublic Function Load( ByVal hostfile , ByVal bmergecomments )\n\t\tOn Error Resume Next\t\t\n\t\tLoad = False\n\t\tm_lines.RemoveAll()\n\t\tm_ip_map.RemoveAll()\n\t\tm_alias_map.RemoveAll()\n\t\tDim rx : Set rx = New RegExp\n\t\trx.Global = true\n\t\trx.IgnoreCase = True\n\t\trx.Pattern = &quot;\\s+&quot;\n\t\tDim objFSO : Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\tDim oFile : Set oFile=Nothing\n\t\tSet oFile = objFSO.OpenTextFile( hostfile , 1 )\n\t\tIf Not oFile Is Nothing Then \n\t\tWhile Not oFile.AtEndOfStream\n\t\t\tDim pos : pos = 0\n\t\t\t&#039; Data will not be modified to preserve the file context\n\t\t\tDim data : data = Trim(oFile.ReadLine())\n\t\t\t&#039; Remove all the extra whitespace so we have a single spacing\t\n\t\t\t&#039; Line will be chopped up to see valid information exists\n\t\t\tDim line : line = Trim(rx.Replace(data, &quot; &quot;))\n\t\t\tDim ip : ip = vbNullString\n\t\t\tDim comment : comment = vbNullString\n\t\t\tDim aliases : aliases = vbNullString\n\t\t\t&#039; Check if the line is empty\n\t\t\tIf line &lt;&gt; vbNullString Then\t\t\t\t\t\n\t\t\t\tCall parse_line( line , comment , ip , aliases )\n\t\t\t\tIf isipv4( ip ) Or isipv6( ip ) Then \t\n\t\t\t\t\tDim a, uid\n\t\t\t\t\t&#039; Map alias -&gt; IPs\n\t\t\t\t\tFor Each a In Split(aliases)\n\t\t\t\t\t\tIf Not m_alias_map.Exists( a ) Then \n\t\t\t\t\t\t\tCall m_alias_map.Add( a , CreateObject(&quot;Scripting.Dictionary&quot;) )\n\t\t\t\t\t\tEnd If\n\t\t\t\t\t\tIf Not m_alias_map.Item( a ).Exists( ip ) Then Call m_alias_map.Item( a ).Add( ip , &quot;&quot; )\n\t\t\t\t\tNext\n\t\t\t\t\t&#039; Map IP -&gt; alias \n\t\t\t\t\tIf m_ip_map.Exists( ip ) Then\n\t\t\t\t\t\tuid = m_ip_map.Item(ip)\n\t\t\t\t\t\t&#039; Lookup the index by ip then add aliases\n\t\t\t\t\t\tFor Each a In Split(aliases)\n\t\t\t\t\t\t\tCall addalias( uid , a )\n\t\t\t\t\t\tNext\n\t\t\t\t\t\tIf bmergecomments Then \n\t\t\t\t\t\t\t&#039; Overkill (should be first # )\n\t\t\t\t\t\t\tpos = InStr( 1, comment , &quot;#&quot; , vbTextCompare )\n\t\t\t\t\t\t\tIf pos &lt;&gt; 0 Then \n\t\t\t\t\t\t\t\t&#039; Replace leading # from dual comment\n\t\t\t\t\t\t\t\tcomment = Mid( comment , pos + 1 )\n\t\t\t\t\t\t\t\t&#039; Merge comments\n\t\t\t\t\t\t\t\tCall setcomment( uid , m_lines.Item( uid )(2) &amp; &quot;,&quot; &amp; comment )\n\t\t\t\t\t\t\tEnd If\n\t\t\t\t\t\tEnd If\n\t\t\t\t\tElse\n\t\t\t\t\t\t&#039; Store File Line\n\t\t\t\t\t\tuid = genguid\n\t\t\t\t\t\tCall m_lines.Add( uid , Array( ip , CreateObject(&quot;Scripting.Dictionary&quot;) , comment ) )\n\t\t\t\t\t\tFor Each a In Split(aliases)\n\t\t\t\t\t\t\tCall addalias( uid , a )\n\t\t\t\t\t\tNext\n\t\t\t\t\t\tCall m_ip_map.Add( ip , uid )\n\t\t\t\t\tEnd If\n\t\t\t\tElse &#039; Unknown IP format or malformed file\n\t\t\t\t\tCall m_lines.Add(genguid,data)\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\tCall m_lines.Add(genguid,data)\n\t\t\tEnd If\n\t\tWend\n\t\tLoad=True\n\t\tEnd If\n\t\tSet objFSO = Nothing\n\tEnd Function\n\tPrivate Function setip( uid , ip )\n\t\tsetip = False\n\t\tIf m_lines.Exists( uid ) Then\n\t\t\tm_lines.Item(uid) = Array( ip , m_lines.Item(uid)(1) , m_lines.Item(uid)(2) ) \n\t\t\tsetip = True\n\t\tEnd If\n\tEnd Function\n\tPrivate Function setcomment( uid , comment )\n\t\tsetcomment = False\n\t\tIf m_lines.Exists( uid ) Then\n\t\t\tDim a : a = m_lines.Item(uid)\n\t\t\tm_lines.Item(uid) = Array( m_lines.Item(uid)(0) , m_lines.Item(uid)(1) , comment )  \n\t\t\tsetcomment = True\n\t\tEnd If\n\tEnd Function\n\tPrivate Function addalias( uid , alias )\n\t\taddalias = False\n\t\tIf m_lines.Exists( uid ) Then\n\t\t\tIf Not m_lines.Item(uid)(1).Exists( alias ) Then \n\t\t\t\tCall m_lines.Item(uid)(1).Add( alias , &quot;&quot; )\n\t\t\t\taddalias = True\n\t\t\tEnd If\n\t\tEnd If\n\tEnd Function\n\tPrivate Function delalias( uid , alias )\n\t\tdelalias = False\n\t\tIf m_lines.Exists( uid ) Then\n\t\t\tIf m_lines.Item(uid)(1).Exists( alias ) Then \n\t\t\t\tCall m_lines.Item(uid)(1).Remove( alias )\n\t\t\t\tdelalias = CBool( Not m_lines.Item(uid)(1).Exists( alias ) )\n\t\t\tEnd If\n\t\tEnd If\n\tEnd Function\n\tPrivate m_lines\n\tPrivate m_ip_map\n\tPrivate m_alias_map\nEnd Class\n\n\nDim arr, n\nDim o_h : Set o_h = New std_host_file\nCall o_h.Load( &quot;C:\\Windows\\System32\\drivers\\etc\\hosts&quot; , False )\n\no_h.DumpData", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\nif [ -f /etc/hosts ]; then\n\n  file=&quot;/etc/hosts&quot;\n  line=`cat $file`\n  \n  while read -r line; do\n    line=`echo $line | sed &#039;s/^ *//g&#039; | sed &#039;s/ *$//g&#039;`\n\n    if [[ &quot;$line&quot; =~ ^#.*$ ]]; then\n\tl=1 #do nothing\n    else\n      if [ -n &quot;$line&quot; ]; then\n        \n        COLS=( $line ); # parses columns without executing a subshell\n        #RESULT=&quot;${COLS[0]}&quot;; # returns first column (0-based indexes)\n        echo &quot;${COLS[1]},${COLS[0]}&quot;\n\n      fi\n    fi\n  done &lt;&lt;&lt; &quot;$line&quot;\n\n\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nif [ -f /etc/hosts ]; then\n\n  file=&quot;/etc/hosts&quot;\n  line=`cat $file`\n  \n  while read -r line; do\n    line=`echo $line | sed &#039;s/^ *//g&#039; | sed &#039;s/ *$//g&#039;`\n\n    if [[ &quot;$line&quot; =~ ^#.*$ ]]; then\n\tl=1 #do nothing\n    else\n      if [ -n &quot;$line&quot; ]; then\n        \n        COLS=( $line ); # parses columns without executing a subshell\n        #RESULT=&quot;${COLS[0]}&quot;; # returns first column (0-based indexes)\n        echo &quot;${COLS[1]},${COLS[0]}&quot;\n\n      fi\n    fi\n  done &lt;&lt;&lt; &quot;$line&quot;\n\n\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Alias", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "IP Address", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 321, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Indicates the last time that the client AV signature was updated.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 3551304570, 
      "hidden_flag": 0, 
      "id": 639, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Forefront Client Signature Applied Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signature Applied Date\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\t\n\t\tWScript.Echo BinaryToDate(binValue)\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 322, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns whether the machine runs a Linux-based OS.  True if so, False if not.\nExample: True", 
      "exclude_from_parse_flag": 0, 
      "hash": 3554080383, 
      "hidden_flag": 0, 
      "id": 641, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Is Linux", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Is Linux\n&#039;========================================\n\nWscript.echo &quot;False&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\necho True\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\necho False\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 323, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the default gateway for all IP enabled network adapters.\nExample: 192.168.10.254", 
      "exclude_from_parse_flag": 1, 
      "hash": 3575849436, 
      "hidden_flag": 0, 
      "id": 643, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Network IP Gateway", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select DefaultIPGateway from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 324, 
      "category": "Microsoft Forefront", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Indicates the last date that the Forefront client signatures were checked by Forefront.\nExample: 09/18/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 3590670635, 
      "hidden_flag": 0, 
      "id": 645, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Forefront Client Signatures Last Checked Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Forefront Client Signatures Last Checked Date\n&#039;========================================\n\nConst HKLM = &amp;h80000002\nSet reg=Getx64RegistryProvider()\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nstrKey = &quot;Software\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nIf Not RegKeyExists(reg, HKLM, strKey) Then\n\tstrKey = &quot;Software\\Wow6432Node\\Microsoft\\Microsoft Antimalware\\Signature Updates&quot;\nEnd If\n\nIf RegKeyExists(reg, HKLM, strKey) Then\n\treg.GetBinaryValue HKLM, strKey, &quot;SignaturesLastChecked&quot;, binValue\n\t\n\tIf Not IsNull(binValue) Then\n\t\t\n\t\tWScript.Echo BinaryToDate(binValue)\n\tElse\n\t\tWScript.Echo &quot;Date not found&quot;\t\n\tEnd If\nElse\n\tWScript.Echo &quot;Forefront Endpoint Protection not found&quot;\nEnd If\n\n Function BinaryToDate(Binary)\n     Err.Clear\n     \n     &#039;Define Variants\n     Dim lngHigh\n     Dim lngLow\n     Dim dtmDate\n     Dim i\n         \n     &#039;Populate Variants\n     lngHigh = 0\n     lngLow = 0\n     \n     &#039;NOTE: Portions of this code taken from:\n     &#039; http://www.visualbasicscript.com/m30907.aspx\n     \n     for i=7 to 4 step -1\n         lngHigh = lngHigh * 256 + Binary(i)\n     next\n     for i=3 to 0 step -1\n         lngLow = lngLow * 256 + Binary(i)\n     next\n      \n     if err.number&lt;&gt;0 then\n         dtmDate = #1/1/1601#\n         Err.Clear\n     else\n         If lngLow &lt; 0 Then\n             lngHigh = lngHigh + 1\n         End If\n         If (lngHigh = 0) And (lngLow = 0 ) Then\n             dtmDate = #1/1/1601#\n         Else\n             dtmDate = #1/1/1601# + (((lngHigh * (2 ^ 32)) _\n                 + lngLow)/600000000 - GetTimeBias())/1440\n         End If\n     End If\n     BinaryToDate = dtmDate\n End Function\n \n \n Function GetTimeBias()\n     &#039;Define Variants\n     Dim lngBiasKey\n     Dim lngBias\n     \n     &#039; Obtain local Time Zone bias from machine registry.\n     reg.GetDWORDValue HKLM, &quot;System\\CurrentControlSet\\Control\\TimeZoneInformation&quot;, &quot;ActiveTimeBias&quot;, lngBiasKey\n     If UCase(TypeName(lngBiasKey)) = &quot;LONG&quot; Then\n         lngBias = lngBiasKey\n     ElseIf UCase(TypeName(lngBiasKey)) = &quot;VARIANT()&quot; Then\n         lngBias = 0\n         For k = 0 To UBound(lngBiasKey)\n             lngBias = lngBias + (lngBiasKey(k) * 256^k)\n         Next\n     End If \n     &#039;wscript.echo &quot;lngBias = &quot; &amp; lngBias\n     GetTimeBias = lngBias\n End Function\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 325, 
      "category": "Symantec", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns list of virus discovery events by Symantec AV on the client machine.\nExample: Security Risk Found!SecurityRisk.OrphanInf in File: e:\\\\autorun.inf by: Scheduled scan.  Action: Delete succeeded.  Action Description: The file was deleted successfully.", 
      "exclude_from_parse_flag": 1, 
      "hash": 3603227740, 
      "hidden_flag": 0, 
      "id": 647, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Symantec Viruses Found", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Message from Win32_NTLogEvent where LogFile = &#039;Application&#039; and SourceName=&#039;Symantec AntiVirus&#039; and Type = &#039;Error&#039; and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039; and Message LIKE &#039;%Risk Found%&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 326, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Indicates any human interface devices connected to the client machine.\nExample: HID-compliant mouse", 
      "exclude_from_parse_flag": 1, 
      "hash": 3605572245, 
      "hidden_flag": 0, 
      "id": 649, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Human Interface Device", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from Win32_PnPEntity where (Status=&#039;OK&#039; and DeviceID like &#039;%HID%&#039;)", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 327, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns users and groups who are members of the Local Administrators group on Windows.  Will not list the individual members of groups in the Local Administrators group.\nExample: Administrator", 
      "exclude_from_parse_flag": 1, 
      "hash": 3622133010, 
      "hidden_flag": 0, 
      "id": 651, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Local Administrators", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Local Administrators\n&#039;========================================\n\n&#039; output of membership (individual users and groups) of Local Administrators\n&#039; will not list members of sub-groups\n\nOption Explicit\n\nDim strMember, dictBlacklist\nSet dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; Add one line for each admin user that you do not want listed in the sensor output.  \n&#039;dictBlacklist.Add LCase(&quot;LocalMgr&quot;), True\n\nFor Each strMember In GetLocalAdmins\n\tDim bShouldList, strItem\n\tbShouldList = True\n\n\tFor Each strItem In dictBlacklist.Keys\n\t\tIf InStr(LCase(strMember), strItem) &gt; 0 Then \n\t\t\tbShouldList = False\n\t\tEnd If\n\tNext\n\n\tIf bShouldList Then \n\t\tWScript.Echo strMember\n\tEnd If \nNext\n\nFunction GetLocalAdmins\n    Dim objWMIService,strLocalAdminQuery,colItems,objItem,strMembers,strComputerName,arrReturn,i\n    Set objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n    \n\t&#039; Get Computer Name\n    Set colItems = objWMIService.ExecQuery( &quot;Select * from Win32_ComputerSystem&quot;, , 48 )\n    For Each objItem in colItems\n        strComputerName = objItem.Name\n    Next\t    \n    \n    strLocalAdminQuery = &quot;select * from Win32_GroupUser where GroupComponent = &quot; &amp; chr(34) &amp; &quot;Win32_Group.Domain=&#039;&quot; &amp; strComputerName &amp; &quot;&#039;,Name=&#039;Administrators&#039;&quot; &amp; Chr(34)\n    \n    Set ColItems = objWMIService.ExecQuery(strLocalAdminQuery)\n    strMembers = &quot;&quot;\n    arrReturn = Array() &#039; set up return array\n    i = 0\n    For Each objItem In colItems\n    \ti = i + 1\n        Dim strMemberName, NamesArray, strDomainName, DomainNameArray\n        NamesArray = Split(objItem.PartComponent,&quot;,&quot;)\n        strMemberName = Replace(Replace(NamesArray(1),Chr(34),&quot;&quot;),&quot;Name=&quot;,&quot;&quot;)\n        DomainNameArray = Split(NamesArray(0),&quot;=&quot;)\n        strDomainName = Replace(DomainNameArray(1),Chr(34),&quot;&quot;)\n        If strDomainName &lt;&gt; strComputerName Then\n            strMemberName = strDomainName &amp; &quot;\\&quot; &amp; strMemberName\n        End If\n        ReDim Preserve arrReturn(UBound(arrReturn) + 1) &#039; increase array by one\n        arrReturn(UBound(arrReturn)) = strMemberName\n    Next\n    \n    GetLocalAdmins = arrReturn\nEnd Function &#039;GetLocalAdmins", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 328, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "CPU cache size in KB.\nExample: 1024 KB", 
      "exclude_from_parse_flag": 1, 
      "hash": 3646624356, 
      "hidden_flag": 0, 
      "id": 653, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "CPU Cache Size", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CPU Cache Size\n&#039;========================================\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Processor&quot;)\nFor Each objItem in colItems\n\n\tIf objItem.L2CacheSize &lt;&gt; &quot;&quot; Then\n\t\tWscript.Echo objItem.L2CacheSize &amp; &quot; KB&quot;\n\tElse\n\t\tWscript.Echo &quot;Cannot calculate CPU Cache,Probably a VM&quot;\n\tEnd If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nline=$(cat /proc/cpuinfo | grep &quot;cache size&quot;)\nset -- $line\necho ${line#*:}\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 329, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the number of days since a Tanium Reboot Action occurred.\nExample: 2", 
      "exclude_from_parse_flag": 1, 
      "hash": 3652459872, 
      "hidden_flag": 0, 
      "id": 655, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Reboot Days Ago", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Option Explicit\n\nGetRebootDateTimeDaysOld\n\nFunction GetRebootDateTimeDaysOld\n&#039;reads a date value in the Tanium Client\\RebootManagment key of the registry\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim objReg,strRegPath,dtmNow,dtmLastReboot,intDaysAgo\n\t\n\tSetLocale(1033)\n\t\n\tdtmNow = Now()\n\t\n\tSet objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\t\n\tstrRegPath = GetTaniumRegistryPath()&amp;&quot;\\RebootManagement&quot;\n\t\n\tIf Not RegKeyExists(objReg,HKLM,strRegPath) Then\n\t\tobjReg.CreateKey HKLM,strRegPath\n\tEnd If\n\t\n\tobjReg.GetStringValue HKLM,strRegPath,&quot;LastReboot&quot;,dtmLastReboot\n\t\n\tIf IsDate(dtmLastReboot) Then\n\t\tintDaysAgo = Round(Abs(DateDiff(&quot;s&quot;,Now(),dtmLastReboot)) / 86400,0)\n\t\tWScript.Echo intDaysAgo\n\tElse\n\t\tWScript.Echo &quot;No Previous Reboot Date Found&quot;\n\tEnd If\n\nEnd Function &#039;GetRebootDateTimeDaysOld\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 330, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "A parameterized Sensor that checks to see if a file exists on a machine.  If it does, it returns back the full path of the file. Will expand environment variables, and will expand %userprofile%/file or \"~/file\" to search all user home directories.\nExample: C:\\Windows\\system32\\notepad.exe", 
      "exclude_from_parse_flag": 1, 
      "hash": 3662289857, 
      "hidden_flag": 0, 
      "id": 657, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "File Exists", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the file path and name to search for.\",\"value\":\"\",\"promptText\":\"e.g. c:\\\\windows\\\\test.txt\",\"defaultValue\":\"\",\"label\":\"File path and name to search for\",\"maxChars\":0,\"key\":\"file\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; File Exists\n&#039;========================================\n\nOption Explicit\n\nDim bExamineRemoteFolders &#039; boolean to decide whether to consider non-local dirs\nbExamineRemoteFolders = True &#039; attempt to look at remote folders, may fail due to access\n\nDim strFilePath, objFso, objShell\n\nstrFilePath = unescape(&quot;||file||&quot;)\n\nIf InStr(LCase(strFilePath),&quot;%userprofile%&quot;) &gt; 0 Then\n\tCheckForAllUsers strFilePath\nElse\n\tCheckNoUserVars strFilePath\nEnd If\n\n\t\nSub CheckNoUserVars(ByVal strFilePath)\n&#039; plain check if a file exists\n\tstrFilePath = FixFileSystemRedirectionForPath(strFilePath)\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrFilePath = objShell.ExpandEnvironmentStrings( strFilePath )\n\t\n\tSet objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tIf objFso.FileExists(strFilePath) Then \n\t\tWScript.Echo &quot;File Exists: &quot; &amp; UnFixFileSystemRedirectionForPath(strFilePath)\n\tElse \n\t\tWScript.Echo &quot;File does not exist&quot;\n\tEnd If\nEnd Sub &#039;CheckNoUserVars\n\nSub CheckForAllUsers(ByVal strFilePath)\n&#039; checks in every user directory\n\n\t&#039; Remove %userprofile% and keep the rest\n\tstrFilePath = Replace(LCase(strFilePath),&quot;%userprofile%&quot;,&quot;&quot;)\t\n\t\n\tOn Error Resume Next &#039; permissions issues, perhaps\n\t\n\tConst HKLM = &amp;H80000002\n\tDim objShell,objFso\n\tDim objRegistry,strKeyPath,objSubKey,arrSubKeys,strValueName,strSubPath\n\tDim strValue,strOut,bFileFound\n\tbFileFound = False\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrFilePath = objShell.ExpandEnvironmentStrings( strFilePath )\n\t\n\tSet objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tSet objRegistry=Getx64RegistryProvider\n \n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList&quot;\n\tobjRegistry.EnumKey HKLM, strKeyPath, arrSubkeys\n \n\n\tFor Each objSubkey In arrSubkeys\n\t    strValueName = &quot;ProfileImagePath&quot;\n\t    strSubPath = strKeyPath &amp; &quot;\\&quot; &amp; objSubkey\n\t    objRegistry.GetExpandedStringValue HKLM,strSubPath,strValueName,strValue\n\n\t    If Not bExamineRemoteFolders And Not InStr(strValue,&quot;:&quot;) &gt; 0 Then &#039; Not Local, don&#039;t get size of remote dirs\n\t    \t&#039; if user profile is not local and not examining remote profiles, ignore\n\t    Else \n\t    \tIf objFSO.FileExists(strValue&amp;strFilePath) Then\n\t\t\t\tbFileFound = True\n\t\t\t\tWScript.Echo &quot;File Exists: &quot; &amp; strValue&amp;strFilePath\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\t\n\tIf Not bFileFound Then\n\n\t\tWScript.Echo &quot;File does not exist&quot;\n\tEnd If\n\n\tOn Error Goto 0\n\nEnd Sub &#039;CheckForAllUsers\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n\tDim objFSO,strSystem32Location,strNewSystem32Location\n\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\n\tUnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\nurldecode() {\n        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\\+/ /g&#039; -e &#039;s/%/\\\\x/g&#039;)\n        printf &#039;%b&#039; &quot;$data&quot;\n}\n\nfile=&quot;$(urldecode &quot;||file||&quot;)&quot;\n\nif [[ &quot;$file&quot; == *~* ]]\nthen\n  # replace home directory with nothing\n  file=&quot;${file#~\\/}&quot;\n\n  # Read in /etc/passwd to determine home dirs\n  awk -F: &#039;$6 ~ /home/ &amp;&amp; $7 ~ /sh/ {print $1, $6}&#039; /etc/passwd |\n  while read NAME homedir\n  do\n     if [ -e &quot;$homedir/$file&quot; ]\n     then\n        echo &quot;$homedir/$file&quot;\n     fi\n   done\nelse\n   if [ -e &quot;$file&quot; ]\n   then\n      echo &quot;$file&quot;\n   fi\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nurldecode() {\n        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\\+/ /g&#039; -e &#039;s/%/\\\\x/g&#039;)\n        printf &#039;%b&#039; &quot;$data&quot;\n}\n\nfile=&quot;$(urldecode &quot;||file||&quot;)&quot;\n\nif [[ &quot;$file&quot; == *~* ]]\nthen\n  # replace home directory with nothing\n  file=&quot;${file#~\\/}&quot;\n\n  for homedir in `find /Users -type d -maxdepth 1`\n  do\n     if [ -e &quot;$homedir/$file&quot; ]\n     then\n        echo &quot;$homedir/$file&quot;\n     fi\n   done\nelse\n   if [ -e &quot;$file&quot; ]\n   then\n      echo &quot;$file&quot;\n   fi\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 331, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "A parameterized Sensor that checks to see if a folder exists on a machine.  If it does, it returns back the full path of the folder. Will expand environment variables, and will expand %userprofile%/folder or \"~/folder\" to search all user home directories.\nExample: C:\\Windows\\system32", 
      "exclude_from_parse_flag": 1, 
      "hash": 1101836903, 
      "hidden_flag": 0, 
      "id": 659, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Folder Exists", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the full drive letter and folder path of the folder. Environment variables accepted.\",\"value\":\"\",\"promptText\":\"e.g. c:\\\\Program Files\\\\MyApp\",\"defaultValue\":\"\",\"label\":\"Folder path to search for\",\"maxChars\":0,\"key\":\"folder\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Folder Exists\n&#039;========================================\n\nOption Explicit\n\nDim bExamineRemoteFolders &#039; boolean to decide whether to consider non-local dirs\nbExamineRemoteFolders = True &#039; attempt to look at remote folders, may fail due to access\n\nDim strFolderPath, objFso, objShell\n\nstrFolderPath = unescape(&quot;||folder||&quot;)\n\nIf InStr(LCase(strFolderPath),&quot;%userprofile%&quot;) &gt; 0 Then\n\tCheckForAllUsers strFolderPath\nElse\n\tCheckNoUserVars strFolderPath\nEnd If\n\n\t\nSub CheckNoUserVars(ByVal strFolderPath)\n&#039; plain check if a file exists\n\tstrFolderPath = FixFileSystemRedirectionForPath(strFolderPath)\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrFolderPath = objShell.ExpandEnvironmentStrings( strFolderPath )\n\t\n\tSet objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tIf objFso.FolderExists(strFolderPath) Then \n\t\tWScript.Echo UnFixFileSystemRedirectionForPath(strFolderPath)\n\tElse \n\t\tWScript.Echo &quot;Folder does not exist&quot;\n\tEnd If\nEnd Sub &#039;CheckNoUserVars\n\nSub CheckForAllUsers(ByVal strFolderPath)\n&#039; checks in every user directory\n\n\t&#039; Remove %userprofile% and keep the rest\n\tstrFolderPath = Replace(LCase(strFolderPath),&quot;%userprofile%&quot;,&quot;&quot;)\t\n\t\n\tOn Error Resume Next &#039; permissions issues, perhaps\n\t\n\tConst HKLM = &amp;H80000002\n\tDim objShell,objFso\n\tDim objRegistry,strKeyPath,objSubKey,arrSubKeys,strValueName,strSubPath\n\tDim strValue,strOut,bFolderFound\n\tbFolderFound = False\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrFolderPath = objShell.ExpandEnvironmentStrings( strFolderPath )\n\t\n\tSet objFso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tSet objRegistry=Getx64RegistryProvider\n \n\tstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList&quot;\n\tobjRegistry.EnumKey HKLM, strKeyPath, arrSubkeys\n \n\n\tFor Each objSubkey In arrSubkeys\n\t    strValueName = &quot;ProfileImagePath&quot;\n\t    strSubPath = strKeyPath &amp; &quot;\\&quot; &amp; objSubkey\n\t    objRegistry.GetExpandedStringValue HKLM,strSubPath,strValueName,strValue\n\n\t    If Not bExamineRemoteFolders And Not InStr(strValue,&quot;:&quot;) &gt; 0 Then &#039; Not Local, don&#039;t get size of remote dirs\n\t    \t&#039; if user profile is not local and not examining remote profiles, ignore\n\t    Else \n\t    \tIf objFSO.FolderExists(strValue&amp;strFolderPath) Then\n\t\t\t\tbFolderFound = True\n\t\t\t\tWScript.Echo strValue&amp;strFolderPath\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\t\n\tIf Not bFolderFound Then\n\n\t\tWScript.Echo &quot;Folder does not exist&quot;\n\tEnd If\n\n\tOn Error Goto 0\n\nEnd Sub &#039;CheckForAllUsers\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n\tDim objFSO,strSystem32Location,strNewSystem32Location\n\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\n\tUnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n\nurldecode() {\n        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\\+/ /g&#039; -e &#039;s/%/\\\\x/g&#039;)\n        printf &#039;%b&#039; &quot;$data&quot;\n}\n\nfile=&quot;$(urldecode &quot;||folder||&quot;)&quot;\n\nif [[ &quot;$file&quot; == *~* ]]\nthen\n  # replace home directory with nothing\n  file=&quot;${file#~\\/}&quot;\n\n  # Read in /etc/passwd to determine home dirs\n  awk -F: &#039;$6 ~ /home/ &amp;&amp; $7 ~ /sh/ {print $1, $6}&#039; /etc/passwd |\n  while read NAME homedir\n  do\n     if [ -e &quot;$homedir/$file&quot; ]\n     then\n        echo &quot;$homedir/$file&quot;\n     fi\n   done\nelse\n   if [ -e &quot;$file&quot; ]\n   then\n      echo &quot;$file&quot;\n   fi\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n\nurldecode() {\n        local data=$(echo &quot;$1&quot; | sed -e &#039;s/\\+/ /g&#039; -e &#039;s/%/\\\\x/g&#039;)\n        printf &#039;%b&#039; &quot;$data&quot;\n}\n\nfile=&quot;$(urldecode &quot;||folder||&quot;)&quot;\n\nif [[ &quot;$file&quot; == *~* ]]\nthen\n  # replace home directory with nothing\n  file=&quot;${file#~\\/}&quot;\n\n  for homedir in `find /Users -type d -maxdepth 1`\n  do\n     if [ -e &quot;$homedir/$file&quot; ]\n     then\n        echo &quot;$homedir/$file&quot;\n     fi\n   done\nelse\n   if [ -e &quot;$file&quot; ]\n   then\n      echo &quot;$file&quot;\n   fi\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 332, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Lists processes that use a module supplied to the sensor.\nExample: explorer.exe", 
      "exclude_from_parse_flag": 1, 
      "hash": 3682298314, 
      "hidden_flag": 0, 
      "id": 661, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Processes Using Module", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[],\"helpString\":\"Enter the Module to search for\",\"value\":\"\",\"promptText\":\"e.g. wbem* or kernel32.dll\",\"defaultValue\":\"\",\"label\":\"Module to search for\",\"maxChars\":0,\"key\":\"search\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Processes Using Module\n&#039;========================================\n\nstrSearch = unescape(&quot;||search||&quot;)\n&#039;strSearch = &quot;wbem*&quot;\n\nstrCommand = &quot;tasklist /M &quot; &amp; strSearch\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrResults = LCase(objScriptExec.StdOut.ReadAll)\n\narrLines = Split(strResults, vbCrLf)\n\nisBody = False\n\nstrProcess = &quot;&quot;\nstrPid = &quot;&quot;\n\nDim moduleDictionary\nSet moduleDictionary = CreateObject(&quot;scripting.dictionary&quot;)\n\nDim pidDictionary\nSet pidDictionary = CreateObject(&quot;scripting.dictionary&quot;)\n\nFor Each line In arrLines\n\n\tIf isBody Then\n\t\tIf Left(line, 4) = &quot;    &quot; Then\n\t\t\t&#039;is list of modules\n\t\t\tarrWords = Split(RemoveMultiSpaces(line), &quot; &quot;)\n\t\t\tFor i = 0 To UBound(arrWords)\n\t\t\t\tPrintModule arrWords(i), strProcess\n\t\t\tNext\n\n\t\tElse\n\t\t\t&#039;is name of process\n\t\t\tIf line &lt;&gt; &quot;&quot; And InStr(line, &quot;.&quot;) Then\n\t\t\t\tarrWords = Split(RemoveMultiSpaces(line), &quot; &quot;)\n\t\t\t\tstrProcess = arrWords(0)\n\t\t\t\tstrPid = arrWords(1)\n\t\t\t\t&#039;WScript.Echo &quot;found process: &quot; &amp; strProcess &amp; &quot;, pid=&quot;&amp;strPid\n\t\t\t\t\n\t\t\t\tFor i = 2 To UBound(arrWords)\n\t\t\t\t\tPrintModule arrWords(i), strProcess\n\t\t\t\tNext\n\t\t\t\t\n\t\t\tEnd If\t\n\t\tEnd If\n\tEnd If\n\t\n\tIf Left(line, 4) = &quot;====&quot; Then\n\t\tisBody = True \n\tEnd If\n\nNext\n\nFunction PrintModule(strMod, strProc)\n\tstrMod = Replace(strMod, &quot;,&quot;, &quot;&quot;)\n\tWScript.Echo strProc &amp; &quot;: &quot; &amp; strMod\nEnd Function\n\nFunction RemoveMultiSpaces(str)\n\tDim regEx\n\tSet regEx = New RegExp\n\tregEx.Global = true\n\tregEx.IgnoreCase = True\n\t\n\tregEx.Pattern = &quot;\\s{2,}&quot;\n\t\n\tRemoveMultiSpaces = Trim(regEx.Replace(str, &quot; &quot;))\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;search&quot;,&quot;validationExpressions&quot;:[],&quot;promptText&quot;:&quot;e.g. wbem* or kernel32.dll&quot;,&quot;helpString&quot;:&quot;Enter the Module to search for&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Module to search for&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||search||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;search&quot;,&quot;validationExpressions&quot;:[],&quot;promptText&quot;:&quot;e.g. wbem* or kernel32.dll&quot;,&quot;helpString&quot;:&quot;Enter the Module to search for&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Module to search for&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||search||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 333, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns Yes or No depending on whether a Windows machine is a Terminal Server\nExample: Yes", 
      "exclude_from_parse_flag": 0, 
      "hash": 3685017662, 
      "hidden_flag": 0, 
      "id": 663, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Is Terminal Server", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Is Terminal Server\n&#039;========================================\n\nOption Explicit\n\nDim strOS\n \nstrOS = GetOSFamily()\nIf UCase(strOS) = &quot;W2K3&quot; Then\n  If isTerminalServer2k3RegRead Then\n    WScript.Echo &quot;Yes&quot;\n  Else\n    WScript.Echo &quot;No&quot;\n  End If\nElse\n\tIf isTerminalServer(strOS) Then\n\t  WScript.Echo &quot;Yes&quot;\n\tElse\n\t  WScript.Echo &quot;No&quot;\n\tEnd If\nEnd If\n\nWScript.Quit(0)\n\nFunction GetOSFamily()\n  Dim strComputer, oWMIService, colOSInfo, oOSProperty, strCaption, strOSFamily\n  Set oWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\n  Set colOSInfo = oWMIService.ExecQuery(&quot;Select * from Win32_OperatingSystem&quot;)\n  For Each oOSProperty in colOSInfo\n    strCaption = oOSProperty.Caption\n  Next\n  If InStr(1,strCaption, &quot;2008&quot;, vbTextCompare) Then strOSFamily = &quot;W2K8&quot;\n  If InStr(1,strCaption, &quot;2003&quot;, vbTextCompare) Then strOSFamily = &quot;W2K3&quot;\n  If InStr(1,strCaption, &quot;2012&quot;, vbTextCompare) Then strOSFamily = &quot;W2K12&quot;  \n  GetOSFamily = strOSFamily\n  Set oWMIService = Nothing\n  Set colOSInfo = Nothing\nEnd Function\n \nFunction isTerminalServer(strOS)\n  Dim strComputer, strNameSpace, objWMIService, colItems, objItem  \n  If ucase(strOS) = &quot;W2K3&quot; Then\n    strNameSpace = &quot;\\root\\cimv2&quot;\n  Else\n    strNameSpace = &quot;\\root\\cimv2\\TerminalServices&quot;\n  End If\n  On Error Resume Next\n  Set objWMIService = GetObject(&quot;winmgmts:&quot; _  \n    &amp; &quot;{impersonationLevel=impersonate}!\\\\.&quot; &amp; strNameSpace) \n  If Err.Number &lt;&gt; 0 Then\n  \tisTerminalServer = False\n  \tExit Function\n  End If\n  Set colItems = objWMIService.ExecQuery _ \n    (&quot;Select * from Win32_TerminalServiceSetting&quot;) \n  For Each objItem in colItems \n    Select Case objItem.LicensingType \n      Case &quot;1&quot; &#039; Remote Administration\n        isTerminalServer = False\n      Case &quot;2&quot; &#039; Per Device\n        isTerminalServer = True\n      Case &quot;4&quot; &#039; Per User\n        isTerminalServer = True\n      Case &quot;5&quot; &#039; Not configured yet\n        isTerminalServer = True\n      Case Else\n        isTerminalServer = False \n    End Select\n  Next \n  Set objWMIService = Nothing \n  Set colItems = Nothing \nEnd Function\n \nFunction isTerminalServer2k3RegRead\n  Dim objShell, strValue, strValueData\n  strValue = &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\TSAppCompat&quot;\n  Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n  On Error Resume Next\n  strValueData = objShell.RegRead(strValue)\n  If Err.Number &lt;&gt; 0 Then\n  \tstrValueData = 0\n  End If\n  On Error Goto 0\n  If strValueData = &quot;1&quot; Then\n    isTerminalServer2k3RegRead = True\n  Else\n    isTerminalServer2k3RegRead = False\n  End If\n  Set objShell = Nothing\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 334, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The calendar date on the managed client.\nExample: 01/30/2012", 
      "exclude_from_parse_flag": 1, 
      "hash": 3727949854, 
      "hidden_flag": 0, 
      "id": 665, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 1800, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Client Date", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Client Date\n&#039;========================================\n\n&#039; This sensor will return the Date the client thinks it is\n\nOption Explicit\n\nSetLocale(GetTaniumLocale())\n\nWScript.Echo FormatDateTime((Date), 2)\n\nFunction GetTaniumLocale() \n\tDim objWshShell, intLocaleID\n\t\n\tintLocaleID = &quot;&quot;\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\&quot; &amp; GetTaniumRegistryPath() &amp; &quot;\\LocaleID&quot;)\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\tSet objWshShell = Nothing\nEnd Function &#039; GetTaniumLocale\n\n&#039; get-tanium-regpath.vbs\n\n&#039; Updated to always generate path so that GetTaniumDir can take multiple folder arguments\n&#039; Updated to always look for the Path string value and not assume a bogus entry\n&#039; in the wrong area is valid.  A valid entry will always have a Path string value\n&#039; uses objshell registry reads which should be faster and more reliable\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;GetTaniumRegistryPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\ndate +%-d/%-m/%Y\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\ndate +%-d/%-m/%Y\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 335, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The current cpu utilization being used by the Tanium Client process on each client machine.  The reported value will be higher than average since the Tanium Client is actively in use while evaluating this Sensor.\nExample: 1%", 
      "exclude_from_parse_flag": 1, 
      "hash": 3734316770, 
      "hidden_flag": 0, 
      "id": 667, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Client CPU", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client CPU\n&#039;========================================\n\nstrComputer = &quot;.&quot;  \nSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \nSet colService = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \nFor Each objService in colService      \nStrSQL = &quot;present&quot;    \nNext  \nif StrSQL = &quot;present&quot; THEN \nfor each Process in GetObject(&quot;winmgmts:&quot;).ExecQuery(&quot;Select * from Win32_Process where Name = &#039;taniumclient.exe&#039;&quot;)   \nWScript.echo CPUUSage(Process.Handle) &amp; &quot;%&quot;  \nNext  \nFunction CPUUSage( ProcID )   \nOn Error Resume Next   \nSet objService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)     \nFor Each objInstance1 in objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;taniumclient&#039;&quot;)        \nN1 = objInstance1.PercentProcessorTime        \nD1 = objInstance1.TimeStamp_Sys100NS      \nExit For    \nNext  \nWScript.Sleep(5000)     \nFor Each perf_instance2 in objService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process where Name = &#039;taniumclient&#039;&quot;)        \nN2 = perf_instance2.PercentProcessorTime        \nD2 = perf_instance2.TimeStamp_Sys100NS      \nExit For    \nNext    \n&#039; CounterType - PERF_100NSEC_TIMER_INV   \n&#039; Formula - (1- ((N2 - N1) / (D2 - D1))) x 100     \nNd = (N2 - N1)     \nDd = (D2-D1)     \nPercentProcessorTime = ( (Nd/Dd))  * 100    \nCPUUSage = Round(PercentProcessorTime ,0) \nEnd Function \nEND IF", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 336, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The family of the processor or CPU (Windows provides a family ID).\nExample: Xeon, Family 198", 
      "exclude_from_parse_flag": 1, 
      "hash": 3763483691, 
      "hidden_flag": 0, 
      "id": 669, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "CPU Family", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CPU Family\n&#039;========================================\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_Processor&quot;)\nFor Each objItem in colItems\n \tWscript.Echo objItem.Family &amp; &quot; Processor Family&quot;\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n#dmidecode -s processor-family | grep -v &quot;Unknown&quot;\nline=$(grep -m 1 -i &quot;cpu family&quot; /proc/cpuinfo)\nset -- $line\necho ${line#*:}\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 337, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Name for SCSI Controller Driver as provided by the manufacturer.\nExample: VClone", 
      "exclude_from_parse_flag": 1, 
      "hash": 3764526140, 
      "hidden_flag": 0, 
      "id": 671, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "SCSI Controller Driver Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select DriverName from win32_SCSIController", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 338, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Swap space in use in MB by the client machine.\nExample: 2164 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 3868118771, 
      "hidden_flag": 0, 
      "id": 673, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Used Swap", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nmemLine=$(free -m | grep &quot;Swap&quot;)\nset -- $memLine\necho $3 MB\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 339, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the contents of the specified folder.\nExample: 0.log", 
      "exclude_from_parse_flag": 1, 
      "hash": 3881863289, 
      "hidden_flag": 0, 
      "id": 675, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Folder Contents", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the full drive letter and folder path of the folder\",\"value\":\"\",\"promptText\":\"e.g. c:\\\\Program Files\\\\MyApp\",\"defaultValue\":\"\",\"label\":\"Folder path to search for\",\"maxChars\":0,\"key\":\"folderPath\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Folder Contents\n&#039;========================================\n\nstrFolderPath = unescape(&quot;||folderPath||&quot;)\nstrFolderPath = FixFileSystemRedirectionForPath(strFolderPath)\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nIf fso.FolderExists(strFolderpath) Then\n\tSet objFolder = fso.GetFolder(strFolderPath)\n\t\n\tSet objSubDir = objFolder.SubFolders\n\n\tSet objFiles = objFolder.Files\n\t\n\tIf objSubDir.Count = 0 AND objFiles.Count = 0 Then\n\t\t\n\t\tWScript.Echo &quot;Folder is Empty&quot;\n\n\t\tWScript.quit()\n\n\tEnd If\n\n\n\tIf objSubDir.Count &gt; 0 Then\n\n\t\tFor Each ObjSubFolder In objSubDir\n\t\t\tWScript.Echo (&quot;Folder : &quot; &amp; ObjSubFolder.Name)\n\n\t\tNext\n\n\tEnd If\n\n\tIf objFiles.Count &gt; 0 Then\n\t\tFor Each objFile In objFiles \n\t\t\tWScript.Echo objFile.Name\n\t\tNext\n\tEnd If\n\nElse\n\tWScript.Echo &quot;Folder does not exist&quot;\n\nEnd If\n\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n    \n    Dim objFSO, strSystem32Location,objShell\n    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n    \n    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n        If InStr(strFilePath,strSystem32Location) = 1 Then\n            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n            strFilePath = strNewSystem32Location&amp;strRestOfPath\n        End If\n    End If\n    FixFileSystemRedirectionForPath = strFilePath\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n    Dim objFSO,strSystem32Location,strNewSystem32Location\n    \n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    \n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n    \n    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;folderPath&quot;,&quot;promptText&quot;:&quot;e.g. c:\\Program Files\\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||folderPath||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;folderPath&quot;,&quot;promptText&quot;:&quot;e.g. c:\\Program Files\\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||folderPath||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 340, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "System unique identifier UUID on Mac or Linux machines.\nExample: 3e6be9de-8139-11d1-9106-a43f08d823a6", 
      "exclude_from_parse_flag": 1, 
      "hash": 3891170751, 
      "hidden_flag": 0, 
      "id": 677, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "System UUID", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s system-uuid\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nsystem_profiler SPHardwareDataType | awk &#039;/Hardware UUID/ {print $NF}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 341, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The IP address the Tanium Client is communicating to the server with.  This can be a public IP, or IP of a NAT device, for example.\nExample: 65.128.25.253", 
      "exclude_from_parse_flag": 1, 
      "hash": 3898138660, 
      "hidden_flag": 0, 
      "id": 679, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Client NAT IP Address", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Client NAT IP Address\n&#039;========================================\n\n\nDim strTaniumPath, strStatusPath\nDim strClientAddress, arrClientAddress, strIPAddress\nDim objReg\n\n\nSet objReg = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\n\nConst HKLM = &amp;h80000002\n\n&#039;Tanium registry key paths\nstrTaniumPath = GetTaniumRegistryPath()\nstrStatusPath = strTaniumPath &amp; &quot;\\Status&quot;\n\n&#039;Pull the registry value out\nobjReg.GetStringValue HKLM, strStatusPath, &quot;ClientAddress&quot;, strClientAddress\n\narrClientAddress = Split(strClientAddress,&quot;0:&quot;)\n\n&#039; Final output\nstrIPAddress = arrClientAddress(1)\n\nWScript.Echo strIPAddress\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\t\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction ParseTaniumIPEntry(strIPEntry)\n&#039; This function will parse a Tanium IP address entry in the registry\n\t\n\tDim strLeftSplit\n\t\n\tstrLeftSplit = Left(strIPEntry,InStr(strIPEntry,&quot;_&quot;)-1)\n\tParseTaniumIPEntry = Right(strLeftSplit,len(strLeftSplit)-InStrRev(strLeftSplit,&quot;:&quot;))\n\nEnd Function &#039;ParseTaniumIPEntry", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 342, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns a list of long running SQL Server jobs on the client machine.  Details include job name, start date, and duration.\nExample: backupjob | 22-july-12 12:00 Am | 00:01:00:00", 
      "exclude_from_parse_flag": 1, 
      "hash": 391368340, 
      "hidden_flag": 0, 
      "id": 681, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "SQL Server Agent Long Running Jobs", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Server Agent Log Running Jobs\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\n\nDim dictInstances, strInstance, objConnection\n\nSet dictInstances = GetMSSQLInstances()\n\nFor Each strInstance In dictInstances.Keys\n\t\n\tDim objRecordSet, Record, strJob, strDate, strDur\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;)   \n\tSet objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;)    \n\t\n\tOn Error Resume Next\n\tobjConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)\n\t\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\tOn Error Goto 0\n\t\n\tobjRecordSet.Open &quot;select job_name, run_datetime, run_duration from (select job_name, run_datetime,SUBSTRING(run_duration, 1, 2) + &#039;:&#039; + SUBSTRING(run_duration, 3, 2) + &#039;:&#039; +SUBSTRING(run_duration, 5, 2) AS run_duration from(select DISTINCT j.name as job_name, run_datetime = CONVERT(DATETIME, RTRIM(run_date)) +  (run_time * 9 + run_time % 10000 * 6 + run_time % 100 * 10) / 216e4, run_duration = RIGHT(&#039;000000&#039; + CONVERT(varchar(6), run_duration), 6) from msdb..sysjobhistory h inner join msdb..sysjobs j on h.job_id = j.job_id) t) t where (run_datetime &gt; (GETDATE()-10) and run_duration &gt; &#039;00:01:00&#039;) order by job_name, run_datetime &quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC    \n\t\n\tIf (objRecordset.EOF = True) Then\n\t\tWScript.Echo &quot;None&quot; &amp; GetMSSQLSensorInstanceStr(strInstance) \n\tElse \n\t\tobjRecordSet.MoveFirst    \n\t\tFor Each Record In objRecordSet.Properties      \n\t\t\tstrJob = objRecordSet(&quot;job_name&quot;)     \n\t\t\tstrDate = objRecordSet(&quot;run_datetime&quot;)     \n\t\t\tstrDur = objRecordSet(&quot;run_duration&quot;)      \n\t\t\tWScript.echo strJob &amp; &quot; at: &quot; &amp; strDate &amp; &quot;, duration:&quot; &amp; strDur &amp; GetMSSQLSensorInstanceStr(strInstance)    \n\t\t\tobjRecordSet.MoveNext      \n\t\t\tIf (objRecordset.EOF = True) Then         \n\t\t\t\tobjRecordSet.Close         \n\t\t\t\tExit For      \n\t\t\tEnd If  \n\t\tNext   \n\tEnd If\nNext\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 343, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Checks if CD-ROM/DVD-ROM drive is loaded.\nExample:  True or False", 
      "exclude_from_parse_flag": 1, 
      "hash": 3914171274, 
      "hidden_flag": 0, 
      "id": 683, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "CD-ROM Drive Loaded", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CD-ROM Drive Loaded\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_CDROMDrive&quot;)\n\nhasDisc = False\nFor Each objItem in colItems\n\tIf objItem.MediaLoaded Then\n\t\thasDisc = True\n\tEnd If\nNext\n\nIf hasDisc Then\n\tWScript.Echo &quot;True&quot;\nElse\n\tWScript.Echo &quot;False&quot;\t\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 344, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Device name for any attached batteries for a machine, commonly found in laptops.\nExample: DELL V57XN24", 
      "exclude_from_parse_flag": 1, 
      "hash": 3963156324, 
      "hidden_flag": 0, 
      "id": 685, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Attached Battery", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "Select Name from Win32_Battery where availability &gt; 0", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 345, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns the location of all user profiles and their sizes\nExample:C:\\Users\\John.Doe 28.2 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 3999173666, 
      "hidden_flag": 0, 
      "id": 687, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "User Profile Directory Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; User Profile Directory Details\n&#039;========================================\nOption Explicit\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\n\nSensorRandomize()\n\nSetLocale(GetTaniumLocale)\n\nOn Error Resume Next &#039; permissions issues, perhaps\n\nConst HKLM = &amp;H80000002\nDim objRegistry,strKeyPath,objSubKey,arrSubKeys,strValueName,strSubPath\nDim objFSO,objFolder,strValue,strSize,strSep\n\nstrSep = &quot;|&quot;\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nSet objRegistry=GetObject(&quot;winmgmts:\\\\.\\root\\default:StdRegProv&quot;)\n \nstrKeyPath = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList&quot;\nobjRegistry.EnumKey HKLM, strKeyPath, arrSubkeys\n \nFor Each objSubkey In arrSubkeys\n    strValueName = &quot;ProfileImagePath&quot;\n    strSubPath = strKeyPath &amp; &quot;\\&quot; &amp; objSubkey\n    objRegistry.GetExpandedStringValue HKLM,strSubPath,strValueName,strValue\n    \n    If Not InStr(strValue,&quot;:&quot;) &gt; 0 Then &#039; Not Local, don&#039;t get size of remote dirs\n    \tstrSize = &quot;Unknown&quot;\n    ElseIf Not objFSO.FolderExists(strValue) Then\n    \tstrSize = &quot;Folder not found&quot;\n    Else\n    \tSet objFolder = objFSO.GetFolder(strValue)\n  \t\tstrSize = GetAccessibleFolderSize(strValue)\n  \t\tstrSize = GetPrettyFileSize(strSize)\n\tEnd If\n    Wscript.Echo strValue &amp; strSep &amp; strSize\nNext\nOn Error Goto 0\n\n\n&#039; --- end main --- &#039;\nFunction GetPrettyFileSize(strSize)\nDim dblSize\n\tdblSize = CDbl(strSize)\n\n\tIf dblSize &gt; 1024*1024*1024 Then &#039;&#039;Should be GB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024 / 1024, 1)) &amp; &quot; GB&quot;\t\n\tElseIf dblsize &gt; 1024*1024 Then  &#039;&#039;Should be MB\n\t\tstrSize = CStr(Round(dblSize / 1024 / 1024, 1)) &amp; &quot; MB&quot;\n\tElseIf dblSize &gt; 1024 Then  &#039;&#039;Should be kB\n\t\tstrSize = CStr(Round(dblSize / 1024)) &amp; &quot; kB&quot;\n\tElse\n\t\tstrSize = CStr(dblSize) &amp; &quot; B&quot;\t\n\tEnd If\t\n\tGetPrettyFileSize = strSize\nEnd Function &#039;GetPrettyFileSize\n\n\nFunction GetAccessibleFolderSize(strFolderPath)\n&#039; Gets the folder sizes that it is able to\n&#039; and skips those it has no rights to see\n    On Error Resume Next &#039; Permissions Errors potentially\n\n\tDim objFSO\n    Dim objFolder,objSubfolder,intSize,bHasSubfolders\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t    \n    bHasSubfolders = False\n\n    Set objFolder = objFSO.GetFolder(strFolderPath)\n    Err.Clear\n    intSize = objFolder.Size\n    If Err.Number &lt;&gt; 0 Then\n        For Each objSubfolder in objFolder.SubFolders\n            intSize = intSize + GetAccessibleFolderSize(objSubfolder.Path)\n            bHasSubfolders = True\n        Next\n\n        If Not bHasSubfolders Then\n            intSize = objFolder.Size\n        End If\n    End If\n\n    GetAccessibleFolderSize = intSize\n    \n    On Error Goto 0\n\nEnd Function &#039;GetAccessibleFolderSize\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 6, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Profile Location", 
            "value_type": "DataSize"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Size", 
            "value_type": "DataSize"
          }
        ]
      }, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 346, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the primary WINS server of a machine.\nExample: WINS1", 
      "exclude_from_parse_flag": 1, 
      "hash": 4018912755, 
      "hidden_flag": 0, 
      "id": 689, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Primary WINS Server", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select WINSPrimaryServer from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 347, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns the run keys that define which programs will be started when a user logs in.\nExample:  System|GlobalProtect|\"C:\\Program Files\\Palo Alto Networks\\GlobalProtect\\PanGPA.exe\"", 
      "exclude_from_parse_flag": 1, 
      "hash": 4058321794, 
      "hidden_flag": 0, 
      "id": 691, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Run Keys", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Run Keys\n&#039;========================================\n\n&#039; returns the system and user keys for a given key\n\nOption Explicit\n\nConst strSep = &quot;|&quot;\n\nDim dictBlacklist, strKeyPath, strKeyPath32, dictResults, strValue, bShouldList, strItem\n\nSet dictBlacklist = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; Add one line for each admin user that you do not want listed in the sensor output.  \n&#039; dictBlacklist.Add LCase(&quot;VMWare User Process&quot;), True\n\n\nstrKeyPath = &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Run&quot;\nstrKeyPath32 = &quot;Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run&quot;\n    \nSet dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nAddValuesForKey dictResults, strKeyPath\nAddValuesForKey dictResults, strKeyPath32\n\nFor Each strValue In dictResults.Keys\n\tbShouldList = True\n    For Each strItem In dictBlacklist.Keys\n        If InStr(LCase(strValue), strItem) &gt; 0 Then \n            bShouldList = False\n        End If\n    Next\n\n    If bShouldList Then \n        WScript.Echo strValue\n    End If \nNext\n\nSub AddValuesForKey(dictResults, strKey)\n&#039; This function will output the two values\n\n    Const HKLM = &amp;h80000002\n\tConst HKEY_USERS = &amp;H80000003\n    \n    Dim objRegistry\n    Dim arrUserKeys,strUserKey, strUserKeyPath\n    \n    &#039; get System Keys\n    Set objRegistry = Getx64RegistryProvider()\n    If RegKeyExists(HKLM, strKey, objRegistry) Then  \n        GetValues objRegistry, HKLM, strKey, dictResults, &quot;System&quot;\n    End If\n    \n    &#039; get User Keys\n    objRegistry.EnumKey HKEY_USERS, &quot;&quot;,arrUserKeys\n\tFor Each strUserKey In arrUserKeys\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserKeyPath = strUserKey &amp; &quot;\\&quot; &amp; strKey\n\t\t\tIf RegKeyExists(HKEY_USERS,strUserKeyPath, objRegistry) Then\n\t\t        GetValues objRegistry, HKEY_USERS, strUserKeyPath, dictResults, &quot;User&quot;\n\t\t \tEnd If\n\t\t End If \n\tNext \nEnd Sub &#039;AddValuesForKey\n\nSub GetValues(objRegistry, hiveConst, keyPath, dictValues, strPrefix)\n    Dim arrKeyNames, arrTypes, arrValueNames, strValueName\n    Dim strValueData, i, strEntry\n        \n    objRegistry.EnumValues hiveConst, keyPath, arrValueNames, arrTypes\n    \n    If Not IsArray(arrValueNames) Then\n        arrValueNames = Array(&quot;&quot;)\n        arrTypes = Array(1)\n    End If\n    \n    For i = LBound(arrValueNames) To UBound(arrValueNames)\n        strValueName = arrValueNames(i)\n        strValueData = GetRegValue(objRegistry, hiveConst, keyPath, strValueName, arrTypes(i))\n        If Not ( IsNull(strValueName) Or IsNull(strValueData) ) Then\n        \tstrEntry = strPrefix &amp; strSep &amp; strValueName &amp; strSep &amp; strValueData\n        \tIf Not dictValues.Exists(strEntry) Then \n        \t\tdictValues.Add strEntry, True\n        \tEnd If \n        End If\n    Next    \nEnd Sub &#039;GetValues\n\nFunction GetRegValue(objRegistry, hiveConst, keyPath, strValueName, constType)\n\n    Const REG_SZ        = 1\n    Const REG_EXPAND_SZ = 2\n    Const REG_BINARY    = 3\n    Const REG_DWORD     = 4\n    Const REG_MULTI_SZ  = 7\n    Const REG_QWORD     = 11\n\n    Dim strValue, arrBytes, uValue, arrValues\n\n    Select Case constType\n        Case REG_SZ  \n            objRegistry.GetStringValue hiveConst, keyPath, strValueName, strValue\n            GetRegValue =  strValue\n            Exit Function\n        Case REG_EXPAND_SZ\n            objRegistry.GetExpandedStringValue hiveConst, keyPath, strValueName, strValue\n            GetRegValue =  strValue\n            Exit Function\n        Case REG_BINARY\n            objRegistry.GetBinaryValue hiveConst, keyPath, strValueName, arrBytes\n            strBytes = &quot;&quot;\n            For Each uByte in arrBytes\n                strBytes = strBytes &amp; Hex(uByte) &amp; &quot; &quot;\n            Next\n            GetRegValue =  strBytes\n            Exit Function\n        Case REG_DWORD\n            objRegistry.GetDWORDValue hiveConst, keyPath, strValueName, uValue\n            GetRegValue =  CStr(uValue)               \n            Exit Function\n        Case REG_QWORD\n            objRegistry.GetQWORDValue hiveConst, keyPath, strValueName, uValue\n            GetRegValue =  CStr(uValue)               \n            Exit Function\n        Case REG_MULTI_SZ\n            objRegistry.GetMultiStringValue hiveConst, keyPath, strValueName, arrValues                             \n            For Each strValue in arrValues\n                GetRegValue =  strValue \n            Next\n            Exit Function\n    End Select\nEnd Function &#039;GetRegValue\n\nFunction RegKeyExists(sHive, sRegKey, objReg)\n    Dim aValueNames, aValueTypes\n    If objReg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n        RegKeyExists = True\n    Else\n        RegKeyExists = False\n    End If\nEnd Function &#039; RegKeyExists\n\n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Type", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Command Line", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 348, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Provided with a parameter indicating the path to a file in the Tanium current directory, this sensor will return the contents of that file.\nExample: <arbitrary file output>", 
      "exclude_from_parse_flag": 1, 
      "hash": 4070262781, 
      "hidden_flag": 0, 
      "id": 693, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium File Contents", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Starting from the Client installation directory, complete the file path to get contents for.\",\"value\":\"\",\"promptText\":\"e.g. Tools\\\\MyTool\\\\MyLog.txt\",\"defaultValue\":\"\",\"label\":\"Relative file path from <Tanium Client Installation Dir>\",\"maxChars\":0,\"key\":\"filePath\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium File Contents\n&#039;========================================\n\nOption Explicit\n\nDim fso, strFilePath, strClientPath, strAbsoluteFilePath, objTextFile\n\nstrFilePath = unescape(&quot;||filePath||&quot;)\nstrFilePath =  GetTaniumDir(&quot;&quot;) &amp; strFilePath\nstrClientPath = GetTaniumDir(&quot;&quot;)\n\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nIf fso.FileExists(strFilePath) Then\n\tstrAbsoluteFilePath = fso.GetAbsolutePathName(strFilePath)\n\t\n\tIf LCase(Left(strAbsoluteFilePath, Len(strClientPath))) = LCase(strClientPath) Then \n\t\tSet objTextFile = fso.OpenTextFile(strFilePath, 1)\n\t\tWScript.Echo Replace(objTextFile.Read(4096),vbLf,&quot;&quot;)\n\t\tobjTextFile.Close\n\tElse\n\t\tWScript.Echo &quot;Not Within Client Directory&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;File does not exist&quot;\nEnd If\n\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filePath&quot;,&quot;promptText&quot;:&quot;e.g. Tools\\MyTool\\MyLog.txt&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filePath||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filePath&quot;,&quot;promptText&quot;:&quot;e.g. Tools\\MyTool\\MyLog.txt&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filePath||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 349, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Retrieves the Tanium Server Name from the Client's Registry\nExample: server.domain.com", 
      "exclude_from_parse_flag": 1, 
      "hash": 4076878703, 
      "hidden_flag": 0, 
      "id": 695, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Server Name", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Server Name\n&#039;========================================\n\n\nOption Explicit\n\nConst HKLM = &amp;h80000002\n\nDim objReg\nDim strTaniumRegPath, strCurrentTaniumServerValue\nDim strComputer\n\nstrComputer = &quot;.&quot;\n\nSet objReg = _ \n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nstrTaniumRegPath = GetTaniumRegistryPath()\n&#039;retrieve current server name value\nobjReg.GetStringValue HKLM, strTaniumRegPath, &quot;ServerName&quot;, strCurrentTaniumServerValue\n\nWScript.Echo strCurrentTaniumServerValue\n\n&#039;Cleanup\nSet objReg = Nothing\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\ngrep ^ServerName TaniumClient.ini  | awk -F= &#039;{print $2}&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\ngrep ^ServerName TaniumClient.ini  | awk -F= &#039;{print $2}&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 350, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the modification date of the file specified by the parameter.\nExample: 12/12/2014 18:00", 
      "exclude_from_parse_flag": 1, 
      "hash": 4080631087, 
      "hidden_flag": 0, 
      "id": 697, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "File Modification Date", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the file path and name to search for.\",\"value\":\"\",\"promptText\":\"e.g. c:\\\\windows\\\\test.txt\",\"defaultValue\":\"\",\"label\":\"File path and name to search for\",\"maxChars\":0,\"key\":\"filename\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; File Modification Date\n&#039;========================================\n\nOption Explicit\n\nSetLocale(1033)\n\nDim filesys, filename, file, modificationdate \n\nfilename = unescape(&quot;||filename||&quot;)\n&#039;filename = &quot;c:\\windows\\regedit.exe&quot;\n\nfilename = FixFileSystemRedirectionForPath(filename)\n\nSet filesys = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nIf filesys.FileExists(filename) Then\n   Set file = filesys.GetFile(filename)\n   modificationdate = file.DateLastModified\n   WScript.Echo FormatDateTime(modificationdate, vbShortDate) &amp; &quot; &quot; &amp; FormatDateTime(modificationdate, vbShortTime)\nElse\n   WScript.Echo &quot;File &quot; &amp; filename &amp; &quot; not found.&quot;\nEnd If\n\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n    \n    Dim objFSO, strSystem32Location,objShell\n    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n    \n    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n        If InStr(strFilePath,strSystem32Location) = 1 Then\n            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n            strFilePath = strNewSystem32Location&amp;strRestOfPath\n        End If\n    End If\n    FixFileSystemRedirectionForPath = strFilePath\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n    Dim objFSO,strSystem32Location,strNewSystem32Location\n    \n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    \n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n    \n    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File path and name to search for&quot;,&quot;helpString&quot;:&quot;Enter the file path and name to search for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "BESDate"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 351, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns the number of used and unused RAM slots.\nExample:2 6", 
      "exclude_from_parse_flag": 1, 
      "hash": 4086041268, 
      "hidden_flag": 0, 
      "id": 699, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "RAM Slots Used and Unused", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; RAM Slots Used and Unused\n&#039;========================================\n\n&#039; This sensor will return the number of free RAM slots\n\nOption Explicit\n\nDim strSep: strSep = &quot;|&quot;\n&#039; This is a multi-column sensor\n&#039; The output is \n&#039; Slots Used | Slots Unused\n\nRAM_SlotsUsedAndUnused(strSep)\n\nFunction RAM_SlotsUsedAndUnused(strSep)\n&#039; This function returns the number of used and unused RAM slots\n\tDim strComputer\n\tDim objWMIService, colPMAs, objPMA\n\tDim colPMs, objPM\n\n\t&#039; How many slots exist\n\tDim intSlots: intSlots = 0\n\t&#039; How many MemoryDevices are present\n\tDim intMemorySticks: intMemorySticks = 0\n\t&#039; How many slots are free\n\tDim intFreeSlots: intFreeSlots = 0\n\t\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\t&#039;Use = 3 is system RAM\n\t&#039; This is the number of slots in the system.\n\tSet colPMAs = objWMIService.ExecQuery(&quot;Select MemoryDevices from Win32_PhysicalMemoryArray where use=&#039;3&#039;&quot;,,48)\n\t\n\tFor Each objPMA In colPMAs\n\t\t&#039; There should be only one\n\t\t&#039; but just in case\n\t\tintSlots = intSlots + objPMA.MemoryDevices\n\t\t&#039; WScript.Echo &quot;objPMA.MemoryDevices is total slots: &quot; &amp; objPMA.MemoryDevices\n\tNext\n\t\n\t&#039; Cleanup\n\tSet colPMAs = Nothing\n\t\n\t&#039; A new query - asking for DeviceLocator where memory type does not \n\t&#039; equal 11 (Flash RAM)\n\t&#039; DeviceLocator is the label of the socket that holds the memory\n\t&#039; So this is the number of sockets in the system\n\tSet colPMs = objWMIService.ExecQuery(&quot;Select DeviceLocator from Win32_PhysicalMemory where MemoryType!=&#039;11&#039;&quot;)\n\t\n\tFor Each objPM In colPMs\n\t\t&#039;Each loop through indicates another slot\n\t\tintMemorySticks = intMemorySticks + 1\n\tNext\n\t\n\t&#039; output is number of used slots, separator, and number of free slots\n\tintFreeSlots = intSlots - intMemorySticks\n\t\n\tWScript.Echo intMemorySticks &amp; strSep &amp; intFreeSlots\n\t\n\t&#039;Cleanup\n\tSet colPMs = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;RAM_SlotsUsedAndUnused", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Slots Used", 
            "value_type": "NumericInteger"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Slots Unused", 
            "value_type": "NumericInteger"
          }
        ]
      }, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 352, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "A short description of the SCSI Controller as provided by the manufacturer.\nExample: Dell PERC S100 S300 Controller", 
      "exclude_from_parse_flag": 1, 
      "hash": 4105783647, 
      "hidden_flag": 0, 
      "id": 701, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "SCSI Controller Caption", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from win32_SCSIController", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 353, 
      "category": "Symantec", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Version of virus definition DAT file on client machine if Symantec AV is installed.\nExample: 20120103", 
      "exclude_from_parse_flag": 1, 
      "hash": 4117529004, 
      "hidden_flag": 0, 
      "id": 703, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Symantec DAT Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Symantec DAT Version\n&#039;========================================\n\nOption Explicit\n\n&#039; Force correct date handling\nSetLocale(1033)\n\nConst HKLM = &amp;H80000002 \nConst keyPath = &quot;Software\\Symantec\\SharedDefs&quot;\nConst keyPath12 = &quot;Software\\Symantec\\Symantec Endpoint Protection\\CurrentVersion\\SharedDefs&quot;\n\nDim objRegistry, strResult, strValue\n\nSet objRegistry = Getx32RegistryProvider()\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tstrResult = &quot;Not Installed&quot;\nEnd If\n\n&#039;check for SEP 12, which uses a different location for definitions&#039;\n&#039;check NAVCORP_70 value&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath12 ,&quot;NAVCORP_70&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatVersion(strValue)\n\tEnd If\nEnd If\n\n&#039;check NAVCORP_70 value&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVCORP_70&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatVersion(strValue)\n\tEnd If\nEnd If\n\n&#039;check NAVNO_50_AP1 value&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNO_50_AP1&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatVersion(strValue)\n\tEnd If\nEnd If\n\n&#039;check NAVNT_50_AP1 value&#039;\nIf strResult = &quot;&quot; Then \n\tobjRegistry.GetStringValue HKLM,keyPath ,&quot;NAVNT_50_AP1&quot;, strValue\n\tIf Not IsNull(strValue) Then\n\t\tstrResult = GetDatVersion(strValue)\n\tEnd If\nEnd If \n\nIf strResult = &quot;&quot; Then \n\tWScript.Echo &quot;Dat value not found&quot;\nElse \n\tWScript.Echo strResult\nEnd If\n\n\nFunction GetDatVersion(strValue)\n\tDim words, datFile\n\twords = Split(strValue, &quot;\\&quot;)\n\tdatFile = words(UBound(words))\n\twords = Split(datFile, &quot;.&quot;)\n\tGetDatVersion = words(0)\nEnd Function\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction Getx32RegistryProvider\n    &#039; Returns the 32 bit registry provider on all platforms:  32 bit on 32 bit systems, 32 bit on 64 bit systems\n    &#039; Useful if you want your script to behave the same regardless of if run in 32 bit or 64 bit cscript\n    Dim objWMIService, iArchType, objCtx, objLocator, objServices, objRegProv\n    \n    iArchType = 32\n   \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx32RegistryProvider = objRegProv\nEnd Function &#039; Getx32RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 354, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the name of the Active Directory Forest that a machine is a member of.  This may produce the same value that the Sensor named AD Domain produces.\nExample: corp.domain.com", 
      "exclude_from_parse_flag": 1, 
      "hash": 4165545489, 
      "hidden_flag": 0, 
      "id": 705, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "AD Forest", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; AD Forest\n&#039;========================================\n\nOption Explicit\nOn Error Resume Next \nDim objSysInfo\nSet objSysInfo = CreateObject(&quot;ADSystemInfo&quot;) \n\nIf IsNull(objSysInfo.ForestDNSName) Then\n\tWScript.Echo &quot;N/A&quot;\nElse\n\tWScript.Echo objSysInfo.ForestDNSName\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 355, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "The amount of free disk space on the main system drive.\nExample: C:|4 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 4180356655, 
      "hidden_flag": 0, 
      "id": 707, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "System Disk Free Space", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Disk Free Space of System Drive\n&#039;========================================\n\n&#039; This sensor uses the Disk Free Space sensor code\n&#039; but limits output to the drive that is designated the system\n&#039; drive\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;) \nSet objEnv = objShell.Environment(&quot;PROCESS&quot;) \n\nstrSystemDrive = objEnv(&quot;SystemDrive&quot;)\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; _\n    &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colDisks = objWMIService.ExecQuery _\n    (&quot;Select * from Win32_LogicalDisk&quot;)\n\nFor Each objDisk in colDisks\n\tIf LCase(objDisk.DeviceID) = LCase(strSystemDrive) Then\n\t\tFreeMB = objDisk.FreeSpace/1024000\n\t  \tIf (FreeMB &lt;&gt; &quot;&quot; and FreeMB &lt;&gt; 0) THEN\n\t    \tFreeGB = FreeMB/1000\n\t    \tWScript.Echo objDisk.DeviceID &amp; &quot;|&quot; &amp; Round(FreeGB) &amp; &quot; GB&quot;\n\t  \tEnd If\n\tEnd If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Disk", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Free Space", 
            "value_type": "DataSize"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 356, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Indicates the free swap space available to the operating system.\nExample: 640MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 4201347922, 
      "hidden_flag": 0, 
      "id": 709, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Free Swap", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nmemLine=$(free -m | grep &quot;Swap&quot;)\nset -- $memLine\necho $4 MB\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 357, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The amount of total disk space on the main system drive.\nExample: C: 100 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 4212162125, 
      "hidden_flag": 0, 
      "id": 711, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Disk Total Size of System Drive", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Disk Total Size of System Drive\n&#039;========================================\n\n&#039; This sensor uses the Disk Total Space sensor code\n&#039; but limits output to the drive that is designated the system\n&#039; drive\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;) \nSet objEnv = objShell.Environment(&quot;PROCESS&quot;) \n\nstrSystemDrive = objEnv(&quot;SystemDrive&quot;)\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; _\n    &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colDisks = objWMIService.ExecQuery _\n    (&quot;Select * from Win32_LogicalDisk&quot;)\nFor Each objDisk in colDisks\n &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID\n    If LCase(objDisk.DeviceID) = LCase(strSystemDrive) Then\n\t    If Not IsNull(objDisk.Size) Then\n\t\t    dblSize = CDbl(objDisk.Size)\n\t\t    dblSize = dblSize / 1024 / 1024 / 1024\n\t\t    intSize = CInt(dblSize)\n\t\t\tWScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intSize &amp; &quot; GB&quot;\n\t    End If\n\tEnd If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 358, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Allows the retreival of the available patches download URLs\nExample:Security Update for Windows Server 2003 (KB2510531) | Critical | URL | Filename", 
      "exclude_from_parse_flag": 1, 
      "hash": 4213159728, 
      "hidden_flag": 0, 
      "id": 713, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Available Patches URLs", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Available Patches URL\n&#039;========================================\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput\nstrSep = &quot;|&quot;\n\n&#039;title|severity|download|filename\n\nDim strScansPath, strToolsPath\nstrToolsPath = GetTaniumDir(&quot;Tools&quot;)\nstrScansPath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = strScansPath &amp; &quot;\\patchresultsreadable.txt&quot;\n\n&#039;Set up exclusions list\nDim excludeFile\nexcludeFile = strToolsPath &amp; &quot;\\patch-exclude.txt&quot;\n\nDim objExclusions\nSet objExclusions = GetPatchExclusions(excludeFile)\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\tWScript.Echo words(0)\n\t\t\t&#039;Else \n&#039;\t\t\t\tWScript.Echo &quot;Run upgraded Patch Scan&quot;\n&#039;\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n&#039;\t\tElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\t\t\tIf Not isComplete Then\n\t\t\t\thasOutput = True\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\t&#039;if InStr(strLine, &quot;(KB&quot;) Then\n\t\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)\n\t\t\t\t\t&#039;End If\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\tElse\n\t\t\t\t\t&#039;Check to see if KB article should be excluded\n\t\t\t\t\tIf Not IsExclusion(strLine, objExclusions) Then\n\t\t\t\t\t\tEchoLines strLine \n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued\n\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t&#039;If InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t&#039;\tWScript.Echo strLine\n\t\t\t\t&#039;End If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\n\tIf Not hasOutput Then\n\t\tWScript.Echo &quot;All available patches queued for installation&quot;\n\tEnd If\n\n\tobjReadFile.close\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd if\nWScript.Quit()\n\nSub EchoLines(strLine) \n\tDim arrTokens, strTitle, strSeverity, strDownloads, strFilenames, i\n\tarrTokens = Split(strLine, &quot;|&quot;)\n\tstrTitle = arrTokens(0)\n\tstrSeverity = arrTokens(1)\n\tstrDownloads = Split(arrTokens(4), &quot;,&quot;)\n\tstrFilenames = Split(arrTokens(5), &quot;,&quot;)\n\n\tFor i=0 To UBound(strDownloads)\n\t\tWScript.Echo strTitle &amp; &quot;|&quot; &amp; strSeverity &amp; &quot;|&quot; &amp; strDownloads(i) &amp; &quot;|&quot; &amp; strFilenames(i)\n\tNext\nEnd Sub\n\nFunction RegKeyExists(reg, sHive, sRegKey)\n  Dim aValueNames, aValueTypes\n  If reg.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n    RegKeyExists = True\n  Else\n    RegKeyExists = False\n  End If\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction IsExclusion(strLine, objDic)\n\tDim colKeys, strKey\n\tcolKeys = objDic.Keys\n\tFor Each strKey in colKeys\n\t\tIf InStr(strLine, strSep &amp; strKey &amp; strSep) &lt;&gt; 0 Then\n\t\t\tIsExclusion = True\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\t\n\tIsExclusion = False\nEnd Function\n\nFunction GetPatchExclusions(strFile)\n\tDim oDic\n\tSet oDic = CreateObject(&quot;scripting.dictionary&quot;)\n\t\n\tDim fso\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tConst ForReading = 1\n\tIf fso.FileExists(strFile) Then\n\t\tDim objFile\n\t\tSet objFile = fso.OpenTextFile(strFile, ForReading)\n\t\t\n\t\tDim strLine\n\t\tDo While objFile.AtEndOfStream &lt;&gt; True\n\t\t\tstrLine = Trim(objFile.ReadLine)\n\t\t\t\n\t\t\t&#039;Ignore lines that start with #\n\t\t\tIf Left(strLine, 1) &lt;&gt; &quot;#&quot; Then\n\t\t\t\toDic.Item(strLine) = &quot;placeholder&quot;\n\t\t\tEnd If\n\t\tLoop\n\tEnd If\n\t\n\tSet GetPatchExclusions = oDic\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Download", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Filename", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 359, 
      "category": "Symantec", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Age in days of the last scan report by Symantec AV on the client machine if it exists.  This sensor is SEP 12 specific\nExample: 9", 
      "exclude_from_parse_flag": 1, 
      "hash": 4225944416, 
      "hidden_flag": 0, 
      "id": 715, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Symantec SEP 12 Last Report Days Old", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Symantec Last Report Days Old - SEP 12 possible\n&#039;========================================\n\n&#039;SEP 12 seems to work differently than previous versions.  This sensor determines the last scan based on&#039;\n&#039;a different criteria than previous SEP versions&#039;\n\nstrComputer = &quot;.&quot;\nSet objRegistry = _\n\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nkeyPath = &quot;SOFTWARE\\Symantec\\Symantec Endpoint Protection\\CurrentVersion\\Common Client\\PathExpansionMap&quot;\nkey64Path = &quot;SOFTWARE\\WOW6432Node\\Symantec\\Symantec Endpoint Protection\\CurrentVersion\\Common Client\\PathExpansionMap&quot;\n\nConst HKLM = &amp;H80000002 \nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\nEnd If \n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tWScript.Echo &quot;Not Installed&quot;\n\tWScript.Quit\nEnd If\n\nstrFile = &quot;\\Data\\IRON\\IronState.dat&quot;\nset theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\n&#039;check SEP 12 State directory&#039;\nobjRegistry.GetStringValue HKLM,keyPath ,&quot;APPDATABASE&quot;, strDir\nIf theFso.FileExists(strDir &amp; strFile) Then\n\tWScript.Echo GetReportDaysOld(strDir &amp; strFile)\n\tWScript.Quit\nEnd If\n\nWScript.Echo &quot;Not Installed&quot;\n\nfunction GetReportDaysOld(theFile)\n\tdim theFso, theVer\n\tset theFso = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\treportDate = FormatDateTime(theFso.GetFile(theFile).DateLastModified,2)\n\t&#039;WScript.Echo (&quot;reportdate: &quot; &amp; reportDate)\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tGetReportDaysOld = DateDiff(&quot;d&quot;, reportDate, today)\nEnd Function\n\nFunction GetDatDaysOld(strValue)\nEnd Function\n\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 360, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Installation directory of the Tanium Client on the client machine.\nExample: C:\\Program Files\\Tanium\\Tanium Client", 
      "exclude_from_parse_flag": 1, 
      "hash": 4225957259, 
      "hidden_flag": 0, 
      "id": 717, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Current Directory", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Current Directory\n&#039;========================================\n\nset wshell = createobject(&quot;wscript.shell&quot;)\nwscript.echo wshell.currentdirectory", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 4, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 361, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "A list of the static IP addresses currently held by the client machine.\nExample: 192.168.1.1", 
      "exclude_from_parse_flag": 1, 
      "hash": 422662332, 
      "hidden_flag": 0, 
      "id": 719, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Static IP Addresses", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select IPAddress from win32_networkadapterconfiguration where DHCPEnabled = False and IPEnabled=True", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "IPAddress"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 362, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the set run level of Linux systems\nExample: 3", 
      "exclude_from_parse_flag": 1, 
      "hash": 4244179900, 
      "hidden_flag": 0, 
      "id": 721, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Run Level", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nline=$(who -r)\nset -- $line\necho $2\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 363, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the number of open slots in the system on Windows client machines.\nExample: 3", 
      "exclude_from_parse_flag": 1, 
      "hash": 4254566410, 
      "hidden_flag": 0, 
      "id": 723, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "System Slots Available", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; System Slots Available\n&#039;========================================\n\n&#039; This sensor will return the number of slots open in the system\n\nOption Explicit\n\nWScript.Echo GetSystemSlotsAvailable\n\nFunction GetSystemSlotsAvailable\n\t\n\tDim objWMIService, colSystemSlots\n\tDim strComputer, objSystemSlots\n\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;) \n\n\t&#039;SlotDesignation is like &quot;PCI-I&quot; and CurrentUsage=3 means available\n\tSet colSystemSlots = objWMIService.ExecQuery _ \n\t\t(&quot;Select SlotDesignation from Win32_SystemSlot where CurrentUsage=3&quot;) \n\tIf Not IsNull(colSystemSlots) Then\n\t\tGetSystemSlotsAvailable = colSystemSlots.Count\n\tElse\n\t\tGetSystemSlotsInAvailable = &quot;WMI Error&quot;\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet colSystemSlots = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;GetSystemSlotsAvailable", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 364, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the IP address of the peer specified in th Tanium registry entry at HKLM\\SOFTWARE\\Tanium\\Tanium Client\\Status\\PeerAddress on windows and TaniumClientStatus.ini on non-windows endpoints.\nExample: 192.168.1.123", 
      "exclude_from_parse_flag": 1, 
      "hash": 4261354259, 
      "hidden_flag": 0, 
      "id": 725, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Peer Address", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Peer Address\n&#039;========================================\n\nOption Explicit\n\nConst HKEY_LOCAL_MACHINE = &amp;H80000002\n\nDim strKeyPath, strValueName, strValue, strTaniumClientVersion, oReg\n\nstrKeyPath = GetTaniumRegistryPath &amp; &quot;\\Status&quot;\nstrValueName = &quot;PeerAddress&quot; \nstrTaniumClientVersion = GetTaniumClientVersion()\n\nIf InStr(strTaniumClientVersion,&quot;6.0.314.&quot; ) &gt; 0 Then\n\t&#039; This may seem exactly opposite, but the 6.0 client does not \n\t&#039; correctly keep up with these values in status, but does the\n\t&#039; &quot;reverse&quot; connection.  So to know who is forward, we need to look\n\t&#039; up the previous back, to know who is backwards, we need the previous\n\t&#039; peer.  Very confusing\n\tstrValueName = &quot;BackPreviousPeerAddress&quot;\nEnd If\n\nSet oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;) \n\noReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue\n\nWscript.Echo strValue\n\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction GetTaniumClientVersion\n\n\tDim fso, filePath, objFile\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tIf GetTaniumDir(&quot;&quot;) = False Then \n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If \n\t\n\tfilePath = GetTaniumDir(&quot;&quot;) &amp; &quot;taniumclient.exe&quot;\n\t\n\tIf fso.FileExists(filePath) Then\n\t\tSet objFile = fso.GetFile(filePath)\n\t\tGetTaniumClientVersion = fso.GetFileVersion(objFile)\n\tElse\n\t\tGetTaniumClientVersion &quot;Not installed&quot;\n\tEnd If\n\nEnd Function &#039;GetTaniumClientVersion\t\t\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\ngrep -w &quot;^PeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\ngrep -w &quot;^PeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 365, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Any Active Directory groups that the currently logged in user is a member of.\nExample: CN=Domain Admins,CN=Users,DC=corp,DC=com", 
      "exclude_from_parse_flag": 1, 
      "hash": 4264207873, 
      "hidden_flag": 0, 
      "id": 727, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "AD User Groups", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; AD User Groups\n&#039;========================================\n\nOn Error Resume Next \nScanUsers\n \nFunction ScanUsers()\n\tDim strComputer, objWMIService, colComputer, objComputer, strId\n\tstrComputer = &quot;.&quot;    \n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; &amp;  &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)  \n\tSet colComputer = objWMIService.ExecQuery (&quot;Select UserName from Win32_ComputerSystem&quot;)    \n\tIf colComputer.Count = 0 Then\n\t\tWScript.Echo &quot;No User&quot;\n\t\tWScript.quit\n\tEnd If\n\tFor Each objComputer in colComputer     \n\t\tif objComputer.UserName &lt;&gt; &quot;&quot; Then\n\t\t\twords = Split(objComputer.UserName, &quot;\\&quot;)\n\t\t\t\n\t\t\tIf UBound(words) &gt; 0 Then\n\t\t\t\tstrId = words(UBound(words))\n\t\t\t\tdn = GetDN(strId)\n\t\t\t\tGetGroups(dn)\n\t\t\tEnd If\n\t\tEnd If  \n\tNext\nEnd Function\n\nFunction GetGroups(strDn)\n&#039;\tWScript.Echo &quot;looking at: &quot;&amp; strDN\n\t&#039;\tOn Error Resume Next\n\tConst E_ADS_PROPERTY_NOT_FOUND  = &amp;h8000500D\n\t \n\tSet objUser = GetObject _\n\t    (&quot;LDAP://&quot; &amp; strDn)\n\t \n\tintPrimaryGroupID = objUser.Get(&quot;primaryGroupID&quot;)\n\tarrMemberOf = objUser.GetEx(&quot;memberOf&quot;)\n\t \n\tIf Err.Number = E_ADS_PROPERTY_NOT_FOUND Then\n\t    WScript.Echo &quot;The memberOf attribute is not set.&quot;\n\tElse\n\t    For Each Group in arrMemberOf\n\t        WScript.Echo Group\n\t    Next\n\tEnd If\nEnd Function\n\nFunction GetDN(strUserId)\n\tConst ADS_SCOPE_SUBTREE = 2\n\t\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;)\n\tSet objCommand =   CreateObject(&quot;ADODB.Command&quot;)\n\tobjConnection.Provider = &quot;ADsDSOObject&quot;\n\tobjConnection.Open &quot;Active Directory Provider&quot;\n\tSet objCommand.ActiveConnection = objConnection\n\t\n\tobjCommand.Properties(&quot;Page Size&quot;) = 1000\n\tobjCommand.Properties(&quot;Searchscope&quot;) = ADS_SCOPE_SUBTREE \n\t\n\tSet objRootDSE = GetObject(&quot;LDAP://RootDSE&quot;)\n\tstrDNSDomain = objRootDSE.Get(&quot;defaultNamingContext&quot;)\n\t\n\tobjCommand.CommandText = _\n\t    &quot;SELECT distinguishedName FROM &#039;LDAP://&quot;&amp;strDNSDomain&amp;&quot;&#039; WHERE objectCategory=&#039;user&#039; &quot; &amp; _\n\t        &quot;AND sAMAccountName=&#039;&quot;&amp;strUserId&amp;&quot;&#039;&quot;\n\tSet objRecordSet = objCommand.Execute\n\t\n\tobjRecordSet.MoveFirst\n\tDo Until objRecordSet.EOF\n\t    &#039;Wscript.Echo objRecordSet.Fields(&quot;distinguishedName&quot;).Value\n\t    GetDN = objRecordSet.Fields(&quot;distinguishedName&quot;).Value\n\t\tExit Function\n\t    objRecordSet.MoveNext\n\tLoop\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 366, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "A sensor which counts the number of patch files queued for install.\nExample: 2", 
      "exclude_from_parse_flag": 1, 
      "hash": 4269230392, 
      "hidden_flag": 0, 
      "id": 729, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Number of Queued Patches", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Number of Queued Patches\n&#039;========================================\n\nOption Explicit\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput\nstrSep = &quot;|&quot;\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\nDim intNumPatches\n\nintNumPatches = 0\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\tWScript.Echo words(0)\n\t\t\t&#039;Else \n&#039;\t\t\t\tWScript.Echo &quot;Run upgraded Patch Scan&quot;\n&#039;\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n&#039;\t\tElseIf InStr(strDownload, &quot;,&quot;) = 0 And InStr(strDownload, &quot; &quot;) = 0 Then\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\t\t\tIf Not isComplete Then\n\t\t\t\thasOutput = True\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\tif InStr(strLine, &quot;(KB&quot;) Then\n\t\t\t\t\t\tstrLine = Replace(strLine, &quot;Already Installed&quot;, &quot;KB Already Installed&quot;)\n\t\t\t\t\tEnd If\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Queued&quot; patches\n\t\t\t\t\t&#039;WScript.Echo strLine\n&#039;\t\t\t\tElse\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Queued&quot; patches\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued \n\t\t\t\tIf InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t\tintNumPatches = intNumPatches + 1\n&#039;WScript.Echo strLine\n\t\t\t\tEnd If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\nWscript.echo intNumPatches\n\n\tobjReadFile.close\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd if\nWScript.Quit()\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 367, 
      "category": "Registry", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns all values contained in a supplied key.  If the hive is HKEY_USERS, it will attempt to output the user name associated with the key.  HKEY_CURRENT_USER will only return data for the SYSTEM account which the Tanium Client runs as.\nExample: John | Version | 32-bit", 
      "exclude_from_parse_flag": 1, 
      "hash": 4276555360, 
      "hidden_flag": 0, 
      "id": 731, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Registry Key Value Names", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{5}\",\"helpString\":\"Value must be at least 5 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the registry key to query\",\"value\":\"\",\"promptText\":\"e.g. HKEY_USERS\\\\Software\\\\Key\",\"defaultValue\":\"\",\"label\":\"Registry Key\",\"maxChars\":0,\"key\":\"strKey\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Key Value Names\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Value Name | Architecture | KeyPath\n\nstrKey = unescape(&quot;||strKey||&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n\nstrSep = &quot;|&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\t\n\t\thasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\t\n\tEnd If\nEnd If\n\nIf Not (hasAnyResult) Then\n\tWScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\t&#039; Note the key that was being searched, will be a hidden column\n\tstrOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n\t\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\tWScript.Echo strUserName &amp; strSep &amp; strValueName &amp; strSep &amp; intBit &amp; &quot;-bit&quot; _\n\t\t\t\t&amp; strSep &amp; strOutputKey &amp; &quot;\\&quot; &amp; strValueName\n\t\tNext\n\t\tCheckValues = True\n\n\tElse\n\t\tCheckValues = False\n\tEnd If\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\\Software\\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value must be at least 5 characters&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;\\S{5}&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strKey&quot;,&quot;promptText&quot;:&quot;e.g. HKEY_USERS\\Software\\Key&quot;,&quot;label&quot;:&quot;Registry Key&quot;,&quot;helpString&quot;:&quot;Enter the registry key to query&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strKey||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "User", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Value Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Architecture", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "KeyPath", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 368, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the IP address of the back peer specified in th Tanium registry entry at HKLM\\SOFTWARE\\Tanium\\Tanium Client\\Status\\PeerAddress on windows and TaniumClientStatus.ini on non-windows endpoints.\nExample: 192.168.1.123", 
      "exclude_from_parse_flag": 1, 
      "hash": 4293389196, 
      "hidden_flag": 0, 
      "id": 733, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Back Peer Address", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Back Peer Address\n&#039;========================================\n\nOption Explicit\n\nConst HKEY_LOCAL_MACHINE = &amp;H80000002\n\nDim strKeyPath, strValueName, strValue, strTaniumClientVersion, oReg\n\nstrKeyPath = GetTaniumRegistryPath &amp; &quot;\\Status&quot;\nstrValueName = &quot;BackPeerAddress&quot; \nstrTaniumClientVersion = GetTaniumClientVersion()\n\nIf InStr(strTaniumClientVersion,&quot;6.0.314.&quot; ) &gt; 0 Then\n\tstrValueName = &quot;PreviousPeerAddress&quot;\nEnd If\n\nSet oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;) \n\noReg.GetStringValue HKEY_LOCAL_MACHINE,strKeyPath,strValueName,strValue\n\nWscript.Echo strValue\n\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction GetTaniumClientVersion\n\n\tDim fso, filePath, objFile\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\n\tIf GetTaniumDir(&quot;&quot;) = False Then \n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If \n\t\n\tfilePath = GetTaniumDir(&quot;&quot;) &amp; &quot;taniumclient.exe&quot;\n\t\n\tIf fso.FileExists(filePath) Then\n\t\tSet objFile = fso.GetFile(filePath)\n\t\tGetTaniumClientVersion = fso.GetFileVersion(objFile)\n\tElse\n\t\tGetTaniumClientVersion &quot;Not installed&quot;\n\tEnd If\n\nEnd Function &#039;GetTaniumClientVersion\t\t\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\ngrep -w &quot;^BackPeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\ngrep -w &quot;^BackPeerAddress&quot; TaniumClientStatus.ini | cut -d= -f2\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 369, 
      "category": "SQL", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the buffer cache hit ratio from SQL Server on the client machine.\nExample: .5", 
      "exclude_from_parse_flag": 1, 
      "hash": 432766313, 
      "hidden_flag": 0, 
      "id": 735, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "SQL Buffer Hit Ratio", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; SQL Buffer Hit Ratio\n&#039;========================================\n&#039;@INCLUDE=sql/mssql_connection_utils.vbs\n\nOption Explicit\n\nDim dictInstances, strInstance, objConnection\n\nSet dictInstances = GetMSSQLInstances()\n\nFor Each strInstance In dictInstances.Keys\n\n\tDim objRecordSet, objRecordSet2, strNumerator, strDenominator, intNum, intDen, result\n\tSet objConnection = CreateObject(&quot;ADODB.Connection&quot;) \n\tSet objRecordSet = CreateObject(&quot;ADODB.Recordset&quot;) \n\tSet objRecordSet2 = CreateObject(&quot;ADODB.Recordset&quot;)  \n\t\n\tOn Error Resume Next\n\tobjConnection.Open GenMSSQLConnectionStr(strInstance, &quot;master&quot;)\n\t\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;Access Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\t\n\tobjRecordSet.Open &quot;select cntr_value from master..sysperfinfo where (counter_name=&#039;Buffer cache hit ratio&#039;)&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC \n\tobjRecordSet2.Open &quot;select cntr_value from master..sysperfinfo where (counter_name=&#039;Buffer cache hit ratio base&#039;)&quot;, objConnection, AD_OPEN_STATIC, AD_LOCK_OPTIMISTIC  \n\tstrNumerator = objRecordSet(&quot;cntr_value&quot;) \n\tstrDenominator = objRecordSet2(&quot;cntr_value&quot;) \n\n\tIf objConnection.Errors.Count &gt; 0 Then \n\t\tWScript.Echo &quot;SQL Error (&quot; &amp; strInstance &amp; &quot;)&quot;\n\t\tExit For\n\tEnd If \n\n\tOn Error Goto 0\n\t\n\tintNum = CInt(strNumerator) \n\tintDen = CInt(StrDenominator) \n\tresult = intNum/IntDen \n\tif result &gt; 1 then \n\t\tresult = 1 \n\tEnd If \n\tWScript.echo result &amp; GetMSSQLSensorInstanceStr(strInstance)\nNext\n\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: sql/mssql_connection_utils.vbs\n\n&#039; Common constants for MSSQL lookups\nConst AD_OPEN_STATIC = 3 \nConst AD_LOCK_OPTIMISTIC = 3  \n\n\nFunction GetMSSQLInstances()\n    Dim dictResult, objWMIService, colServices, objService\n    Dim strCaption, strInstance, intStartIndex, intStopIndex\n    Set dictResult = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n    Set objWMIService = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)  \n    Set colServices = objWMIService.ExecQuery (&quot;select * from win32_Service&quot;)  \n    For Each objService In colServices\n        strCaption = objService.Caption\n    \n        If (InStr(strCaption,&quot;SQL Server&quot;) &lt;&gt; 0 And ObjService.State = &quot;Running&quot;) Then    \n            &#039; OK -- found SQL Server on this machien, now we need to find the instance name\n            &#039; if this is the correct service\n            strInstance = &quot;.&quot;\n            intStartIndex = InStr(strCaption, &quot;(&quot;)\n            intStopIndex = InStr(strCaption, &quot;)&quot;)\n            \n            If(intStartIndex &lt;&gt; 0) And (intStopIndex &lt;&gt; 0) Then \n                strInstance = Mid(strCaption, intStartIndex + 1, intStopIndex - intStartIndex - 1)\n                    \n                If strInstance = &quot;MSSQLSERVER&quot; Then \n                    strInstance = &quot;.&quot;\n                End If \n\n                If Not dictResult.Exists(strInstance) Then\n                    dictResult.Add strInstance, True\n                End if\n            End If             \n        End If  \n    Next  \n    \n    Set GetMSSQLInstances = dictResult\n\nEnd Function &#039; GetMSSQLInstances\n\nFunction GenMSSQLConnectionStr(strInstance, strCatalog) \n    Dim strDataSource, strConnection\n\n    If strInstance = &quot;.&quot; Then \n        strDataSource = strInstance\n    Else \n        strDataSource = &quot;.\\&quot; &amp; strInstance\n    End If \n\n    strConnection = &quot;Provider=SQLOLEDB;Data Source=&quot; &amp; strDataSource &amp; &quot;;Trusted_Connection=Yes;Initial Catalog=&quot; &amp; strCatalog &amp; &quot;;&quot;\n\n    GenMSSQLConnectionStr = strConnection\nEnd Function &#039; OpenMSSQLConnection\n\nFunction GetMSSQLSensorInstanceStr(strInstance)\n    If strInstance = &quot;.&quot; Then\n        GetMSSQLSensorInstanceStr = &quot;&quot;\n    Else\n        GetMSSQLSensorInstanceStr = &quot; (&quot; &amp; strInstance &amp; &quot;)&quot;\n    End If\nEnd Function &#039; GetMSSQLSensorInstanceStr\n&#039;- End file: sql/mssql_connection_utils.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 370, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns IPv4 network routes, filtered to exclude noise. With Flags, Metric, Interface columns.\nExample:  172.16.0.0|192.168.1.1|255.255.0.0|UG|100|eth0", 
      "exclude_from_parse_flag": 1, 
      "hash": 435227963, 
      "hidden_flag": 0, 
      "id": 737, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 60, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "IP Route Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "strComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\nSet collip = objWMIService.ExecQuery(&quot;select * from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;&quot;)\ndim ipaddrs()\nipcount = 0\nfor each ipItem in collip\n    for each ipaddr in ipItem.IPAddress\n        ipcount = ipcount + 1\n    next\nnext\nredim ipaddrs(ipcount)\nipcount = 0\nfor each ipItem in collip\n    for each ipaddr in ipItem.IPAddress\n        ipcount = ipcount + 1\n        ipaddrs(ipcount) = ipaddr\n    next\nnext\nlocalhost = &quot;127.0.0.1&quot;\n\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_IP4RouteTable&quot;)\n\nFor Each objItem in colItems\n    dest = objItem.Destination\n    gw = objItem.NextHop\n    mask = objItem.Mask\n    metric = objItem.Metric1\n    flags = objItem.Type\n    intf = objItem.InterfaceIndex\n    For i = 0 to ipcount\n        if gw = ipaddrs(i) and gw &lt;&gt; localhost then\n            gw = &quot;0.0.0.0&quot;\n        end if\n    Next\n    if gw &lt;&gt; localhost and dest &lt;&gt; &quot;224.0.0.0&quot; and right(dest,3) &lt;&gt; &quot;255&quot; then\n        Wscript.Echo dest &amp; &quot;|&quot; &amp; gw &amp; &quot;|&quot; &amp; mask &amp; &quot;|&quot; &amp; &quot;-&quot; &amp; &quot;|&quot; &amp; metric &amp; &quot;|&quot; &amp; &quot;-&quot;\n    end if\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "route -n | grep -v Kernel | grep -v Destination | awk &#039;{ print $1 &quot;|&quot; $2 &quot;|&quot; $3 &quot;|&quot; $4 &quot;|&quot; $5 &quot;|&quot; $8 }&#039; | grep -v &quot;|127.0.0.1|&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "netstat -rn | grep -v &quot;:&quot; | grep -v Destination | grep -v Routing | grep -v -e &quot;^$&quot; | awk &#039;{ print $1 &quot;|&quot; $2 &quot;||&quot; $3 &quot;||&quot; $6 }&#039; | grep -v &quot;|127.0.0.1|&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 52, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Destination", 
            "value_type": "IPAddress"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Gateway", 
            "value_type": "IPAddress"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Mask", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Flags", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Metric", 
            "value_type": "NumericInteger"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Interface", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 371, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The Active Directory domain name (if any) that the computer is joined to.\nExample: intra.company.com", 
      "exclude_from_parse_flag": 1, 
      "hash": 462732724, 
      "hidden_flag": 0, 
      "id": 739, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "AD Domain", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Domain from win32_ComputerSystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 372, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns IPv4 network routes, filtered to exclude noise.\nExample:  172.16.0.0|192.168.1.1|255.255.0.0", 
      "exclude_from_parse_flag": 1, 
      "hash": 487354270, 
      "hidden_flag": 0, 
      "id": 741, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 60, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "IP Routes", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "strComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\n\n&#039;Build list of local IP addresses\n&#039;For identifying locally connected networks\n&#039;(which show local IP address as gateway)\nSet collip = objWMIService.ExecQuery(&quot;select * from win32_networkadapterconfiguration where IPEnabled=&#039;True&#039;&quot;)\ndim ipaddrs()\nipcount = 0\nfor each ipItem in collip\n    for each ipaddr in ipItem.IPAddress\n        ipcount = ipcount + 1\n    next\nnext\nredim ipaddrs(ipcount)\nipcount = 0\nfor each ipItem in collip\n    for each ipaddr in ipItem.IPAddress\n        ipcount = ipcount + 1\n        ipaddrs(ipcount) = ipaddr\n    next\nnext\nlocalhost = &quot;127.0.0.1&quot;\n\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_IP4RouteTable&quot;)\n\nFor Each objItem in colItems\n    dest = objItem.Destination\n    gw = objItem.NextHop\n    mask = objItem.Mask\n    For i = 0 to ipcount\n        if gw = ipaddrs(i) and gw &lt;&gt; localhost then\n            &#039;Show single gateway for local networks\n            &#039;to allow proper clustering\n            gw = &quot;0.0.0.0&quot;\n        end if\n    Next\n    if gw &lt;&gt; localhost and dest &lt;&gt; &quot;224.0.0.0&quot; and right(dest,3) &lt;&gt; &quot;255&quot; then\n        &#039;Exclude local, multicast and broadcast\n        Wscript.Echo dest &amp; &quot;|&quot; &amp; gw &amp; &quot;|&quot; &amp; mask\n    end if\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "route -n | grep -v Kernel | grep -v Destination | awk &#039;{ print $1 &quot;|&quot; $2 &quot;|&quot; $3 }&#039; | grep -v &quot;|127.0.0.1|&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "netstat -rn | grep -v &quot;:&quot; | grep -v Destination | grep -v Routing | grep -v -e &quot;^$&quot; | awk &#039;{ print $1 &quot;|&quot; $2 &quot;|&quot; &quot;-&quot; }&#039; | grep -v &quot;|127.0.0.1|&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Destination", 
            "value_type": "IPAddress"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Gateway", 
            "value_type": "IPAddress"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Subnet Mask", 
            "value_type": "IPAddress"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 373, 
      "category": "Windows Event Logs", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Recent event codes from the application event logs in Windows.\nExample: 1001", 
      "exclude_from_parse_flag": 1, 
      "hash": 502812713, 
      "hidden_flag": 0, 
      "id": 743, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Application Event Log IDs", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select EventCode from Win32_NTLogEvent where LogFile = &#039;Application&#039;  and TimeWritten &gt; &#039;$$GETUTCDATE$$86000$$&#039;", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 374, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The amount of used disk space per partition.\nExample: C: 40 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 508127351, 
      "hidden_flag": 0, 
      "id": 745, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Disk Used Space", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Disk Used Space\n&#039;========================================\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n    &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; _\n    &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colDisks = objWMIService.ExecQuery _\n    (&quot;Select * from Win32_LogicalDisk&quot;)\nFor Each objDisk in colDisks\n &#039;   Wscript.Echo &quot;DeviceID: &quot; &amp; objDisk.DeviceID\n    \n    If Not IsNull(objDisk.Size) And Not IsNull(objDisk.FreeSpace) Then\n\t    dblSize = CDbl(objDisk.Size) - CDbl(objDisk.FreeSpace)\n\t    dblSize = dblSize / 1024 / 1024 / 1024\n\t    intSize = CInt(dblSize)\n\t\tWScript.Echo objDisk.DeviceID &amp; &quot; &quot; &amp; intSize &amp; &quot; GB&quot;\n    End If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndf -TPh |grep -vE &quot;Use%|tmpfs&quot; |while read line\ndo\n\tset -- $line\n\techo $7: $4\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\ndf -Hl | grep -vE &#039;^Filesystem|tmpfs|cdrom&#039; | awk &#039;/^\\// { print $9&quot;: &quot; $3 }&#039;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 375, 
      "category": "Security", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "A list of all shared folders and the permissions currently enabled for those folders.\nExample: Downloads, BUILTIN\\Administrators-FULL | \\CREATOR OWNER-FULL | NT AUTHORITY\\SYSTEM-FULL", 
      "exclude_from_parse_flag": 1, 
      "hash": 542266296, 
      "hidden_flag": 0, 
      "id": 747, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Share Folder Permissions", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Share Folder Permissions\n&#039;========================================\n\n&#039;Script will return permissions on each enabled share\n\nstrComputer = &quot;.&quot;\nSet objWMI = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMI.ExecQuery(&quot;Select * from win32_share&quot;)\n\nFor Each i In colItems\nstrDir = i.path\nstrName = i.name\nresult = Trim (Replace(CollectAceInfo(strDir),&quot;|&quot;,&quot;&quot;, 1 , 1))\nwscript.echo strName &amp; &quot;,&quot; &amp; result\nNext\n\nFunction CollectAceInfo(strDir)\nDim ArrayStrAce()\ni=0 \nstrDir = Replace(strDir,&quot;\\&quot;,&quot;\\\\&quot;)\nSet colItems = objWMI.ExecQuery(&quot;Select * from win32_logicalFileSecuritySetting WHERE Path=&#039;&quot; &amp; strDir &amp; &quot;&#039;&quot;,,48)\n\tfor each objItem in colItems\n\t\tIf objItem.GetSecurityDescriptor(wmiSecurityDescriptor) Then\n\t\tCollectAceInfo = &quot;GetSecurityDescriptor failed&quot;\n\t\tDisplayFileSecurity = False\n\t\tExit Function\n\t\tEnd if\n\nFor each wmiAce in wmiSecurityDescriptor.DACL\nstrACE = wmiAce.Trustee.Domain &amp; &quot;\\&quot; &amp; wmiAce.Trustee.Name\nstrAceMask = wmiAce.AccessMask\n\nstrMask = GetMaskValue(strAceMask)\nIf strMask &lt;&gt; &quot;1&quot; then\ni = i + 1\nReDim Preserve ArrayStrAce(i)\nArrayStrAce(i) = strAce &amp; &quot;-&quot; &amp; strMask\nCollectAceInfo = Join(ArrayStrAce,&quot; | &quot;)\nend if\nnext\nnext\nEnd Function\n\nFunction GetMaskValue(StrAceMask)\n&#039;Dim MaskArray()\nSelect Case StrAceMask\nCase &quot;1179817&quot;\n\tGetMaskValue = &quot;READ&quot;\nCase &quot;1245631&quot;\n\tGetMaskValue = &quot;CHANGE&quot;\nCase &quot;2032127&quot;\n\tGetMaskValue = &quot;FULL&quot;\nCase Else\n\tGetMaskValue = &quot;1&quot;\nEnd Select\n\n&#039;i=0\n&#039;If StrAceMask AND 16 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Write extended attributes&quot;\n&#039;End If\n&#039;if StrAceMask AND 1048576 Then\n&#039;\ti=i + 1\n&#039;    ReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Synchronize&quot;\n&#039;End If\n&#039;If StrAceMask AND 524288 Then\n&#039;    i=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Write owner&quot;\n&#039;End If\n&#039;If StrAceMask AND 262144 Then\n&#039;\ti=i + 1\n&#039;   ReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Write ACL&quot;\n&#039;End If\n&#039;If StrAceMask AND 131072 Then\n&#039;\ti=i + 1\n&#039;    ReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Read security&quot;\n&#039;End If\n&#039;If StrAceMask AND 65536 Then\n&#039;    i=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Delete&quot;\n&#039;End If\n&#039;If StrAceMask AND 256 Then\n&#039;    i=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Write attributes&quot;\n&#039;End If\n&#039;If StrAceMask AND 128 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;    MaskArray(i) =  &quot;Read attributes&quot;\n&#039;End If\n&#039;If StrAceMask AND 64 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;    MaskArray(i) =  &quot;Delete dir&quot;\n&#039;End If\n&#039;If StrAceMask AND 32 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;    MaskArray(i) =  &quot;Execute&quot;\n&#039;End If\n&#039;If StrAceMask AND 16 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;    MaskArray(i) =  &quot;Write extended attributes&quot;\n&#039;End If\n&#039;If StrAceMask AND 8 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;   MaskArray(i) =  &quot;Read extended attributes&quot;\n&#039;End If\n&#039;If StrAceMask AND 4 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;    MaskArray(i) =  &quot;Append&quot;\n&#039;End If\n&#039;If StrAceMask AND 2 Then\n&#039;    i=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;\tMaskArray(i) =  &quot;Write&quot;\n&#039;End If\n&#039;If StrAceMask AND 1 Then\n&#039;\ti=i + 1\n&#039;\tReDim Preserve MaskArray(i)\n&#039;    MaskArray(i) =  &quot;Read&quot;\n&#039;End If\n&#039;GetMaskValue = Join(MaskArray,&quot; : &quot;)\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Share", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Permissions", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 376, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns the OS language along with any Language Packs installed.\nExample: English-United States en-US", 
      "exclude_from_parse_flag": 1, 
      "hash": 549503533, 
      "hidden_flag": 0, 
      "id": 749, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Operating System Language", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Operating System Language\n&#039;========================================\n\n&#039; This sensor will output the language of the installed OS along with\n&#039; any language packs installed.\n&#039; it is a multi-column sensor that looks like:\n&#039; OS Language | Language Packs Installed\n\nOption Explicit\n\nDim strSep\nstrSep = &quot;|&quot;\n\nWScript.Echo GetOSLanguage(strSep)\n\n&#039;-----------End Main-------------&#039;\nFunction GetOSLanguage(strSep)\n&#039; Retrieves the OS language and whether there are any MUI packs installed.\n&#039; Will only retrieve MUI packs on Vista+\n\n\tConst HKLM = &amp;H80000002\n\t\n\tDim strComputer\n\tDim strWMILanguageCode, arrLangKeys, strLangKey\n\tDim strLanguagesRegPath1, strLanguagesRegPath2\n\tDim strLanguagePacksInstalled\n\tDim objRegistry, objWMIService, objOperatingSystem\n\tDim colOperatingSystems\n\n\t\n\tstrComputer = &quot;.&quot;\n\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n\t&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;) \n\tSet colOperatingSystems = objWMIService.ExecQuery _ \n\t\t(&quot;Select * from Win32_OperatingSystem&quot;) \n\tFor Each objOperatingSystem in colOperatingSystems \t\n\t\tstrWMILanguageCode = objOperatingSystem.OSLanguage\n\tNext\n\t\t\t\n\tSet objRegistry = _\n\t\tGetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; _ \n\t\t&amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\t\n\tstrLanguagePacksInstalled = &quot;&quot;\n\tstrLanguagesRegPath1 = &quot;SYSTEM\\CurrentControlSet\\Control\\MUI\\UILanguages&quot;\n\tstrLanguagesRegPath2 = &quot;SYSTEM\\CurrentControlSet\\Control\\Nls\\MUILanguages&quot;\t\n\t\n\t&#039; This works on newer OS&#039;s\n\tobjRegistry.EnumKey HKLM, strLanguagesRegPath1, arrLangKeys\n\tIf Not IsNull(arrLangKeys) Then\n\t\tFor Each strLangKey In arrLangKeys\n\t\t\tIf strLanguagePacksInstalled = &quot;&quot; Then\n\t\t\t\tstrLanguagePacksInstalled = strLangKey\n\t\t\tElse\n\t\t\t\tstrLanguagePacksInstalled = strLanguagePacksInstalled &amp; &quot;,&quot; &amp; strLangKey\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\t\n\tIf strLanguagePacksInstalled = &quot;&quot; Then strLanguagePacksInstalled = &quot;XP or Earlier OS&quot;\n\t\n\tGetOSLanguage = LocaleCodeToLanguage(strWMILanguageCode) &amp; strSep &amp; strLanguagePacksInstalled\n\t\n\t&#039; need to : cleanup\n\t&#039; map language codes to readable english\n\t&#039;Cleanup\n\n\tSet objRegistry = Nothing\t\t\nEnd Function &#039;GetOSLanguage\n\nFunction LocaleCodeToLanguage(strCode)\n&#039; This function takes an numeric locale code and returns\n&#039; a readable language mapping\n\n\tDim arrLangCodes, i\n\n\tarrLangCodes = array(&quot;1078&quot;,&quot;Afrikaans&quot;,&quot;1052&quot;,&quot;Albanian&quot;,&quot;14337&quot;,&quot;Arabic - United Arab Emirates&quot;,&quot;15361&quot;,&quot;Arabic - Bahrain&quot;,&quot;5121&quot;,&quot;Arabic - Algeria&quot;,&quot;3073&quot;,_\n\t&quot;Arabic - Egypt&quot;,&quot;2049&quot;,&quot;Arabic - Iraq&quot;,&quot;11265&quot;,&quot;Arabic - Jordan&quot;,&quot;13313&quot;,&quot;Arabic - Kuwait&quot;,&quot;12289&quot;,&quot;Arabic - Lebanon&quot;,&quot;4097&quot;,&quot;Arabic - Libya&quot;,&quot;6145&quot;,_\n\t&quot;Arabic - Morocco&quot;,&quot;8193&quot;,&quot;Arabic - Oman&quot;,&quot;16385&quot;,&quot;Arabic - Qatar&quot;,&quot;1025&quot;,&quot;Arabic - Saudi Arabia&quot;,&quot;10241&quot;,&quot;Arabic - Syria&quot;,&quot;7169&quot;,&quot;Arabic - Tunisia&quot;,&quot;9217&quot;,_\n\t&quot;Arabic - Yemen&quot;,&quot;1067&quot;,&quot;Armenian&quot;,&quot;1068&quot;,&quot;Azeri - Latin&quot;,&quot;2092&quot;,&quot;Azeri - Cyrillic&quot;,&quot;1069&quot;,&quot;Basque&quot;,&quot;1059&quot;,&quot;Belarusian&quot;,&quot;1026&quot;,&quot;Bulgarian&quot;,&quot;1027&quot;,&quot;Catalan&quot;,&quot;2052&quot;,_\n\t&quot;Chinese - China&quot;,&quot;3076&quot;,&quot;Chinese - Hong Kong S.A.R.&quot;,&quot;5124&quot;,&quot;Chinese - Macau S.A.R&quot;,&quot;4100&quot;,&quot;Chinese - Singapore&quot;,&quot;1028&quot;,&quot;Chinese - Taiwan&quot;,&quot;1050&quot;,&quot;Croatian&quot;,&quot;1029&quot;,_\n\t&quot;Czech&quot;,&quot;1030&quot;,&quot;Danish&quot;,&quot;1043&quot;,&quot;Dutch - The Netherlands&quot;,&quot;2067&quot;,&quot;Dutch - Belgium&quot;,&quot;3081&quot;,&quot;English - Australia&quot;,&quot;10249&quot;,&quot;English - Belize&quot;,&quot;4105&quot;,&quot;English - Canada&quot;,&quot;9225&quot;,_\n\t&quot;English - Carribbean&quot;,&quot;6153&quot;,&quot;English - Ireland&quot;,&quot;8201&quot;,&quot;English - Jamaica&quot;,&quot;5129&quot;,&quot;English - New Zealand&quot;,&quot;13321&quot;,&quot;English - Phillippines&quot;,&quot;7177&quot;,_\n\t&quot;English - South Africa&quot;,&quot;11273&quot;,&quot;English - Trinidad&quot;,&quot;2057&quot;,&quot;English - United Kingdom&quot;,&quot;1033&quot;,&quot;English - United States&quot;,&quot;1061&quot;,&quot;Estonian&quot;,&quot;1065&quot;,&quot;Farsi&quot;,&quot;1035&quot;,_\n\t&quot;Finnish&quot;,&quot;1080&quot;,&quot;Faroese&quot;,&quot;1036&quot;,&quot;French - France&quot;,&quot;2060&quot;,&quot;French - Belgium&quot;,&quot;3084&quot;,&quot;French - Canada&quot;,&quot;5132&quot;,&quot;French - Luxembourg&quot;,&quot;4108&quot;,&quot;French - Switzerland&quot;,&quot;2108&quot;,_\n\t&quot;Gaelic - Ireland&quot;,&quot;1084&quot;,&quot;Gaelic - Scotland&quot;,&quot;1031&quot;,&quot;German - Germany&quot;,&quot;3079&quot;,&quot;German - Austria&quot;,&quot;5127&quot;,&quot;German - Liechtenstein&quot;,&quot;4103&quot;,&quot;German - Luxembourg&quot;,&quot;2055&quot;,_\n\t&quot;German - Switzerland&quot;,&quot;1032&quot;,&quot;Greek&quot;,&quot;1037&quot;,&quot;Hebrew&quot;,&quot;1081&quot;,&quot;Hindi&quot;,&quot;1038&quot;,&quot;Hungarian&quot;,&quot;1039&quot;,&quot;Icelandic&quot;,&quot;1057&quot;,&quot;Indonesian&quot;,&quot;1040&quot;,&quot;Italian - Italy&quot;,&quot;2064&quot;,_\n\t&quot;Italian - Switzerland&quot;,&quot;1041&quot;,&quot;Japanese&quot;,&quot;1042&quot;,&quot;Korean&quot;,&quot;1062&quot;,&quot;Latvian&quot;,&quot;1063&quot;,&quot;Lithuanian&quot;,&quot;1071&quot;,&quot;FYRO Macedonian&quot;,&quot;1086&quot;,&quot;Malay - Malaysia&quot;,&quot;2110&quot;,_\n\t&quot;Malay - Brunei&quot;,&quot;1082&quot;,&quot;Maltese&quot;,&quot;1102&quot;,&quot;Marathi&quot;,&quot;1044&quot;,&quot;Norwegian - Bokm-l&quot;,&quot;2068&quot;,&quot;Norwegian - Nynorsk&quot;,&quot;1045&quot;,&quot;Polish&quot;,&quot;2070&quot;,&quot;Portuguese - Portugal&quot;,&quot;1046&quot;,_\n\t&quot;Portuguese - Brazil&quot;,&quot;1047&quot;,&quot;Raeto-Romance&quot;,&quot;1048&quot;,&quot;Romanian - Romania&quot;,&quot;2072&quot;,&quot;Romanian - Moldova&quot;,&quot;1049&quot;,&quot;Russian&quot;,&quot;2073&quot;,&quot;Russian - Moldova&quot;,&quot;1103&quot;,&quot;Sanskrit&quot;,&quot;3098&quot;,_\n\t&quot;Serbian - Cyrillic&quot;,&quot;2074&quot;,&quot;Serbian - Latin&quot;,&quot;1074&quot;,&quot;Setsuana&quot;,&quot;1060&quot;,&quot;Slovenian&quot;,&quot;1051&quot;,&quot;Slovak&quot;,&quot;1070&quot;,&quot;Sorbian&quot;,&quot;1034&quot;,&quot;Spanish - Spain&quot;,&quot;11274&quot;,_\n\t&quot;Spanish - Argentina&quot;,&quot;16394&quot;,&quot;Spanish - Bolivia&quot;,&quot;13322&quot;,&quot;Spanish - Chile&quot;,&quot;9226&quot;,&quot;Spanish - Colombia&quot;,&quot;5130&quot;,&quot;Spanish - Costa Rica&quot;,&quot;7178&quot;,_\n\t&quot;Spanish - Dominican Republic&quot;,&quot;12298&quot;,&quot;Spanish - Ecuador&quot;,&quot;4106&quot;,&quot;Spanish - Guatemala&quot;,&quot;18442&quot;,&quot;Spanish - Honduras&quot;,&quot;2058&quot;,&quot;Spanish - Mexico&quot;,&quot;19466&quot;,_\n\t&quot;Spanish - Nicaragua&quot;,&quot;6154&quot;,&quot;Spanish - Panama&quot;,&quot;10250&quot;,&quot;Spanish - Peru&quot;,&quot;20490&quot;,&quot;Spanish - Puerto Rico&quot;,&quot;15370&quot;,&quot;Spanish - Paraguay&quot;,&quot;17418&quot;,&quot;Spanish - El Salvador&quot;,&quot;14346&quot;,_\n\t&quot;Spanish - Uruguay&quot;,&quot;8202&quot;,&quot;Spanish - Venezuela&quot;,&quot;1072&quot;,&quot;Sutu&quot;,&quot;1089&quot;,&quot;Swahili&quot;,&quot;1053&quot;,&quot;Swedish - Sweden&quot;,&quot;2077&quot;,&quot;Swedish - Finland&quot;,&quot;1097&quot;,&quot;Tamil&quot;,&quot;1092&quot;,&quot;Tatar&quot;,&quot;1054&quot;,_\n\t&quot;Thai&quot;,&quot;1055&quot;,&quot;Turkish&quot;,&quot;1073&quot;,&quot;Tsonga&quot;,&quot;1058&quot;,&quot;Ukrainian&quot;,&quot;1056&quot;,&quot;Urdu&quot;,&quot;2115&quot;,&quot;Uzbek - Cyrillic&quot;,&quot;1091&quot;,&quot;Uzbek - Latin&quot;,&quot;1066&quot;,&quot;Vietnamese&quot;,&quot;1076&quot;,&quot;Xhosa&quot;,&quot;1085&quot;,&quot;Yiddish&quot;,&quot;1077&quot;,&quot;Zulu&quot;)\n\n\tFor i = 0 To UBound(arrLangCodes)\n\t\tIf CStr(arrLangCodes(i)) = CStr(strCode) Then\n\t\t\t&#039;Return the value immediately after the found code\n\t\t\tLocaleCodeToLanguage = arrLangCodes(i+1)\n\t\tEnd If\t\n\tNext\nEnd Function &#039;LocaleCodeToLanguage", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "OS Language", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Language Packs Installed", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 377, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the number of fixed drives installed in the system.\nExample:4", 
      "exclude_from_parse_flag": 1, 
      "hash": 590837956, 
      "hidden_flag": 0, 
      "id": 751, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Number of Fixed Drives", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Number of Fixed Drives\n&#039;========================================\n\n&#039; This sensor will output the number of fixed disk drives\n\nOption Explicit\n\nWScript.Echo GetNumberOfFixedDrives\n\nFunction GetNumberOfFixedDrives\n\t\n\tDim objWMIService, colDiskDrives\n\tDim strComputer, objDiskDrive, intDriveCount\n\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;) \n\n\t&#039;SlotDesignation is like &quot;PCI-I&quot; and CurrentUsage=4 means occupied\n\tSet colDiskDrives = objWMIService.ExecQuery _ \n\t\t(&quot;Select MediaType from Win32_DiskDrive&quot;) \n\tIf Not IsNull(colDiskDrives) Then\n\t\tintDriveCount = 0\n\t\tFor Each objDiskDrive In colDiskDrives\t\n\t\t\tIf InStr(LCase(objDiskDrive.MediaType), &quot;fixed&quot; ) &gt; 0 Then\t\n\t\t\t\tintDriveCount = intDriveCount + 1\n\t\t\tEnd If\n\t\tNext\n\t\tGetNumberOfFixedDrives = intDriveCount\n\tElse\n\t\tGetNumberOfFixedDrives = &quot;WMI Error&quot;\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet colDiskDrives = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;GetNumberOfFixedDrives", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 378, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "A multi-column sensor that lists every running process and the amount of CPU usage they are taking up.\nExample: svchost | 15", 
      "exclude_from_parse_flag": 1, 
      "hash": 600562575, 
      "hidden_flag": 0, 
      "id": 753, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "CPU by Process", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; CPU by Process\n&#039;========================================\n\n&#039; a multi-column sensor whose output looks like:\n&#039; Process Name | Percentage\n\nOption Explicit\n\nDim objWMIService,colItems\nDim objItem,strSep,strName,intPoundPos\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfFormattedData_PerfProc_Process&quot;,,48)\n\nstrSep = &quot;|&quot;\n\nFor Each objItem in colItems\n\n\tstrName = LCase(objItem.Name)\n\tintPoundPos = InStr(strName,&quot;#&quot;)\n\tIf intPoundPos &gt; 0 Then\n\t\t&#039; if it&#039;s a duplicate process, the name may put a #x after it\n\t\t&#039; as in \n\t\t&#039; chome#9\n\t\t&#039; Remove everything after a #\n\t\tstrName = Left(strName,intPoundPos - 1)\n\tEnd If\n\t&#039; ignore _Total Entry or Idle Entry\n\tIf Not (strName = &quot;_total&quot; Or strName = &quot;idle&quot; Or strName = &quot;taniumclient&quot;)  Then\n\t\tWScript.Echo strName &amp; strSep &amp; objItem.PercentProcessorTime\n\tEnd If\nNext\n\n&#039;Cleanup\nSet objWMIService = Nothing\nSet colItems = Nothing", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "CPU %", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 379, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the ports which are listening on a local machine and the IP address the port is bound to.  0.0.0.0 indicates that the port is bound to all IP addresses.\nExample: 0.0.0.0:80", 
      "exclude_from_parse_flag": 1, 
      "hash": 601571508, 
      "hidden_flag": 0, 
      "id": 755, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Open Port", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Open Port\n&#039;========================================\n\nport = &quot;*&quot;\n\nIf port = &quot;*&quot; Then\n   strcommand = &quot;cmd /c netstat -an | find &quot; &amp; chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34)\nElse \n   strcommand = &quot;cmd /c netstat -an | find &quot; &amp; chr(34) &amp; &quot;LISTENING&quot; &amp; Chr(34) &amp; _\n        &quot;| find &quot; &amp; chr(34) &amp; &quot;:&quot; &amp; port &amp; &quot; &quot; &amp; Chr(34)\nEnd If\n\nDim bHasOutput : bHasOutput = False\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrPingResults = LCase(objScriptExec.StdOut.ReadAll)\n\nresults = Split(strPingResults, vbCrLf)\nfor Each line in results\n    &#039;WScript.Echo &quot;parsing line: &quot; &amp; line\n    \n    line = cleanWhitespace(Trim(line))\n    \n    lineResults = Split(line)\n    i = 0\n    For Each word In lineResults\n    &#039;   WScript.Echo &quot;    word &quot;&amp;i&amp; &quot;: &quot; &amp; word\n       If i = 1 Then\n          WScript.Echo word\n          bHasOutput = True\n       End If\n       i = i + 1\n    Next\nnext\n\nIf Not bHasOutput Then\n\tIf GetLocale() &lt;&gt; 1033 Then\n\t\tWScript.Echo &quot;English Language OS Required&quot;\n\tEnd If\nEnd If\n\n&#039;if len (strPingResults) &gt; 0 then\n&#039; WScript.Echo strPingResults\n&#039;WScript.Echo &quot;results: &quot; &amp; strPingResults\n&#039;End If\n\nFunction cleanWhitespace(strStarter)\n   intStarter = Len(strStarter)\n   For i = intStarter to 2 Step -1\n       strChars = Space(i)\n       strStarter = Replace(strStarter, strChars, &quot; &quot;)\n   Next\n   cleanWhitespace = strStarter\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nnetstat -tulpn | grep &quot;LISTEN&quot; | grep &quot;0.0.0.0&quot; | grep &quot;tcp&quot; |while read line\ndo\n set -- $line\n\techo $4\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nnetstat -a | grep tcp4 | grep LISTEN |while read line\ndo\n set -- $line\n\techo $4\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 50, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 380, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the size of the file specified by the parameter.\nExample: 69120", 
      "exclude_from_parse_flag": 1, 
      "hash": 63201224, 
      "hidden_flag": 0, 
      "id": 757, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "File Size", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the full drive letter, folder path and file name of the file.\",\"value\":\"\",\"promptText\":\"e.g. c:\\\\windows\\\\test.txt\",\"defaultValue\":\"\",\"label\":\"File name to search for\",\"maxChars\":0,\"key\":\"filename\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; File Size\n&#039;========================================\n\nDim filesys, filename, file, createdate \n\nfilename = unescape(&quot;||filename||&quot;)\n\nfilename = FixFileSystemRedirectionForPath(filename)\n\nSet filesys = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\nIf filesys.FileExists(filename) Then\n   Set file = filesys.GetFile(filename)\n   WScript.Echo file.Size   \nElse\n   WScript.Echo &quot;File &quot; &amp; filename &amp; &quot; not found.&quot;\nEnd If\n\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n    \n    Dim objFSO, strSystem32Location,objShell\n    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n    \n    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n        If InStr(strFilePath,strSystem32Location) = 1 Then\n            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n            strFilePath = strNewSystem32Location&amp;strRestOfPath\n        End If\n    End If\n    FixFileSystemRedirectionForPath = strFilePath\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n    Dim objFSO,strSystem32Location,strNewSystem32Location\n    \n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    \n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n    \n    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;filename&quot;,&quot;promptText&quot;:&quot;e.g. c:\\windows\\test.txt&quot;,&quot;label&quot;:&quot;File name to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter, folder path and file name of the file.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||filename||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 381, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Folder size (in GB, MB, KB, or B)\nExample: 62 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 632662206, 
      "hidden_flag": 0, 
      "id": 759, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Folder Size", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the full drive letter and folder path of the folder\",\"value\":\"\",\"promptText\":\"e.g. c:\\\\Program Files\\\\MyApp\",\"defaultValue\":\"\",\"label\":\"Folder path to search for\",\"maxChars\":0,\"key\":\"strFolder\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Folder Size\n&#039;========================================\n\n&#039; TAG: REDIRECTION\n\nDim strFolder\nstrFolder = unescape(&quot;||strFolder||&quot;)\n\nstrFolder = FixFileSystemRedirectionForPath(strFolder)\n\nDim intRound\nintRound = 0\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nDim objFolder\n\nIf fso.FolderExists(strFolder) Then\n\tintSize = GetFolderSize(strFolder)\n\t\n\tintKB = 1024\n\tintMB = 1024*1024\n\tintGB = 1024*1024*1024\n\t\n\tIf intSize &gt; intGB Then\n\t\tWScript.Echo Int(intSize / intGB) &amp; &quot; GB&quot;\n\tElseIf intSize &gt; intMB Then\n\t\tWScript.Echo Int(intSize / intMB) &amp; &quot; MB&quot;\n\tElseIf intSize &gt; intKB Then\n\t\tWScript.Echo Int(intSize / intKB) &amp; &quot; KB&quot;\n\tElse\n\t\tWScript.Echo intSize &amp; &quot; B&quot;\n\tEnd If\nElse\n\tWScript.Echo &quot;Folder not found&quot;\nEnd If\n\nFunction GetFolderSize(folderName)\n\t&#039; Some directories have files which are never accessible.  \n\t&#039; This allows retrieving the values for those type of directories\n    On Error Resume Next\n\n    Dim fso, folder, subfolder, size, hasSubfolders\n\n\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\n    size = 0\n    hasSubfolders = False\n\n    Set folder = fso.GetFolder(folderName)\n    &#039; Try the non-recursive way first (potentially faster?)\n    Err.Clear\n    size = folder.Size\n    If Err.Number &lt;&gt; 0 then     &#039; Did not work; do recursive way:\n        For Each subfolder in folder.SubFolders\n            size = size + getFolderSize(subfolder.Path)\n            hasSubfolders = True\n        Next\n\n        If not hasSubfolders then\n            size = folder.Size\n        End If\n    End If\n\n\tOn Error Goto 0\n    GetFolderSize = size\nEnd Function\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n    \n    Dim objFSO, strSystem32Location,objShell\n    Dim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    Set objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n    \n    If objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n        If InStr(strFilePath,strSystem32Location) = 1 Then\n            strRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n            strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n            strFilePath = strNewSystem32Location&amp;strRestOfPath\n        End If\n    End If\n    FixFileSystemRedirectionForPath = strFilePath\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n    Dim objFSO,strSystem32Location,strNewSystem32Location\n    \n    Set objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n    \n    strFilePath = LCase(strFilePath)\n    strSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n    strNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n    \n    UnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n    \n    &#039;Cleanup\n    Set objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strFolder&quot;,&quot;promptText&quot;:&quot;e.g. c:\\Program Files\\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strFolder||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;strFolder&quot;,&quot;promptText&quot;:&quot;e.g. c:\\Program Files\\MyApp&quot;,&quot;label&quot;:&quot;Folder path to search for&quot;,&quot;helpString&quot;:&quot;Enter the full drive letter and folder path of the folder&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||strFolder||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 382, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Shows applications that are currently running and how long they have been running for.\nExample: Dropbox - 3 days", 
      "exclude_from_parse_flag": 1, 
      "hash": 664237249, 
      "hidden_flag": 0, 
      "id": 761, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Application Run Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Application Run Time\n&#039;========================================\n\n&#039;On Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select Name, ExecutablePath, CreationDate from Win32_Process&quot;,,48)\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\nDim nameDictionary, processDictionary\nSet nameDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)\nSet processDictionary = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039;ADD PROCESS NAME IN LOWER CASE\nnameDictionary.Add &quot;hppusg.exe&quot;, &quot;Some HP Application&quot;\nnameDictionary.Add &quot;taniumclient.exe&quot;, &quot;TANIUM CLIENT&quot;\n\n&#039;array used to print output (no dictionary since we need duplicates)\nDim arrOutput()\nintSize = 0\nReDim Preserve arrOutput(intSize)\n\nstrComputer = &quot;.&quot;\nConst HKLM = &amp;h80000002\nSet reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n\nregPath = GetTaniumRegistryPath() &amp; &quot;\\Sensor Data\\Applications&quot;\nIf Not RegKeyExists(reg, HKLM, regPath) Then\n\treg.createKey HKLM, regPath\nEnd If\n\nFor Each objItem in colItems\n\tIf InStr(LCase(objItem.ExecutablePath), &quot;windows\\system32\\&quot;) = 0 Then\n\t    Dim fso\n\t    Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t    If fso.FileExists(objItem.ExecutablePath) Then\n    \t\tDim strOutput, fullName\n\n\t    \tSet execFile = fso.GetFile(objItem.ExecutablePath)\n\t    \t\n   \t\t\tfullName = nameDictionary.Item(LCase(objItem.Name))\n\n\t\t\tIf IsEmpty(fullName) Then\n\t    \t\tfullName = GetProcName(objItem.Name, reg, HKLM, regPath)\n    \t\tEnd If\n    \t\t\t\t\t\n    \t\tIf fullName = &quot;&quot; Then\n    \t\t\tfullName = objItem.Name\n    \t\tEnd If\n\n&#039;\t\t\tIf InStr(LCase(fullName), LCase(appName)) &gt; 0 Then\n\t\t\tlastStart = GetLastStart(objItem.Name, reg, HKLM, regPath)\n\t\t\tIf lastStart &lt;&gt; &quot;&quot; Then\t\t\t\t\n\t   \t\t\tstrOutput = fullName &amp; &quot; - &quot; &amp; GetDaysOld(lastStart)\n\t   \t\tElse\n\t   \t\t\tstrOutput = fullName &amp; &quot; - Launch date unknown&quot;\t\n\t\t\tEnd If\n\n \t\t\tIf not ArrayContains(arrOutput, strOutput) Then\n\t\t\t\tarrOutput(intSize) = strOutput\n\t\t\t\tintSize = intSize + 1\n\t\t\t\tReDim Preserve arrOutput(intSize)\n\t\t\tEnd If\n\t    End If\n\tEnd If\nNext\n\nFor Each output In arrOutput \n\tIf Not IsEmpty(output) Then\n\t\tWScript.Echo output\n\tEnd If\nNext\n\nFunction GetLastStart(strProc, objReg, hive, baseRegKey) \n\twords = Split(strProc, &quot;.&quot;)\t\n\tregKey = baseRegKey &amp; &quot;\\&quot; &amp; words(0)\n\tIf RegKeyExists(objReg, hive, regKey) Then\n\t\tobjReg.GetStringValue hive, regKey, &quot;Last Start&quot;, GetLastStart\n\tEnd If\nEnd Function\n\nFunction GetProcName(strProc, objReg, hive, baseRegKey) \n\twords = Split(strProc, &quot;.&quot;)\t\n\tregKey = baseRegKey &amp; &quot;\\&quot; &amp; words(0)\n\tIf RegKeyExists(objReg, hive, regKey) Then\n\t\tobjReg.GetStringValue hive, regKey, &quot;Description&quot;, GetProcName\n\tEnd If\nEnd Function\n\nFunction ArrayContains(arr, str)\n\tFor Each obj In arr \n\t\tIf obj = str Then\n\t\t\tArrayContains = True\n\t\t\tExit Function\n\t\tEnd If\n\tNext\n\tArrayContains = False\nEnd Function\n\n&#039;date format is MM/DD/YYYY\nfunction GetDaysOld(strDate)\n\tpatternDate = CDate( strDate )\n\ttoday = CDate( Month(Now) &amp; &quot;/&quot; &amp; Day(Now) &amp; &quot;/&quot; &amp; Year(Now))\n\tdays = DateDiff(&quot;d&quot;, patternDate, today)\n\t\n\tIf days = 1 Then\n\t\tGetDaysOld = &quot;1 day&quot;\n\tElse \n\t\tGetDaysOld = days &amp; &quot; days&quot;\n\tEnd If\nEnd Function\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 383, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns a list of installed RPMs by name on Linux systems.\nExample: glibc-2.5-12", 
      "exclude_from_parse_flag": 1, 
      "hash": 676468157, 
      "hidden_flag": 0, 
      "id": 763, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Installed RPMs", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\nrpm -qa\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 384, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns whether McAfee Endpoint Encryption is Activated\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 732965965, 
      "hidden_flag": 0, 
      "id": 765, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "McAfee Endpoint Encryption Activated", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; McAfee Endpoint Encryption Activated\n&#039;========================================\n\n&#039; This sensor will return whether McAfee Endpoint Encryption is Activated\n&#039; This is a Yes or No Value\n\nOption Explicit\n\nDim objRegistry,keyPath,key64Path,strSep\nstrSep = &quot;|&quot; &#039; column delimiter\n\nSet objRegistry = Getx64RegistryProvider()\n\nConst HKLM = &amp;H80000002\n\nkeyPath = &quot;SOFTWARE\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\nkey64Path = &quot;SOFTWARE\\Wow6432Node\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If\n\nIf RegKeyExists(HKLM, keyPath) Then\n\tDim strReturn\n\tstrReturn = ReturnStringValueOrEchoError _\n\t\t(objRegistry,HKLM,keyPath,&quot;Activated&quot;,&quot;McAfee Endpoint Encryption Activation Status Not Found&quot;)\n\tIf VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error\n\t\tWScript.Echo strReturn\n\tElse\n\t\tWScript.Quit\n\tEnd If\nElse\n\tWScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;\n\tWScript.Quit\nEnd If\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)\n&#039; Return a value or fatal error message and error result\n\tDim intReturn,strValueData\n\tintReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)\n\tIf intReturn = 0 Then\n\t\tReturnStringValueOrEchoError = strValueData\n\tElse\n\t\tReturnStringValueOrEchoError = -1\n\t\tWScript.Echo strErrorMessage\n\tEnd If\nEnd Function \n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 385, 
      "category": "Miscellaneous", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Simple sensor that returns the word \"Target\" that is used when targeting actions within Tanium.\nExample: Target", 
      "exclude_from_parse_flag": 1, 
      "hash": 740857544, 
      "hidden_flag": 0, 
      "id": 767, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Target", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Target\n&#039;========================================\n\nWScript.Echo &quot;Target&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 386, 
      "category": "Active Directory", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns information on AD accounts which are logged in using cached credentials.\nExample:john.doe Cached - RDP", 
      "exclude_from_parse_flag": 1, 
      "hash": 745447734, 
      "hidden_flag": 0, 
      "id": 769, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Cached AD Logins", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Cached AD Logins\n&#039;========================================\n&#039; This sensor will enumerate the Usernames of all accounts which are\n&#039; cached\n\nOption Explicit\n\nDim strSep : strSep = &quot;|&quot;\n&#039; This is a multi-column sensor whose output looks like\n&#039; Username|Type\n&#039; Where account type is Cached - Interactive or Cached - RDP\n\nListCachedAccounts\n\nFunction ListCachedAccounts\n\n\tDim objWMI, colSessions, colProcesses, objProcess\n\tDim objSession, colList, objItem, colOwner, strProcessOwner\n\tDim strAccountType, dictProcessOwners, strOwnerUser, strOwnerDomain\n\tDim bDisplay, objReg\n\t\n\tSet objWMI = GetObject(&quot;winmgmts:&quot; _ \n\t              &amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;) \n\tSet objReg = GetObject(&quot;winmgmts:\\\\.\\root\\default:StdRegProv&quot;)              \n\t\n\t&#039; Get owner information for running processes to filter out stale user results\n\t&#039; because Win32_LogonSession can have days old logins in there.\n\t\n\t&#039; store in dictionary object\n\tSet dictProcessOwners = CreateObject(&quot;Scripting.Dictionary&quot;)\n\t\n\tSet colProcesses = objWMI.ExecQuery(&quot;Select * from Win32_Process&quot;,,48)\n\tOn Error Resume Next &#039; some processes may not have owner and domain properties\n\tFor Each objProcess in colProcesses\n\t\tcolOwner = objProcess.GetOwner(strOwnerUser,strOwnerDomain)\n\t\t\t\n\t\tIf Not dictProcessOwners.Exists(strOwnerDomain&amp;&quot;\\&quot;&amp;strOwnerUser) Then\n\t\t\tdictProcessOwners.Add strOwnerDomain&amp;&quot;\\&quot;&amp;strOwnerUser,1 &#039; for uniqueness\n\t\tEnd If\n\tNext\n\tOn Error Goto 0 &#039;back to normal\n\t\n\n\tSet colSessions = objWMI.ExecQuery(&quot;Select * from Win32_LogonSession&quot;) \n\t\t\n\tIf colSessions.Count = 0 Then \n\t\t&#039; Do Nothing\n\tElse \n\t   For Each objSession in colSessions\n\t     Set colList = objWMI.ExecQuery(&quot;Associators of &quot; _ \n\t         &amp; &quot;{Win32_LogonSession.LogonId=&#039;&quot; &amp; objSession.LogonId &amp; &quot;&#039;} &quot; _ \n\t         &amp; &quot;Where AssocClass=Win32_LoggedOnUser Role=Dependent&quot; ) \n\t     For Each objItem in colList\n\t     \tSelect Case objSession.LogonType\n\t     \t\tCase 11\n\t     \t\t\tstrAccountType = &quot;:Cached: :Interactive:&quot;\n\t     \t\t\tbDisplay = True\n\t     \t\tCase 12\n\t     \t\t\tstrAccountType = &quot;:Cached: :RDP:&quot;\n\t     \t\t\tbDisplay = True\t     \t\t\t\n\t     \t\tCase Else\n\t     \t\t&#039; There are more cases that we shouldn&#039;t really see\n\t     \t\t\tstrAccountType = objSession.LogonType\n\t     \tEnd Select\n\t     \t\n \t\t\tFor Each strProcessOwner In dictProcessOwners.Keys\n\t      \t\tIf bDisplay And InStr(LCase(objItem.Caption),LCase(Split(strProcessOwner,&quot;\\&quot;)(0))) &gt; 0 And InStr(LCase(objItem.Caption),LCase(Split(strProcessOwner,&quot;\\&quot;)(1))) &gt; 0 Then\n\t\t       \t\tWScript.Echo GetUserForSIDLocal(objReg,objItem.SID) &amp; strSep &amp; strAccountType\n\t\t       \t\tExit For\n\t\t       \tEnd If\n\t\t   bDisplay = False\n\t\t   Next\n\t     \t\n\t     Next\n\t  Next\n\tEnd If\n\t\t     \t\nEnd Function &#039;ListCachedAccounts\n\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t&#039; find last backslash\n\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t&#039; get right from that pos\n\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\tGetUserForSIDLocal = strUserData\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "User", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Type", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 387, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Will output \"Windows Server\" or \"Windows Workstation\" depending on the OS type.\nExample: Windows Server", 
      "exclude_from_parse_flag": 1, 
      "hash": 74624344, 
      "hidden_flag": 0, 
      "id": 771, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 3600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Windows OS Type", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Windows OS Type\n&#039;========================================\n\nOption Explicit\n\nSelect Case (LCase(GetProductType))\n\t&#039; Workstations will always output WinNT\n\tCase &quot;winnt&quot;\n\t\tWScript.Echo &quot;Windows Workstation&quot;\n\tCase &quot;servernt&quot;\n\t\tWScript.Echo &quot;Windows Server&quot;\n\tCase &quot;lanmannt&quot;\n\t\tWScript.Echo &quot;Windows Server&quot;\t\t\n\tCase Else\n\t\tWScript.Echo &quot;Error: Cannot determine OS type&quot;\nEnd Select\n\t\nFunction GetProductType\n\n\tDim objShell\n\tDim keyPath, strPath, strFoundPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyPath = &quot;SYSTEM\\CurrentControlSet\\Control\\ProductOptions&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyPath&amp;&quot;\\ProductType&quot;)\n    On Error Goto 0\n\tstrFoundPath = strPath\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tGetProductType = strFoundPath\n  \tElse\n  \t\tGetProductType = False\n  \t\tWScript.Echo &quot;Error: Cannot determine OS type&quot;\n  \t\tWScript.Quit\n  \tEnd If\nEnd Function &#039;GetProductType", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\necho Non-Windows\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\necho Non-Windows\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 388, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the number of used slots in the system on Windows client machines.\nExample: 1", 
      "exclude_from_parse_flag": 1, 
      "hash": 747106243, 
      "hidden_flag": 0, 
      "id": 773, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "System Slots In Use", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; System Slots in Use\n&#039;========================================\n\n&#039; This sensor will return the number of slots in use\n\nOption Explicit\n\nWScript.Echo GetSystemSlotsInUse\n\nFunction GetSystemSlotsInUse\n\t\n\tDim objWMIService, colSystemSlots\n\tDim strComputer, objSystemSlots\n\n\tstrComputer = &quot;.&quot;\n\tSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n\t\t&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;) \n\n\t&#039;SlotDesignation is like &quot;PCI-I&quot; and CurrentUsage=4 means occupied\n\tSet colSystemSlots = objWMIService.ExecQuery _ \n\t\t(&quot;Select SlotDesignation from Win32_SystemSlot where CurrentUsage=4&quot;) \n\tIf Not IsNull(colSystemSlots) Then\n\t\tGetSystemSlotsInUse = colSystemSlots.Count\n\tElse\n\t\tGetSystemSlotsInUse = &quot;WMI Error&quot;\n\tEnd If\n\t\n\t&#039;Cleanup\n\tSet colSystemSlots = Nothing\n\tSet objWMIService = Nothing\nEnd Function &#039;GetSystemSlotsInUse", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "NumericInteger"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 389, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the size of the maximum amount of RAM a machine can carry.\nExample: 8 GB", 
      "exclude_from_parse_flag": 1, 
      "hash": 782305667, 
      "hidden_flag": 0, 
      "id": 775, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "RAM Max Capacity", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; RAM Max Capacity\n&#039;========================================\n\n&#039; This sensor will pull the maximum amount of RAM a machine can carry via WMI\n\nOption Explicit\nDim objWMIService, colItems, objItem\nDim strWMIQuery, strItem, strComputer, cap\n\nIf Left(GetOSMajorVersion(), 1) = &quot;5&quot; Then \n\t&#039; This function does not work on Windows XP or 2003, return Not Available\n\tWScript.Echo &quot;Not Available&quot;\n\tWScript.Quit\nEnd If\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t&amp; &quot;{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\n\n&#039; 3 is system memory (not video or flash mem)\nstrWMIQuery = &quot;Select MaxCapacity from Win32_PhysicalMemoryArray where Use=&#039;3&#039;&quot;\n\nSet colItems = objWMIService.ExecQuery(strWMIQuery)\ncap = 0\nFor Each objItem In colItems\n\tcap = CDbl(objItem.MaxCapacity)\n\tIf cap &gt; 0 Then\n\t\tWScript.Echo PrettyFileSize(cap * 1024)\n\tElse\n\t\tWScript.Echo &quot;Error / Unknown&quot;\n\tEnd If\nNext\n\nFunction PrettyFileSize(strBytes)\n\n\tDim size,intKB,intMB,intGB\n\t\n\tIf IsNumeric(strBytes) Then\n\t\tsize = CDbl(strBytes)\n\t\t\n\t\tintKB = 1024\n\t\tintMB = 1024*1024\n\t\tintGB = 1024*1024*1024\n\t\n\t\tIf size &gt; intGB Then\n\t\t\tPrettyFileSize = Int(size / intGB) &amp; &quot; GB&quot;\n\t\tElseIf size &gt; intMB Then\n\t\t\tPrettyFileSize = Int(size / intMB) &amp; &quot; MB&quot;\n\t\tElseIf size &gt; intKB Then\n\t\t\tPrettyFileSize = Int(size / intKB) &amp; &quot; KB&quot;\n\t\tElse\n\t\t\tPrettyFileSize = size &amp; &quot; B&quot;\n\t\tEnd If\n\tElse\n\t\tPrettyFileSize = &quot;Error / Unknown&quot;\n\tEnd If\n\nEnd Function &#039;PrettyFileSize\n\nFunction GetOSMajorVersion\n&#039; Returns the OS Major Version\n&#039; A different way to examine the OS instead of by name\n\n\tDim objWMIService,colItems,objItem\n\tDim strVersion\n\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    \n\tFor Each objItem In colItems\n\t\tstrVersion = objItem.Version &#039; like 6.2.9200\n\t\tstrVersion = Left(strVersion,Len(strVersion) - 5)\n\tNext\n\t\n\tGetOSMajorVersion = strVersion\n\t\nEnd Function &#039;GetOSMajorVersion", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "DataSize"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 390, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Indicates whether the machine's harddrive requires defragmentation\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 801419063, 
      "hidden_flag": 0, 
      "id": 777, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Defrag Needed", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Defrag Needed\n&#039;========================================\n\n&#039; will output whether a machine needs a defrag for a particular volume\n&#039; and some statistics about the volume.\n&#039; A defrag has no meaning to an SSD, but there is no way to link\n&#039; a volume object property to a disk_drive property\n&#039; Not cleanly, anyway.  Perhaps in Windows 8 :)\nOption Explicit\n\nDim strComputer: strComputer = &quot;.&quot;\nDim strSep: strSep = &quot;|&quot;\n\nDim bRecommended, errResult\nDim objWMIService, colVolumes, objVolume, objReport\n\n&#039; output looks like: Defrag Recommended|DriveLetter|Volume Size|% Fragmented\n\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _\n\t&amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colVolumes = objWMIService.ExecQuery(&quot;Select * from Win32_Volume&quot;)\n\nFor Each objVolume In colVolumes\n\terrResult = objVolume.DefragAnalysis(bRecommended, objReport)\n\t\tIf bRecommended = True Then\n\t\t\tWScript.Echo &quot;Yes&quot; &amp; strSep &amp; objVolume.DriveLetter &amp; _\n\t\t\t\tstrSep &amp; objReport.VolumeSize &amp; strSep &amp; _\n\t\t\t\tobjReport.TotalPercentFragmentation\n\t\tEnd If\n\t\tIf bRecommended = False Then\n\t\t\t&#039; Do nothing.  If you echo No, you get multiple results for each machine.\n\t\tEnd If\nNext\n\n&#039; cleanup\nSet objWMIService = Nothing\nSet colVolumes = Nothing\nSet objVolume = Nothing\nSet objReport = Nothing", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Recommended", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Drive Letter", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Volume Size", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "% Fragmented", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 391, 
      "category": "User", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns a list of local users to the Windows machine and the user's full name.\nExample:johndoe|John Doe", 
      "exclude_from_parse_flag": 1, 
      "hash": 801908140, 
      "hidden_flag": 0, 
      "id": 779, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "User Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;=================================\n&#039; User Details\n&#039; Don&#039;t try this on a domain controller because all domain users are local users on a DC!\n&#039;=================================\n\nsComputer = &quot;.&quot;\nFunction DomainRole(sNode)\n\tSet oWMI = GetObject(&quot;winmgmts:&quot; &amp; &quot;{impersonationLevel=impersonate}!\\\\&quot; &amp; sNode &amp; &quot;\\root\\cimv2&quot;)\n\tSet colComputer = oWMI.ExecQuery(&quot;Select DomainRole from Win32_ComputerSystem&quot;)\n\tFor Each oComputer in colComputer\n\t\tiDR = oComputer.DomainRole\n\tNext\n\tSelect Case iDR\n\tCase 0\n\t\t&#039; standalone workstation\n\t\tDomainRole = &quot;SW&quot;\n\tCase 1\n\t\t&#039; member workstation\n\t\tDomainRole = &quot;MW&quot;\n\tCase 2\n\t\t&#039; standalone server\n\t\tDomainRole = &quot;SS&quot;\n\tCase 3\n\t\t&#039; member server\n\t\tDomainRole = &quot;MS&quot;\n\tCase 4\n\t\t&#039; backup domain controller\n\t\tDomainRole = &quot;BDC&quot;\n\tCase 5\n\t\t&#039; primary domain controller\n\t\tDomainRole = &quot;PDC&quot;\n\tCase Else\n\t\t&#039;; unknown\n\t\tDomainRole = &quot;UNK&quot;\n\tEnd Select\nEnd Function\n\t\nIf DomainRole(sComputer) = &quot;PDC&quot; Or DomainRole(sComputer) = &quot;BDC&quot; Then\n\tWScript.Echo &quot;Domain Controller, Can&#039;t Enumerate users&quot;\nElse\n\tSet objNetwork = CreateObject(&quot;Wscript.Network&quot;)\n\tstrComputer = objNetwork.ComputerName\n\tSet colAccounts = GetObject(&quot;WinNT://&quot; &amp; strComputer &amp; &quot;&quot;)\n\tcolAccounts.Filter = Array(&quot;user&quot;)\n\tFor Each objUser In colAccounts\n\t    \tstrFullName = objUser.FullName\n    \t\tIf strFullName = &quot;&quot; Then\n    \t\t\tstrFullName = objUser.Name\n    \t\tEnd If\n    \t\tWScript.Echo objUser.Name &amp; &quot;|&quot; &amp; strFullName\n\tNext\nEnd If", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\nawk -F: &#039;{print $1&quot;|&quot;$5}&#039; /etc/passwd\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\nawk -F: &#039;{print $1&quot;|&quot;$5}&#039; /etc/passwd\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 146, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "User Account", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Full Name", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 392, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The version number of the video driver on the client machine.\nExample: 6.1.7600.16385", 
      "exclude_from_parse_flag": 1, 
      "hash": 8168018, 
      "hidden_flag": 0, 
      "id": 781, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Video Driver Version", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select DriverVersion from win32_VideoController", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Version"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 393, 
      "category": "Office", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns details of PST files that have been mounted by users on a system.\nExample: c:\\psts\\huge.pst 4088 MB", 
      "exclude_from_parse_flag": 1, 
      "hash": 856087598, 
      "hidden_flag": 0, 
      "id": 783, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "PST Information", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; PST Information\n&#039;========================================\n\n&#039; This sensor will return data about attached PST files in all profiles.\n&#039; This sensor should run in either 32-bit or 64-bit mode without issue\n&#039; And will work properly when run in system context of course.\n&#039; Times returned are local to the client.\n\nOption Explicit\n &#039;On Error Resume Next \n Const HKEY_CURRENT_USER = &amp;H80000001 \n Const HKEY_USERS = &amp;H80000003\n Const r_PSTGuidLocation = &quot;01023d00&quot; \n Const r_MasterConfig = &quot;01023d0e&quot; \n Const r_PSTCheckFile = &quot;00033009&quot; \n Const r_PSTFile = &quot;001f6700&quot; \n Const r_keyMaster = &quot;9207f3e0a3b11019908b08002b2a56c2&quot; \n Const r_ProfilesRoot = &quot;Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles&quot; \n Const r_DefaultOutlookProfile = &quot;Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows Messaging Subsystem\\Profiles&quot; \n Const r_DefaultProfileString = &quot;DefaultProfile&quot; \n Dim oReg        :Set oReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)   \n Dim arrSubKeys, subkey, strValue, i, pstFile, arrPSTs, DefaultProfileName, arrUserKeys, strUserKey\n Dim profileName\n Dim strSep: strSep = &quot;|&quot; &#039; This is a multi-column sensor\n\n&#039; This sensor uses dates and should have locale set\nSetLocale(GetTaniumLocale) &#039; Default is US/English\n\n\n&#039; first get all users from HKEY_USERS\noReg.EnumKey HKEY_USERS,&quot;&quot;,arrUserKeys\n\n&#039;And loop through those SIDs\nFor Each strUserKey In arrUserKeys\n\t&#039; WScript.Echo userKey &amp; &quot; is current user SID key&quot;\n\t&#039; return the keys under HKEY_USERS\n\t&#039; WScript.Echo &quot;We&#039;re in &quot; &amp; strUserKey\n\toReg.EnumKey HKEY_USERS,strUserKey &amp; &quot;\\&quot; &amp; r_ProfilesRoot,arrSubKeys\n\t&#039; and loop through those looking for outlook profiles\n\t&#039; there may be multiple profiles per user.\n\tIf Not IsNull(arrSubKeys) Then\n\t\tFor Each profileName In arrSubKeys\n\t\t\t&#039;WScript.Echo profileName &amp; &quot; Is profilename&quot;\n\t\t\t&#039;WScript.Echo &quot;We&#039;re going to try to get PSTs for this profile: &quot; &amp; strUserKey &amp; &quot;\\&quot; &amp; r_ProfilesRoot &amp; &quot;\\&quot; &amp; profileName\n\t\t\tShowPSTsForProfile strUserKey &amp; &quot;\\&quot; &amp; r_ProfilesRoot, profileName\n\t\tNext &#039; end inner loop\n\tEnd If\nNext &#039; end outer loop\n\n&#039;&#039; End Main Line\n\n\n &#039;_____________________________________________________________________________________________________________________________ \n Function ShowPSTsForProfile(profilePath, p_profileName)\n Dim strHexNumber, strPSTGuid\n Dim HexCount    :HexCount = 0\n Dim strPSTFile, arrBinValue \n\n &#039; WScript.Echo &quot;ProfilePath is &quot; &amp; profilePath\n &#039; WScript.Echo &quot;And we&#039;re fetching &quot; &amp; profilePath &amp; &quot;\\&quot; &amp; p_profileName &amp; &quot;\\&quot; &amp; r_keyMaster &amp; &quot;-&quot; &amp; r_MasterConfig\n oReg.GetBinaryValue HKEY_USERS,profilePath &amp; &quot;\\&quot; &amp; p_profileName &amp; &quot;\\&quot; &amp; r_keyMaster,r_MasterConfig,arrBinValue\n\n     For i = lBound(arrBinValue) to uBound(arrBinValue)     \n             If Len(Hex(arrBinValue(i))) = 1 Then  \n                 strHexNumber = &quot;0&quot; &amp; Hex(arrBinValue(i)) \n             Else \n                 strHexNumber = Hex(arrBinValue(i)) \n             End If         \n         strPSTGuid = strPSTGuid + strHexNumber \n         HexCount = HexCount + 1 \n             If HexCount = 16 Then  \n                     If IsAPST(profilePath &amp; &quot;\\&quot; &amp; p_profileName &amp; &quot;\\&quot; &amp; strPSTGuid) Then \n                         &#039; WScript.Echo &quot;It is a PST!!&quot; &amp; profilePath &amp; &quot;\\&quot; &amp; p_profileName &amp; &quot;\\&quot; &amp; strPSTGuid\n                         strPSTFile = PSTFileName(profilePath &amp; &quot;\\&quot; &amp; p_profileName &amp; &quot;\\&quot; &amp; PSTlocation(profilePath &amp; &quot;\\&quot; &amp; p_profileName &amp; &quot;\\&quot; &amp; strPSTGuid))\n                         WScript.Echo GetFileInfo (strPSTFile, strSep)                         \n                     End If     \n                 HexCount = 0 \n                 strPSTGuid = &quot;&quot; \n             End If             \n     Next\n End Function \n &#039;_____________________________________________________________________________________________________________________________ \n Function IsAPST(p_PSTGuid) \n Dim x, P_PSTGuidValue \n Dim P_PSTCheck:P_PSTCheck=0 \n IsAPST=False \n oReg.GetBinaryValue HKEY_USERS,p_PSTGuid,r_PSTCheckFile,P_PSTGuidValue \n     For x = lBound(P_PSTGuidValue) to uBound(P_PSTGuidValue)     \n         P_PSTCheck = P_PSTCheck + Hex(P_PSTGuidValue(x)) \n     Next     \n     If P_PSTCheck=20 Then \n         IsAPST=True \n     End If     \n End Function  \n &#039;_____________________________________________________________________________________________________________________________ \n Function PSTlocation(p_PSTGuid) \n Dim y, P_PSTGuidValue, t_strHexNumber \n oReg.GetBinaryValue HKEY_USERS,p_PSTGuid,r_PSTGuidLocation,P_PSTGuidValue\n \tIf Not IsNull(P_PSTGuidValue) Then \n     For y = lBound(P_PSTGuidValue) to uBound(P_PSTGuidValue)     \n         If Len(Hex(P_PSTGuidValue(y))) = 1 Then \n             PSTlocation = PSTlocation + &quot;0&quot; &amp; Hex(P_PSTGuidValue(y)) \n         Else \n             PSTlocation = PSTlocation + Hex(P_PSTGuidValue(y))     \n         End If     \n     Next\n   End If     \n End Function  \n &#039;_____________________________________________________________________________________________________________________________ \n Function PSTFileName(p_PSTGuid) \n Dim z, P_PSTName \n Dim strString:strString = &quot;&quot; \n &#039; WScript.Echo &quot;In PSTFileName, p_PSTGUID is : &quot; &amp; p_PSTGuid\n oReg.GetBinaryValue HKEY_USERS,p_PSTGuid,r_PSTFile,P_PSTName \n     For z = lBound(P_PSTName) to uBound(P_PSTName)     \n         If P_PSTName(z) &gt; 0 Then \n             strString = strString &amp; Chr(P_PSTName(z)) \n         End If     \n     Next     \n     PSTFileName = strString \n Set z = nothing \n Set P_PSTName = nothing \n End Function  \n &#039;_________________________________________________________________________________________________________ \n Function GetFileInfo(strFilePath, strSep)\n &#039; This will return the file name\n &#039; The file size\n  \n  \n \tDim objFSO\n \tDim file\n \n \tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n \tSet file = objFSO.GetFile(strFilePath)\n \t&#039; let&#039;s just return a separated string with all kinds of information in it\n \t&#039;GetFileInfo = strFilePath &amp; strSep &amp; file.DateCreated &amp; strSep &amp; _ \n \t&#039;\tfile.DateLastAccessed &amp; strSep &amp; file.DateLastModified _\n \t&#039;\t&amp; strSep &amp; file.Size &amp; &quot; bytes&quot;\n \n  \tGetFileInfo = strFilePath &amp; strSep &amp; BytesConvert(file.Size)\n \t\n \t&#039;cleanup\n \tSet file = Nothing\n \tSet objFSO = Nothing\n \t\n End Function &#039;GetFileInfo\n \nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale\n\nFunction BytesConvert(dblSize)\n\n\tDim strSuffix, intCommaSpot\n\t\n\tDo While InStr(dblSize,&quot;,&quot;) &#039;Remove commas from dblSize \n\t    intCommaSpot = InStr(dblSize,&quot;,&quot;) \n\t    dblSize = Mid(dblSize,1,intCommaSpot - 1) &amp; _ \n\t        Mid(dblSize,intCommaSpot + 1,Len(dblSize) - intCommaSpot) \n\tLoop\n\t\n\tOn Error Resume Next\n\tdblSize = CDbl(dblSize)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tBytesConvert = &quot;Invalid input&quot;\n\t\tExit Function\n\tEnd If\n\tOn Error Goto 0\n\n\tstrSuffix = &quot; Bytes&quot; \n\tIf dblSize &gt;= 1024 Then strSuffix = &quot; KB&quot; \n\tIf dblSize &gt;= 1048576 Then strSuffix = &quot; MB&quot; \n\tIf dblSize &gt;= 1073741824 Then strSuffix = &quot; GB&quot; \n\tIf dblSize &gt;= 1099511627776 Then strSuffix = &quot; TB&quot; \n\t\n\tSelect Case strSuffix \n\t    Case &quot; KB&quot; dblSize = Round(dblSize / 1024, 1) \n\t    Case &quot; MB&quot; dblSize = Round(dblSize / 1048576, 1) \n\t    Case &quot; GB&quot; dblSize = Round(dblSize / 1073741824, 1) \n\t    Case &quot; TB&quot; dblSize = Round(dblSize / 1099511627776, 1) \n\tEnd Select\n\t\n\tBytesConvert = dblSize &amp; strSuffix \nEnd Function &#039;BytesConvert", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "File", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Size", 
            "value_type": "DataSize"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 394, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Details on any shared printers available from the client machine.  Details include printer name, print server, and share name.\nExample: \\\\PRINTSERVER1\\PRINTER2 | netserver | \\\\PRINTSERVER1\\PRINTER2", 
      "exclude_from_parse_flag": 1, 
      "hash": 861367460, 
      "hidden_flag": 0, 
      "id": 785, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Shared Network Printer Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Shared Network Printer Details\n&#039;========================================\n\n&#039; This is a multi-column sensor that returns details on\n&#039; printers that are served by a print server.\n&#039; The columns look like:\n&#039; Printer|Server|Share Name\n\nstrSep = &quot;|&quot;\n \nstrComputer =&quot;.&quot;\n\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\CIMV2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Printer&quot;)\n\nFor Each objItem In colItems\n\tIf (objitem.Servername &lt;&gt; &quot;&quot;) Then\n\t\tWScript.Echo objItem.name &amp; strSep &amp; objitem.ServerName _\n\t\t&amp; strSep &amp; objitem.ShareName\n\tEnd If\nNext\n\nSet objWMIService = Nothing\nSet colItems = Nothing", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Printer", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Server", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Share Name", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 395, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns loaded kernel modules on Linux systems.\nExample:dcdbas", 
      "exclude_from_parse_flag": 1, 
      "hash": 865123401, 
      "hidden_flag": 0, 
      "id": 787, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Kernel Modules", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "WScript.Echo &quot;Not a Windows Sensor&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ncat /proc/modules | while read line\ndo\n        set -- $line\n\techo $1\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 396, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Indicates whether hyperthreading is enabled on the client machine.  This is not supported on all OS patch levels.\nExample: Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 867160258, 
      "hidden_flag": 0, 
      "id": 789, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Hyperthreading Enabled", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Hyperthreading Enabled\n&#039;========================================\n\n&#039; checking if the number of logical processors is greater than\n&#039; the number of cores on each physical, socketed processor.\nOn Error Resume Next\n\nSet objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;SELECT * FROM Win32_Processor&quot;) \nintNumCores = 0\n\nFor Each objItem in colItems\n\tintNumCores = intNumCores + CInt(objItem.NumberOfCores)\n\t&#039;decide whether to continue for unsupported OS patch levels\n\tIf intNumCores = 0 Then &#039; machine does not support counting cores\n\t\tstrOs = GetOS\n\t\t&#039;Windows 2000 isn&#039;t supported for core count, can&#039;t determine hyperthreading\n\t\tIf InStr(strOs, &quot;2000&quot;) &gt; 0 Then\n\t\t\tWScript.Echo &quot;Windows 2000 - Cannot determine&quot;\n\t\tElseIf InStr(strOs, &quot;XP&quot;) &gt; 0 Then\n\t\t\tWScript.Echo &quot;XP SP3 Required to determine&quot;\n\t\tElseIf InStr(strOs, &quot;2003&quot;) &gt; 0 Then\n\t\t\t&#039;For Win Server 2003 SEE KB 932370\n\t\t\t&#039;http://support.microsoft.com/kb/932370/\n\t\t\tWScript.Echo &quot;KB932370 Required to determine&quot;\n\t\tElse\n\t\t\tWScript.Echo &quot;N/A&quot;\n\t\tEnd If\n\tElseIf intNumCores &lt; objItem.NumberOfLogicalProcessors Then\n\t\tWScript.Echo &quot;Yes&quot;\n\tElseIf intNumCores = objItem.NumberOfLogicalProcessors Then\n\t\tWScript.Echo &quot;No&quot;\n\tElse\n\t\tWScript.Echo &quot;Unsure&quot;\n\tEnd If\n\tWScript.Quit &#039;if reported once, it will be the same value across all CPUs\nNext\n\nFunction GetOS\n\tSet oWsh = WScript.CreateObject(&quot;WScript.Shell&quot;)    \n\tSet oWshSysEnv = oWsh.Environment(&quot;PROCESS&quot;)    \n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)    \n\tSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Caption from win32_operatingsystem&quot;)    \n\tFor Each objItem In colItems       \n\tstrStrip1 = Right(ObjItem.Caption, (Len(objItem.Caption) - Instr(objItem.Caption, &quot; &quot;)))   \n\t&#039;strStrip2 = Right(strStrip1, (Len(strStrip1) - Instr(strStrip1, &quot; &quot;)))   \n\tif Instr(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;)) &lt;&gt; 0 THEN   \n\tstrOS = Replace(strStrip1,&quot;Server&quot; &amp; Unescape(&quot;%AE&quot;),&quot;Server&quot;)   \n\tElse   \n\tstrOS = strStrip1\n\tEnd IF   \n\tGetOS = Trim(strOS)\n\tNext\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 397, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns the connected network printers.\nExample: printer_name | driver | port", 
      "exclude_from_parse_flag": 1, 
      "hash": 876725971, 
      "hidden_flag": 0, 
      "id": 791, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Network Printer Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Network Printer Details\n&#039;========================================\n\nOn Error Resume Next\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\cimv2&quot;)\nSet colItems = objWMIService.ExecQuery(&quot;Select PortName,Caption,DriverName from Win32_Printer&quot;,,48)\n\nstrSep = &quot;|&quot;\n\nFor Each objItem in colItems\n\tIf InStr(objItem.PortName, &quot;.&quot;) Then\n\t\n\t\tWScript.Echo objItem.Caption &amp; strSep &amp; _\n\t\t\tobjItem.DriverName &amp; strSep &amp; _\n\t\t\tobjItem.PortName\n\tEnd If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Printer", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Driver", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Port", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 398, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the Motherboard Manufacturer of a system.\nExample:Lenovo", 
      "exclude_from_parse_flag": 1, 
      "hash": 885259283, 
      "hidden_flag": 0, 
      "id": 793, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Motherboard Manufacturer", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Motherboard Manufacturer\n&#039;========================================\n\nSet objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2&quot;)\nSet colMB = objWMIService.ExecQuery(&quot;Select * from Win32_BaseBoard&quot;)\nFor Each mb In colMB\nmbManufacturer = mb.Manufacturer\nWScript.Echo mbManufacturer\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode -s baseboard-manufacturer\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\necho Apple\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 399, 
      "category": "McAfee", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Returns the Product Code of a McAfee Endpoint Encryption install\nExample: Enterprise", 
      "exclude_from_parse_flag": 1, 
      "hash": 892119042, 
      "hidden_flag": 0, 
      "id": 795, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "McAfee Endpoint Encryption Product Code", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; McAfee Endpoint Encryption Product Code\n&#039;========================================\n\n&#039; This sensor will return the Product Code of a\n&#039; McAfee Endpoint Encryption install\n&#039; This is a string value such as &quot;Enterprise&quot;\n\nOption Explicit\n\nDim objRegistry,keyPath,key64Path,strSep\nstrSep = &quot;|&quot; &#039; column delimiter\n\nSet objRegistry = Getx64RegistryProvider()\n\nConst HKLM = &amp;H80000002\n\nkeyPath = &quot;SOFTWARE\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\nkey64Path = &quot;SOFTWARE\\Wow6432Node\\McAfee Endpoint Encryption\\MfeEpePC\\Status&quot;\n\nIf Not RegKeyExists(HKLM, keyPath) Then\n\tkeyPath = key64Path\n\n\tIf Not RegKeyExists(HKLM, keyPath) Then\n\t\tWScript.Echo &quot;Not installed&quot;\n\t\tWScript.Quit\n\tEnd If\nEnd If\n\nIf RegKeyExists(HKLM, keyPath) Then\n\tDim strReturn\n\tstrReturn = ReturnStringValueOrEchoError _\n\t\t(objRegistry,HKLM,keyPath,&quot;ProductCode&quot;,&quot;McAfee Endpoint Encryption Product Code Not Found&quot;)\n\tIf VarType(strReturn) = 8 Then &#039;string value 8 indicates success, integer is error\n\t\tWScript.Echo strReturn\n\tElse\n\t\tWScript.Quit\n\tEnd If\nElse\n\tWScript.Echo &quot;McAfee Endpoint Encryption Not Found&quot;\n\tWScript.Quit\nEnd If\n\nFunction RegKeyExists(sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction ReturnStringValueOrEchoError(objRegistry,HIVE,strKeyName,strValueName,strErrorMessage)\n&#039; Return a value or fatal error message and error result\n\tDim intReturn,strValueData\n\tintReturn = objRegistry.GetStringValue(HIVE, strKeyname, strValueName, strValueData)\n\tIf intReturn = 0 Then\n\t\tReturnStringValueOrEchoError = strValueData\n\tElse\n\t\tReturnStringValueOrEchoError = -1\n\t\tWScript.Echo strErrorMessage\n\tEnd If\nEnd Function \n\nFunction Getx64RegistryProvider\n    &#039; Returns the best available registry provider:  32 bit on 32 bit systems, 64 bit on 64 bit systems\n    Dim objWMIService, colItems, objItem, iArchType, objCtx, objLocator, objServices, objRegProv\n    Set objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n    Set colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n    For Each objItem In colItems\n        If InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n            iArchType = 64\n        Else\n            iArchType = 32\n        End If\n    Next\n    \n    Set objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n    objCtx.Add &quot;__ProviderArchitecture&quot;, iArchType\n    Set objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n    Set objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n    Set objRegProv = objServices.Get(&quot;StdRegProv&quot;)   \n    \n    Set Getx64RegistryProvider = objRegProv\nEnd Function &#039; Getx64RegistryProvider", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 400, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Shows the currently specified country code used by the operating system.\nExample: 1    (United States)", 
      "exclude_from_parse_flag": 1, 
      "hash": 902205018, 
      "hidden_flag": 0, 
      "id": 797, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Country Code", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select CountryCode from win32_operatingsystem", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 401, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Whether data execution prevention is enabled for 32-bit machines.  If disabled, code can be executed from a non-executable memory region.\nExample: TRUE, FALSE", 
      "exclude_from_parse_flag": 1, 
      "hash": 916410332, 
      "hidden_flag": 0, 
      "id": 799, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Data Execution Prevention Enabled", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Data Execution Prevention Enabled\n&#039;========================================\n\nstrComputer = &quot;.&quot; \nSet objWMIService = GetObject(&quot;winmgmts:\\\\&quot; &amp; strComputer &amp; &quot;\\root\\CIMV2&quot;) \nSet colItems = objWMIService.ExecQuery( _\n    &quot;SELECT * FROM Win32_OperatingSystem&quot;,,48) \nFor Each objItem in colItems \n    If objItem.DataExecutionPrevention_32BitApplications Then\n        Wscript.Echo &quot;True&quot;\n    Else\n        Wscript.Echo &quot;False&quot;\n    End If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 402, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Name of any installed CD-ROM or DVD-ROM drives.\nExample: SONY DVD-ROM DDU1615 ATA Device", 
      "exclude_from_parse_flag": 1, 
      "hash": 923740265, 
      "hidden_flag": 0, 
      "id": 801, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "CD-ROM Drive", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from win32_CDROMDRIVE", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\nLINUX=`uname -o | grep -c -i linux`\n\nif [ $LINUX -eq 1 ]\nthen\nlshal | grep -i info.product | grep CD | sed &#039;s/info.product = &#039;\\&#039;&#039;\\(.*\\)&#039;\\&#039;&#039;.*/\\1/g&#039;\nfi\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 403, 
      "category": "Applications", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Gets a list of all Services on the client machine.\nExample: Task Scheduler", 
      "exclude_from_parse_flag": 1, 
      "hash": 926119908, 
      "hidden_flag": 0, 
      "id": 803, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Service", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Caption from win32_Service", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\nchkconfig --list | while read line\ndo\n        set -- $line\n\techo $1\ndone\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nfirst=true\nlaunchctl list | while read line\ndo\n    set -- $line\nif ( $first ); \nthen\n\tfirst=false\nelse\n\techo $3\nfi\ndone\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 404, 
      "category": "Tanium", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Provided with a parameter indicating the path to a file in the Tanium current directory, returns True or False based on whether that file exists in the specified location.\nExample: True", 
      "exclude_from_parse_flag": 1, 
      "hash": 95001259, 
      "hidden_flag": 0, 
      "id": 805, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium File Exists", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Starting from the Client installation directory, complete the file path to get contents for.\",\"value\":\"\",\"promptText\":\"e.g. uninst.exe or Tools\\\\Wsusscn2.cab\",\"defaultValue\":\"\",\"label\":\"Relative file path from <Tanium Client Installation Dir>\",\"maxChars\":0,\"key\":\"file\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium File Exists\n&#039;========================================\n\nfilePath = unescape(&quot;||file||&quot;)\nstrTaniumDir = GetTaniumDir(&quot;&quot;)\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nfilePath = strTaniumDir &amp; filePath\n\nIf fso.FileExists(filePath) Then \n\t&#039;WScript.Echo filePath\n\tWScript.Echo &quot;True&quot;\nElse \n\tWScript.Echo &quot;File does not exist&quot;\nEnd If\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;e.g. uninst.exe or Tools\\Wsusscn2.cab&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||file||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;file&quot;,&quot;promptText&quot;:&quot;e.g. uninst.exe or Tools\\Wsusscn2.cab&quot;,&quot;label&quot;:&quot;Relative file path from &lt;Tanium Client Installation Dir&gt;&quot;,&quot;helpString&quot;:&quot;Starting from the Client installation directory, complete the file path to get contents for.&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:0,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||file||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 405, 
      "category": "Hardware", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Description of the video card in the client machine.\nExample: ATI Radeon HD 2400 Pro", 
      "exclude_from_parse_flag": 1, 
      "hash": 953427826, 
      "hidden_flag": 0, 
      "id": 807, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 86400, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Video/Graphics Card", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "select Name from Win32_VideoController", 
            "script_type": "WMIQuery"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\ndmidecode | grep -A2 &quot;Type: Video&quot; | awk -F&quot;: &quot; &#039;$1 ~ &quot;Description&quot; {print $2}&#039;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\nvideo=$(system_profiler SPDisplaysDataType | grep Chipset | awk -F&#039;: &#039; &#039;{print $2}&#039;)\nif [ &quot;&quot; = &quot;$video&quot; ]\nthen\n\techo &quot;Unknown&quot;\nelse\n\techo &quot;$video&quot;\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 406, 
      "category": "Patch", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Sensor which looks at the patch results file to determine how many security patches are necessary and if that number is above a threshold value (default 20).  Can be edited to determine what severity counts as a security patch.  Threshold can also be adjusted.\nExample:Yes", 
      "exclude_from_parse_flag": 1, 
      "hash": 956515908, 
      "hidden_flag": 0, 
      "id": 809, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Security Patches Needed Above Threshold", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Security Patches Needed Above Threshold\n&#039;========================================\n\n&#039; sensor - security patches needed above threshold\n&#039; This sensor will Yes or No if the count of security updates needed\n&#039; is above a threshold value.\n\n\nOption Explicit\n\nDim strHighestSeverityThatCounts\n&#039; This sensor is modifiable\n&#039; customers can decide how to flag an update as countable in this sensor\n&#039; by default, we include all available patches\n\n&#039; This string value will determine what we count.  The valid values here are:\n&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS\n\nstrHighestSeverityThatCounts = &quot;ALL&quot;\n\nDim objFSO, fn, objReadFile, contents, path, strSep, hasOutput, intCriticalThreshold\nDim intTotalThreshold\nstrSep = &quot;|&quot;\nintCriticalThreshold = 5\nintTotalThreshold = 20\n\nDim showSingleStatus\nshowSingleStatus = True\n\npath = GetTaniumDir(&quot;Tools\\Scans&quot;)\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nfn = path &amp; &quot;\\patchresultsreadable.txt&quot;\n\nIf objFSO.FileExists(fn) Then\n\tSet objReadFile = objFSO.OpenTextFile(fn, 1, False)\n\n\tDim strLine, words, strFilename, strPatchDir, arrFilenames, isComplete\n\t\n\thasOutput = False\n\n\t&#039;note: intNone refers to patches with severity=none\n\tDim intCritical, intImportant, intModerate, intLow, intNone, intSecurityBulletin\n\t\n\tintCritical = 0\n\tintImportant = 0\n\tintModerate = 0\n\tintLow = 0\t\n\tintNone = 0\n\tintSecurityBulletin = 0\n\t\n\tDo While Not objReadFile.AtEndOfStream\n\t\tstrLine = objReadFile.ReadLine\n\n\t\t&#039;CHECK FOR MULTI-URL PATCHES\n\t\twords = Split(strLine, strSep)\n\t\t\n\t\t&#039;Ignore old Patch Results format without separator\n\t\tIf UBound(words) &lt; 4 Then \n\t\t\tIf left(words(0), 4) = &quot;Scan&quot; Then\n\t\t\t\thasOutput = True\n\t\t\t\t&#039;WScript.Echo words(0)\n\t\t\tElse \n\t\t\t\t&#039;WScript.Echo &quot;Run upgraded Patch Scan&quot;\n\t\t\t\tWScript.Quit\n\t\t\tEnd If\t\n\t\tElse\n\t\t\tarrFilenames = Split(words(5), &quot;,&quot;)\n\t\t\t&#039;patch filename must be in Tools\\Patch directory for queue\n\t\t\tDim fso\n\t\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\t\t\n\t\t\tstrPatchDir = GetTaniumDir(&quot;Tools\\Patches&quot;)\n\t\t\t\n\t\t\tisComplete = True\n\t\t\tFor Each strFilename In arrFilenames\n\t\t\t\tIf Not fso.FileExists(strPatchDir &amp; &quot;\\&quot; &amp; strFilename) Then\n\t\t\t\t\tisComplete = False\n\t\t\t\tEnd If\t\t\t\n\t\t\tNext\n\n\n&#039; A previously defined string value will determine what we count.  \n&#039; The valid values here are:\n&#039; ALL,MS_SECURITY_BULLETINS,CRITICALS,IMPORTANTS,MODERATES,LOWS\n\n\t\t\tIf Not isComplete Then\n\t\t\t\tIf InStr(strLine, &quot;Already Installed&quot;) Then\n\t\t\t\t\t&#039;Do not echo since we only want to output &quot;Available&quot; patches\n\t\t\t\tElse\n\t\t\t\t\thasOutput = True\n\t\t\t\t\tSelect Case words(1)\n\t\t\t\t\t    Case &quot;Critical&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;CRITICALS&quot; Or _\n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _\n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\t\tintCritical = intCritical + 1\n\t\t\t\t\t    \tEnd If\n\t\t\t\t\t    Case &quot;Important&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;IMPORTANTS&quot; Or _\n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\t\tintImportant = intImportant + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t    \t\n\n\t\t\t\t\t    Case &quot;Moderate&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;MODERATES&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\tintModerate = intModerate + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t    \t\t\t\t\t\t    \n\t\t\t\t\t    Case &quot;Low&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\tintLow = intLow + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\t    Case &quot;None&quot;\n\t\t\t\t\t    \tIf strHighestSeverityThatCounts = &quot;ALL&quot; Or _ \n\t\t\t\t\t    \t\tstrHighestSeverityThatCounts = &quot;LOWS&quot; Then\n\t\t\t\t\t    \t\tintNone = intNone + 1\n\t\t\t\t\t    \tEnd If\t\t\t\t\t\t\t\t\t    \n\t\t\t\t\tEnd Select\n\t\t\t\t\tIf LCase(words(2)) &lt;&gt; &quot;none&quot; Then &#039; there is an MS Security Bulletin ID associated\n\t\t\t\t\t\tintSecurityBulletin = intSecurityBulletin + 1\n\t\t\t\t\tEnd If\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039;If we&#039;re here, update has been queued\n\t\t\t\t&#039;Do not echo since we only want to output &quot;Installed&quot; patches\n\t\t\t\t&#039;If InStr(strLine, &quot;Not Installed&quot;) Then\n\t\t\t\t&#039;\tstrLine = Replace(strLine, &quot;Not Installed&quot;, &quot;Queued&quot;)\n\t\t\t\t&#039;\tWScript.Echo strLine\n\t\t\t\t&#039;End If\n\t\t\tEnd If \n\t\tEnd If\t\n\tLoop\n\n\tobjReadFile.close\n\n\tIf hasOutput Then &#039; output sum, ignoring the &#039;None&#039; category\n\t\tIf strHighestSeverityThatCounts = &quot;MS_SECURITY_BULLETINS&quot; Then\n\t\t\tWScript.Echo intSecurityBulletin\n\t\tElse\n\t\t\tIf intCritical + intImportant + intModerate + intLow + intNone &gt; intTotalThreshold Then\n\t\t\t\tWScript.Echo &quot;Yes&quot;\n\t\t\tElse\n\t\t\t\tWScript.Echo &quot;No&quot;\n\t\t\tEnd If\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;No&quot;\n\tEnd If\n\nElse\n   Wscript.echo &quot;Patch results output not found&quot;\nEnd If\n\nFunction GetTaniumPath\n   Dim strComputer, key32path, key64path, keyPath, reg\n   strComputer = &quot;.&quot;\n   Const HKLM = &amp;h80000002\n   \n   key32Path = &quot;Software\\Tanium\\Tanium Client&quot;\n   key64Path = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n   \n   Set reg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer &amp; &quot;\\root\\default:StdRegProv&quot;)\n   \n   If RegKeyExists(reg, HKLM, key64Path) Then\n        keyPath = key64Path\n   ElseIf RegKeyExists(reg, HKLM, key32Path) Then\n      keyPath = key32Path\n   End If\n   \n   reg.GetStringValue HKLM,keyPath,&quot;Path&quot;,GetTaniumPath\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 407, 
      "category": "Tanium Diagnostics", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "Provided with an action number as a parameter, this sensor returns the log from the action from each client machine that executed the action.\nExample: 2012-11-02 03:30:17 +0000|Command Completed", 
      "exclude_from_parse_flag": 1, 
      "hash": 969736519, 
      "hidden_flag": 0, 
      "id": 811, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Tanium Action Log", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"[0-9]+\",\"helpString\":\"\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter a valid Action ID Number from the Action History tab\",\"value\":\"\",\"promptText\":\"e.g. 1234\",\"defaultValue\":\"\",\"label\":\"Action ID Number\",\"maxChars\":0,\"key\":\"actionNumber\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Tanium Action Log\n&#039;========================================\n\nOption Explicit\n\nConst MAX_LINES_TO_RETURN = 100\n\nDim strAction, strTaniumPath, strFilePath\n\nstrAction = &quot;||actionNumber||&quot;\nstrTaniumPath = GetTaniumDir(&quot;Downloads&quot;)\n\nstrFilePath = strTaniumPath &amp; &quot;\\Action_&quot;&amp;strAction&amp;&quot;.log&quot;\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\nIf fso.FileExists(strFilePath) Then\n\tDim objTextFile, strLine, intLineNumber\n\tSet objTextFile = fso.OpenTextFile(strFilePath, 1)\n\t\n\tintLineNumber = 1\n\tDo Until objTextFile.AtEndOfStream\n\t\tWScript.Echo zeroPad(intLineNumber,3) &amp; &quot;|&quot; &amp; objTextFile.ReadLine\n\t\tintLineNumber = intLineNumber + 1\n\t\t\n\t\tIf(intLineNumber &gt; MAX_LINES_TO_RETURN) Then\n\t\t\tWScript.Echo zeroPad(intLineNumber,3) &amp; &quot;|Max number of lines reached in Action Log Sensor&quot;\n\t\t\tWScript.Quit\n\t\tEnd If\n\tLoop \n\t\nElse\n\tWScript.Echo &quot;File does not exist&quot;\nEnd If\n\nFunction zeroPad(m, t)\n   zeroPad = String(t-Len(m),&quot;0&quot;)&amp;m\nEnd Function\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n    \n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        If strSubDir &lt;&gt; &quot;&quot; Then\n            strSubDir = &quot;\\&quot; &amp; strSubDir\n        End If  \n    \n        Dim fso\n        Set fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n        If fso.FolderExists(strPath) Then\n            If Not fso.FolderExists(strPath &amp; strSubDir) Then\n                &#039;&#039;Need to loop through strSubDir and create all sub directories\n                GeneratePath strPath &amp; strSubDir, fso\n            End If\n            GetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n        Else\n            &#039; Specified Path doesn&#039;t exist on the filesystem\n            WScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n            GetTaniumDir = False\n        End If\n    Else\n        WScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n        GetTaniumDir = False\n    End If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n    GeneratePath = False\n\n    If Not fso.FolderExists(pFolderPath) Then\n        If GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n            GeneratePath = True\n            Call fso.CreateFolder(pFolderPath)\n        End If\n    Else\n        GeneratePath = True\n    End If\nEnd Function &#039;GeneratePath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;actionNumber&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;[0-9]+&quot;,&quot;helpString&quot;:&quot;&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter a valid Action ID Number from the Action History tab&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID Number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||actionNumber||  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;key&quot;:&quot;actionNumber&quot;,&quot;validationExpressions&quot;:[{&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;[0-9]+&quot;,&quot;helpString&quot;:&quot;&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;promptText&quot;:&quot;e.g. 1234&quot;,&quot;helpString&quot;:&quot;Enter a valid Action ID Number from the Action History tab&quot;,&quot;maxChars&quot;:0,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;label&quot;:&quot;Action ID Number&quot;,&quot;restrict&quot;:null,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# ||actionNumber||  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 408, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The amount of time, in seconds, that the last boot of this machine took.\nExample:  100", 
      "exclude_from_parse_flag": 1, 
      "hash": 98057726, 
      "hidden_flag": 0, 
      "id": 813, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Boot Time", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Boot Time in Minutes\n&#039;========================================\n&#039;\n\nOption Explicit\n\nDim strBootTimeInSec\n\nIf Left(GetOSMajorVersion(), 1) &lt; 6 Then \n\tWScript.Echo &quot;Not Available&quot;\nElse\n\tstrBootTimeInSec = GetBootTimeInSec\n\tWScript.Echo strBootTimeInSec\nEnd If\n\nFunction GetBootTimeInSec() \n\tDim objShell, objShellExec, strCmd, strCmdOutput, strBootTime\n\tDim xmlDoc, bLoadSuccess, objList, objNode\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrCmd = &quot;wevtutil.exe qe Microsoft-Windows-Diagnostics-Performance/Operational /rd:true /f:xml /c:1 /q:&quot;&quot;*[System[(EventID = 100)]]&quot;&quot; /e:Events&quot;\n\t\n\tSet objShellExec = objShell.Exec(strCmd)\n\tstrCmdOutput = objShellExec.StdOut.ReadAll\n\n\t&#039; the command gave us back XML -- put the XML into an xml object, then find what we are looking for.\n\t\n\tSet xmlDoc = CreateObject(&quot;Msxml2.DOMDocument&quot;)\n\tbLoadSuccess = xmlDoc.loadXml(strCmdOutput)\n\t\n\tIf Not bLoadSuccess Then\n\t    &#039; On Server machines, the above will report that the channel can not be found,\n\t    &#039; and return nothing.  (that log is only available on clients)  The XML won&#039;t parse,\n\t    &#039; so return Not Available\n\t\tWScript.Echo &quot;Not Available&quot;\n\t\tWScript.Quit\n\tEnd If\n\t\n\tSet objList = xmlDoc.getElementsByTagName(&quot;Data&quot;)\n\tIf objList.length &gt; 0 Then\n        For Each objNode In objList\n        \tDim strAttribute\n        \tstrAttribute = objNode.getAttribute(&quot;Name&quot;)\n        \t\n        \tIf strAttribute = &quot;BootTime&quot; Then\n        \t\tstrBootTime = objNode.text\n        \tEnd If\n        Next\n    End If\n\n\tGetBootTimeInSec = Round(strBootTime / 1000)\nEnd Function &#039; GetBootTimeInSec\n\t\nFunction GetOSMajorVersion\n&#039; Returns the OS Major Version\n&#039; A different way to examine the OS instead of by name\n\n\tDim objWMIService,colItems,objItem\n\tDim strVersion\n\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = GetObject(&quot;WinMgmts:root/cimv2&quot;).ExecQuery(&quot;select Version from win32_operatingsystem&quot;)    \n\tFor Each objItem In colItems\n\t\tstrVersion = objItem.Version &#039; like 6.2.9200\n\t\tstrVersion = Left(strVersion,Len(strVersion) - 5)\n\tNext\n\t\n\tGetOSMajorVersion = strVersion\n\t\nEnd Function &#039;GetOSMajorVersion", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "Numeric"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 409, 
      "category": "Network", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": ",", 
      "description": "The configured workgroup or computer domain for each client machine.\nExample: mycompanydomain", 
      "exclude_from_parse_flag": 1, 
      "hash": 991644931, 
      "hidden_flag": 0, 
      "id": 815, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Workgroup", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Workgroup\n&#039;========================================\n\nSet objWMISvc = GetObject( &quot;winmgmts:\\\\.\\root\\cimv2&quot; )\nSet colItems = objWMISvc.ExecQuery(&quot;Select * From Win32_ComputerSystem&quot;)\nFor Each objItem in colItems\n\tstrComputerDomain = objItem.Domain\n\tIf Not objItem.PartOfDomain Then\n    \t&#039; If the machine is not part of a domain, then the &quot;Domain&quot; is the workgroup\n    \t&#039; Don&#039;t print domain, only workgroup\n    \tWScript.Echo  strComputerDomain\n\tEnd If\nNext", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 410, 
      "category": "Security", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Returns information on the FileVault status of a machine\nExample: If Available | Fully Secure | Status", 
      "exclude_from_parse_flag": 1, 
      "hash": 1326015223, 
      "hidden_flag": 0, 
      "id": 817, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 900, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "Tanium"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "FileVault Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039; THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n&#039; \n&#039; \n\nWScript.Echo &quot;N/A on Windows&quot;", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n# \n# Sensor that goes through the current status of the drives via diskutil,\n# and outputs the current FileVault status\n\n\nCORESTORAGESTATUS=&quot;/private/tmp/corestorage.txt&quot;\nENCRYPTSTATUS=&quot;/private/tmp/encrypt_status.txt&quot;\nENCRYPTDIRECTION=&quot;/private/tmp/encrypt_direction.txt&quot;\n\nDEVICE_COUNT=`diskutil cs list | grep -E &quot;^CoreStorage logical volume groups&quot; | awk &#039;{print $5}&#039; | sed -e&#039;s/(//&#039;`\n\nEGREP_STRING=&quot;&quot;\nif [ &quot;$DEVICE_COUNT&quot; != &quot;1&quot; ]; then\n  EGREP_STRING=&quot;^\\| *&quot;\nfi\n\nosversionlong=`sw_vers -productVersion`\nosvers=${osversionlong:3:1}\nCONTEXT=`diskutil cs list | grep -E &quot;$EGREP_STRING\\Encryption Context&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $3}&#039;`\nENCRYPTIONEXTENTS=`diskutil cs list | grep -E &quot;$EGREP_STRING\\Has Encrypted Extents&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $4}&#039;`\nENCRYPTION=`diskutil cs list | grep -E &quot;$EGREP_STRING\\Encryption Type&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $3}&#039;`\nCONVERTED=`diskutil cs list | grep -E &quot;$EGREP_STRING\\Size \\(Converted\\)&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $5, $6}&#039;`\nSIZE=`diskutil cs list | grep -E &quot;$EGREP_STRING\\Size \\(Total\\)&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $5, $6}&#039;`\n\n# Checks to see if the OS on the Mac is 10.7 or 10.8.\n# These older versions of mac OS do not have the ability to encrypt\n\nif [[ ${osvers} -lt 7 ]]; then\n  echo &quot;Not Available|No|None&quot;\nfi\n\n\n\nif [[ ${osvers} -ge 7 ]]; then\n  diskutil cs list &gt;&gt; $CORESTORAGESTATUS\n  \n    # If the Mac is running 10.7 or 10.8, but not does not have\n    # any CoreStorage volumes, the status is:\n    # Not Enabled\n    \n    if grep -iE &#039;No CoreStorage&#039; $CORESTORAGESTATUS 1&gt;/dev/null; then\n       echo &quot;Available|No|None&quot;\n    fi\n    \n    if grep -iE &#039;Logical Volume Family&#039; $CORESTORAGESTATUS 1&gt;/dev/null; then\n\n    # This section does 10.7-specific checking of the Mac&#039;s\n    # FileVault 2 status\n\n      if [ &quot;$CONTEXT&quot; = &quot;Present&quot; ]; then\n        if [ &quot;$ENCRYPTION&quot; = &quot;AES-XTS&quot; ]; then\n\t      diskutil cs list | grep -E &quot;$EGREP_STRING\\Conversion Status&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTSTATUS\n\t\t    if grep -iE &#039;Complete&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then \n\t\t      echo &quot;Available|Yes|Encrypted&quot;\n            else\n\t\t      if  grep -iE &#039;Converting&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then\n\t\t        diskutil cs list | grep -E &quot;$EGREP_STRING\\Conversion Direction&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTDIRECTION\n\t\t          if grep -iE &#039;Forward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then\n\t\t            echo &quot;Available|No|Encrypting $CONVERTED of $SIZE&quot;\n                  else\n\t\t            echo &quot;Available|No|Unknown&quot;\n\t              fi\n               fi\n             fi\n        else\n            if [ &quot;$ENCRYPTION&quot; = &quot;None&quot; ]; then\n              diskutil cs list | grep -E &quot;$EGREP_STRING\\Conversion Direction&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTDIRECTION\n                if grep -iE &#039;Backward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then\n                  echo &quot;Available|No|Decrypting $CONVERTED of $SIZE&quot;\n                elif grep -iE &#039;-none-&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then\n                  echo &quot;Available|No|Not Encrypted&quot;\n                fi\n            fi \n        fi\n      fi  \nfi\nfi\n    # This section does 10.8-specific checking of the Mac&#039;s\n    # FileVault 2 status\n\n      if [ &quot;$ENCRYPTIONEXTENTS&quot; = &quot;Yes&quot; ]; then\n        if [ &quot;$ENCRYPTION&quot; = &quot;AES-XTS&quot; ]; then\n\t      diskutil cs list | grep -E &quot;$EGREP_STRING\\Fully Secure&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTSTATUS\n\t\t    if grep -iE &#039;Yes&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then \n\t\t      echo &quot;Available|Yes|Encrypted&quot;\n            else\n\t\t      if  grep -iE &#039;No&#039; $ENCRYPTSTATUS 1&gt;/dev/null; then\n\t\t        diskutil cs list | grep -E &quot;$EGREP_STRING\\Conversion Direction&quot; | sed -e&#039;s/\\|//&#039; | awk &#039;{print $3}&#039; &gt;&gt; $ENCRYPTDIRECTION\n\t\t          if grep -iE &#039;forward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then\n\t\t            echo &quot;Available|No|Encrypting $CONVERTED of $SIZE&quot;\n\n                  else\n\t\t          if grep -iE &#039;backward&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then\n                  \t    echo &quot;Available|No|Decrypting $CONVERTED of $SIZE&quot;\n                          elif grep -iE &#039;-none-&#039; $ENCRYPTDIRECTION 1&gt;/dev/null; then\n                            echo &quot;Available|No|Not Encrypted&quot;\n\t              fi\n               fi\n             fi\n      fi  \nfi\nfi\n\n\n\n# Remove the temp files created during the script\n\nif [ -f /private/tmp/corestorage.txt ]; then\n   rm /private/tmp/corestorage.txt\nfi\n\nif [ -f /private/tmp/encrypt_status.txt ]; then\n   rm /private/tmp/encrypt_status.txt\nfi\n\nif [ -f /private/tmp/encrypt_direction.txt ]; then\n   rm /private/tmp/encrypt_direction.txt\nfi\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Availablity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Fully Secure", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Status", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 411, 
      "category": "Operating System", 
      "creation_time": "2015-01-05T20:22:05", 
      "delimiter": "|", 
      "description": "Return details about loaded drivers\nExample:\nWIMMount|Stopped|C:\\Windows\\system32\\drivers\\wimmount.sys|6.3.9600.16384", 
      "exclude_from_parse_flag": 1, 
      "hash": 1994896093, 
      "hidden_flag": 0, 
      "id": 819, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Jim Olsen", 
      "max_age_seconds": 2700, 
      "modification_time": "2015-01-05T20:22:05", 
      "name": "Driver Details", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Driver Details\n&#039;========================================\n&#039; this sensor will return specific data about all drivers in the driver store\n&#039; many columns are parsed, but only a few are output\n&#039; set hash type to something valid (md5 or sha1) in order to enable hash output\n&#039; which would change the column count\n\nOption Explicit\n\nOn Error Resume Next\nDim strHashType\n&#039; Either MD5 or SHA1. If neither, do not hash\n&#039; requires IR tools to hash\n&#039;strHashType = &quot;MD5&quot;\n&#039;strHashType = &quot;SHA1&quot;\nstrHashType = &quot;None&quot;\n\nDim strCommand,objShell,objScriptExec,strDriverResults,results,line\nDim arrFields,strMName,strDName,strDesc,strDType,strStartMode,strState,strStatus,strAccStop\nDim strAccPause,strPP,strCode,strBSS,strLinkDate,strPath,strInit,strFixedPath\nDim strFindChr,strReplaceChr,strSep,bHasOutput,dictOut,strOut,strSystem32Location,objFSO\nDim dictFilesToHash,inputFile,bHashOutput,strHashOfDriver,strFileVersion\n\nSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet dictFilesToHash = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; call the 64-bit driver query on a 64-bit machine when necessary\nstrSystem32Location = FixFileSystemRedirectionForPath(objFSO.GetSpecialFolder(1))\n\nstrCommand = &quot;cmd /c &quot;&amp;strSystem32Location&amp;&quot;\\driverquery.exe /V /NH /FO CSV&quot;\n\nSet objShell = CreateObject(&quot;WScript.Shell&quot;)\nSet objScriptExec = objShell.Exec (strCommand)\nstrDriverResults = objScriptExec.StdOut.ReadAll\n\nresults = Split(strDriverResults, vbCrLf)\n\nstrFindChr = Chr(34)\nstrReplaceChr = &quot;&quot;\n\nstrSep = &quot;|&quot;\n\nSet dictOut = CreateObject(&quot;Scripting.Dictionary&quot;)\n\nbHasOutput = False\nFor Each line in results\n\tarrFields = Split(line, Chr(34)&amp;Chr(44))\n\tIf UBound(arrFields) &gt;= 14 Then\n\t\tstrMName = Replace(Trim(arrFields(0)),strFindChr,strReplaceChr)\n\t\tstrDName = Replace(Trim(arrFields(1)),strFindChr,strReplaceChr)\n\t\tstrDesc = Replace(Trim(arrFields(2)),strFindChr,strReplaceChr)\n\t\tstrDType = Replace(Trim(arrFields(3)),strFindChr,strReplaceChr)\n\t\tstrStartMode = Replace(Trim(arrFields(4)),strFindChr,strReplaceChr)\n\t\tstrState = Replace(Trim(arrFields(5)),strFindChr,strReplaceChr)\n\t\tstrStatus = Replace(Trim(arrFields(6)),strFindChr,strReplaceChr)\n\t\tstrAccStop = Replace(Trim(arrFields(7)),strFindChr,strReplaceChr)\n\t\tstrAccPause = Replace(Trim(arrFields(8)),strFindChr,strReplaceChr)\n\t\tstrPP = Replace(Trim(arrFields(9)),strFindChr,strReplaceChr)\n\t\tstrCode = Replace(Trim(arrFields(10)),strFindChr,strReplaceChr)\n\t\tstrBSS = Replace(Trim(arrFields(11)),strFindChr,strReplaceChr)\n\t\tstrLinkDate = Replace(Trim(arrFields(12)),strFindChr,strReplaceChr)\n\t\tstrPath = Replace(Trim(arrFields(13)),strFindChr,strReplaceChr)\n\t\tstrPath = Replace(strPath,&quot;\\??\\&quot;,&quot;&quot;) &#039;&#039; eliminate strange path chars\n\t\tstrInit = Replace(Trim(arrFields(14)),strFindChr,strReplaceChr)\n\t\tstrFixedPath = FixFileSystemRedirectionForPath(strPath)\n\t\tstrFixedPath = LCase(strFixedPath) &#039; necessary for dict compare later\n\t\tstrFileVersion = GetFileVersion(objFSO,strFixedPath)\n\t\tstrOut = strDName &amp; strSep &amp; strState &amp; strSep &amp; strPath &amp; strSep &amp; strFileVersion\n\t\tIf Not dictOut.Exists(strOut) Then\n\t\t\tdictOut.Add strOut,strFixedPath\n\t\t\tIf Not dictFilesToHash.Exists(LCase(strFixedPath)) Then\n\t\t\t\t&#039; Default message is Cannot Hash if the IR tools are not installed properly or file cannot be hashed\n\t\t\t\tdictFilesToHash.Add LCase(strFixedPath),&quot;cannot hash&quot;\n\t\t\tEnd If\n\t\t\tbHasOutput = True\n\t\tEnd If\n\tEnd If\nNext\n\nstrHashType = LCase(strHashType)\nIf strHashType = &quot;md5&quot; Or strHashType = &quot;sha1&quot; Then\n\tinputFile = GetTaniumDir(&quot;Tools\\IR&quot;) &amp; &quot;driver-details-with-hash-&quot;&amp;strHashType&amp;&quot;.xml&quot;\n\t&#039;delete potential previous input file on entry\n\tOn Error Resume Next\n\tIf objFSO.FileExists(inputFile) Then\n\t\tobjFSO.DeleteFile inputFile, True\n\tEnd If\n\tOn Error Goto 0\n\tCreateXmlInputFileByHashType dictFilesToHash,inputFile,strHashType\n\t&#039; add the hash of the files to the files to hash dictionary\n\tAddHashToHashesDictFromMD5Output inputFile,dictFilesToHash,strHashType\n\tOn Error Resume Next\n\t&#039;delete potential previous input file on entry\n\tIf objFSO.FileExists(inputFile) Then\n\t\tobjFSO.DeleteFile inputFile, True\n\tEnd If\n\tOn Error Goto 0\nEnd If\n\nIf Not bHasOutput Then\n\tWScript.echo  &quot;Error: driver data cannot be interpreted&quot;\nElse\nbHashOutput = False\nIf strHashType = &quot;md5&quot; Or strHashType = &quot;sha1&quot; Then bHashOutput = True\n\tFor Each strOut In dictOut.Keys\n\t\tIf bHashOutput Then\n\t\t\tIf dictFilesToHash.Exists(dictOut.Item(strOut)) Then\n\t\t\t\tstrHashOfDriver = dictFilesToHash.Item(dictOut.Item(strOut))\n\t\t\tElse\n\t\t\t\tstrHashOfDriver = &quot;unknown&quot;\n\t\t\tEnd If\n\t\t\tWScript.Echo strOut &amp; strSep &amp; strHashOfDriver\n\t\tElse\n\t\t\tWScript.Echo strOut\n\t\tEnd If\n\tNext\nEnd If\n\n\nFunction GetFileVersion(ByRef fso, strPath)\n\tDim strVersion\n\tIf fso.FileExists(strPath) Then\n\t\tOn Error Resume Next\n\t\tstrVersion = fso.GetFileVersion(strPath)\n\t\tOn Error Goto 0\n\t\tIf strVersion = &quot;&quot; Then\n\t\t\tstrVersion = &quot;Version not found&quot;\n\t\tEnd If\n\tElse \n\t\tstrVersion = &quot;File not found&quot;\n\tEnd If\n\n\tGetFileVersion = strVersion\nEnd Function &#039;GetFileVersion\n\nFunction FixFileSystemRedirectionForPath(ByVal strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,strWindowsLocation,objShell\n\tDim strProgramFilesx86\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrWindowsLocation = LCase(objFSO.GetSpecialFolder(0))\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrFilePath = Replace(strFilePath,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n\nFunction UnFixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will undo the changes made to a path by the \n&#039; FixFileSystemRedirectionForPath function\n&#039; if a path is passed in with the sysnative string in it\n&#039; it will simply change it to system32, regardless of whether\n&#039; the OS is 64-bit.  A path will only be changed when it&#039;s\n&#039; necessary, so this has no effect when it&#039;s not changed.\n\n\tDim objFSO,strSystem32Location,strNewSystem32Location\n\t\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\n\tUnFixFileSystemRedirectionForPath = Replace(strFilePath,strNewSystem32Location,strSystem32Location)\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;UnFixFileSystemRedirectionForPath\n\nFunction CreateXmlInputFileByHashType(fileStrings, inputFileName, strHashType)\n\tIf Not (strHashType = &quot;md5&quot; Or strHashType = &quot;sha1&quot;) Then\n\t\tWScript.Echo &quot;Invalid hash type: &quot; &amp; strHashType&amp; &quot;, Quitting&quot;\n\t\tWScript.Quit\n\tEnd If\n\tDim masterXmlDom\n\tSet masterXmlDom = CreateObject(&quot;Msxml2.DOMDocument&quot;)\n    masterXmlDom.Async = false\n\t\n\tDim oFSO, oExistingTextFile, existingXML\n\tSet oFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\t\t\n\tDim pi\n\tSet pi = masterXmlDom.createProcessingInstruction(&quot;xml&quot;, &quot;version=&#039;1.0&#039; encoding=&#039;UTF-8&#039;&quot;)\n\tmasterXmlDom.insertBefore pi, masterXmlDom.firstChild\n\t\n\tDim fcivElement\n\tSet fcivElement = masterXmlDom.createElement(&quot;FCIV&quot;)\n\tmasterXmlDom.appendChild fcivElement\n\t\n\tDim fPath, fileEntryElement, nameElement, hashtypeElement\n\tFor Each fPath In fileStrings\n\t\tfPath = FixFileSystemRedirectionForPath(fPath)\n\t\t\n\t\tSet fileEntryElement = masterXmlDom.createElement(&quot;FILE_ENTRY&quot;)\n\t\tfcivElement.appendChild fileEntryElement\n\t\t\n\t\tSet nameElement = masterXmlDom.createElement(&quot;name&quot;)\n\t\tnameElement.text = fPath\n\t\tfileEntryElement.appendChild nameElement\n\t\t\n\t\tSet hashtypeElement = masterXmlDom.createElement(UCase(strHashType))\n\t\tfileEntryElement.appendChild hashtypeElement\n\tNext\t\n\t&#039;WScript.Echo &quot;Current XML: &quot; &amp; masterXmlDom.xml\n\tmasterXmlDom.save(inputFileName)\n\t\nEnd Function &#039;CreateXmlInputFileByHashType\n\nFunction AddHashToHashesDictFromMD5Output(inputFileName,ByRef dictFilesToHash,strHashType)\n&#039; takes a dictionary of files to hash, adds their hash to the file. Carefully consdier\n&#039; whether the path is fixed for file system redirection\n\n\tDim objShell, objExec, bErr\n\tDim strLine,arrLine,strErrFile,intHashLength,strHasherPath\n\t\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\n\t&#039; Ensure file exists\n\tIf Not objFSO.FileExists(inputFileName) Then\n\t\tWScript.Echo &quot;Error: XML input file not written&quot;\n\t\t&#039;Cleanup and exit\n\t\tSet objShell = Nothing\n\t\tSet objFSO = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\t&#039; Ensure utility exists\n\tstrHasherPath = GetTaniumDir(&quot;Tools\\IR&quot;) &amp; &quot;fciv.exe&quot;\n\tIf Not objFSO.FileExists(strHasherPath) Then\n\t\tWScript.Echo &quot;Error: Could not locate hash utility, ensure machine has Tanium IR tools&quot;\n\t\t&#039;Cleanup and exit\n\t\tSet objShell = Nothing\n\t\tSet objFSO = Nothing\n\t\tExit Function\n\tEnd If\n\t\n\tstrHashType = LCase(strHashType) &#039; must be md5 or sha1\n\tSelect Case strHashType\n\t\tCase &quot;md5&quot;\n\t\t\tintHashLength = 32\n\t\tCase &quot;sha1&quot;\n\t\t\tintHashLength = 40\n\t\tCase Else\n\t\t\tWScript.Echo &quot;Invalid hash type: &quot; &amp;strHashType&amp;&quot;, quitting&quot;\n\t\t\tWScript.Quit\n\tEnd Select\n\n\tSet objExec = objShell.Exec(Chr(34)&amp;strHasherPath&amp;Chr(34)&amp; &quot; -v -&quot;&amp;strHashType&amp;&quot; -xml &quot; &amp; Chr(34)&amp;inputFileName&amp;Chr(34))\n\t&#039; examine output\n\tDim fName, fHex\n\tWhile objExec.StdOut.AtEndOfStream &lt;&gt; True\n\t\tstrLine = LCase(Trim(objExec.StdOut.ReadLine))\n\n\t\tIf Len(strLine) &gt; 2 Then strLine = Left(strLine, Len(strLine)-2) &#039;adjust for 2 invisible characters at end of line\n\t\t\n\t\t&#039;Start processesing on lines that are file names\n\t\t&#039;This is based on the second character being a :, such as C: or D:\n\t\tIf Mid(strLine,2,1) = &quot;:&quot; Then\n\t\t\tfName = strLine\n\t\t\tobjExec.StdOut.SkipLine\n\t\t\tstrLine = LCase(Trim(objExec.StdOut.ReadLine))\n\t\t\tIf Len(strLine) &gt; 0 Then strLine = Left(strLine, Len(strLine)-1) &#039;adjust for 1 invisible character at end of line\n\t\t\tfHex = Right(strLine,intHashLength)\n\t\t\tIf dictFilesToHash.Exists(fName) Then\n\t\t\t\tdictFilesToHash.Item(fName) = fHex\n\t\t\t\t&#039; WScript.Echo fName&amp;strSep&amp;fHex\n\t\t\tEnd If\n\t\tEnd If\n\tWend\n\n\tstrErrFile = GetTaniumDir(&quot;Tools\\IR&quot;) &amp; &quot;fciv.err&quot;\n\tIf objFSO.FileExists(strErrFile) Then\n\t\tobjFSO.DeleteFile strErrFile, True\n\tEnd If\nEnd Function &#039;AddHashToHashesDictFromMD5Output\n\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# \n# \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Display Name", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "State", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Path", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "Version", 
            "value_type": "Version"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 412, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478889353, 
      "hidden_flag": 0, 
      "id": 4294967295, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Number of Application Crashes in Last X Days[5]", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||days||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Number of Application Crashes in Last X Days\n&#039;========================================\n\nOption Explicit\nDim strSep\nDim objWMIService, colEvents, objEvent\nDim dtmStart\n\nstrSep = &quot;|&quot;\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\n\ndtmStart = GetTimeWrittenByDaysOld(5)\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\\\.\\root\\cimv2&quot;) \n\nSet colEvents = objWMIService.ExecQuery _\n    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _\n        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _\n        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)\n\nDim numCrashes\nnumCrashes = 0\n\nFor Each objEvent In colEvents\n    Dim strMessage, arrLines, strLine, strApp, strModule, strTime\n    \n    strMessage = objEvent.Message\n    arrLines = Split(strMessage, vbCrLf)\n    \n    Dim strIndex, strIndexXp\n\n\t&#039;just go through first line of log to grab app name\n\tstrLine = arrLines(0)\n\t\n\t&#039;strIndex is for new OSes, strIndexXP for older...\n\tstrIndex = &quot;Faulting application name: &quot;\n\tstrIndexXp = &quot;Faulting application &quot;\n\tIf Left(strLine, Len(strIndex)) = strIndex Then\n\t\tstrApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)\n\tElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then\n\t\tstrApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)\n\tEnd If\n\t\n    strTime = DatetimeToDate(objEvent.TimeWritten)\n    \t \n\tIf Not IsNull(strApp) And Not IsEmpty(strApp) Then\n\t\tnumCrashes = numCrashes + 1\n\tEnd If\nNext\n\nWScript.Echo numCrashes\n\nFunction DatetimeToDate(strDate)\n   DatetimeToDate = _\n       CDate(Mid(strDate, 5, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Mid(strDate, 7, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Left(strDate, 4) &amp; _\n       &quot; &quot; &amp; _\n       Mid (strDate, 9, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 11, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 13, 2))\nEnd Function\n\nFunction GetTimeWrittenByDaysOld(days)\n   &#039;subtract &quot;days&quot; days worth of seconds\n\n\tDim epoc, monthAgo   \n   \tepoc = date2epoch(Now()) - days*24*60*60\n   \tmonthAgo = epoch2date(epoc)\n   \n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate monthAgo, True\n\t \n  \tGetTimeWrittenByDaysOld = dateTime\nEnd Function\n\nfunction date2epoch(myDate)\n   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)\nend Function\n\nfunction epoch2date(myEpoch)\n   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)\nend Function", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 175, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 413, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478888048, 
      "hidden_flag": 0, 
      "id": 4294967294, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Linux:tempsensor_1", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||days||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 175, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 414, 
      "delimiter": "|", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478888483, 
      "hidden_flag": 0, 
      "id": 4294967293, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Application Crashes in Last X Days[5]", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||days||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Application Crashes in Last X Days\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\nDim strSep\nDim objWMIService, colEvents, objEvent, intCount\nDim dtmStart\n\nstrSep = &quot;|&quot;\nintCount = 0\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\ndtmStart = GetTimeWrittenByDaysOld(5)\n&#039;dtmStart = GetTimeWrittenByDaysOld(7)\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\\\.\\root\\cimv2&quot;) \n\nSet colEvents = objWMIService.ExecQuery _\n    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _\n        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _\n        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)\n\nFor Each objEvent In colEvents\n    Dim strMessage, arrLines, strLine, strApp, strModule, strTime\n    \n    strMessage = objEvent.Message\n    arrLines = Split(strMessage, vbCrLf)\n    \n    Dim strIndex, strIndexXp\n\n\t&#039;just go through first line of log to grab app name\n\tstrLine = arrLines(0)\n\t\n\t&#039;strIndex is for new OSes, strIndexXP for older...\n\tstrIndex = &quot;Faulting application name: &quot;\n\tstrIndexXp = &quot;Faulting application &quot;\n\tIf Left(strLine, Len(strIndex)) = strIndex Then\n\t\tstrApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)\n\tElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then\n\t\tstrApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)\n\tEnd If\n\t\n    strTime = DatetimeToDate(objEvent.TimeWritten)\n    \n    Dim strDate, arrTemp\n    arrTemp = Split(strTime)\n    strDate = arrTemp(0)\n\tWScript.Echo strApp &amp; strSep &amp; strDate\n\tintCount = intCount + 1\nNext\n\nIf intCount = 0 Then\n\tWScript.Echo &quot;No Application Crashes Found&quot; &amp; strSep\nEnd if\n\nFunction DatetimeToDate(strDate)\n   DatetimeToDate = _\n       CDate(Mid(strDate, 5, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Mid(strDate, 7, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Left(strDate, 4) &amp; _\n       &quot; &quot; &amp; _\n       Mid (strDate, 9, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 11, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 13, 2))\nEnd Function\n\nFunction GetTimeWrittenByDaysOld(days)\n   &#039;subtract &quot;days&quot; days worth of seconds\n\n\tDim epoc, monthAgo   \n   \tepoc = date2epoch(Now()) - days*24*60*60\n   \tmonthAgo = epoch2date(epoc)\n   \n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate monthAgo, True\n\t \n  \tGetTimeWrittenByDaysOld = dateTime\nEnd Function\n\nfunction date2epoch(myDate)\n   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)\nend Function\n\nfunction epoch2date(myEpoch)\n   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)\nend Function\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 283, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Date", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 415, 
      "delimiter": "|", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478890658, 
      "hidden_flag": 0, 
      "id": 4294967292, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Linux:tempsensor_3", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||days||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 283, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Process", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 1, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Date", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 416, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478891093, 
      "hidden_flag": 0, 
      "id": 4294967291, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Last System Crash in X Days[7]", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query and return system crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"dayThresh\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||dayThresh||", 
            "value": "7"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Last System Crash in X Days\n&#039;========================================\n\ndayThresh = LCase(Trim(Unescape(&quot;7&quot;)))\n&#039;dayThresh = LCase(Trim(Unescape(&quot;1&quot;)))\nIf Not IsNumeric(dayThresh) Then \n    WScript.Echo &quot;Parameter Not Number&quot;\n    WScript.Quit\nEnd If \ndayThresh = Cint(dayThresh)\n\nDim strValueName, strKey\n\nstrValueName = &quot;DumpFile&quot;\nstrDumpsDirName = &quot;MinidumpDir&quot;\n\nstrKey = &quot;SYSTEM\\CurrentControlSet\\Control\\CrashControl&quot;\n\nSet objReg=GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv&quot;)\nConst HKLM = &amp;h80000002\n\n&#039;Uses date math - set locale\n\nSetLocale(GetTaniumLocale)\n\nDim fso\nSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\n&#039;Get main dump file\nDim mainDumpDate\nIf RegKeyExists(objReg, HKLM, strKey) Then\n\tobjReg.GetExpandedStringValue HKLM, strKey, strValueName, strValue\n\n\tIf fso.FileExists(strValue) Then\n\t\t\n\t\tSet objFile = fso.GetFile(strValue)\n\t\tmainDumpDate = objfile.DateLastModified\n\tEnd If\nElse\n\tWScript.Echo &quot;Error, Dump key not found: HKLM\\SYSTEM\\CurrentControlSet\\Control\\CrashControl&quot;\nEnd If\n\n\n&#039;Examine minidump folder\nDim newestMini\n\nIf RegKeyExists(objReg, HKLM, strKey) Then\n\tobjReg.GetExpandedStringValue HKLM, strKey, strDumpsDirName, strDumpDir\n\n\tIf fso.FolderExists(strDumpDir) Then\n\t\tSet oFolder = fso.GetFolder(strDumpDir)\n\t\tFor Each sFile In oFolder.Files\n\t\t    If newestMini = &quot;&quot; Then\n\t\t        Set newestMini = sFile\n\t\t    Else\n\t\t        If newestMini.DateLastModified &lt; sFile.DateLastModified Then\n\t\t          Set newestMini = sFile\n\t\t        End If\n\t\t    End If\n\t\tNext\n\tEnd If\nEnd If\n\n\n\nIf newestMini = &quot;&quot; And mainDumpDate = &quot;&quot; Then\n\tWScript.Echo &quot;No system crashes found&quot;\n\tWScript.Quit\nEnd If\n\nDim responseDate\nIf newestMini = &quot;&quot; Then\t\n\tresponseDate = mainDumpDate\nElseIf mainDumpDate = &quot;&quot; Then\n\tresponseDate = newestMini.DateLastModified\nElse\n\tIf newestMini.DateLastModified &lt; mainDumpDate Then\n\t\tresponseDate = mainDumpDate\n\tElse\n\t\tresponseDate = newestMini.DateLastModified\t\n\tEnd If\nEnd If\n\ncurrent = Now()\ndayDiff = DateDiff(&quot;d&quot;, responseDate, current)\n\nDim arrTemp\nIf dayDiff &lt;= dayThresh Then\n\tarrTemp = Split(responseDate)\n\tresponseDate = arrTemp(0)\n\n\tWScript.Echo responseDate\nElse \n\tWScript.Echo &quot;No system crashes in day range&quot;\nEnd If\t\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 281, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 417, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478889788, 
      "hidden_flag": 0, 
      "id": 4294967290, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Linux:tempsensor_5", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query and return system crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"dayThresh\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||dayThresh||", 
            "value": "7"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 7  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;dayThresh&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query and return system crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 7  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 281, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 418, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478890223, 
      "hidden_flag": 0, 
      "id": 4294967289, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "High Memory Processes[5]", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":50,\"stepSize\":1,\"helpString\":\"Enter the number of processes to return\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Processes\",\"minimum\":1,\"key\":\"numOutput\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||numOutput||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; High Memory Processes\n&#039;========================================\n\ntopNum = Trim(Unescape(&quot;5&quot;))\nIf Not IsNumeric(topNum) Then \n\tWScript.Echo &quot;Parameter Not Number&quot;\n\tWScript.Quit\nEnd If \ntopNum = Cint(topNum)\n\nprintMemory = false\n\nDim objWMIService, objItem, colItems, query\nDim strComputer, strList\n\n\nstrComputer = &quot;.&quot;\nSet objWMIService = GetObject(&quot;winmgmts:{impersonationLevel=impersonate}!\\\\&quot; &amp; strComputer&amp; &quot;\\root\\cimv2&quot;)\n\nConst MaxCharacters = 255\nConst adBSTR = 8 \nConst adDouble = 5\nSet DataList = CreateObject(&quot;ADOR.Recordset&quot;)\nDataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters\nDataList.Fields.Append &quot;ProcessMemory&quot;, adDouble\n\nDataList.Open\n\nSet colProcs = objWMIService.ExecQuery(&quot;Select Name, WorkingSetSize From Win32_Process&quot;)\nFor Each proc in colProcs\n   DataList.AddNew\n   DataList(&quot;ProcessName&quot;) = proc.Name\n   DataList(&quot;ProcessMemory&quot;) = round(cdbl(proc.WorkingSetSize)/1024/1024, 0)\n   DataList.Update\nNext\nDataList.Sort = &quot;ProcessMemory DESC&quot;\nDataList.MoveFirst\ni = 1\nDo Until DataList.EOF Or i &gt; topNum\n   Set field = DataList.Fields\n   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))\n   If printMemory Then\n      strPrint = strPrint &amp; &quot; (&quot; &amp; DataList.Fields.Item(&quot;ProcessMemory&quot;) &amp; &quot; Mb)&quot;\n   End if   \n   WScript.Echo strPrint\n   DataList.MoveNext\n   i = i + 1\nLoop\n\nWScript.Quit\n\n&#039;removes .exe and process number at end of process\nFunction CleanString(str)\n\twords = Split(str, &quot;#&quot;)\n\tstr = words(0)\n\n\tIf Right(str, 4) = &quot;.exe&quot; Then\n\t\tstr = Left(str, Len(str) - 4)\n\tEnd If \n\tCleanString = str\nEnd Function", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 257, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 419, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478892398, 
      "hidden_flag": 0, 
      "id": 4294967288, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Linux:tempsensor_7", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":50,\"stepSize\":1,\"helpString\":\"Enter the number of processes to return\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Processes\",\"minimum\":1,\"key\":\"numOutput\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||numOutput||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 257, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 420, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 3478892833, 
      "hidden_flag": 0, 
      "id": 4294967287, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "High CPU Processes[5]", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":50,\"stepSize\":1,\"helpString\":\"Enter the number of processes to return\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Processes\",\"minimum\":1,\"key\":\"numOutput\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||numOutput||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; High CPU Processes\n&#039;========================================\n\ntopNum = Trim(Unescape(&quot;5&quot;))\nIf Not IsNumeric(topNum) Then \n\tWScript.Echo &quot;Parameter Not Number&quot;\n\tWScript.Quit\nEnd If \ntopNum = Cint(topNum)\n\nprintPercent = false\nConst HKLM = &amp;H80000002 \nstrComputer = &quot;.&quot;\n\nSet objWMIService = GetObject(&quot;Winmgmts:{impersonationlevel=impersonate}!\\Root\\Cimv2&quot;)\n\nConst MaxCharacters = 255\nConst adBSTR = 8 \nConst adDouble = 5\n\nSet DataList = CreateObject(&quot;ADOR.Recordset&quot;)\nDataList.Fields.Append &quot;ProcessName&quot;, adBSTR, MaxCharacters\nDataList.Fields.Append &quot;ProcessCPU1&quot;, adDouble\nDataList.Fields.Append &quot;ProcessCPU2&quot;, adDouble\nDataList.Fields.Append &quot;ProcessCPUDiff&quot;, adDouble\nDataList.Open\n\nDim total1, total2, totalDiff\n\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   \nFor Each objItem in colProcItems\n   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then\n      DataList.AddNew\n      DataList(&quot;ProcessName&quot;) = objItem.Name\n      DataList(&quot;ProcessCPU1&quot;) = objItem.PercentProcessorTime\n      DataList.Update\n   ElseIf objItem.Name = &quot;_Total&quot; Then \n      total1 = CDbl(objItem.PercentProcessorTime)\n   End If\nNext\n\nsleep = 5\nWScript.Sleep(sleep * 1000)\n\nSet colProcItems = objWMIService.ExecQuery(&quot;Select * from Win32_PerfRawData_PerfProc_Process&quot;)   \nFor Each objItem in colProcItems\n   If objItem.Name &lt;&gt; &quot;Idle&quot; And objItem.Name &lt;&gt; &quot;_Total&quot; Then\n      \n      DataList.MoveFirst\n      DataList.Find(&quot;ProcessName = &#039;&quot;&amp; objItem.Name&amp;&quot;&#039;&quot;)\n\n      If DataList.EOF Then\n              WScript.Echo &quot;** Not Found **&quot;\n      Else\n         DataList(&quot;ProcessCPU2&quot;) = objItem.PercentProcessorTime\n         DataList(&quot;ProcessCPUDiff&quot;) = DataList(&quot;ProcessCPU2&quot;) - DataList(&quot;ProcessCPU1&quot;)\n         DataList.Update\n           &#039;WScript.Echo &quot;name: &quot; &amp; DataList.Fields.Item(&quot;ProcessName&quot;) &amp; &quot;, cpu 1: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU1&quot;) &amp; &quot;, cpu 2: &quot; &amp; DataList.Fields.Item(&quot;ProcessCPU2&quot;)\n      End if\n   ElseIf objItem.Name = &quot;_Total&quot; Then \n      total2 = CDbl(objItem.PercentProcessorTime)\n      totalDiff = total2 - total1\n   End If\nNext\n\nDataList.Sort = &quot;ProcessCPUDiff DESC&quot;\nDataList.MoveFirst\ni = 1\nDo Until DataList.EOF  Or i &gt; topNum\n   strPrint = CleanString(DataList.Fields.Item(&quot;ProcessName&quot;))\n   If printPercent Then\n      strPrint = strPrint &amp; &quot; (&quot; &amp; Round(DataList.Fields.Item(&quot;ProcessCPUDiff&quot;) / totalDiff * 100, 0) &amp; &quot;%)&quot;\n   End if   \n   WScript.Echo strPrint\n   DataList.MoveNext\n   i = i + 1\nLoop\n\nWScript.Quit\n\n&#039;removes .exe and process number at end of \nFunction CleanString(str)\n\twords = Split(str, &quot;#&quot;)\n\tstr = words(0)\n\tCleanString = str\n\n\tIf Right(str, 4) = &quot;.exe&quot; Then\n\t\tstr = Left(str, Len(str) - 4)\n\tEnd If \nEnd Function", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 255, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 421, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488401243, 
      "hidden_flag": 0, 
      "id": 4294967286, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Linux:tempsensor_9", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":50,\"stepSize\":1,\"helpString\":\"Enter the number of processes to return\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Processes\",\"minimum\":1,\"key\":\"numOutput\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||numOutput||", 
            "value": "5"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Processes&quot;,&quot;key&quot;:&quot;numOutput&quot;,&quot;maximum&quot;:50,&quot;helpString&quot;:&quot;Enter the number of processes to return&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 5  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 255, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 422, 
      "delimiter": "|", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488400808, 
      "hidden_flag": 0, 
      "id": 4294967285, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Patch Failures[Yes]", 
      "parameter_definition": "{\"parameters\":[{\"helpString\":\"Enter Yes, or No, to return failures for applicable patches only\",\"value\":\"\",\"promptText\":\"Yes/No\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Show failures only for needed patches\",\"key\":\"ShowOnlyIfApplicable\",\"values\":[\"Yes\",\"No\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||ShowOnlyIfApplicable||", 
            "value": "Yes"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patch Failures\n&#039;========================================\n\n&#039; sensor: patch failures\n&#039; paramterized sensor which can show failures for all patches\n&#039; or only for patches which are failed but necessary\n\nOption Explicit\n\nConst FORREADING = 1\n\nDim objFSO,objTextFile\nDim dictHistory\nDim strScanDir\nDim strHistoryTextReadableFilePath\nDim strSep : strSep = &quot;|&quot;\nDim strLine,arrLine,strGUID,strCVE\nDim strTitle,strKB,strBulletin,strDate,strException,strSeverity\nDim dictResults,bShowOnlyIfApplicable,strShowOnlyIfApplicable\nDim strResultsReadableFilePath,strInstallStatus,strTaniumPatchID\n\n&#039; take parameter\nstrShowOnlyIfApplicable=Trim(Unescape(&quot;Yes&quot;))\n\nSelect Case LCase(strShowOnlyIfApplicable)\n\tCase &quot;yes&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase &quot;true&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase &quot;no&quot;\n\t\tbShowOnlyIfApplicable = False\n\tCase &quot;false&quot;\n\t\tbShowOnlyIfApplicable = False\n\tCase &quot;&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase Else\n\t\tWScript.Echo &quot;Parameter must be Yes or No, Quitting&quot;\n\t\tWScript.Quit\nEnd Select\n\n\nSet objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)\nstrScanDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\n\nstrHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;\nstrResultsReadableFilePath = strScanDir&amp;&quot;patchresultsreadable.txt&quot;\n\nIf Not objFSO.FileExists(strHistoryTextReadableFilePath) Then\n\tWScript.Echo &quot;Cannot find History file&quot;\n\tSet objFSO = Nothing\n\tWScript.Quit\nEnd If\n\n&#039;uses date math, may need locale set\nSetLocale(GetTaniumLocale)\n\nSet dictHistory = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; read History into dictionary\nSet objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)\nWhile objTextFile.AtEndOfStream = False\n\tstrLine = objTextFile.ReadLine\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t\tIf UBound(arrLine) &gt; 0 Then\n\t\t\tIf Not dictHistory.Exists(strLine) Then\n\t\t\t\tdictHistory.Add strLine,1\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\tEnd If\n\tElse\n\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\tEnd If\nWend\nobjTextFile.Close\n\nSet dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)\nIf bShowOnlyIfApplicable Then\n\t&#039; We will tie the GUID in history to the GUID here - if it exists in patch results and if it says\n\t&#039; not installed, only then will we write it\n\t&#039; Read results into dictionary\n\tSet objTextFile = objFSO.OpenTextFile(strResultsReadableFilePath,FORREADING)\n\tWhile objTextFile.AtEndOfStream = False\n\t\tstrLine = objTextFile.ReadLine\n\t\t&#039; WScript.Echo strLIne \n\t\t&#039;element 5 must be not installed\n\t\tarrLine = Split(strLine,strSep)\n\t\tIf IsArray(arrLine) Then\n\t\t\tIf UBound(arrLine) &gt; 0 Then\n\t\t\t\t&#039; pull GUID to use as key\n\t\t\t\tstrGUID = arrLine(7)\n\t\t\t\tIf Not (UBound(arrLine) &gt; 4 And dictResults.Exists(strGUID)) Then\n\t\t\t\t\tdictResults.Add strGUID,strLine\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\tEnd If\n\tWend\n\tobjTextFile.Close\nEnd If\n\n\nDim strkey\n\nFor Each strkey In dictHistory.Keys\n\t&#039; WScript.Echo dictHistory.Item(strkey)\n\tstrLine = strkey\n\t&#039; 13 History Columns\n\t&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|PatchID\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t\tIf UBound(arrLine) &gt; 11 Then\n\t\t\tIf LCase(arrLine(1)) = &quot;installation&quot; And LCase(arrLine(2)) = &quot;failed&quot; Then\n\t\t\t\t&#039; install failure\n\t\t\t\t&#039; report title, kb, bulletin, date, and exception\n\t\t\t\tstrGUID = arrLine(0)\n\t\t\t\tstrTitle=arrLine(6)\n\t\t\t\tstrKB=arrLine(10)\n\t\t\t\tstrBulletin=arrLine(9)\n\t\t\t\tstrCVE = arrLine(11)\n\t\t\t\tOn Error Resume Next\n\t\t\t\t&#039; Convert from UTC to Local and show only the date\n\t\t\t\tstrDate = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)\n\t\t\t\tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t\tstrDate = &quot;Unknown&quot;\n\t\t\t\t\tErr.Clear\n\t\t\t\tEnd If\n\t\t\t\tOn Error Goto 0\n\t\t\t\tstrException=arrLine(3)\n\t\t\t\tstrSeverity=arrLine(8)\n\t\t\t\tIf UBound(arrLine) &gt; 12 Then\n\t\t\t\t\tstrTaniumPatchID=arrLine(13)\n\t\t\t\tElse\n\t\t\t\t\tstrTaniumPatchID=&quot;Unknown&quot;\n\t\t\t\tEnd If\n\t\t\t\tIf bShowOnlyIfApplicable Then\n\t\t\t\t\tIf dictResults.Exists(strGUID) Then\n\t\t\t\t\t\tstrInstallStatus = Split(dictResults.Item(strGUID),&quot;|&quot;)(6)\n\t\t\t\t\t\tIf LCase(strInstallStatus) = &quot;not installed&quot; Then\n\t\t\t\t\t\t\tWScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _\n\t\t\t\t\t\t\t\t&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _\n\t\t\t\t\t\t\t\t&amp;strSep&amp;strTaniumPatchID\n\t\t\t\t\t\tEnd If\n\t\t\t\t\tEnd If\n\t\t\t\tElse\n\t\t\t\t\tWScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _\n\t\t\t\t\t\t&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _\n\t\t\t\t\t\t&amp;strSep&amp;strTaniumPatchID\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;History Line malformed - needs 11 fields&quot;\n\t\tEnd If\n\tElse\n\t\t&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable\n\tEnd If\nNext\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale\n\nFunction GetTZBias\n&#039; This functiong returns the number of minutes\n&#039; (positive or negative) to add to current time to get UTC\n&#039; considers daylight savings\n\n\tDim objLocalTimeZone, intTZBiasInMinutes\n\n\n\tFor Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)\n\t\tintTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone\n\tNext\n\n\tGetTZBias = intTZBiasInMinutes\n\t\t\nEnd Function &#039;GetTZBias", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 233, 
      "string_count": 0, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Error", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Bulletin ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 423, 
      "delimiter": "|", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488402113, 
      "hidden_flag": 0, 
      "id": 4294967284, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Linux:tempsensor_11", 
      "parameter_definition": "{\"parameters\":[{\"helpString\":\"Enter Yes, or No, to return failures for applicable patches only\",\"value\":\"\",\"promptText\":\"Yes/No\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Show failures only for needed patches\",\"key\":\"ShowOnlyIfApplicable\",\"values\":[\"Yes\",\"No\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||ShowOnlyIfApplicable||", 
            "value": "Yes"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# Yes  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# Yes  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 233, 
      "string_count": 91426, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Error", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Bulletin ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 424, 
      "delimiter": "|", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488401678, 
      "hidden_flag": 0, 
      "id": 4294967283, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Patch Failures[Yes]", 
      "parameter_definition": "{\"parameters\":[{\"helpString\":\"Enter Yes, or No, to return failures for applicable patches only\",\"value\":\"\",\"promptText\":\"Yes/No\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Show failures only for needed patches\",\"key\":\"ShowOnlyIfApplicable\",\"values\":[\"Yes\",\"No\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||ShowOnlyIfApplicable||", 
            "value": "Yes"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Patch Failures\n&#039;========================================\n\n&#039; sensor: patch failures\n&#039; paramterized sensor which can show failures for all patches\n&#039; or only for patches which are failed but necessary\n\nOption Explicit\n\nConst FORREADING = 1\n\nDim objFSO,objTextFile\nDim dictHistory\nDim strScanDir\nDim strHistoryTextReadableFilePath\nDim strSep : strSep = &quot;|&quot;\nDim strLine,arrLine,strGUID,strCVE\nDim strTitle,strKB,strBulletin,strDate,strException,strSeverity\nDim dictResults,bShowOnlyIfApplicable,strShowOnlyIfApplicable\nDim strResultsReadableFilePath,strInstallStatus,strTaniumPatchID\n\n&#039; take parameter\nstrShowOnlyIfApplicable=Trim(Unescape(&quot;Yes&quot;))\n\nSelect Case LCase(strShowOnlyIfApplicable)\n\tCase &quot;yes&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase &quot;true&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase &quot;no&quot;\n\t\tbShowOnlyIfApplicable = False\n\tCase &quot;false&quot;\n\t\tbShowOnlyIfApplicable = False\n\tCase &quot;&quot;\n\t\tbShowOnlyIfApplicable = True\n\tCase Else\n\t\tWScript.Echo &quot;Parameter must be Yes or No, Quitting&quot;\n\t\tWScript.Quit\nEnd Select\n\n\nSet objFSO = CreateObject(&quot;Scripting.Filesystemobject&quot;)\nstrScanDir = GetTaniumDir(&quot;Tools\\Scans&quot;)\n\nstrHistoryTextReadableFilePath = strScanDir&amp;&quot;patchhistoryreadable.txt&quot;\nstrResultsReadableFilePath = strScanDir&amp;&quot;patchresultsreadable.txt&quot;\n\nIf Not objFSO.FileExists(strHistoryTextReadableFilePath) Then\n\tWScript.Echo &quot;Cannot find History file&quot;\n\tSet objFSO = Nothing\n\tWScript.Quit\nEnd If\n\n&#039;uses date math, may need locale set\nSetLocale(GetTaniumLocale)\n\nSet dictHistory = CreateObject(&quot;Scripting.Dictionary&quot;)\n\n&#039; read History into dictionary\nSet objTextFile = objFSO.OpenTextFile(strHistoryTextReadableFilePath,FORREADING)\nWhile objTextFile.AtEndOfStream = False\n\tstrLine = objTextFile.ReadLine\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t\tIf UBound(arrLine) &gt; 0 Then\n\t\t\tIf Not dictHistory.Exists(strLine) Then\n\t\t\t\tdictHistory.Add strLine,1\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\tEnd If\n\tElse\n\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\tEnd If\nWend\nobjTextFile.Close\n\nSet dictResults = CreateObject(&quot;Scripting.Dictionary&quot;)\nIf bShowOnlyIfApplicable Then\n\t&#039; We will tie the GUID in history to the GUID here - if it exists in patch results and if it says\n\t&#039; not installed, only then will we write it\n\t&#039; Read results into dictionary\n\tSet objTextFile = objFSO.OpenTextFile(strResultsReadableFilePath,FORREADING)\n\tWhile objTextFile.AtEndOfStream = False\n\t\tstrLine = objTextFile.ReadLine\n\t\t&#039; WScript.Echo strLIne \n\t\t&#039;element 5 must be not installed\n\t\tarrLine = Split(strLine,strSep)\n\t\tIf IsArray(arrLine) Then\n\t\t\tIf UBound(arrLine) &gt; 0 Then\n\t\t\t\t&#039; pull GUID to use as key\n\t\t\t\tstrGUID = arrLine(7)\n\t\t\t\tIf Not (UBound(arrLine) &gt; 4 And dictResults.Exists(strGUID)) Then\n\t\t\t\t\tdictResults.Add strGUID,strLine\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;Error parsing results file&quot;\n\t\tEnd If\n\tWend\n\tobjTextFile.Close\nEnd If\n\n\nDim strkey\n\nFor Each strkey In dictHistory.Keys\n\t&#039; WScript.Echo dictHistory.Item(strkey)\n\tstrLine = strkey\n\t&#039; 13 History Columns\n\t&#039; GUID|Operation|Result|Exception|Install Date|Publish Date|Title|FirstNeededDate|Severity|MS ID|KB|CVE ID|Size|PatchID\n\tarrLine = Split(strLine,strSep)\n\tIf IsArray(arrLine) Then\n\t\tIf UBound(arrLine) &gt; 11 Then\n\t\t\tIf LCase(arrLine(1)) = &quot;installation&quot; And LCase(arrLine(2)) = &quot;failed&quot; Then\n\t\t\t\t&#039; install failure\n\t\t\t\t&#039; report title, kb, bulletin, date, and exception\n\t\t\t\tstrGUID = arrLine(0)\n\t\t\t\tstrTitle=arrLine(6)\n\t\t\t\tstrKB=arrLine(10)\n\t\t\t\tstrBulletin=arrLine(9)\n\t\t\t\tstrCVE = arrLine(11)\n\t\t\t\tOn Error Resume Next\n\t\t\t\t&#039; Convert from UTC to Local and show only the date\n\t\t\t\tstrDate = FormatDateTime(DateAdd(&quot;n&quot;,GetTZBias,CDate(arrLine(4))),vbShortDate)\n\t\t\t\tIf Err.Number &lt;&gt; 0 Then\n\t\t\t\t\tstrDate = &quot;Unknown&quot;\n\t\t\t\t\tErr.Clear\n\t\t\t\tEnd If\n\t\t\t\tOn Error Goto 0\n\t\t\t\tstrException=arrLine(3)\n\t\t\t\tstrSeverity=arrLine(8)\n\t\t\t\tIf UBound(arrLine) &gt; 12 Then\n\t\t\t\t\tstrTaniumPatchID=arrLine(13)\n\t\t\t\tElse\n\t\t\t\t\tstrTaniumPatchID=&quot;Unknown&quot;\n\t\t\t\tEnd If\n\t\t\t\tIf bShowOnlyIfApplicable Then\n\t\t\t\t\tIf dictResults.Exists(strGUID) Then\n\t\t\t\t\t\tstrInstallStatus = Split(dictResults.Item(strGUID),&quot;|&quot;)(6)\n\t\t\t\t\t\tIf LCase(strInstallStatus) = &quot;not installed&quot; Then\n\t\t\t\t\t\t\tWScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _\n\t\t\t\t\t\t\t\t&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _\n\t\t\t\t\t\t\t\t&amp;strSep&amp;strTaniumPatchID\n\t\t\t\t\t\tEnd If\n\t\t\t\t\tEnd If\n\t\t\t\tElse\n\t\t\t\t\tWScript.Echo strTitle&amp;strSep&amp;strException&amp;strSep&amp;strDate _\n\t\t\t\t\t\t&amp;strSep&amp;strKB&amp;strSep&amp;strBulletin&amp;strSep&amp;strSeverity&amp;strSep&amp;strCVE _\n\t\t\t\t\t\t&amp;strSep&amp;strTaniumPatchID\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tElse\n\t\t\t&#039; WScript.Echo &quot;History Line malformed - needs 11 fields&quot;\n\t\tEnd If\n\tElse\n\t\t&#039;WScript.Echo &quot;History Line Malformed&quot; &#039; not pipe splittable\n\tEnd If\nNext\n\nFunction GetTaniumDir(strSubDir)\n&#039;GetTaniumDir with GeneratePath, works in x64 or x32\n&#039;looks for a valid Path value\n\t\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n\t\tIf strSubDir &lt;&gt; &quot;&quot; Then\n\t\t\tstrSubDir = &quot;\\&quot; &amp; strSubDir\n\t\tEnd If\t\n\t\n\t\tDim fso\n\t\tSet fso = WScript.CreateObject(&quot;Scripting.Filesystemobject&quot;)\n\t\tIf fso.FolderExists(strPath) Then\n\t\t\tIf Not fso.FolderExists(strPath &amp; strSubDir) Then\n\t\t\t\t&#039;&#039;Need to loop through strSubDir and create all sub directories\n\t\t\t\tGeneratePath strPath &amp; strSubDir, fso\n\t\t\tEnd If\n\t\t\tGetTaniumDir = strPath &amp; strSubDir &amp; &quot;\\&quot;\n\t\tElse\n\t\t\t&#039; Specified Path doesn&#039;t exist on the filesystem\n\t\t\tWScript.Echo &quot;Error: &quot; &amp; strPath &amp; &quot; does not exist on the filesystem&quot;\n\t\t\tGetTaniumDir = False\n\t\tEnd If\n\tElse\n\t\tWScript.Echo &quot;Error: Cannot find Tanium Client path in Registry&quot;\n\t\tGetTaniumDir = False\n\tEnd If\nEnd Function &#039;GetTaniumDir\n\nFunction GeneratePath(pFolderPath, fso)\n\tGeneratePath = False\n\n\tIf Not fso.FolderExists(pFolderPath) Then\n\t\tIf GeneratePath(fso.GetParentFolderName(pFolderPath), fso) Then\n\t\t\tGeneratePath = True\n\t\t\tCall fso.CreateFolder(pFolderPath)\n\t\tEnd If\n\tElse\n\t\tGeneratePath = True\n\tEnd If\nEnd Function &#039;GeneratePath\n\nFunction GetTaniumLocale\n&#039;&#039; This function will retrieve the locale value\n&#039; previously set which governs Tanium content that\n&#039; is locale sensitive.\n\n\tDim objWshShell\n\tDim intLocaleID\n\t\n\tSet objWshShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tIf Err.Number &lt;&gt; 0 Then\n\t\tintLocaleID = objWshShell.RegRead(&quot;HKLM\\Software\\Wow6432Node\\Tanium\\Tanium Client\\LocaleID&quot;)\n\tEnd If\n\tOn Error Goto 0\n\tIf intLocaleID = &quot;&quot; Then\n\t\tGetTaniumLocale = 1033 &#039; default to us/English\n\tElse\n\t\tGetTaniumLocale = intLocaleID\n\tEnd If\n\n\t&#039; Cleanup\n\tSet objWshShell = Nothing\n\nEnd Function &#039;GetTaniumLocale\n\nFunction GetTZBias\n&#039; This functiong returns the number of minutes\n&#039; (positive or negative) to add to current time to get UTC\n&#039; considers daylight savings\n\n\tDim objLocalTimeZone, intTZBiasInMinutes\n\n\n\tFor Each objLocalTimeZone in GetObject(&quot;winmgmts:&quot;).InstancesOf(&quot;Win32_ComputerSystem&quot;)\n\t\tintTZBiasInMinutes = objLocalTimeZone.CurrentTimeZone\n\tNext\n\n\tGetTZBias = intTZBiasInMinutes\n\t\t\nEnd Function &#039;GetTZBias", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 233, 
      "string_count": 3, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Error", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Bulletin ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 425, 
      "delimiter": "|", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488402983, 
      "hidden_flag": 0, 
      "id": 4294967282, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Linux:tempsensor_13", 
      "parameter_definition": "{\"parameters\":[{\"helpString\":\"Enter Yes, or No, to return failures for applicable patches only\",\"value\":\"\",\"promptText\":\"Yes/No\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Show failures only for needed patches\",\"key\":\"ShowOnlyIfApplicable\",\"values\":[\"Yes\",\"No\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||ShowOnlyIfApplicable||", 
            "value": "Yes"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# Yes  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;values&quot;:[&quot;Yes&quot;,&quot;No&quot;],&quot;label&quot;:&quot;Show failures only for needed patches&quot;,&quot;key&quot;:&quot;ShowOnlyIfApplicable&quot;,&quot;promptText&quot;:&quot;Yes/No&quot;,&quot;helpString&quot;:&quot;Enter Yes, or No, to return failures for applicable patches only&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;value&quot;:&quot;&quot;,&quot;requireSelection&quot;:true,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::DropDownParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# Yes  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 233, 
      "string_count": 2, 
      "subcolumns": {
        "_type": "subcolumns", 
        "subcolumn": [
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 0, 
            "name": "Title", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 1, 
            "name": "Error", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 2, 
            "name": "Date", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 3, 
            "name": "KB Article", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 4, 
            "name": "Bulletin ID", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 5, 
            "name": "Severity", 
            "value_type": "String"
          }, 
          {
            "_type": "subcolumn", 
            "hidden_flag": 0, 
            "ignore_case_flag": 1, 
            "index": 6, 
            "name": "Tanium Patch ID", 
            "value_type": "String"
          }
        ]
      }, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 426, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488402548, 
      "hidden_flag": 0, 
      "id": 4294967281, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Number of Application Crashes in Last X Days[7]", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||days||", 
            "value": "7"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Number of Application Crashes in Last X Days\n&#039;========================================\n\nOption Explicit\nDim strSep\nDim objWMIService, colEvents, objEvent\nDim dtmStart\n\nstrSep = &quot;|&quot;\n\n&#039;Uses date math - set locale\n\nSetLocale(1033)\n\n\ndtmStart = GetTimeWrittenByDaysOld(7)\n\nSet objWMIService = GetObject(&quot;winmgmts:&quot; _ \n    &amp; &quot;{impersonationLevel=impersonate,authenticationLevel=Pkt,(Security)}!\\\\.\\root\\cimv2&quot;) \n\nSet colEvents = objWMIService.ExecQuery _\n    (&quot;SELECT * FROM Win32_NTLogEvent WHERE Message like &#039;Faulting application %&#039; AND Logfile = &#039;Application&#039; AND &quot; _\n        &amp; &quot;TimeWritten &gt;= &#039;&quot; &amp; dtmStart &amp; &quot;&#039; AND &quot; _\n        &amp; &quot;(EventCode = &#039;1000&#039;)&quot;)\n\nDim numCrashes\nnumCrashes = 0\n\nFor Each objEvent In colEvents\n    Dim strMessage, arrLines, strLine, strApp, strModule, strTime\n    \n    strMessage = objEvent.Message\n    arrLines = Split(strMessage, vbCrLf)\n    \n    Dim strIndex, strIndexXp\n\n\t&#039;just go through first line of log to grab app name\n\tstrLine = arrLines(0)\n\t\n\t&#039;strIndex is for new OSes, strIndexXP for older...\n\tstrIndex = &quot;Faulting application name: &quot;\n\tstrIndexXp = &quot;Faulting application &quot;\n\tIf Left(strLine, Len(strIndex)) = strIndex Then\n\t\tstrApp = Mid(strLine, Len(strIndex) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndex) - 1)\n\tElseIf Left(strLine, Len(strIndexXp)) = strIndexXp Then\n\t\tstrApp = Mid(strLine, Len(strIndexXp) + 1, InStr(strLine, &quot;,&quot;) - Len(strIndexXp) - 1)\n\tEnd If\n\t\n    strTime = DatetimeToDate(objEvent.TimeWritten)\n    \t \n\tIf Not IsNull(strApp) And Not IsEmpty(strApp) Then\n\t\tnumCrashes = numCrashes + 1\n\tEnd If\nNext\n\nWScript.Echo numCrashes\n\nFunction DatetimeToDate(strDate)\n   DatetimeToDate = _\n       CDate(Mid(strDate, 5, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Mid(strDate, 7, 2) &amp; _\n       &quot;/&quot; &amp; _\n       Left(strDate, 4) &amp; _\n       &quot; &quot; &amp; _\n       Mid (strDate, 9, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 11, 2) &amp; _\n       &quot;:&quot; &amp; _\n       Mid(strDate, 13, 2))\nEnd Function\n\nFunction GetTimeWrittenByDaysOld(days)\n   &#039;subtract &quot;days&quot; days worth of seconds\n\n\tDim epoc, monthAgo   \n   \tepoc = date2epoch(Now()) - days*24*60*60\n   \tmonthAgo = epoch2date(epoc)\n   \n\tDim dateTime\n\tSet dateTime = CreateObject(&quot;WbemScripting.SWbemDateTime&quot;)\n\tdateTime.SetVarDate monthAgo, True\n\t \n  \tGetTimeWrittenByDaysOld = dateTime\nEnd Function\n\nfunction date2epoch(myDate)\n   date2epoch = DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, myDate)\nend Function\n\nfunction epoch2date(myEpoch)\n   epoch2date = DateAdd(&quot;s&quot;, myEpoch, &quot;01/01/1970 00:00:00&quot;)\nend Function", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 175, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 427, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488403853, 
      "hidden_flag": 0, 
      "id": 4294967280, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Linux:tempsensor_15", 
      "parameter_definition": "{\"parameters\":[{\"maximum\":365,\"stepSize\":1,\"helpString\":\"Enter the number of days to query for Application Crashes\",\"value\":\"5\",\"defaultValue\":\"5\",\"snapInterval\":1,\"label\":\"Number of Days\",\"minimum\":1,\"key\":\"days\",\"model\":\"com.tanium.components.parameters::NumericParameter\",\"parameterType\":\"com.tanium.components.parameters::NumericParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||days||", 
            "value": "7"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 7  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;label&quot;:&quot;Number of Days&quot;,&quot;key&quot;:&quot;days&quot;,&quot;maximum&quot;:365,&quot;helpString&quot;:&quot;Enter the number of days to query for Application Crashes&quot;,&quot;stepSize&quot;:1,&quot;minimum&quot;:1,&quot;snapInterval&quot;:1,&quot;defaultValue&quot;:&quot;5&quot;,&quot;value&quot;:&quot;5&quot;,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::NumericParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# 7  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 175, 
      "string_count": 2, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 428, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488403418, 
      "hidden_flag": 0, 
      "id": 4294967279, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Tanium Client Explicit Setting[LogVerbosityLevel]", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)\",\"value\":\"\",\"promptText\":\"Enter the Client Setting Name\",\"defaultValue\":\"\",\"label\":\"Client Setting Name\",\"maxChars\":64,\"key\":\"setting\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||setting||", 
            "value": "LogVerbosityLevel"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Value Data\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Data | Type | Architecture | KeyPath | Value\n\n&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)\n\nstrKey = &quot;HKLM\\&quot;&amp;GetTaniumRegistryPath()\nstrValue = unescape(&quot;LogVerbosityLevel&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n&#039;strValue = &quot;Version&quot;\n\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n&#039;strValue = &quot;Emailname&quot;\nstrSep = &quot;~~&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\n\t\thasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\n\tEnd If\nEnd If\n\nIf Not (hasAnyResult) Then\n\tWScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\tarrTypes = Outparams.Types\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\t\n\t\t\t&#039;if strValue is found, echo\n\t\t\tIf LCase(strValueName) = LCase(strValue) Then\n\t\t\t\tEchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit\n\t\t\t\tCheckValues = True\n\t\t\t\tExit Function\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\tCheckValues = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit)\n\tIf intBit = 64 Then\n\t\tstrArch = &quot;64-bit&quot;\n\tElse\n\t\tstrArch = &quot;32-bit&quot;\n\tEnd If\n\t\t\t\n\tGetDisplayString = strValue\nEnd Function\n\nFunction EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)\n\t&#039; Note the key that was being searched, will be a hidden column\n\tstrOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n\t\n\tDim objInParams, objOutParams\n\tSelect Case constType\n\t\tCase REG_SZ  \n\t\t\tSet objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_EXPAND_SZ\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_BINARY\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)\n\n\t\t\tstrBytes = &quot;&quot;\n\t\t\tFor Each uByte in objOutParams.uValue\n\t\t\t\tstrTemp = Hex(uByte)\n\t\t\t\tIf Len(strTemp) &lt; 2 Then\n\t\t\t\t\tstrTemp = &quot;0&quot; &amp; strTemp\n\t\t\t\tEnd If\t\n\t\t\t\tstrBytes = strBytes &amp; strTemp &amp; &quot; &quot;\n\t\t\tNext\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)\n\t\tCase REG_DWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_QWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_MULTI_SZ\n\t\t    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tarrValues = objOutParams.sValue\n\t\t\tstrResponse = &quot;&quot;\n\n\t\t\tFor Each strTemp In arrValues\n\t\t\t\tIf strResponse = &quot;&quot; Then\n\t\t\t\t\tstrResponse = strTemp\n\t\t\t\tElse\n\t\t\t\t\tstrResponse = strResponse &amp; vbCrLf &amp; strTemp\n\t\t\t\tEnd If\n\t\t\tNext\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)\n\tEnd Select\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 31, 
      "string_count": 21244, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 429, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488397763, 
      "hidden_flag": 0, 
      "id": 4294967278, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Linux:tempsensor_17", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)\",\"value\":\"\",\"promptText\":\"Enter the Client Setting Name\",\"defaultValue\":\"\",\"label\":\"Client Setting Name\",\"maxChars\":64,\"key\":\"setting\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||setting||", 
            "value": "LogVerbosityLevel"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# LogVerbosityLevel  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# LogVerbosityLevel  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 31, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 430, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1488397328, 
      "hidden_flag": 0, 
      "id": 4294967277, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Tanium Client Explicit Setting[SaveClientStateIntervalInSeconds]", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)\",\"value\":\"\",\"promptText\":\"Enter the Client Setting Name\",\"defaultValue\":\"\",\"label\":\"Client Setting Name\",\"maxChars\":64,\"key\":\"setting\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||setting||", 
            "value": "SaveClientStateIntervalInSeconds"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Value Data\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Data | Type | Architecture | KeyPath | Value\n\n&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)\n\nstrKey = &quot;HKLM\\&quot;&amp;GetTaniumRegistryPath()\nstrValue = unescape(&quot;SaveClientStateIntervalInSeconds&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n&#039;strValue = &quot;Version&quot;\n\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n&#039;strValue = &quot;Emailname&quot;\nstrSep = &quot;~~&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\n\t\thasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\n\tEnd If\nEnd If\n\nIf Not (hasAnyResult) Then\n\tWScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\tarrTypes = Outparams.Types\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\t\n\t\t\t&#039;if strValue is found, echo\n\t\t\tIf LCase(strValueName) = LCase(strValue) Then\n\t\t\t\tEchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit\n\t\t\t\tCheckValues = True\n\t\t\t\tExit Function\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\tCheckValues = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit)\n\tIf intBit = 64 Then\n\t\tstrArch = &quot;64-bit&quot;\n\tElse\n\t\tstrArch = &quot;32-bit&quot;\n\tEnd If\n\t\t\t\n\tGetDisplayString = strValue\nEnd Function\n\nFunction EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)\n\t&#039; Note the key that was being searched, will be a hidden column\n\tstrOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n\t\n\tDim objInParams, objOutParams\n\tSelect Case constType\n\t\tCase REG_SZ  \n\t\t\tSet objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_EXPAND_SZ\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_BINARY\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)\n\n\t\t\tstrBytes = &quot;&quot;\n\t\t\tFor Each uByte in objOutParams.uValue\n\t\t\t\tstrTemp = Hex(uByte)\n\t\t\t\tIf Len(strTemp) &lt; 2 Then\n\t\t\t\t\tstrTemp = &quot;0&quot; &amp; strTemp\n\t\t\t\tEnd If\t\n\t\t\t\tstrBytes = strBytes &amp; strTemp &amp; &quot; &quot;\n\t\t\tNext\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)\n\t\tCase REG_DWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_QWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_MULTI_SZ\n\t\t    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tarrValues = objOutParams.sValue\n\t\t\tstrResponse = &quot;&quot;\n\n\t\t\tFor Each strTemp In arrValues\n\t\t\t\tIf strResponse = &quot;&quot; Then\n\t\t\t\t\tstrResponse = strTemp\n\t\t\t\tElse\n\t\t\t\t\tstrResponse = strResponse &amp; vbCrLf &amp; strTemp\n\t\t\t\tEnd If\n\t\t\tNext\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)\n\tEnd Select\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 31, 
      "string_count": 21244, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 431, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1487791808, 
      "hidden_flag": 0, 
      "id": 4294967276, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Linux:tempsensor_19", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)\",\"value\":\"\",\"promptText\":\"Enter the Client Setting Name\",\"defaultValue\":\"\",\"label\":\"Client Setting Name\",\"maxChars\":64,\"key\":\"setting\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||setting||", 
            "value": "SaveClientStateIntervalInSeconds"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# SaveClientStateIntervalInSeconds  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# SaveClientStateIntervalInSeconds  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 31, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 432, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1487792243, 
      "hidden_flag": 0, 
      "id": 4294967275, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Tanium Client Explicit Setting[RandomSensorDelayInSeconds]", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)\",\"value\":\"\",\"promptText\":\"Enter the Client Setting Name\",\"defaultValue\":\"\",\"label\":\"Client Setting Name\",\"maxChars\":64,\"key\":\"setting\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||setting||", 
            "value": "RandomSensorDelayInSeconds"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Registry Value Data\n&#039;========================================\n\n&#039;Columns:\n&#039; User | Data | Type | Architecture | KeyPath | Value\n\n&#039; Value is a hidden column for later use in sensor-fed actions (modify, delete)\n\nstrKey = &quot;HKLM\\&quot;&amp;GetTaniumRegistryPath()\nstrValue = unescape(&quot;RandomSensorDelayInSeconds&quot;)\n\n&#039;strKey = &quot;HKLM\\Software\\Tanium\\Tanium Client&quot;\n&#039;strValue = &quot;Version&quot;\n\n&#039;strKey = &quot;HKEY_USERS\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;\n&#039;strValue = &quot;Emailname&quot;\nstrSep = &quot;~~&quot;\n\n\n&#039;Constants for value types\nConst REG_SZ        = 1\nConst REG_EXPAND_SZ = 2\nConst REG_BINARY    = 3\nConst REG_DWORD     = 4\nConst REG_MULTI_SZ  = 7\nConst REG_QWORD     = 11\n\n\n&#039;Split up strKey into the hive constant and the registry key\nwords = Split(strKey, &quot;\\&quot;)\nstrHive = words(0)\nconstHive = GetHiveConst(strHive)\n\nstrKey = Right(strKey, Len(strKey) - Len(strHive) -1)\n\n&#039;Global for Username\nDim strUserName\nstrUserName = &quot;N/A&quot; &#039; default value, overridden if HKEY_USERS hive\n\n&#039;Set up registry objects for 32-bit, then check value\n&#039;Need to check all values of key in order to get type\nSet objCtx = GetObjCtx(32)\nSet objReg = GetObjReg(objCtx)\n\nIf strHive = &quot;HKEY_USERS&quot; Then\n&#039; go through each User&#039;s hive\n\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\thasValues32 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 32)\n\t\t\tIf hasValues32 Then hasAnyResult = True\n\t\tEnd If\n\tNext\nElse &#039; was another hive\n\thasValues32 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 32)\n\tIf hasValues32 Then hasAnyResult = True\nEnd If\n\n\nIf Is64 Then\n\tSet objCtx = GetObjCtx(64)\n\tSet objReg = GetObjReg(objCtx)\n\tIf strHive = &quot;HKEY_USERS&quot; Then\n\t&#039; go through each User&#039;s hive in 64-bit context\n\t\tFor Each strUserKey In GetSubKeys(objReg, objCtx, constHive, &quot;&quot;)\n\t\tIf Not InStr(strUserKey,&quot;_Classes&quot;) &gt; 0 Then &#039; ignore _Classes entries\n\t\t\t\tstrUserName = GetUserForSIDLocal(objReg,strUserKey)\n\t\t\t\tIf strUserName = False Then strUserName = strUserKey\n\t\t\t\tstrFullUserKey = strUserKey&amp;&quot;\\&quot;&amp;strKey\n\t\t\t\thasValues64 = CheckValues(objReg, objCTX, constHive, strFullUserKey, strValue, 64)\n\t\t\t\tIf hasValues64 Then hasAnyResult = True\t\n\t\t\tEnd If\n\t\tNext\n\tElse &#039; was another hive\n\t\thasValues64 = CheckValues(objReg, objCtx, constHive, strKey, strValue, 64)\n\t\tIf hasValues64 Then hasAnyResult = True\n\tEnd If\nEnd If\n\nIf Not (hasAnyResult) Then\n\tWScript.Echo &quot;Key/Value not found&quot;\nEnd If\n\nFunction GetTaniumRegistryPath\n&#039;GetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n    Dim objShell\n    Dim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n      \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n    keyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n    keyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n    strFoundTaniumRegistryPath = keyNativePath\n \n    If strPath = &quot;&quot; Then\n        &#039; Could not find 32-bit mode path, checking Wow6432Node\n        On Error Resume Next\n        strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n        On Error Goto 0\n        strFoundTaniumRegistryPath = keyWoWPath\n    End If\n    \n    If Not strPath = &quot;&quot; Then\n        GetTaniumRegistryPath = strFoundTaniumRegistryPath\n    Else\n        GetTaniumRegistryPath = False\n        WScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n    End If\nEnd Function &#039;GetTaniumRegistryPath\n\nFunction RegKeyExists(objRegistry, sHive, sRegKey)\n\tDim aValueNames, aValueTypes\n\tIf objRegistry.EnumValues(sHive, sRegKey, aValueNames, aValueTypes) = 0 Then\n\t\tRegKeyExists = True\n\tElse\n\t\tRegKeyExists = False\n\tEnd If\nEnd Function &#039;RegKeyExists\n\n&#039;Goes through all values in a key, returns True if strValue is found\nFunction CheckValues(objReg, objCtx, constHive, strKey, strValue, intBit)\n\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumValues&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumValues&quot;, Inparams,,objCtx)\n\t\n\tarrNames = Outparams.sNames\n\tarrTypes = Outparams.Types\n\n\tIf Not IsNull(arrNames) Then\n\t\tFor i = LBound(arrNames) To UBound(arrNames)\n\t\t\tstrValueName = arrNames(i)\n\t\t\t\n\t\t\t&#039;if strValue is found, echo\n\t\t\tIf LCase(strValueName) = LCase(strValue) Then\n\t\t\t\tEchoValue objReg, objCtx, constHive, strKey, strValue, arrTypes(i), intBit\n\t\t\t\tCheckValues = True\n\t\t\t\tExit Function\n\t\t\tEnd If\n\t\tNext\n\tEnd If\n\tCheckValues = False\nEnd Function\n\nFunction GetDisplayString(strKey, strType, strValue, intBit)\n\tIf intBit = 64 Then\n\t\tstrArch = &quot;64-bit&quot;\n\tElse\n\t\tstrArch = &quot;32-bit&quot;\n\tEnd If\n\t\t\t\n\tGetDisplayString = strValue\nEnd Function\n\nFunction EchoValue(objReg, objCtx, constHive, strKey, strValue, constType, intBit)\n\t&#039; Note the key that was being searched, will be a hidden column\n\tstrOutputKey = strHive&amp;&quot;\\&quot;&amp;strKey\n\t\n\tDim objInParams, objOutParams\n\tSelect Case constType\n\t\tCase REG_SZ  \n\t\t\tSet objInParams = objReg.Methods_(&quot;GetStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_EXPAND_SZ\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetExpandedStringValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetExpandedStringValue&quot;, objInParams, , objCtx)\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_EXPAND_SZ&quot;, objOutParams.sValue, intBit)\n\t\tCase REG_BINARY\n\t\t\tSet objInParams = objReg.Methods_(&quot;GetBinaryValue&quot;).InParameters\n\t\t\tobjInParams.hDefKey = constHive\n\t\t\tobjInParams.sSubKeyName = strKey\n\t\t\tobjInParams.sValueName = strValue\t\t\t\n\t\t\tSet objOutParams = objReg.ExecMethod_(&quot;GetBinaryValue&quot;, objInParams, , objCtx)\n\n\t\t\tstrBytes = &quot;&quot;\n\t\t\tFor Each uByte in objOutParams.uValue\n\t\t\t\tstrTemp = Hex(uByte)\n\t\t\t\tIf Len(strTemp) &lt; 2 Then\n\t\t\t\t\tstrTemp = &quot;0&quot; &amp; strTemp\n\t\t\t\tEnd If\t\n\t\t\t\tstrBytes = strBytes &amp; strTemp &amp; &quot; &quot;\n\t\t\tNext\n\t\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_BINARY&quot;, strBytes, intBit)\n\t\tCase REG_DWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetDWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetDWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_DWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_QWORD\n\t\t    Set objInParams = objReg.Methods_(&quot;GetQWordValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetQWordValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_QWORD&quot;, CStr(objOutParams.uValue), intBit)\n\t\tCase REG_MULTI_SZ\n\t\t    Set objInParams = objReg.Methods_(&quot;GetMultiStringValue&quot;).InParameters\n\t\t    objInParams.hDefKey = constHive\n\t\t    objInParams.sSubKeyName = strKey\n\t\t    objInParams.sValueName = strValue\n\t\t    Set objOutParams = objReg.ExecMethod_(&quot;GetMultiStringValue&quot;, objInParams, , objCtx)\n\t\t\n\t\t\tarrValues = objOutParams.sValue\n\t\t\tstrResponse = &quot;&quot;\n\n\t\t\tFor Each strTemp In arrValues\n\t\t\t\tIf strResponse = &quot;&quot; Then\n\t\t\t\t\tstrResponse = strTemp\n\t\t\t\tElse\n\t\t\t\t\tstrResponse = strResponse &amp; vbCrLf &amp; strTemp\n\t\t\t\tEnd If\n\t\t\tNext\n\t\t\n\t\t\tWScript.Echo GetDisplayString(strKey, &quot;REG_MULTI_SZ&quot;, strResponse, intBit)\n\tEnd Select\nEnd Function\n\n\nFunction GetObjCtx(intArch)\n\tDim objCtx\n\tSet objCtx = CreateObject(&quot;WbemScripting.SWbemNamedValueSet&quot;)\n\tobjCtx.Add &quot;__ProviderArchitecture&quot;, intArch\n\tobjCtx.Add &quot;__RequiredArchitecture&quot;, TRUE\n\tSet GetObjCtx = objCtx\nEnd Function\n\nFunction GetObjReg(objCtx)\n\tDim objLocator, objServices\n\tSet objLocator = CreateObject(&quot;Wbemscripting.SWbemLocator&quot;)\n\tSet objServices = objLocator.ConnectServer(&quot;&quot;,&quot;root\\default&quot;,&quot;&quot;,&quot;&quot;,,,,objCtx)\n\tSet GetObjReg = objServices.Get(&quot;StdRegProv&quot;) \nEnd Function\n\nFunction GetSubKeys(objReg, objCtx, constHive, strKey)\n\tDim Inparams, Outparams\n\tSet Inparams = objReg.Methods_(&quot;EnumKey&quot;).Inparameters\n\tInparams.Hdefkey = constHive\n\tInparams.sSubkeyname = strKey\n\tSet Outparams = objReg.ExecMethod_(&quot;EnumKey&quot;, Inparams,,objCtx)\n\tGetSubKeys = Outparams.sNames\nEnd Function\n\nFunction Is64 \n\tDim objWMIService, colItems, objItem\n\tSet objWMIService = GetObject(&quot;winmgmts:\\\\.\\root\\CIMV2&quot;)\n\tSet colItems = objWMIService.ExecQuery(&quot;Select SystemType from Win32_ComputerSystem&quot;)    \n\tFor Each objItem In colItems\n\t\tIf InStr(LCase(objItem.SystemType), &quot;x64&quot;) &gt; 0 Then\n\t\t\tIs64 = True\n\t\tElse\n\t\t\tIs64 = False\n\t\tEnd If\t\t\n\tNext\nEnd Function\n\n\nFunction GetHiveConst(hive)\n\tConst HKEY_CLASSES_ROOT   = &amp;H80000000\n\tConst HKEY_CURRENT_USER   = &amp;H80000001\n\tConst HKEY_LOCAL_MACHINE  = &amp;H80000002\n\tConst HKEY_USERS          = &amp;H80000003\n\n\tSelect Case UCase(hive)\n\t\tCase &quot;HKLM&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKEY_LOCAL_MACHINE&quot;\n\t\t\tGetHiveConst = HKEY_LOCAL_MACHINE\n\t\tCase &quot;HKCR&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CLASSES_ROOT&quot;\n\t\t\tGetHiveConst = HKEY_CLASSES_ROOT\n\t\tCase &quot;HKEY_CURRENT_USER&quot;\n\t\t\tGetHiveConst = HKEY_CURRENT_USER\n\t\tCase &quot;HKEY_USERS&quot;\n\t\t\tGetHiveConst = HKEY_USERS\n\tEnd Select\n\t\n\tIf IsEmpty(GetHiveConst) Then\n\t\tWScript.Echo &quot;Invalid registry hive: &quot; &amp; hive\n\t\tWScript.Quit\n\tEnd If\nEnd Function\n\nFunction GetUserForSIDLocal(objReg,strSID)\n&#039; This function converts a SID to a user name\n&#039; by doing a registry lookup, avoiding an LDAP query\n&#039; this will fail in the case where the user&#039;s name was changed in AD\n&#039; as they will still have their old home directory name\n\n\tConst HKLM = &amp;h80000002\n\t\n\tDim strHiveListKey,strUserData,intDatPos,intFinalBackslashPos\n\t\n\tstrHiveListKey = &quot;SYSTEM\\CurrentControlSet\\Control\\hivelist&quot;\n\tobjReg.GetStringValue HKLM,strHiveListKey,&quot;\\Registry\\User\\&quot;&amp;strSID,strUserData\n\tIf Not IsNull(strUserData) Then\n\t&#039; strUserData would look like\n\t&#039; \\Device\\HarddiskVolume2\\Users\\user.name\\NTUSER.DAT\n\t\tintDatPos = InStr(UCase(strUserData),&quot;\\NTUSER.DAT&quot;)\n\t\t&#039; strip off the dat file\n\t\tIf intDatPos &gt; 0 Then &#039; must be in string\n\t\t\tstrUserData = Left(strUserData,intDatPos - 1)\n\t\t\t&#039; find last backslash\n\t\t\tintFinalBackslashPos = InStrRev(strUserData,&quot;\\&quot;)\n\t\t\t&#039; get right from that pos\n\t\t\tstrUserData = Right(strUserData,Len(strUserData) - intFinalBackslashPos)\n\t\t\tGetUserForSIDLocal = strUserData\n\t\tElse\n\t\t\tstrUserData = False\n\t\tEnd If\n\tElse\n\t\tGetUserForSIDLocal = False\n\tEnd If\nEnd Function &#039;GetUserForSIDLocal", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 31, 
      "string_count": 766, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 433, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1487792678, 
      "hidden_flag": 0, 
      "id": 4294967274, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 900, 
      "name": "Linux:tempsensor_21", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"^\\\\S\",\"helpString\":\"Value can not be blank\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)\",\"value\":\"\",\"promptText\":\"Enter the Client Setting Name\",\"defaultValue\":\"\",\"label\":\"Client Setting Name\",\"maxChars\":64,\"key\":\"setting\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||setting||", 
            "value": "RandomSensorDelayInSeconds"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# RandomSensorDelayInSeconds  \n\necho &quot;N/A on Linux&quot;\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/sh\n\n# THIS IS A STUB - NOT INTENDED AS FUNCTIONAL - NA\n# {&quot;parameters&quot;:[{&quot;validationExpressions&quot;:[{&quot;helpString&quot;:&quot;Value can not be blank&quot;,&quot;flags&quot;:&quot;&quot;,&quot;expression&quot;:&quot;^\\S&quot;,&quot;parameterType&quot;:&quot;com.tanium.models::ValidationExpression&quot;,&quot;model&quot;:&quot;com.tanium.models::ValidationExpression&quot;}],&quot;key&quot;:&quot;setting&quot;,&quot;promptText&quot;:&quot;Enter the Client Setting Name&quot;,&quot;label&quot;:&quot;Client Setting Name&quot;,&quot;helpString&quot;:&quot;The Client Setting Name must be typed exactly as it appears in the client registry, including necessary underscores. NOTE: most settings have no spaces (Example: LogVerbosityLevel)&quot;,&quot;value&quot;:&quot;&quot;,&quot;defaultValue&quot;:&quot;&quot;,&quot;restrict&quot;:null,&quot;maxChars&quot;:64,&quot;parameterType&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::TextInputParameter&quot;}],&quot;parameterType&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;,&quot;model&quot;:&quot;com.tanium.components.parameters::ParametersArray&quot;}\n# RandomSensorDelayInSeconds  \n\necho &quot;N/A on Mac&quot;\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 31, 
      "string_count": 0, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 434, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1487793113, 
      "hidden_flag": 0, 
      "id": 4294967273, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Folder Name Search with RegEx Match[No, Program Files, No, ]", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the folder name to search for\",\"value\":\"\",\"promptText\":\"e.g Program Files\",\"defaultValue\":\"\",\"label\":\"Search for Folder Name\",\"maxChars\":0,\"key\":\"dirname\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the regular expression to search for.\",\"value\":\"\",\"promptText\":\"e.g. test*.exe\",\"defaultValue\":\"\",\"label\":\"Regular Expression\",\"maxChars\":0,\"key\":\"regexp\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"helpString\":\"Enter Yes/No for case sensitivity of search.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Case sensitive?\",\"key\":\"casesensitive\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"},{\"helpString\":\"Enter Yes/No whether the search is global.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Global\",\"key\":\"global\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||casesensitive||", 
            "value": "No"
          }, 
          {
            "_type": "parameter", 
            "key": "||dirname||", 
            "value": "Program Files"
          }, 
          {
            "_type": "parameter", 
            "key": "||global||", 
            "value": "No"
          }, 
          {
            "_type": "parameter", 
            "key": "||regexp||"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&#039;========================================\n&#039; Folder Name Search with RegEx Match\n&#039;========================================\n&#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\n\nSensorRandomize()\n\nDim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg\nDim bGlobal,bCaseSensitive\n\nPattern = unescape(&quot;Program%20Files&quot;)\nstrRegExp = Trim(Unescape(&quot;&quot;))\nstrGlobalArg = Trim(Unescape(&quot;No&quot;))\nstrCaseSensitiveArg = Trim(Unescape(&quot;No&quot;))\n\nbGlobal = GetTrueFalseArg(&quot;global&quot;,strGlobalArg)\nbCaseSensitive = GetTrueFalseArg(&quot;casesensitive&quot;,strCaseSensitiveArg)\n\nConst SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1\n\nDim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine\n\nSet FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\nSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\nOutputFilename = TempName() &#039; a temporary file in system&#039;s temp dir\n\n&#039; Go through file system, refresh output file for filename\nIf Not FSO.FileExists(OutputFilename) Then\n\t\n\tIf FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename\n\n\t&#039; Get the collection of local drives.\n\tSet Drives = FSO.Drives\n\tFor Each Drive in Drives\n\t\tIf Drive.DriveType = 2 Then &#039; 2 = Fixed drive\n\t\t\t&#039; Run the Dir command that looks for the filename pattern.\n\t\t\tRunCommand &quot;dir &quot; &amp;Chr(34)&amp; Drive.DriveLetter &amp; &quot;:\\&quot; &amp; Pattern &amp; Chr(34)&amp;&quot; /a:D /B /S&quot;, OutputFilename, true\n\t\tEnd If\n\tNext\nEnd If\n\n&#039; Open the output file, echo each line, and then close and delete it.\nSet TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)\nDo While Not TextStream.AtEndOfStream\n\tstrLine = TextStream.ReadLine()\n\tIf RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then\n\t\tWScript.Echo strLine\n\tEnd If\nLoop\n\n\nTextStream.Close()\n \nIf FSO.FileExists(OutputFileName) Then\n\tOn Error Resume Next\n\tFSO.DeleteFile OutputFileName, True\n\tOn Error Goto 0\nEnd If\n\nFunction RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)\n\n\tDim re\n\tSet re = New RegExp\n\tWith re\n\t  .Pattern = strPattern\n\t  .Global = bGlobal\n\t  .IgnoreCase = Not bIsCaseSensitive\n\tEnd With\n\t\n\tRegExpMatch = re.Test(strToMatch)\n\nEnd Function &#039;RegExpMatch\n\n\nFunction GetTrueFalseArg(strArgName,strArgValue)\n\t&#039; Checks for valid values, will fail with error message\n\t\n\tDim bArgVal\n\tbArgVal = False\n\tSelect Case LCase(strArgValue)\n\t\tCase &quot;true&quot;\n\t\t\tbArgVal = True\n\t\tCase &quot;yes&quot;\n\t\t\tbArgVal = True\n\t\tCase &quot;false&quot;\n\t\t\tbArgVal = False\n\t\tCase &quot;no&quot;\n\t\t\tbArgVal = False\n\t\tCase Else\n\t\t\tWScript.Echo &quot;Error: Argument &#039;&quot;&amp;strArgName&amp;&quot;&#039; must be True or False, quitting&quot;\n\t\t\tPrintUsage\n\tEnd Select\n\tGetTrueFalseArg = bArgVal\n\nEnd Function &#039;GetTrueFalseArg\n\n\n&#039; Returns the name of a temporary file in the Temp directory.\nFunction TempName()\n\tDim Result\n\tDo\n \t\tResult = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())\n\t\tWScript.Sleep 200 &#039;avoid potential busy loop\n\tLoop While FSO.FileExists(Result)\n\t\n\tTempName = Result\nEnd Function &#039;TempName\n\n&#039; Runs a command with Cmd.exe and redirects its output to a temporary\n&#039; file. The function returns the name of the temporary file that holds\n&#039; the command&#039;s output.\nFunction RunCommand(Command, OutputFilename, b64BitNecessary)\n\t&#039; 64BitNecessary true when you need to examine the 64-bit areas like system32\n\tDim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet WshShell = CreateObject(&quot;WScript.Shell&quot;)\n\t\n\tstrDOSCall = &quot;%ComSpec% /C &quot;\n\t\n\t&#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection\n\tstrProgramFilesx86=WshShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\tIf objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &#039; quick check for x64\n\t\tstrDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))\n\tEnd If\n\t\t\n\tCommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp; Command &amp; &quot; &gt;&gt; &quot;&quot;&quot; &amp; OutputFileName &amp; &quot;&quot;&quot;&quot;)\n\tWshShell.Run CommandLine, 0, True\nEnd Function &#039;RunCommand\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&#039; This function will fix a folder location so that\n&#039; a 32-bit program can be passed the windows\\system32 directory\n&#039; as a parameter.\n&#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&#039; program called in a 64-bit environment cannot access\n&#039; the system32 directory - it would be redirected to syswow64.\n&#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)\n\tSet objShell = CreateObject(&quot;Wscript.Shell&quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles%&quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&quot;%ProgramFiles(x86)%&quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&quot;&quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&quot;system32&quot;,&quot;sysnative&quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &#039;FixFileSystemRedirectionForPath\n&#039;------------ INCLUDES after this line. Do not edit past this point -----\n&#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&#039;&#039; -- Begin Random Sleep Functions -- &#039;&#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&#039; sleeps for a random period of time, intSleepTime is in seconds\n&#039; if the sensor randomize flag is on\n&#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;&quot;\\Sensor Data\\Random Sleep&quot;\n\t\n\tSet objShell = CreateObject(&quot;WScript.Shell&quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeFlag&quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&quot;HKLM\\&quot;&amp;strRandomizeRegPath&amp;&quot;\\SensorRandomizeScalingPercentage&quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &quot;Randomize scaling percentage of &quot; _ \n\t\t\t\t&amp; intRandomizeScalingPercentage &amp; &quot; applied, new sleep time is &quot; &amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &#039; convert to milliseconds\n\t\t&#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &quot;Sleeping for &quot; &amp; intSensorRandomizeWaitTime &amp; &quot; milliseconds&quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &quot;Done sleeping, continuing ...&quot;\n\tElse \n\t\tSensorRandomizeEcho &quot;SensorRandomize Not Enabled - No Op&quot;\n\tEnd If\nEnd Function &#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    \n\tkeyNativePath = &quot;Software\\Tanium\\Tanium Client&quot;\n\tkeyWoWPath = &quot;Software\\Wow6432Node\\Tanium\\Tanium Client&quot;\n    \n    &#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyNativePath&amp;&quot;\\Path&quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &quot;&quot; Then\n  \t\t&#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&quot;HKLM\\&quot;&amp;keyWoWPath&amp;&quot;\\Path&quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &quot;&quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &quot;Error: Cannot locate Tanium Registry Path&quot;\n  \tEnd If\nEnd Function &#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&#039;&#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &quot;ComputerID&quot;\n    Set objShell = CreateObject(&quot;WScript.Shell&quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&quot;HKLM\\&quot;&amp;strKeyPath&amp;&quot;\\&quot;&amp;strValueName)\n    If Err.Number &lt;&gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &#039;SensorRandomizeEcho\n&#039; -- End Random Sleep Functions --&#039;\n&#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }
        ]
      }, 
      "source_id": 381, 
      "string_count": 513, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 435, 
      "delimiter": ",", 
      "exclude_from_parse_flag": 1, 
      "hash": 1487793548, 
      "hidden_flag": 0, 
      "id": 4294967272, 
      "ignore_case_flag": 1, 
      "max_age_seconds": 600, 
      "name": "Linux:tempsensor_23", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the folder name to search for\",\"value\":\"\",\"promptText\":\"e.g Program Files\",\"defaultValue\":\"\",\"label\":\"Search for Folder Name\",\"maxChars\":0,\"key\":\"dirname\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the regular expression to search for.\",\"value\":\"\",\"promptText\":\"e.g. test*.exe\",\"defaultValue\":\"\",\"label\":\"Regular Expression\",\"maxChars\":0,\"key\":\"regexp\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"helpString\":\"Enter Yes/No for case sensitivity of search.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Case sensitive?\",\"key\":\"casesensitive\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"},{\"helpString\":\"Enter Yes/No whether the search is global.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Global\",\"key\":\"global\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "parameters": {
        "_type": "parameters", 
        "parameter": [
          {
            "_type": "parameter", 
            "key": "||casesensitive||", 
            "value": "No"
          }, 
          {
            "_type": "parameter", 
            "key": "||dirname||", 
            "value": "Program Files"
          }, 
          {
            "_type": "parameter", 
            "key": "||global||", 
            "value": "No"
          }, 
          {
            "_type": "parameter", 
            "key": "||regexp||"
          }
        ]
      }, 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n#Program%20FilesNoNo\necho Windows Only\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n#Program%20FilesNoNo\necho Windows Only\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 381, 
      "string_count": 3, 
      "value_type": "String"
    }, 
    {
      "_type": "sensor", 
      "cache_row_id": 436, 
      "category": "File System", 
      "creation_time": "2015-01-05T20:29:39", 
      "delimiter": ",", 
      "description": "Finds the specified folder and provides the full path if the folder exists on the client machine. Takes regular expression to match.\nExample: C:\\WINDOWS\\System32", 
      "exclude_from_parse_flag": 1, 
      "hash": 839342978, 
      "hidden_flag": 0, 
      "id": 821, 
      "ignore_case_flag": 1, 
      "last_modified_by": "Tanium User", 
      "max_age_seconds": 600, 
      "metadata": {
        "_type": "metadata", 
        "item": [
          {
            "_type": "item", 
            "admin_flag": 0, 
            "name": "defined", 
            "value": "McAfee"
          }
        ]
      }, 
      "modification_time": "2015-01-05T20:29:39", 
      "name": "Folder Name Search with RegEx Match API TEST", 
      "parameter_definition": "{\"parameters\":[{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the folder name to search for\",\"value\":\"\",\"promptText\":\"e.g Program Files\",\"defaultValue\":\"\",\"label\":\"Search for Folder Name\",\"maxChars\":0,\"key\":\"dirname\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"restrict\":null,\"validationExpressions\":[{\"flags\":\"\",\"expression\":\"\\\\S{3}\",\"helpString\":\"Value must be at least 3 characters\",\"model\":\"com.tanium.models::ValidationExpression\",\"parameterType\":\"com.tanium.models::ValidationExpression\"}],\"helpString\":\"Enter the regular expression to search for.\",\"value\":\"\",\"promptText\":\"e.g. test*.exe\",\"defaultValue\":\"\",\"label\":\"Regular Expression\",\"maxChars\":0,\"key\":\"regexp\",\"model\":\"com.tanium.components.parameters::TextInputParameter\",\"parameterType\":\"com.tanium.components.parameters::TextInputParameter\"},{\"helpString\":\"Enter Yes/No for case sensitivity of search.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Case sensitive?\",\"key\":\"casesensitive\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"},{\"helpString\":\"Enter Yes/No whether the search is global.\",\"value\":\"\",\"promptText\":\"\",\"defaultValue\":\"\",\"requireSelection\":true,\"label\":\"Global\",\"key\":\"global\",\"values\":[\"No\",\"Yes\"],\"model\":\"com.tanium.components.parameters::DropDownParameter\",\"parameterType\":\"com.tanium.components.parameters::DropDownParameter\"}],\"model\":\"com.tanium.components.parameters::ParametersArray\",\"parameterType\":\"com.tanium.components.parameters::ParametersArray\"}", 
      "queries": {
        "_type": "queries", 
        "query": [
          {
            "_type": "query", 
            "platform": "Windows", 
            "script": "&amp;#039;========================================\n&amp;#039; Folder Name Search with RegEx Match\n&amp;#039;========================================\n&amp;#039;@INCLUDE=utils/SensorRandomization/SensorRandomizationFunctions.vbs\nOption Explicit\n\nSensorRandomize()\n\nDim Pattern,strRegExp,strGlobalArg,strCaseSensitiveArg\nDim bGlobal,bCaseSensitive\n\nPattern = unescape(&amp;quot;||dirname||&amp;quot;)\nstrRegExp = Trim(Unescape(&amp;quot;||regexp||&amp;quot;))\nstrGlobalArg = Trim(Unescape(&amp;quot;||global||&amp;quot;))\nstrCaseSensitiveArg = Trim(Unescape(&amp;quot;||casesensitive||&amp;quot;))\n\nbGlobal = GetTrueFalseArg(&amp;quot;global&amp;quot;,strGlobalArg)\nbCaseSensitive = GetTrueFalseArg(&amp;quot;casesensitive&amp;quot;,strCaseSensitiveArg)\n\nConst SYSTEM_FOLDER = 1, TEMP_FOLDER = 2, FOR_READING = 1\n\nDim FSO, WshShell, Drives, Drive, TextStream, OutputFilename, strLine\n\nSet FSO = CreateObject(&amp;quot;Scripting.FileSystemObject&amp;quot;)\nSet WshShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)\n\nOutputFilename = TempName() &amp;#039; a temporary file in system&amp;#039;s temp dir\n\n&amp;#039; Go through file system, refresh output file for filename\nIf Not FSO.FileExists(OutputFilename) Then\n\t\n\tIf FSO.FileExists(OutputFilename) Then FSO.DeleteFile OutputFilename\n\n\t&amp;#039; Get the collection of local drives.\n\tSet Drives = FSO.Drives\n\tFor Each Drive in Drives\n\t\tIf Drive.DriveType = 2 Then &amp;#039; 2 = Fixed drive\n\t\t\t&amp;#039; Run the Dir command that looks for the filename pattern.\n\t\t\tRunCommand &amp;quot;dir &amp;quot; &amp;amp;Chr(34)&amp;amp; Drive.DriveLetter &amp;amp; &amp;quot;:\\&amp;quot; &amp;amp; Pattern &amp;amp; Chr(34)&amp;amp;&amp;quot; /a:D /B /S&amp;quot;, OutputFilename, true\n\t\tEnd If\n\tNext\nEnd If\n\n&amp;#039; Open the output file, echo each line, and then close and delete it.\nSet TextStream = FSO.OpenTextFile(OutputFileName, FOR_READING)\nDo While Not TextStream.AtEndOfStream\n\tstrLine = TextStream.ReadLine()\n\tIf RegExpMatch(strRegExp,strLine,bGlobal,bCaseSensitive) Then\n\t\tWScript.Echo strLine\n\tEnd If\nLoop\n\n\nTextStream.Close()\n \nIf FSO.FileExists(OutputFileName) Then\n\tOn Error Resume Next\n\tFSO.DeleteFile OutputFileName, True\n\tOn Error Goto 0\nEnd If\n\nFunction RegExpMatch(strPattern,strToMatch,bGlobal,bIsCaseSensitive)\n\n\tDim re\n\tSet re = New RegExp\n\tWith re\n\t  .Pattern = strPattern\n\t  .Global = bGlobal\n\t  .IgnoreCase = Not bIsCaseSensitive\n\tEnd With\n\t\n\tRegExpMatch = re.Test(strToMatch)\n\nEnd Function &amp;#039;RegExpMatch\n\n\nFunction GetTrueFalseArg(strArgName,strArgValue)\n\t&amp;#039; Checks for valid values, will fail with error message\n\t\n\tDim bArgVal\n\tbArgVal = False\n\tSelect Case LCase(strArgValue)\n\t\tCase &amp;quot;true&amp;quot;\n\t\t\tbArgVal = True\n\t\tCase &amp;quot;yes&amp;quot;\n\t\t\tbArgVal = True\n\t\tCase &amp;quot;false&amp;quot;\n\t\t\tbArgVal = False\n\t\tCase &amp;quot;no&amp;quot;\n\t\t\tbArgVal = False\n\t\tCase Else\n\t\t\tWScript.Echo &amp;quot;Error: Argument &amp;#039;&amp;quot;&amp;amp;strArgName&amp;amp;&amp;quot;&amp;#039; must be True or False, quitting&amp;quot;\n\t\t\tPrintUsage\n\tEnd Select\n\tGetTrueFalseArg = bArgVal\n\nEnd Function &amp;#039;GetTrueFalseArg\n\n\n&amp;#039; Returns the name of a temporary file in the Temp directory.\nFunction TempName()\n\tDim Result\n\tDo\n \t\tResult = FSO.BuildPath(FSO.GetSpecialFolder(TEMP_FOLDER), FSO.GetTempName())\n\t\tWScript.Sleep 200 &amp;#039;avoid potential busy loop\n\tLoop While FSO.FileExists(Result)\n\t\n\tTempName = Result\nEnd Function &amp;#039;TempName\n\n&amp;#039; Runs a command with Cmd.exe and redirects its output to a temporary\n&amp;#039; file. The function returns the name of the temporary file that holds\n&amp;#039; the command&amp;#039;s output.\nFunction RunCommand(Command, OutputFilename, b64BitNecessary)\n\t&amp;#039; 64BitNecessary true when you need to examine the 64-bit areas like system32\n\tDim CommandLine,WshShell,strPRogramFilesx86,strDOSCall,objFSO\n\tSet objFSO = CreateObject(&amp;quot;Scripting.FileSystemObject&amp;quot;)\n\tSet WshShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)\n\t\n\tstrDOSCall = &amp;quot;%ComSpec% /C &amp;quot;\n\t\n\t&amp;#039; if 64-bit OS *and* we must examine in 64-bit mode to avoid FS Redirection\n\tstrProgramFilesx86=WshShell.ExpandEnvironmentStrings(&amp;quot;%ProgramFiles%&amp;quot;)\n\tIf objFSO.FolderExists(strProgramFilesx86) And b64BitNecessary Then &amp;#039; quick check for x64\n\t\tstrDOSCall = FixFileSystemRedirectionForPath(WshShell.ExpandEnvironmentStrings(strDOSCall))\n\tEnd If\n\t\t\n\tCommandLine = WshShell.ExpandEnvironmentStrings(strDOSCall &amp;amp; Command &amp;amp; &amp;quot; &amp;gt;&amp;gt; &amp;quot;&amp;quot;&amp;quot; &amp;amp; OutputFileName &amp;amp; &amp;quot;&amp;quot;&amp;quot;&amp;quot;)\n\tWshShell.Run CommandLine, 0, True\nEnd Function &amp;#039;RunCommand\n\nFunction FixFileSystemRedirectionForPath(strFilePath)\n&amp;#039; This function will fix a folder location so that\n&amp;#039; a 32-bit program can be passed the windows\\system32 directory\n&amp;#039; as a parameter.\n&amp;#039; Even if the sensor or action runs in 64-bit mode, a 32-bit\n&amp;#039; program called in a 64-bit environment cannot access\n&amp;#039; the system32 directory - it would be redirected to syswow64.\n&amp;#039; you would not want to do this for 64-bit programs.\n\t\n\tDim objFSO, strSystem32Location,objShell\n\tDim strProgramFilesx86,strNewSystem32Location,strRestOfPath\n\tSet objFSO = CreateObject(&amp;quot;Scripting.FileSystemObject&amp;quot;)\n\tSet objShell = CreateObject(&amp;quot;Wscript.Shell&amp;quot;)\n\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&amp;quot;%ProgramFiles%&amp;quot;)\n\n\tstrFilePath = LCase(strFilePath)\n\tstrSystem32Location = LCase(objFSO.GetSpecialFolder(1))\n\tstrProgramFilesx86=objShell.ExpandEnvironmentStrings(&amp;quot;%ProgramFiles(x86)%&amp;quot;)\n\t\n\tIf objFSO.FolderExists(strProgramFilesx86) Then &amp;#039; quick check for x64\n\t\tIf InStr(strFilePath,strSystem32Location) = 1 Then\n\t\t\tstrRestOfPath = Replace(strFilePath,strSystem32Location,&amp;quot;&amp;quot;)\n\t\t\tstrNewSystem32Location = Replace(strSystem32Location,&amp;quot;system32&amp;quot;,&amp;quot;sysnative&amp;quot;)\n\t\t\tstrFilePath = strNewSystem32Location&amp;amp;strRestOfPath\n\t\tEnd If\n\tEnd If\n\tFixFileSystemRedirectionForPath = strFilePath\n\t\n\t&amp;#039;Cleanup\n\tSet objFSO = Nothing\nEnd Function &amp;#039;FixFileSystemRedirectionForPath\n&amp;#039;------------ INCLUDES after this line. Do not edit past this point -----\n&amp;#039;- Begin file: utils/SensorRandomization/SensorRandomizationFunctions.vbs\n&amp;#039;&amp;#039; -- Begin Random Sleep Functions -- &amp;#039;&amp;#039;\n\nDim bSensorRandomizeDebugOutput : bSensorRandomizeDebugOutput = False\n\nFunction SensorRandomizeLow()\n    Dim intSensorRandomizeWaitLow : intSensorRandomizeWaitLow = 10\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitLow)\nEnd Function &amp;#039; SensorRandomizeLow\n\nFunction SensorRandomize()\n    Dim intSensorRandomizeWaitMed : intSensorRandomizeWaitMed = 20\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitMed)\nEnd Function &amp;#039; SensorRandomize\n\nFunction SensorRandomizeHigh()\n    Dim intSensorRandomizeWaitHigh : intSensorRandomizeWaitHigh = 30\n    SensorRandomizeRandomSleep(intSensorRandomizeWaitHigh)\nEnd Function &amp;#039; SensorRandomize\n\nFunction SensorRandomizeRandomSleep(intSleepTime)\n&amp;#039; sleeps for a random period of time, intSleepTime is in seconds\n&amp;#039; if the sensor randomize flag is on\n&amp;#039; RandomizeScalingFactor is a multiplier on the values hardcoded in the sensor\n&amp;#039; not typically set but can adjust timings per endpoint, optionally\n\tDim intSensorRandomizeWaitTime\n\tDim objShell,intRandomizeFlag,strRandomizeRegPath,intRandomizeScalingPercentage\n\tstrRandomizeRegPath = SensorRandomizeGetTaniumRegistryPath&amp;amp;&amp;quot;\\Sensor Data\\Random Sleep&amp;quot;\n\t\n\tSet objShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)\n\tOn Error Resume Next\n\tintRandomizeFlag = objShell.RegRead(&amp;quot;HKLM\\&amp;quot;&amp;amp;strRandomizeRegPath&amp;amp;&amp;quot;\\SensorRandomizeFlag&amp;quot;)\n\tintRandomizeScalingPercentage = objShell.RegRead(&amp;quot;HKLM\\&amp;quot;&amp;amp;strRandomizeRegPath&amp;amp;&amp;quot;\\SensorRandomizeScalingPercentage&amp;quot;)\n\tOn Error Goto 0\n\tIf intRandomizeFlag &amp;gt; 0 Then\n\t\tIf intRandomizeScalingPercentage &amp;gt; 0 Then\n\t\t\tintSleepTime = intRandomizeScalingPercentage * .01 * intSleepTime\n\t\t\tSensorRandomizeEcho &amp;quot;Randomize scaling percentage of &amp;quot; _ \n\t\t\t\t&amp;amp; intRandomizeScalingPercentage &amp;amp; &amp;quot; applied, new sleep time is &amp;quot; &amp;amp; intSleepTime\n\t\tEnd If\n\t\tintSensorRandomizeWaitTime = CLng(intSleepTime) * 1000 &amp;#039; convert to milliseconds\n\t\t&amp;#039; wait random interval between 0 and the max\n\t\tRandomize(SensorRandomizeTaniumRandomSeed)\n\t\t&amp;#039; assign random value to wait time max value\n\t\tintSensorRandomizeWaitTime = Int( ( intSensorRandomizeWaitTime + 1 ) * Rnd )\n\t\tSensorRandomizeEcho &amp;quot;Sleeping for &amp;quot; &amp;amp; intSensorRandomizeWaitTime &amp;amp; &amp;quot; milliseconds&amp;quot;\n\t\tWScript.Sleep(intSensorRandomizeWaitTime)\n\t\tSensorRandomizeEcho &amp;quot;Done sleeping, continuing ...&amp;quot;\n\tElse \n\t\tSensorRandomizeEcho &amp;quot;SensorRandomize Not Enabled - No Op&amp;quot;\n\tEnd If\nEnd Function &amp;#039;SensorRandomizeRandomSleep\n\nFunction SensorRandomizeTaniumRandomSeed\n&amp;#039; for randomizing sensor code, the default seed is not random enough\n\tDim timerNum\n\ttimerNum = Timer()\n\tIf timerNum &amp;lt; 1 Then\n\t\tSensorRandomizeTaniumRandomSeed = (SensorRandomizeGetTaniumComputerID / Timer() * 10 )\n\tElse\n\t\tSensorRandomizeTaniumRandomSeed = SensorRandomizeGetTaniumComputerID / Timer\n\tEnd If\nEnd Function &amp;#039;SensorRandomizeTaniumRandomSeed\n\nFunction SensorRandomizeGetTaniumRegistryPath\n&amp;#039;SensorRandomizeGetTaniumRegistryPath works in x64 or x32\n&amp;#039;looks for a valid Path value\n\n\tDim objShell\n\tDim keyNativePath, keyWoWPath, strPath, strFoundTaniumRegistryPath\n\t  \n    Set objShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)\n    \n\tkeyNativePath = &amp;quot;Software\\Tanium\\Tanium Client&amp;quot;\n\tkeyWoWPath = &amp;quot;Software\\Wow6432Node\\Tanium\\Tanium Client&amp;quot;\n    \n    &amp;#039; first check the Software key (valid for 32-bit machines, or 64-bit machines in 32-bit mode)\n    On Error Resume Next\n    strPath = objShell.RegRead(&amp;quot;HKLM\\&amp;quot;&amp;amp;keyNativePath&amp;amp;&amp;quot;\\Path&amp;quot;)\n    On Error Goto 0\n\tstrFoundTaniumRegistryPath = keyNativePath\n \n  \tIf strPath = &amp;quot;&amp;quot; Then\n  \t\t&amp;#039; Could not find 32-bit mode path, checking Wow6432Node\n  \t\tOn Error Resume Next\n  \t\tstrPath = objShell.RegRead(&amp;quot;HKLM\\&amp;quot;&amp;amp;keyWoWPath&amp;amp;&amp;quot;\\Path&amp;quot;)\n  \t\tOn Error Goto 0\n\t\tstrFoundTaniumRegistryPath = keyWoWPath\n  \tEnd If\n  \t\n  \tIf Not strPath = &amp;quot;&amp;quot; Then\n  \t\tSensorRandomizeGetTaniumRegistryPath = strFoundTaniumRegistryPath\n  \tElse\n  \t\tSensorRandomizeGetTaniumRegistryPath = False\n  \t\tWScript.Echo &amp;quot;Error: Cannot locate Tanium Registry Path&amp;quot;\n  \tEnd If\nEnd Function &amp;#039;SensorRandomizeGetTaniumRegistryPath\n\nFunction SensorRandomizeGetTaniumComputerID\n&amp;#039;&amp;#039; This function gets the Tanium Computer ID\n\tDim objShell\n\tDim intClientID,strID,strKeyPath,strValueName\n\t\n    strKeyPath = SensorRandomizeGetTaniumRegistryPath\n    strValueName = &amp;quot;ComputerID&amp;quot;\n    Set objShell = CreateObject(&amp;quot;WScript.Shell&amp;quot;)\n    On Error Resume Next\n    intClientID = objShell.RegRead(&amp;quot;HKLM\\&amp;quot;&amp;amp;strKeyPath&amp;amp;&amp;quot;\\&amp;quot;&amp;amp;strValueName)\n    If Err.Number &amp;lt;&amp;gt; 0 Then\n    \tSensorRandomizeGetTaniumComputerID = 0\n    Else\n\t\tSensorRandomizeGetTaniumComputerID = SensorRandomizeReinterpretSignedAsUnsigned(intClientID)\n\tEnd If\n\tOn Error Goto 0\nEnd Function &amp;#039;SensorRandomizeGetTaniumComputerID\n\nFunction SensorRandomizeReinterpretSignedAsUnsigned(ByVal x)\n\t  If x &amp;lt; 0 Then x = x + 2^32\n\t  SensorRandomizeReinterpretSignedAsUnsigned = x\nEnd Function &amp;#039;SensorRandomizeReinterpretSignedAsUnsigned\n\nSub SensorRandomizeEcho(str)\n\tIf bSensorRandomizeDebugOutput = true Then WScript.Echo str\nEnd Sub &amp;#039;SensorRandomizeEcho\n&amp;#039; -- End Random Sleep Functions --&amp;#039;\n&amp;#039;- End file: utils/SensorRandomization/SensorRandomizationFunctions.vbs", 
            "script_type": "VBScript"
          }, 
          {
            "_type": "query", 
            "platform": "Linux", 
            "script": "#!/bin/bash\n#||dirname||||regexp||||casesensitive||||global||\necho Windows Only\n", 
            "script_type": "UnixShell"
          }, 
          {
            "_type": "query", 
            "platform": "Mac", 
            "script": "#!/bin/bash\n#||dirname||||regexp||||casesensitive||||global||\necho Windows Only\n", 
            "script_type": "UnixShell"
          }
        ]
      }, 
      "source_id": 0, 
      "string_count": 0, 
      "value_type": "String"
    }
  ]
}